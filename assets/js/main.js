!(function (t) {
	var e = {};
	function n(i) {
		if (e[i]) return e[i].exports;
		var r = (e[i] = { i, l: !1, exports: {} });
		return t[i].call(r.exports, r, r.exports, n), (r.l = !0), r.exports;
	}
	(n.m = t),
		(n.c = e),
		(n.d = function (t, e, i) {
			n.o(t, e) || Object.defineProperty(t, e, { enumerable: !0, get: i });
		}),
		(n.r = function (t) {
			"undefined" != typeof Symbol &&
				Symbol.toStringTag &&
				Object.defineProperty(t, Symbol.toStringTag, { value: "Module" }),
				Object.defineProperty(t, "__esModule", { value: !0 });
		}),
		(n.t = function (t, e) {
			if ((1 & e && (t = n(t)), 8 & e)) return t;
			if (4 & e && "object" == typeof t && t && t.__esModule) return t;
			var i = Object.create(null);
			if (
				(n.r(i),
				Object.defineProperty(i, "default", { enumerable: !0, value: t }),
				2 & e && "string" != typeof t)
			)
				for (var r in t)
					n.d(
						i,
						r,
						function (e) {
							return t[e];
						}.bind(null, r)
					);
			return i;
		}),
		(n.n = function (t) {
			var e =
				t && t.__esModule
					? function () {
							return t.default;
					  }
					: function () {
							return t;
					  };
			return n.d(e, "a", e), e;
		}),
		(n.o = function (t, e) {
			return Object.prototype.hasOwnProperty.call(t, e);
		}),
		(n.p = ""),
		n((n.s = 9));
})([
	function (t, e) {
		t.exports = function (t, e) {
			if (!(t instanceof e))
				throw new TypeError("Cannot call a class as a function");
		};
	},
	function (t, e) {
		function n(t, e) {
			for (var n = 0; n < e.length; n++) {
				var i = e[n];
				(i.enumerable = i.enumerable || !1),
					(i.configurable = !0),
					"value" in i && (i.writable = !0),
					Object.defineProperty(t, i.key, i);
			}
		}
		t.exports = function (t, e, i) {
			return e && n(t.prototype, e), i && n(t, i), t;
		};
	},
	function (t, e) {
		function n(e) {
			return (
				(t.exports = n =
					Object.setPrototypeOf
						? Object.getPrototypeOf
						: function (t) {
								return t.__proto__ || Object.getPrototypeOf(t);
						  }),
				n(e)
			);
		}
		t.exports = n;
	},
	function (t, e, n) {
		var i = n(10);
		t.exports = function (t, e) {
			if ("function" != typeof e && null !== e)
				throw new TypeError(
					"Super expression must either be null or a function"
				);
			(t.prototype = Object.create(e && e.prototype, {
				constructor: { value: t, writable: !0, configurable: !0 },
			})),
				e && i(t, e);
		};
	},
	function (t, e, n) {
		var i = n(5),
			r = n(6);
		t.exports = function (t, e) {
			return !e || ("object" !== i(e) && "function" != typeof e) ? r(t) : e;
		};
	},
	function (t, e) {
		function n(e) {
			"@babel/helpers - typeof";
			return (
				"function" == typeof Symbol && "symbol" == typeof Symbol.iterator
					? (t.exports = n =
							function (t) {
								return typeof t;
							})
					: (t.exports = n =
							function (t) {
								return t &&
									"function" == typeof Symbol &&
									t.constructor === Symbol &&
									t !== Symbol.prototype
									? "symbol"
									: typeof t;
							}),
				n(e)
			);
		}
		t.exports = n;
	},
	function (t, e) {
		t.exports = function (t) {
			if (void 0 === t)
				throw new ReferenceError(
					"this hasn't been initialised - super() hasn't been called"
				);
			return t;
		};
	},
	,
	,
	function (t, e, n) {
		t.exports = n(21);
	},
	function (t, e) {
		function n(e, i) {
			return (
				(t.exports = n =
					Object.setPrototypeOf ||
					function (t, e) {
						return (t.__proto__ = e), t;
					}),
				n(e, i)
			);
		}
		t.exports = n;
	},
	function (t, e, n) {
		var i, r, o, s, a, c, l, h, u, d, p, f, m, g, v, y, x, b, w, _, M, S;
		/**
		 * isMobile.js v0.4.1
		 *
		 * A simple library to detect Apple phones and tablets,
		 * Android phones and tablets, other mobile devices (like blackberry, mini-opera and windows phone),
		 * and any kind of seven inch device, via user agent sniffing.
		 *
		 * @author: Kai Mallea (kmallea@gmail.com)
		 *
		 * @license: http://creativecommons.org/publicdomain/zero/1.0/
		 */
		/**
		 * isMobile.js v0.4.1
		 *
		 * A simple library to detect Apple phones and tablets,
		 * Android phones and tablets, other mobile devices (like blackberry, mini-opera and windows phone),
		 * and any kind of seven inch device, via user agent sniffing.
		 *
		 * @author: Kai Mallea (kmallea@gmail.com)
		 *
		 * @license: http://creativecommons.org/publicdomain/zero/1.0/
		 */
		(s = this),
			(a = /iPhone/i),
			(c = /iPod/i),
			(l = /iPad/i),
			(h = /(?=.*\bAndroid\b)(?=.*\bMobile\b)/i),
			(u = /Android/i),
			(d = /(?=.*\bAndroid\b)(?=.*\bSD4930UR\b)/i),
			(p =
				/(?=.*\bAndroid\b)(?=.*\b(?:KFOT|KFTT|KFJWI|KFJWA|KFSOWI|KFTHWI|KFTHWA|KFAPWI|KFAPWA|KFARWI|KFASWI|KFSAWI|KFSAWA)\b)/i),
			(f = /Windows Phone/i),
			(m = /(?=.*\bWindows\b)(?=.*\bARM\b)/i),
			(g = /BlackBerry/i),
			(v = /BB10/i),
			(y = /Opera Mini/i),
			(x = /(CriOS|Chrome)(?=.*\bMobile\b)/i),
			(b = /(?=.*\bFirefox\b)(?=.*\bMobile\b)/i),
			(w = new RegExp("(?:Nexus 7|BNTV250|Kindle Fire|Silk|GT-P1000)", "i")),
			(_ = function (t, e) {
				return t.test(e);
			}),
			(M = function (t) {
				var e = t || navigator.userAgent,
					n = e.split("[FBAN");
				if (
					(void 0 !== n[1] && (e = n[0]),
					void 0 !== (n = e.split("Twitter"))[1] && (e = n[0]),
					(this.apple = {
						phone: _(a, e),
						ipod: _(c, e),
						tablet: !_(a, e) && _(l, e),
						device: _(a, e) || _(c, e) || _(l, e),
					}),
					(this.amazon = {
						phone: _(d, e),
						tablet: !_(d, e) && _(p, e),
						device: _(d, e) || _(p, e),
					}),
					(this.android = {
						phone: _(d, e) || _(h, e),
						tablet: !_(d, e) && !_(h, e) && (_(p, e) || _(u, e)),
						device: _(d, e) || _(p, e) || _(h, e) || _(u, e),
					}),
					(this.windows = {
						phone: _(f, e),
						tablet: _(m, e),
						device: _(f, e) || _(m, e),
					}),
					(this.other = {
						blackberry: _(g, e),
						blackberry10: _(v, e),
						opera: _(y, e),
						firefox: _(b, e),
						chrome: _(x, e),
						device: _(g, e) || _(v, e) || _(y, e) || _(b, e) || _(x, e),
					}),
					(this.seven_inch = _(w, e)),
					(this.any =
						this.apple.device ||
						this.android.device ||
						this.windows.device ||
						this.other.device ||
						this.seven_inch),
					(this.phone =
						this.apple.phone || this.android.phone || this.windows.phone),
					(this.tablet =
						this.apple.tablet || this.android.tablet || this.windows.tablet),
					"undefined" == typeof window)
				)
					return this;
			}),
			(S = function () {
				var t = new M();
				return (t.Class = M), t;
			}),
			t.exports && "undefined" == typeof window
				? (t.exports = M)
				: t.exports && "undefined" != typeof window
				? (t.exports = S())
				: ((r = []),
				  (i = s.isMobile = S()),
				  void 0 === (o = "function" == typeof i ? i.apply(e, r) : i) ||
						(t.exports = o));
	},
	,
	,
	,
	,
	,
	,
	,
	,
	,
	function (t, e, n) {
		"use strict";
		function i() {}
		n.r(e),
			(i.prototype = {
				on: function (t, e, n) {
					var i = this.e || (this.e = {});
					return (i[t] || (i[t] = [])).push({ fn: e, ctx: n }), this;
				},
				once: function (t, e, n) {
					var i = this;
					function r() {
						i.off(t, r), e.apply(n, arguments);
					}
					return (r._ = e), this.on(t, r, n);
				},
				emit: function (t) {
					for (
						var e = [].slice.call(arguments, 1),
							n = ((this.e || (this.e = {}))[t] || []).slice(),
							i = 0,
							r = n.length;
						i < r;
						i++
					)
						n[i].fn.apply(n[i].ctx, e);
					return this;
				},
				off: function (t, e) {
					var n = this.e || (this.e = {}),
						i = n[t],
						r = [];
					if (i && e)
						for (var o = 0, s = i.length; o < s; o++)
							i[o].fn !== e && i[o].fn._ !== e && r.push(i[o]);
					return r.length ? (n[t] = r) : delete n[t], this;
				},
			});
		var r = i;
		r.TinyEmitter = i;
		var o = function (t) {
			(this.wrap = document.querySelector("[data-router-wrapper]")),
				(this.properties = t),
				(this.Transition = t.transition
					? new t.transition.class(this.wrap, t.transition.name)
					: null);
		};
		(o.prototype.setup = function () {
			this.onEnter && this.onEnter(),
				this.onEnterCompleted && this.onEnterCompleted();
		}),
			(o.prototype.add = function () {
				this.wrap.insertAdjacentHTML(
					"beforeend",
					this.properties.view.outerHTML
				);
			}),
			(o.prototype.update = function () {
				document.title = this.properties.page.title;
			}),
			(o.prototype.show = function (t) {
				var e = this;
				return new Promise(function (n) {
					try {
						function i(t) {
							e.onEnterCompleted && e.onEnterCompleted(), n();
						}
						return (
							e.update(),
							e.onEnter && e.onEnter(),
							Promise.resolve(
								e.Transition
									? Promise.resolve(e.Transition.show(t)).then(i)
									: i()
							)
						);
					} catch (t) {
						return Promise.reject(t);
					}
				});
			}),
			(o.prototype.hide = function (t) {
				var e = this;
				return new Promise(function (n) {
					try {
						function i(t) {
							e.onLeaveCompleted && e.onLeaveCompleted(), n();
						}
						return (
							e.onLeave && e.onLeave(),
							Promise.resolve(
								e.Transition
									? Promise.resolve(e.Transition.hide(t)).then(i)
									: i()
							)
						);
					} catch (t) {
						return Promise.reject(t);
					}
				});
			});
		var s = new window.DOMParser(),
			a = function (t, e) {
				(this.renderers = t), (this.transitions = e);
			};
		(a.prototype.getOrigin = function (t) {
			var e = t.match(/(https?:\/\/[\w\-.]+)/);
			return e ? e[1].replace(/https?:\/\//, "") : null;
		}),
			(a.prototype.getPathname = function (t) {
				var e = t.match(/https?:\/\/.*?(\/[\w_\-./]+)/);
				return e ? e[1] : "/";
			}),
			(a.prototype.getAnchor = function (t) {
				var e = t.match(/(#.*)$/);
				return e ? e[1] : null;
			}),
			(a.prototype.getParams = function (t) {
				var e = t.match(/\?([\w_\-.=&]+)/);
				if (!e) return null;
				for (var n = e[1].split("&"), i = {}, r = 0; r < n.length; r++) {
					var o = n[r].split("=");
					i[o[0]] = o[1];
				}
				return i;
			}),
			(a.prototype.getDOM = function (t) {
				return "string" == typeof t ? s.parseFromString(t, "text/html") : t;
			}),
			(a.prototype.getView = function (t) {
				return t.querySelector("[data-router-view]");
			}),
			(a.prototype.getSlug = function (t) {
				return t.getAttribute("data-router-view");
			}),
			(a.prototype.getRenderer = function (t) {
				if (!this.renderers) return Promise.resolve(o);
				if (t in this.renderers) {
					var e = this.renderers[t];
					return "function" != typeof e || o.isPrototypeOf(e)
						? "function" == typeof e.then
							? Promise.resolve(e).then(function (t) {
									return t.default;
							  })
							: Promise.resolve(e)
						: Promise.resolve(e()).then(function (t) {
								return t.default;
						  });
				}
				return Promise.resolve(o);
			}),
			(a.prototype.getTransition = function (t) {
				return this.transitions
					? t in this.transitions
						? { class: this.transitions[t], name: t }
						: "default" in this.transitions
						? { class: this.transitions.default, name: "default" }
						: null
					: null;
			}),
			(a.prototype.getProperties = function (t) {
				var e = this.getDOM(t),
					n = this.getView(e),
					i = this.getSlug(n);
				return {
					page: e,
					view: n,
					slug: i,
					renderer: this.getRenderer(i, this.renderers),
					transition: this.getTransition(i, this.transitions),
				};
			}),
			(a.prototype.getLocation = function (t) {
				return {
					href: t,
					anchor: this.getAnchor(t),
					origin: this.getOrigin(t),
					params: this.getParams(t),
					pathname: this.getPathname(t),
				};
			});
		var c = (function (t) {
				function e(e) {
					var n = this;
					void 0 === e && (e = {});
					var i = e.renderers,
						r = e.transitions;
					t.call(this),
						(this.Helpers = new a(i, r)),
						(this.Transitions = r),
						(this.Contextual = !1),
						(this.location = this.Helpers.getLocation(window.location.href)),
						(this.properties = this.Helpers.getProperties(
							document.cloneNode(!0)
						)),
						(this.popping = !1),
						(this.running = !1),
						(this.trigger = null),
						(this.cache = new Map()),
						this.cache.set(this.location.href, this.properties),
						this.properties.renderer.then(function (t) {
							(n.From = new t(n.properties)), n.From.setup();
						}),
						(this._navigate = this.navigate.bind(this)),
						window.addEventListener("popstate", this.popState.bind(this)),
						(this.links = document.querySelectorAll(
							"a:not([target]):not([data-router-disabled])"
						)),
						this.attach(this.links);
				}
				return (
					t && (e.__proto__ = t),
					((e.prototype = Object.create(t && t.prototype)).constructor = e),
					(e.prototype.attach = function (t) {
						for (var e = 0, n = t; e < n.length; e += 1)
							n[e].addEventListener("click", this._navigate);
					}),
					(e.prototype.detach = function (t) {
						for (var e = 0, n = t; e < n.length; e += 1)
							n[e].removeEventListener("click", this._navigate);
					}),
					(e.prototype.navigate = function (t) {
						if (!t.metaKey && !t.ctrlKey) {
							t.preventDefault();
							var e =
								!!t.currentTarget.hasAttribute("data-transition") &&
								t.currentTarget.dataset.transition;
							this.redirect(t.currentTarget.href, e, t.currentTarget);
						}
					}),
					(e.prototype.redirect = function (t, e, n) {
						if (
							(void 0 === e && (e = !1),
							void 0 === n && (n = "script"),
							(this.trigger = n),
							!this.running && t !== this.location.href)
						) {
							var i = this.Helpers.getLocation(t);
							(this.Contextual = !1),
								e &&
									((this.Contextual = this.Transitions.contextual[e].prototype),
									(this.Contextual.name = e)),
								i.origin !== this.location.origin ||
								(i.anchor && i.pathname === this.location.pathname)
									? (window.location.href = t)
									: ((this.location = i), this.beforeFetch());
						}
					}),
					(e.prototype.popState = function () {
						(this.trigger = "popstate"), (this.Contextual = !1);
						var t = this.Helpers.getLocation(window.location.href);
						this.location.pathname !== t.pathname ||
						(!this.location.anchor && !t.anchor)
							? ((this.popping = !0), (this.location = t), this.beforeFetch())
							: (this.location = t);
					}),
					(e.prototype.pushState = function () {
						this.popping ||
							window.history.pushState(this.location, "", this.location.href);
					}),
					(e.prototype.fetch = function () {
						try {
							var t = this;
							return Promise.resolve(
								fetch(t.location.href, {
									mode: "same-origin",
									method: "GET",
									headers: { "X-Requested-With": "Highway" },
									credentials: "same-origin",
								})
							).then(function (e) {
								if (e.status >= 200 && e.status < 300) return e.text();
								window.location.href = t.location.href;
							});
						} catch (t) {
							return Promise.reject(t);
						}
					}),
					(e.prototype.beforeFetch = function () {
						try {
							var t = this;
							function e() {
								t.afterFetch();
							}
							t.pushState(),
								(t.running = !0),
								t.emit("NAVIGATE_OUT", {
									from: {
										page: t.From.properties.page,
										view: t.From.properties.view,
									},
									trigger: t.trigger,
									location: t.location,
								});
							var n = { trigger: t.trigger, contextual: t.Contextual },
								i = t.cache.has(t.location.href)
									? Promise.resolve(t.From.hide(n)).then(function () {
											t.properties = t.cache.get(t.location.href);
									  })
									: Promise.resolve(
											Promise.all([t.fetch(), t.From.hide(n)])
									  ).then(function (e) {
											(t.properties = t.Helpers.getProperties(e[0])),
												t.cache.set(t.location.href, t.properties);
									  });
							return Promise.resolve(i && i.then ? i.then(e) : e());
						} catch (t) {
							return Promise.reject(t);
						}
					}),
					(e.prototype.afterFetch = function () {
						try {
							var t = this;
							return Promise.resolve(t.properties.renderer).then(function (e) {
								return (
									(t.To = new e(t.properties)),
									t.To.add(),
									t.emit("NAVIGATE_IN", {
										to: {
											page: t.To.properties.page,
											view: t.To.wrap.lastElementChild,
										},
										trigger: t.trigger,
										location: t.location,
									}),
									Promise.resolve(
										t.To.show({ trigger: t.trigger, contextual: t.Contextual })
									).then(function () {
										(t.popping = !1),
											(t.running = !1),
											t.detach(t.links),
											(t.links = document.querySelectorAll(
												"a:not([target]):not([data-router-disabled])"
											)),
											t.attach(t.links),
											t.emit("NAVIGATE_END", {
												to: {
													page: t.To.properties.page,
													view: t.To.wrap.lastElementChild,
												},
												from: {
													page: t.From.properties.page,
													view: t.From.properties.view,
												},
												trigger: t.trigger,
												location: t.location,
											}),
											(t.From = t.To),
											(t.trigger = null);
									})
								);
							});
						} catch (t) {
							return Promise.reject(t);
						}
					}),
					e
				);
			})(r),
			l = function (t, e) {
				(this.wrap = t), (this.name = e);
			};
		(l.prototype.show = function (t) {
			var e = this,
				n = t.trigger,
				i = t.contextual,
				r = this.wrap.lastElementChild,
				o = this.wrap.firstElementChild;
			return new Promise(function (t) {
				i
					? (r.setAttribute("data-transition-in", i.name),
					  r.removeAttribute("data-transition-out", i.name),
					  i.in && i.in({ to: r, from: o, trigger: n, done: t }))
					: (r.setAttribute("data-transition-in", e.name),
					  r.removeAttribute("data-transition-out", e.name),
					  e.in && e.in({ to: r, from: o, trigger: n, done: t }));
			});
		}),
			(l.prototype.hide = function (t) {
				var e = this,
					n = t.trigger,
					i = t.contextual,
					r = this.wrap.firstElementChild;
				return new Promise(function (t) {
					i
						? (r.setAttribute("data-transition-out", i.name),
						  r.removeAttribute("data-transition-in", i.name),
						  i.out && i.out({ from: r, trigger: n, done: t }))
						: (r.setAttribute("data-transition-out", e.name),
						  r.removeAttribute("data-transition-in", e.name),
						  e.out && e.out({ from: r, trigger: n, done: t }));
				});
			}),
			console.log("Highway v2.2.0");
		var h,
			u = { Core: c, Helpers: a, Renderer: o, Transition: l },
			d = n(0),
			p = n.n(d),
			f = n(1),
			m = n.n(f),
			g = (function () {
				function t(e) {
					var n =
						arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {};
					p()(this, t),
						(this.worker = new Worker(`${domain_url}/assets/js/image-load.js`)),
						(this.array = []),
						(this.domElements = !1),
						(this.count = 0),
						(this.sent = 0),
						(this.total = 0),
						(this.callbackCap = void 0 === n.callbackCap ? 1e6 : n.callbackCap),
						(this.dataAttr = void 0 === n.dataAttr ? "preload" : n.dataAttr),
						(this.forceNoWorker =
							void 0 !== n.forceNoWorker && n.forceNoWorker),
						(this.size = void 0 === n.size ? "mobile" : n.size),
						(this.tagExclusions =
							void 0 === n.tagExclusions
								? ["audio", "iframe", "video"]
								: n.tagExclusions),
						(this.workerCap = void 0 === n.workerCap ? 1e6 : n.workerCap),
						this.bindEvents();
				}
				return (
					m()(t, [
						{
							key: "bindEvents",
							value: function () {
								var t = this;
								this.worker.addEventListener(
									"message",
									function (e) {
										var n = e.data,
											i = URL.createObjectURL(n.blob);
										if (((t.array[n.url] = i), t.domElements))
											for (
												var r = document.querySelectorAll(
														"[data-"
															.concat(t.dataAttr, "-")
															.concat(t.size, '="')
															.concat(n.url, '"]')
													),
													o = 0;
												o < r.length;
												o++
											)
												t.preload(r[o], i);
										else t.returnedUrls.push(i), t.count++;
									},
									{ passive: !0 }
								);
							},
						},
						{
							key: "remove",
							value: function (t, e) {
								return t.filter(function (t) {
									return t !== e;
								});
							},
						},
						{
							key: "loadImage",
							value: function (t) {
								var e = t.getAttribute(
									"data-".concat(this.dataAttr, "-").concat(this.size)
								);
								void 0 !== this.array[e] &&
									"" !== this.array[e] &&
									this.preload(t, this.array[e]);
							},
						},
						{
							key: "loadImages",
							value: function () {
								var t = this,
									e =
										arguments.length > 0 && void 0 !== arguments[0]
											? arguments[0]
											: [],
									n = arguments.length > 1 ? arguments[1] : void 0,
									i = arguments.length > 2 ? arguments[2] : void 0;
								"string" === n &&
									((e = document.querySelectorAll(e)), (this.domElements = !0)),
									"nodeList" === n && (this.domElements = !0),
									"array" === n &&
										((this.domElements = !1), (this.returnedUrls = []));
								var r = window.location.protocol + "//";
								(this.count = 0), (this.total = e.length);
								for (var o = 0; o < e.length; o++) {
									var s = void 0,
										a = void 0;
									this.domElements
										? ((s = e[o].getAttribute(
												"data-".concat(this.dataAttr, "-").concat(this.size)
										  )),
										  (a = e[o].tagName.toLowerCase()))
										: (s = e[o]),
										s && "" !== s
											? (s.indexOf("http") < 0 &&
													(s = r + window.location.host + s),
											  (void 0 !== this.array[s] && "" === this.array[s]) ||
													(void 0 === this.array[s] || "" === this.array[s]
														? (this.domElements &&
																(!0 === this.forceNoWorker ||
																	this.tagExclusions.indexOf(a) >= 0 ||
																	this.sent >= this.workerCap)) ||
														  s.indexOf("gif") > 0
															? this.preload(e[o], s)
															: ((this.array[s] = ""),
															  this.sent++,
															  this.message(s))
														: (this.domElements
																? this.preload(e[o], this.array[s])
																: this.returnedUrls.push(this.array[s]),
														  this.total--)))
											: (this.clearElement(e[o]), this.total--);
								}
								var c = setInterval(function () {
									(t.count >= t.total || t.count >= t.callbackCap) &&
										(clearInterval(c),
										t.domElements
											? i(
													t.count +
														" elements loaded, " +
														(t.count - t.total) +
														" duplicate elements, " +
														(e.length - t.total) +
														" deferred elements"
											  )
											: i(t.returnedUrls));
								}, 10);
							},
						},
						{
							key: "preload",
							value: function (t, e) {
								switch (t.tagName.toLowerCase()) {
									case "audio":
									case "video":
										this.loadSource(t, e);
										break;
									case "image":
										this.loadSVGImage(t, e);
										break;
									case "iframe":
									case "img":
										this.loadSrc(t, e);
										break;
									default:
										this.loadBackgroundImage(t, e);
								}
								this.clearElement(t);
							},
						},
						{
							key: "loadSource",
							value: function (t, e) {
								var n = document.createElement("source");
								n.setAttribute("src", e),
									t.appendChild(n),
									t.load(),
									this.count++;
							},
						},
						{
							key: "loadSrc",
							value: function (t, e) {
								var n = this;
								(t.onload = function () {
									n.count++;
								}),
									(t.onerror = function () {
										n.count++;
									}),
									t.setAttribute("src", e);
							},
						},
						{
							key: "loadSVGImage",
							value: function (t, e) {
								var n = this;
								(t.onload = function () {
									n.count++;
								}),
									(t.onerror = function () {
										n.count++;
									}),
									t.setAttribute("href", e);
							},
						},
						{
							key: "loadBackgroundImage",
							value: function (t, e) {
								var n = this,
									i = new Image();
								(i.onload = function () {
									(t.style.backgroundImage = "url(" + e + ")"), n.count++;
								}),
									(i.onerror = function () {
										n.count++;
									}),
									(i.src = e);
							},
						},
						{
							key: "clearElement",
							value: function (t) {
								t.classList.remove("preload"),
									t.classList.remove("preload-critical"),
									t.removeAttribute("data-preload-desktop"),
									t.removeAttribute("data-preload-mobile");
							},
						},
						{
							key: "clearBlob",
							value: function (t) {
								this.array[t] &&
									(URL.revokeObjectURL(this.array[t]),
									this.remove(this.array, t));
							},
						},
						{
							key: "clearAllBlobs",
							value: function () {
								for (var t = 0; t < this.array.length; t++)
									URL.revokeObjectURL(this.array[t]);
								this.array = [];
							},
						},
						{
							key: "message",
							value: function (t) {
								this.worker.postMessage(t);
							},
						},
					]),
					t
				);
			})(),
			v = function (t, e, n, i, r) {
				return ((t - e) * (r - i)) / (n - e) + i;
			},
			y = function (t, e, n) {
				return t * (1 - n) + e * n;
			},
			x = function (t, e) {
				for (var n = e.length, i = 0; i < n; i++) t[e[i]] = t[e[i]].bind(t);
			},
			b = function () {
				var t;
				if (location.search && "" !== location.search) {
					var e = location.search.substring(1);
					t = JSON.parse(
						'{"' +
							decodeURI(e)
								.replace(/"/g, '\\"')
								.replace(/&/g, '","')
								.replace(/=/g, '":"') +
							'"}'
					);
				}
				return t;
			},
			w = function () {
				var t = window,
					e = "inner";
				return (
					"innerWidth" in window ||
						((e = "client"), (t = document.documentElement || document.body)),
					{ width: t[e + "Width"], height: t[e + "Height"] }
				);
			};
		document.documentElement;
		window.matchMedia("(prefers-color-scheme: light)").matches
			? (window.matchMedia("(prefers-color-scheme: light)"), (h = "light"))
			: window.matchMedia("(prefers-color-scheme: dark)").matches
			? (window.matchMedia("(prefers-color-scheme: dark)"), (h = "dark"))
			: (window.matchMedia("(prefers-color-scheme)"), (h = "light"));
		var _ = {
				assetPath:
					document.getElementById("site-data") &&
					window.location.host.indexOf("localhost") < 0
						? document
								.getElementById("site-data")
								.getAttribute("data-asset-path")
						: "/assets/code/",
				firstLoad: !0,
				isMobile: !1,
				isSafari: !1,
				isChrome: !1,
				isFirefox: navigator.userAgent.indexOf("Firefox") > -1,
				windowHeight: "",
				windowWidth: "",
				aboutHandTL: "",
				mouseEnterContext: !1,
				aboutHandLoaded: !1,
				fromAboutDrawer: !1,
				transitionFinished: !1,
				queryParams: {},
				referrer: "",
				tripMode: !1,
				drawerOpen: !1,
				reducedMotion: window.matchMedia("(prefers-reduced-motion: reduce)")
					.matches,
				prefColorScheme: h,
				headerShowing: !0,
				aboutDrawerScroll: !1,
				workDrawerScroll: !1,
				keyToggle: !1,
			},
			M = {
				header: document.getElementById("header"),
				footer: document.getElementById("footer"),
				mainEl: document.getElementById("main"),
				workMobileFilterEl: !1,
				tieDieEl: document.querySelector(".third-media"),
				tieDieMedia: document.querySelector(".third-media video"),
				aboutHand: document.getElementById("about-hand"),
				containerEl: document.getElementById("container"),
				globalMask: document.getElementById("global-mask"),
				bttEls: document.querySelectorAll(
					".back-to-top .letter, .back-to-top img"
				),
				bttHand: document.querySelector(".back-to-top img"),
				drawers: document.querySelectorAll(".drawer-wrapper"),
				whiteBackdrop: document.querySelector(".color-backdrops .white"),
				blackBackdrop: document.querySelector(".color-backdrops .black"),
				openMobileMenu: function () {},
				closeMobileMenu: function () {},
				resetMobileMenu: function () {},
				potentialSections: !1,
			},
			S = {
				renderer: null,
				scene: null,
				camera: null,
				perspectiveCamera: null,
			},
			T = navigator.userAgent.indexOf("Chrome") > -1,
			E = navigator.userAgent.indexOf("Safari") > -1,
			A = navigator.userAgent.toLowerCase().indexOf("op") > -1;
		function L(t) {
			if (void 0 === t)
				throw new ReferenceError(
					"this hasn't been initialised - super() hasn't been called"
				);
			return t;
		}
		function P(t, e) {
			(t.prototype = Object.create(e.prototype)),
				(t.prototype.constructor = t),
				(t.__proto__ = e);
		}
		/*!
		 * GSAP 3.5.1
		 * https://greensock.com
		 *
		 * @license Copyright 2008-2020, GreenSock. All rights reserved.
		 * Subject to the terms at https://greensock.com/standard-license or for
		 * Club GreenSock members, the agreement issued with that membership.
		 * @author: Jack Doyle, jack@greensock.com
		 */ T && E && (E = !1),
			T && A && (T = !1),
			E && (_.isSafari = !0),
			T && (_.isChrome = !0);
		var R,
			C,
			O,
			D,
			I,
			k,
			N,
			B,
			F = {
				autoSleep: 120,
				force3D: "auto",
				nullTargetWarn: 1,
				units: { lineHeight: "" },
			},
			z = { duration: 0.5, overwrite: !1, delay: 0 },
			H = 1e-8,
			U = 2 * Math.PI,
			G = U / 4,
			V = 0,
			j = Math.sqrt,
			W = Math.cos,
			q = Math.sin,
			Y = function (t) {
				return "string" == typeof t;
			},
			X = function (t) {
				return "function" == typeof t;
			},
			Z = function (t) {
				return "number" == typeof t;
			},
			J = function (t) {
				return void 0 === t;
			},
			K = function (t) {
				return "object" == typeof t;
			},
			Q = function (t) {
				return !1 !== t;
			},
			$ = function () {
				return "undefined" != typeof window;
			},
			tt = function (t) {
				return X(t) || Y(t);
			},
			et =
				("function" == typeof ArrayBuffer && ArrayBuffer.isView) ||
				function () {},
			nt = Array.isArray,
			it = /(?:-?\.?\d|\.)+/gi,
			rt = /[-+=.]*\d+[.e\-+]*\d*[e\-\+]*\d*/g,
			ot = /[-+=.]*\d+[.e-]*\d*[a-z%]*/g,
			st = /[-+=.]*\d+(?:\.|e-|e)*\d*/gi,
			at = /[+-]=-?[\.\d]+/,
			ct = /[#\-+.]*\b[a-z\d-=+%.]+/gi,
			lt = {},
			ht = {},
			ut = function (t) {
				return (ht = Bt(t, lt)) && yn;
			},
			dt = function (t, e) {
				return console.warn(
					"Invalid property",
					t,
					"set to",
					e,
					"Missing plugin? gsap.registerPlugin()"
				);
			},
			pt = function (t, e) {
				return !e && console.warn(t);
			},
			ft = function (t, e) {
				return (t && (lt[t] = e) && ht && (ht[t] = e)) || lt;
			},
			mt = function () {
				return 0;
			},
			gt = {},
			vt = [],
			yt = {},
			xt = {},
			bt = {},
			wt = 30,
			_t = [],
			Mt = "",
			St = function (t) {
				var e,
					n,
					i = t[0];
				if ((K(i) || X(i) || (t = [t]), !(e = (i._gsap || {}).harness))) {
					for (n = _t.length; n-- && !_t[n].targetTest(i); );
					e = _t[n];
				}
				for (n = t.length; n--; )
					(t[n] && (t[n]._gsap || (t[n]._gsap = new Ve(t[n], e)))) ||
						t.splice(n, 1);
				return t;
			},
			Tt = function (t) {
				return t._gsap || St(he(t))[0]._gsap;
			},
			Et = function (t, e, n) {
				return (n = t[e]) && X(n)
					? t[e]()
					: (J(n) && t.getAttribute && t.getAttribute(e)) || n;
			},
			At = function (t, e) {
				return (t = t.split(",")).forEach(e) || t;
			},
			Lt = function (t) {
				return Math.round(1e5 * t) / 1e5 || 0;
			},
			Pt = function (t, e) {
				for (var n = e.length, i = 0; t.indexOf(e[i]) < 0 && ++i < n; );
				return i < n;
			},
			Rt = function (t, e, n) {
				var i,
					r = Z(t[1]),
					o = (r ? 2 : 1) + (e < 2 ? 0 : 1),
					s = t[o];
				if ((r && (s.duration = t[1]), (s.parent = n), e)) {
					for (i = s; n && !("immediateRender" in i); )
						(i = n.vars.defaults || {}), (n = Q(n.vars.inherit) && n.parent);
					(s.immediateRender = Q(i.immediateRender)),
						e < 2 ? (s.runBackwards = 1) : (s.startAt = t[o - 1]);
				}
				return s;
			},
			Ct = function () {
				var t,
					e,
					n = vt.length,
					i = vt.slice(0);
				for (yt = {}, vt.length = 0, t = 0; t < n; t++)
					(e = i[t]) &&
						e._lazy &&
						(e.render(e._lazy[0], e._lazy[1], !0)._lazy = 0);
			},
			Ot = function (t, e, n, i) {
				vt.length && Ct(), t.render(e, n, i), vt.length && Ct();
			},
			Dt = function (t) {
				var e = parseFloat(t);
				return (e || 0 === e) && (t + "").match(ct).length < 2
					? e
					: Y(t)
					? t.trim()
					: t;
			},
			It = function (t) {
				return t;
			},
			kt = function (t, e) {
				for (var n in e) n in t || (t[n] = e[n]);
				return t;
			},
			Nt = function (t, e) {
				for (var n in e)
					n in t || "duration" === n || "ease" === n || (t[n] = e[n]);
			},
			Bt = function (t, e) {
				for (var n in e) t[n] = e[n];
				return t;
			},
			Ft = function t(e, n) {
				for (var i in n) e[i] = K(n[i]) ? t(e[i] || (e[i] = {}), n[i]) : n[i];
				return e;
			},
			zt = function (t, e) {
				var n,
					i = {};
				for (n in t) n in e || (i[n] = t[n]);
				return i;
			},
			Ht = function (t) {
				var e = t.parent || R,
					n = t.keyframes ? Nt : kt;
				if (Q(t.inherit))
					for (; e; ) n(t, e.vars.defaults), (e = e.parent || e._dp);
				return t;
			},
			Ut = function (t, e, n, i) {
				void 0 === n && (n = "_first"), void 0 === i && (i = "_last");
				var r = e._prev,
					o = e._next;
				r ? (r._next = o) : t[n] === e && (t[n] = o),
					o ? (o._prev = r) : t[i] === e && (t[i] = r),
					(e._next = e._prev = e.parent = null);
			},
			Gt = function (t, e) {
				t.parent && (!e || t.parent.autoRemoveChildren) && t.parent.remove(t),
					(t._act = 0);
			},
			Vt = function (t, e) {
				if (t && (!e || e._end > t._dur || e._start < 0))
					for (var n = t; n; ) (n._dirty = 1), (n = n.parent);
				return t;
			},
			jt = function t(e) {
				return !e || (e._ts && t(e.parent));
			},
			Wt = function (t) {
				return t._repeat ? qt(t._tTime, (t = t.duration() + t._rDelay)) * t : 0;
			},
			qt = function (t, e) {
				return (t /= e) && ~~t === t ? ~~t - 1 : ~~t;
			},
			Yt = function (t, e) {
				return (
					(t - e._start) * e._ts +
					(e._ts >= 0 ? 0 : e._dirty ? e.totalDuration() : e._tDur)
				);
			},
			Xt = function (t) {
				return (t._end = Lt(
					t._start + (t._tDur / Math.abs(t._ts || t._rts || H) || 0)
				));
			},
			Zt = function (t, e) {
				var n = t._dp;
				return (
					n &&
						n.smoothChildTiming &&
						t._ts &&
						((t._start = Lt(
							t._dp._time -
								(t._ts > 0
									? e / t._ts
									: ((t._dirty ? t.totalDuration() : t._tDur) - e) / -t._ts)
						)),
						Xt(t),
						n._dirty || Vt(n, t)),
					t
				);
			},
			Jt = function (t, e) {
				var n;
				if (
					((e._time || (e._initted && !e._dur)) &&
						((n = Yt(t.rawTime(), e)),
						(!e._dur || oe(0, e.totalDuration(), n) - e._tTime > H) &&
							e.render(n, !0)),
					Vt(t, e)._dp && t._initted && t._time >= t._dur && t._ts)
				) {
					if (t._dur < t.duration())
						for (n = t; n._dp; )
							n.rawTime() >= 0 && n.totalTime(n._tTime), (n = n._dp);
					t._zTime = -H;
				}
			},
			Kt = function (t, e, n, i) {
				return (
					e.parent && Gt(e),
					(e._start = Lt(n + e._delay)),
					(e._end = Lt(
						e._start + (e.totalDuration() / Math.abs(e.timeScale()) || 0)
					)),
					(function (t, e, n, i, r) {
						void 0 === n && (n = "_first"), void 0 === i && (i = "_last");
						var o,
							s = t[i];
						if (r) for (o = e[r]; s && s[r] > o; ) s = s._prev;
						s
							? ((e._next = s._next), (s._next = e))
							: ((e._next = t[n]), (t[n] = e)),
							e._next ? (e._next._prev = e) : (t[i] = e),
							(e._prev = s),
							(e.parent = e._dp = t);
					})(t, e, "_first", "_last", t._sort ? "_start" : 0),
					(t._recent = e),
					i || Jt(t, e),
					t
				);
			},
			Qt = function (t, e) {
				return (
					(lt.ScrollTrigger || dt("scrollTrigger", e)) &&
					lt.ScrollTrigger.create(e, t)
				);
			},
			$t = function (t, e, n, i) {
				return (
					Ze(t, e),
					t._initted
						? !n &&
						  t._pt &&
						  ((t._dur && !1 !== t.vars.lazy) || (!t._dur && t.vars.lazy)) &&
						  k !== Re.frame
							? (vt.push(t), (t._lazy = [e, i]), 1)
							: void 0
						: 1
				);
			},
			te = function (t, e, n, i) {
				var r = t._repeat,
					o = Lt(e) || 0,
					s = t._tTime / t._tDur;
				return (
					s && !i && (t._time *= o / t._dur),
					(t._dur = o),
					(t._tDur = r ? (r < 0 ? 1e10 : Lt(o * (r + 1) + t._rDelay * r)) : o),
					s && !i ? Zt(t, (t._tTime = t._tDur * s)) : t.parent && Xt(t),
					n || Vt(t.parent, t),
					t
				);
			},
			ee = function (t) {
				return t instanceof We ? Vt(t) : te(t, t._dur);
			},
			ne = { _start: 0, endTime: mt },
			ie = function t(e, n) {
				var i,
					r,
					o = e.labels,
					s = e._recent || ne,
					a = e.duration() >= 1e8 ? s.endTime(!1) : e._dur;
				return Y(n) && (isNaN(n) || n in o)
					? "<" === (i = n.charAt(0)) || ">" === i
						? ("<" === i ? s._start : s.endTime(s._repeat >= 0)) +
						  (parseFloat(n.substr(1)) || 0)
						: (i = n.indexOf("=")) < 0
						? (n in o || (o[n] = a), o[n])
						: ((r = +(n.charAt(i - 1) + n.substr(i + 1))),
						  i > 1 ? t(e, n.substr(0, i - 1)) + r : a + r)
					: null == n
					? a
					: +n;
			},
			re = function (t, e) {
				return t || 0 === t ? e(t) : e;
			},
			oe = function (t, e, n) {
				return n < t ? t : n > e ? e : n;
			},
			se = function (t) {
				return (t = (t + "").substr((parseFloat(t) + "").length)) && isNaN(t)
					? t
					: "";
			},
			ae = [].slice,
			ce = function (t, e) {
				return (
					t &&
					K(t) &&
					"length" in t &&
					((!e && !t.length) || (t.length - 1 in t && K(t[0]))) &&
					!t.nodeType &&
					t !== C
				);
			},
			le = function (t, e, n) {
				return (
					void 0 === n && (n = []),
					t.forEach(function (t) {
						var i;
						return (Y(t) && !e) || ce(t, 1)
							? (i = n).push.apply(i, he(t))
							: n.push(t);
					}) || n
				);
			},
			he = function (t, e) {
				return !Y(t) || e || (!O && Ce())
					? nt(t)
						? le(t, e)
						: ce(t)
						? ae.call(t, 0)
						: t
						? [t]
						: []
					: ae.call(D.querySelectorAll(t), 0);
			},
			ue = function (t) {
				return t.sort(function () {
					return 0.5 - Math.random();
				});
			},
			de = function (t) {
				if (X(t)) return t;
				var e = K(t) ? t : { each: t },
					n = Fe(e.ease),
					i = e.from || 0,
					r = parseFloat(e.base) || 0,
					o = {},
					s = i > 0 && i < 1,
					a = isNaN(i) || s,
					c = e.axis,
					l = i,
					h = i;
				return (
					Y(i)
						? (l = h = { center: 0.5, edges: 0.5, end: 1 }[i] || 0)
						: !s && a && ((l = i[0]), (h = i[1])),
					function (t, s, u) {
						var d,
							p,
							f,
							m,
							g,
							v,
							y,
							x,
							b,
							w = (u || e).length,
							_ = o[w];
						if (!_) {
							if (!(b = "auto" === e.grid ? 0 : (e.grid || [1, 1e8])[1])) {
								for (
									y = -1e8;
									y < (y = u[b++].getBoundingClientRect().left) && b < w;

								);
								b--;
							}
							for (
								_ = o[w] = [],
									d = a ? Math.min(b, w) * l - 0.5 : i % b,
									p = a ? (w * h) / b - 0.5 : (i / b) | 0,
									y = 0,
									x = 1e8,
									v = 0;
								v < w;
								v++
							)
								(f = (v % b) - d),
									(m = p - ((v / b) | 0)),
									(_[v] = g =
										c ? Math.abs("y" === c ? m : f) : j(f * f + m * m)),
									g > y && (y = g),
									g < x && (x = g);
							"random" === i && ue(_),
								(_.max = y - x),
								(_.min = x),
								(_.v = w =
									(parseFloat(e.amount) ||
										parseFloat(e.each) *
											(b > w
												? w - 1
												: c
												? "y" === c
													? w / b
													: b
												: Math.max(b, w / b)) ||
										0) * ("edges" === i ? -1 : 1)),
								(_.b = w < 0 ? r - w : r),
								(_.u = se(e.amount || e.each) || 0),
								(n = n && w < 0 ? Ne(n) : n);
						}
						return (
							(w = (_[t] - _.min) / _.max || 0),
							Lt(_.b + (n ? n(w) : w) * _.v) + _.u
						);
					}
				);
			},
			pe = function (t) {
				var e = t < 1 ? Math.pow(10, (t + "").length - 2) : 1;
				return function (n) {
					return (
						Math.floor(Math.round(parseFloat(n) / t) * t * e) / e +
						(Z(n) ? 0 : se(n))
					);
				};
			},
			fe = function (t, e) {
				var n,
					i,
					r = nt(t);
				return (
					!r &&
						K(t) &&
						((n = r = t.radius || 1e8),
						t.values
							? ((t = he(t.values)), (i = !Z(t[0])) && (n *= n))
							: (t = pe(t.increment))),
					re(
						e,
						r
							? X(t)
								? function (e) {
										return (i = t(e)), Math.abs(i - e) <= n ? i : e;
								  }
								: function (e) {
										for (
											var r,
												o,
												s = parseFloat(i ? e.x : e),
												a = parseFloat(i ? e.y : 0),
												c = 1e8,
												l = 0,
												h = t.length;
											h--;

										)
											(r = i
												? (r = t[h].x - s) * r + (o = t[h].y - a) * o
												: Math.abs(t[h] - s)) < c && ((c = r), (l = h));
										return (
											(l = !n || c <= n ? t[l] : e),
											i || l === e || Z(e) ? l : l + se(e)
										);
								  }
							: pe(t)
					)
				);
			},
			me = function (t, e, n, i) {
				return re(nt(t) ? !e : !0 === n ? !!(n = 0) : !i, function () {
					return nt(t)
						? t[~~(Math.random() * t.length)]
						: (n = n || 1e-5) &&
								(i = n < 1 ? Math.pow(10, (n + "").length - 2) : 1) &&
								Math.floor(
									Math.round((t + Math.random() * (e - t)) / n) * n * i
								) / i;
				});
			},
			ge = function (t, e, n) {
				return re(n, function (n) {
					return t[~~e(n)];
				});
			},
			ve = function (t) {
				for (var e, n, i, r, o = 0, s = ""; ~(e = t.indexOf("random(", o)); )
					(i = t.indexOf(")", e)),
						(r = "[" === t.charAt(e + 7)),
						(n = t.substr(e + 7, i - e - 7).match(r ? ct : it)),
						(s +=
							t.substr(o, e - o) +
							me(r ? n : +n[0], r ? 0 : +n[1], +n[2] || 1e-5)),
						(o = i + 1);
				return s + t.substr(o, t.length - o);
			},
			ye = function (t, e, n, i, r) {
				var o = e - t,
					s = i - n;
				return re(r, function (e) {
					return n + (((e - t) / o) * s || 0);
				});
			},
			xe = function (t, e, n) {
				var i,
					r,
					o,
					s = t.labels,
					a = 1e8;
				for (i in s)
					(r = s[i] - e) < 0 == !!n &&
						r &&
						a > (r = Math.abs(r)) &&
						((o = i), (a = r));
				return o;
			},
			be = function (t, e, n) {
				var i,
					r,
					o = t.vars,
					s = o[e];
				if (s)
					return (
						(i = o[e + "Params"]),
						(r = o.callbackScope || t),
						n && vt.length && Ct(),
						i ? s.apply(r, i) : s.call(r)
					);
			},
			we = function (t) {
				return Gt(t), t.progress() < 1 && be(t, "onInterrupt"), t;
			},
			_e = {
				aqua: [0, 255, 255],
				lime: [0, 255, 0],
				silver: [192, 192, 192],
				black: [0, 0, 0],
				maroon: [128, 0, 0],
				teal: [0, 128, 128],
				blue: [0, 0, 255],
				navy: [0, 0, 128],
				white: [255, 255, 255],
				olive: [128, 128, 0],
				yellow: [255, 255, 0],
				orange: [255, 165, 0],
				gray: [128, 128, 128],
				purple: [128, 0, 128],
				green: [0, 128, 0],
				red: [255, 0, 0],
				pink: [255, 192, 203],
				cyan: [0, 255, 255],
				transparent: [255, 255, 255, 0],
			},
			Me = function (t, e, n) {
				return (
					(255 *
						(6 * (t = t < 0 ? t + 1 : t > 1 ? t - 1 : t) < 1
							? e + (n - e) * t * 6
							: t < 0.5
							? n
							: 3 * t < 2
							? e + (n - e) * (2 / 3 - t) * 6
							: e) +
						0.5) |
					0
				);
			},
			Se = function (t, e, n) {
				var i,
					r,
					o,
					s,
					a,
					c,
					l,
					h,
					u,
					d,
					p = t ? (Z(t) ? [t >> 16, (t >> 8) & 255, 255 & t] : 0) : _e.black;
				if (!p) {
					if (("," === t.substr(-1) && (t = t.substr(0, t.length - 1)), _e[t]))
						p = _e[t];
					else if ("#" === t.charAt(0))
						4 === t.length &&
							(t =
								"#" +
								(i = t.charAt(1)) +
								i +
								(r = t.charAt(2)) +
								r +
								(o = t.charAt(3)) +
								o),
							(p = [
								(t = parseInt(t.substr(1), 16)) >> 16,
								(t >> 8) & 255,
								255 & t,
							]);
					else if ("hsl" === t.substr(0, 3))
						if (((p = d = t.match(it)), e)) {
							if (~t.indexOf("="))
								return (p = t.match(rt)), n && p.length < 4 && (p[3] = 1), p;
						} else
							(s = (+p[0] % 360) / 360),
								(a = +p[1] / 100),
								(i =
									2 * (c = +p[2] / 100) -
									(r = c <= 0.5 ? c * (a + 1) : c + a - c * a)),
								p.length > 3 && (p[3] *= 1),
								(p[0] = Me(s + 1 / 3, i, r)),
								(p[1] = Me(s, i, r)),
								(p[2] = Me(s - 1 / 3, i, r));
					else p = t.match(it) || _e.transparent;
					p = p.map(Number);
				}
				return (
					e &&
						!d &&
						((i = p[0] / 255),
						(r = p[1] / 255),
						(o = p[2] / 255),
						(c = ((l = Math.max(i, r, o)) + (h = Math.min(i, r, o))) / 2),
						l === h
							? (s = a = 0)
							: ((u = l - h),
							  (a = c > 0.5 ? u / (2 - l - h) : u / (l + h)),
							  (s =
									l === i
										? (r - o) / u + (r < o ? 6 : 0)
										: l === r
										? (o - i) / u + 2
										: (i - r) / u + 4),
							  (s *= 60)),
						(p[0] = ~~(s + 0.5)),
						(p[1] = ~~(100 * a + 0.5)),
						(p[2] = ~~(100 * c + 0.5))),
					n && p.length < 4 && (p[3] = 1),
					p
				);
			},
			Te = function (t) {
				var e = [],
					n = [],
					i = -1;
				return (
					t.split(Ae).forEach(function (t) {
						var r = t.match(ot) || [];
						e.push.apply(e, r), n.push((i += r.length + 1));
					}),
					(e.c = n),
					e
				);
			},
			Ee = function (t, e, n) {
				var i,
					r,
					o,
					s,
					a = "",
					c = (t + a).match(Ae),
					l = e ? "hsla(" : "rgba(",
					h = 0;
				if (!c) return t;
				if (
					((c = c.map(function (t) {
						return (
							(t = Se(t, e, 1)) &&
							l +
								(e
									? t[0] + "," + t[1] + "%," + t[2] + "%," + t[3]
									: t.join(",")) +
								")"
						);
					})),
					n && ((o = Te(t)), (i = n.c).join(a) !== o.c.join(a)))
				)
					for (s = (r = t.replace(Ae, "1").split(ot)).length - 1; h < s; h++)
						a +=
							r[h] +
							(~i.indexOf(h)
								? c.shift() || l + "0,0,0,0)"
								: (o.length ? o : c.length ? c : n).shift());
				if (!r)
					for (s = (r = t.split(Ae)).length - 1; h < s; h++) a += r[h] + c[h];
				return a + r[s];
			},
			Ae = (function () {
				var t,
					e =
						"(?:\\b(?:(?:rgb|rgba|hsl|hsla)\\(.+?\\))|\\B#(?:[0-9a-f]{3}){1,2}\\b";
				for (t in _e) e += "|" + t + "\\b";
				return new RegExp(e + ")", "gi");
			})(),
			Le = /hsl[a]?\(/,
			Pe = function (t) {
				var e,
					n = t.join(" ");
				if (((Ae.lastIndex = 0), Ae.test(n)))
					return (
						(e = Le.test(n)),
						(t[1] = Ee(t[1], e)),
						(t[0] = Ee(t[0], e, Te(t[1]))),
						!0
					);
			},
			Re = (function () {
				var t,
					e,
					n,
					i,
					r,
					o,
					s = Date.now,
					a = 500,
					c = 33,
					l = s(),
					h = l,
					u = 1e3 / 240,
					d = u,
					p = [],
					f = function n(f) {
						var m,
							g,
							v,
							y,
							x = s() - h,
							b = !0 === f;
						if (
							(x > a && (l += x - c),
							((m = (v = (h += x) - l) - d) > 0 || b) &&
								((y = ++i.frame),
								(r = v - 1e3 * i.time),
								(i.time = v /= 1e3),
								(d += m + (m >= u ? 4 : u - m)),
								(g = 1)),
							b || (t = e(n)),
							g)
						)
							for (o = 0; o < p.length; o++) p[o](v, r, y, f);
					};
				return (i = {
					time: 0,
					frame: 0,
					tick: function () {
						f(!0);
					},
					deltaRatio: function (t) {
						return r / (1e3 / (t || 60));
					},
					wake: function () {
						I &&
							(!O &&
								$() &&
								((C = O = window),
								(D = C.document || {}),
								(lt.gsap = yn),
								(C.gsapVersions || (C.gsapVersions = [])).push(yn.version),
								ut(ht || C.GreenSockGlobals || (!C.gsap && C) || {}),
								(n = C.requestAnimationFrame)),
							t && i.sleep(),
							(e =
								n ||
								function (t) {
									return setTimeout(t, (d - 1e3 * i.time + 1) | 0);
								}),
							(B = 1),
							f(2));
					},
					sleep: function () {
						(n ? C.cancelAnimationFrame : clearTimeout)(t), (B = 0), (e = mt);
					},
					lagSmoothing: function (t, e) {
						(a = t || 1 / H), (c = Math.min(e, a, 0));
					},
					fps: function (t) {
						(u = 1e3 / (t || 240)), (d = 1e3 * i.time + u);
					},
					add: function (t) {
						p.indexOf(t) < 0 && p.push(t), Ce();
					},
					remove: function (t) {
						var e;
						~(e = p.indexOf(t)) && p.splice(e, 1) && o >= e && o--;
					},
					_listeners: p,
				});
			})(),
			Ce = function () {
				return !B && Re.wake();
			},
			Oe = {},
			De = /^[\d.\-M][\d.\-,\s]/,
			Ie = /["']/g,
			ke = function (t) {
				var e,
					n,
					i,
					r,
					o = (t + "").split("("),
					s = Oe[o[0]];
				return s && o.length > 1 && s.config
					? s.config.apply(
							null,
							~t.indexOf("{")
								? [
										(function (t) {
											for (
												var e,
													n,
													i,
													r = {},
													o = t.substr(1, t.length - 3).split(":"),
													s = o[0],
													a = 1,
													c = o.length;
												a < c;
												a++
											)
												(n = o[a]),
													(e = a !== c - 1 ? n.lastIndexOf(",") : n.length),
													(i = n.substr(0, e)),
													(r[s] = isNaN(i) ? i.replace(Ie, "").trim() : +i),
													(s = n.substr(e + 1).trim());
											return r;
										})(o[1]),
								  ]
								: ((e = t),
								  (n = e.indexOf("(") + 1),
								  (i = e.indexOf(")")),
								  (r = e.indexOf("(", n)),
								  e.substring(n, ~r && r < i ? e.indexOf(")", i + 1) : i))
										.split(",")
										.map(Dt)
					  )
					: Oe._CE && De.test(t)
					? Oe._CE("", t)
					: s;
			},
			Ne = function (t) {
				return function (e) {
					return 1 - t(1 - e);
				};
			},
			Be = function t(e, n) {
				for (var i, r = e._first; r; )
					r instanceof We
						? t(r, n)
						: !r.vars.yoyoEase ||
						  (r._yoyo && r._repeat) ||
						  r._yoyo === n ||
						  (r.timeline
								? t(r.timeline, n)
								: ((i = r._ease),
								  (r._ease = r._yEase),
								  (r._yEase = i),
								  (r._yoyo = n))),
						(r = r._next);
			},
			Fe = function (t, e) {
				return (t && (X(t) ? t : Oe[t] || ke(t))) || e;
			},
			ze = function (t, e, n, i) {
				void 0 === n &&
					(n = function (t) {
						return 1 - e(1 - t);
					}),
					void 0 === i &&
						(i = function (t) {
							return t < 0.5 ? e(2 * t) / 2 : 1 - e(2 * (1 - t)) / 2;
						});
				var r,
					o = { easeIn: e, easeOut: n, easeInOut: i };
				return (
					At(t, function (t) {
						for (var e in ((Oe[t] = lt[t] = o),
						(Oe[(r = t.toLowerCase())] = n),
						o))
							Oe[
								r +
									("easeIn" === e ? ".in" : "easeOut" === e ? ".out" : ".inOut")
							] = Oe[t + "." + e] = o[e];
					}),
					o
				);
			},
			He = function (t) {
				return function (e) {
					return e < 0.5 ? (1 - t(1 - 2 * e)) / 2 : 0.5 + t(2 * (e - 0.5)) / 2;
				};
			},
			Ue = function t(e, n, i) {
				var r = n >= 1 ? n : 1,
					o = (i || (e ? 0.3 : 0.45)) / (n < 1 ? n : 1),
					s = (o / U) * (Math.asin(1 / r) || 0),
					a = function (t) {
						return 1 === t ? 1 : r * Math.pow(2, -10 * t) * q((t - s) * o) + 1;
					},
					c =
						"out" === e
							? a
							: "in" === e
							? function (t) {
									return 1 - a(1 - t);
							  }
							: He(a);
				return (
					(o = U / o),
					(c.config = function (n, i) {
						return t(e, n, i);
					}),
					c
				);
			},
			Ge = function t(e, n) {
				void 0 === n && (n = 1.70158);
				var i = function (t) {
						return t ? --t * t * ((n + 1) * t + n) + 1 : 0;
					},
					r =
						"out" === e
							? i
							: "in" === e
							? function (t) {
									return 1 - i(1 - t);
							  }
							: He(i);
				return (
					(r.config = function (n) {
						return t(e, n);
					}),
					r
				);
			};
		At("Linear,Quad,Cubic,Quart,Quint,Strong", function (t, e) {
			var n = e < 5 ? e + 1 : e;
			ze(
				t + ",Power" + (n - 1),
				e
					? function (t) {
							return Math.pow(t, n);
					  }
					: function (t) {
							return t;
					  },
				function (t) {
					return 1 - Math.pow(1 - t, n);
				},
				function (t) {
					return t < 0.5
						? Math.pow(2 * t, n) / 2
						: 1 - Math.pow(2 * (1 - t), n) / 2;
				}
			);
		}),
			(Oe.Linear.easeNone = Oe.none = Oe.Linear.easeIn),
			ze("Elastic", Ue("in"), Ue("out"), Ue()),
			(function (t, e) {
				var n = 1 / e,
					i = function (i) {
						return i < n
							? t * i * i
							: i < 0.7272727272727273
							? t * Math.pow(i - 1.5 / e, 2) + 0.75
							: i < 0.9090909090909092
							? t * (i -= 2.25 / e) * i + 0.9375
							: t * Math.pow(i - 2.625 / e, 2) + 0.984375;
					};
				ze(
					"Bounce",
					function (t) {
						return 1 - i(1 - t);
					},
					i
				);
			})(7.5625, 2.75),
			ze("Expo", function (t) {
				return t ? Math.pow(2, 10 * (t - 1)) : 0;
			}),
			ze("Circ", function (t) {
				return -(j(1 - t * t) - 1);
			}),
			ze("Sine", function (t) {
				return 1 === t ? 1 : 1 - W(t * G);
			}),
			ze("Back", Ge("in"), Ge("out"), Ge()),
			(Oe.SteppedEase =
				Oe.steps =
				lt.SteppedEase =
					{
						config: function (t, e) {
							void 0 === t && (t = 1);
							var n = 1 / t,
								i = t + (e ? 0 : 1),
								r = e ? 1 : 0,
								o = 1 - H;
							return function (t) {
								return (((i * oe(0, o, t)) | 0) + r) * n;
							};
						},
					}),
			(z.ease = Oe["quad.out"]),
			At(
				"onComplete,onUpdate,onStart,onRepeat,onReverseComplete,onInterrupt",
				function (t) {
					return (Mt += t + "," + t + "Params,");
				}
			);
		var Ve = function (t, e) {
				(this.id = V++),
					(t._gsap = this),
					(this.target = t),
					(this.harness = e),
					(this.get = e ? e.get : Et),
					(this.set = e ? e.getSetter : on);
			},
			je = (function () {
				function t(t, e) {
					var n = t.parent || R;
					(this.vars = t),
						(this._delay = +t.delay || 0),
						(this._repeat = t.repeat || 0) &&
							((this._rDelay = t.repeatDelay || 0),
							(this._yoyo = !!t.yoyo || !!t.yoyoEase)),
						(this._ts = 1),
						te(this, +t.duration, 1, 1),
						(this.data = t.data),
						B || Re.wake(),
						n && Kt(n, this, e || 0 === e ? e : n._time, 1),
						t.reversed && this.reverse(),
						t.paused && this.paused(!0);
				}
				var e = t.prototype;
				return (
					(e.delay = function (t) {
						return t || 0 === t
							? (this.parent &&
									this.parent.smoothChildTiming &&
									this.startTime(this._start + t - this._delay),
							  (this._delay = t),
							  this)
							: this._delay;
					}),
					(e.duration = function (t) {
						return arguments.length
							? this.totalDuration(
									this._repeat > 0 ? t + (t + this._rDelay) * this._repeat : t
							  )
							: this.totalDuration() && this._dur;
					}),
					(e.totalDuration = function (t) {
						return arguments.length
							? ((this._dirty = 0),
							  te(
									this,
									this._repeat < 0
										? t
										: (t - this._repeat * this._rDelay) / (this._repeat + 1)
							  ))
							: this._tDur;
					}),
					(e.totalTime = function (t, e) {
						if ((Ce(), !arguments.length)) return this._tTime;
						var n = this._dp;
						if (n && n.smoothChildTiming && this._ts) {
							for (Zt(this, t); n.parent; )
								n.parent._time !==
									n._start +
										(n._ts >= 0
											? n._tTime / n._ts
											: (n.totalDuration() - n._tTime) / -n._ts) &&
									n.totalTime(n._tTime, !0),
									(n = n.parent);
							!this.parent &&
								this._dp.autoRemoveChildren &&
								((this._ts > 0 && t < this._tDur) ||
									(this._ts < 0 && t > 0) ||
									(!this._tDur && !t)) &&
								Kt(this._dp, this, this._start - this._delay);
						}
						return (
							(this._tTime !== t ||
								(!this._dur && !e) ||
								(this._initted && Math.abs(this._zTime) === H) ||
								(!t && !this._initted && (this.add || this._ptLookup))) &&
								(this._ts || (this._pTime = t), Ot(this, t, e)),
							this
						);
					}),
					(e.time = function (t, e) {
						return arguments.length
							? this.totalTime(
									Math.min(this.totalDuration(), t + Wt(this)) % this._dur ||
										(t ? this._dur : 0),
									e
							  )
							: this._time;
					}),
					(e.totalProgress = function (t, e) {
						return arguments.length
							? this.totalTime(this.totalDuration() * t, e)
							: this.totalDuration()
							? Math.min(1, this._tTime / this._tDur)
							: this.ratio;
					}),
					(e.progress = function (t, e) {
						return arguments.length
							? this.totalTime(
									this.duration() *
										(!this._yoyo || 1 & this.iteration() ? t : 1 - t) +
										Wt(this),
									e
							  )
							: this.duration()
							? Math.min(1, this._time / this._dur)
							: this.ratio;
					}),
					(e.iteration = function (t, e) {
						var n = this.duration() + this._rDelay;
						return arguments.length
							? this.totalTime(this._time + (t - 1) * n, e)
							: this._repeat
							? qt(this._tTime, n) + 1
							: 1;
					}),
					(e.timeScale = function (t) {
						if (!arguments.length) return this._rts === -H ? 0 : this._rts;
						if (this._rts === t) return this;
						var e =
							this.parent && this._ts
								? Yt(this.parent._time, this)
								: this._tTime;
						return (
							(this._rts = +t || 0),
							(this._ts = this._ps || t === -H ? 0 : this._rts),
							(function (t) {
								for (var e = t.parent; e && e.parent; )
									(e._dirty = 1), e.totalDuration(), (e = e.parent);
								return t;
							})(this.totalTime(oe(-this._delay, this._tDur, e), !0))
						);
					}),
					(e.paused = function (t) {
						return arguments.length
							? (this._ps !== t &&
									((this._ps = t),
									t
										? ((this._pTime =
												this._tTime || Math.max(-this._delay, this.rawTime())),
										  (this._ts = this._act = 0))
										: (Ce(),
										  (this._ts = this._rts),
										  this.totalTime(
												this.parent && !this.parent.smoothChildTiming
													? this.rawTime()
													: this._tTime || this._pTime,
												1 === this.progress() &&
													(this._tTime -= H) &&
													Math.abs(this._zTime) !== H
										  ))),
							  this)
							: this._ps;
					}),
					(e.startTime = function (t) {
						if (arguments.length) {
							this._start = t;
							var e = this.parent || this._dp;
							return (
								e && (e._sort || !this.parent) && Kt(e, this, t - this._delay),
								this
							);
						}
						return this._start;
					}),
					(e.endTime = function (t) {
						return (
							this._start +
							(Q(t) ? this.totalDuration() : this.duration()) /
								Math.abs(this._ts)
						);
					}),
					(e.rawTime = function (t) {
						var e = this.parent || this._dp;
						return e
							? t &&
							  (!this._ts ||
									(this._repeat && this._time && this.totalProgress() < 1))
								? this._tTime % (this._dur + this._rDelay)
								: this._ts
								? Yt(e.rawTime(t), this)
								: this._tTime
							: this._tTime;
					}),
					(e.globalTime = function (t) {
						for (var e = this, n = arguments.length ? t : e.rawTime(); e; )
							(n = e._start + n / (e._ts || 1)), (e = e._dp);
						return n;
					}),
					(e.repeat = function (t) {
						return arguments.length
							? ((this._repeat = t), ee(this))
							: this._repeat;
					}),
					(e.repeatDelay = function (t) {
						return arguments.length
							? ((this._rDelay = t), ee(this))
							: this._rDelay;
					}),
					(e.yoyo = function (t) {
						return arguments.length ? ((this._yoyo = t), this) : this._yoyo;
					}),
					(e.seek = function (t, e) {
						return this.totalTime(ie(this, t), Q(e));
					}),
					(e.restart = function (t, e) {
						return this.play().totalTime(t ? -this._delay : 0, Q(e));
					}),
					(e.play = function (t, e) {
						return null != t && this.seek(t, e), this.reversed(!1).paused(!1);
					}),
					(e.reverse = function (t, e) {
						return (
							null != t && this.seek(t || this.totalDuration(), e),
							this.reversed(!0).paused(!1)
						);
					}),
					(e.pause = function (t, e) {
						return null != t && this.seek(t, e), this.paused(!0);
					}),
					(e.resume = function () {
						return this.paused(!1);
					}),
					(e.reversed = function (t) {
						return arguments.length
							? (!!t !== this.reversed() &&
									this.timeScale(-this._rts || (t ? -H : 0)),
							  this)
							: this._rts < 0;
					}),
					(e.invalidate = function () {
						return (this._initted = 0), (this._zTime = -H), this;
					}),
					(e.isActive = function () {
						var t,
							e = this.parent || this._dp,
							n = this._start;
						return !(
							e &&
							!(
								this._ts &&
								this._initted &&
								e.isActive() &&
								(t = e.rawTime(!0)) >= n &&
								t < this.endTime(!0) - H
							)
						);
					}),
					(e.eventCallback = function (t, e, n) {
						var i = this.vars;
						return arguments.length > 1
							? (e
									? ((i[t] = e),
									  n && (i[t + "Params"] = n),
									  "onUpdate" === t && (this._onUpdate = e))
									: delete i[t],
							  this)
							: i[t];
					}),
					(e.then = function (t) {
						var e = this;
						return new Promise(function (n) {
							var i = X(t) ? t : It,
								r = function () {
									var t = e.then;
									(e.then = null),
										X(i) && (i = i(e)) && (i.then || i === e) && (e.then = t),
										n(i),
										(e.then = t);
								};
							(e._initted && 1 === e.totalProgress() && e._ts >= 0) ||
							(!e._tTime && e._ts < 0)
								? r()
								: (e._prom = r);
						});
					}),
					(e.kill = function () {
						we(this);
					}),
					t
				);
			})();
		kt(je.prototype, {
			_time: 0,
			_start: 0,
			_end: 0,
			_tTime: 0,
			_tDur: 0,
			_dirty: 0,
			_repeat: 0,
			_yoyo: !1,
			parent: null,
			_initted: !1,
			_rDelay: 0,
			_ts: 1,
			_dp: 0,
			ratio: 0,
			_zTime: -H,
			_prom: 0,
			_ps: !1,
			_rts: 1,
		});
		var We = (function (t) {
			function e(e, n) {
				var i;
				return (
					void 0 === e && (e = {}),
					((i = t.call(this, e, n) || this).labels = {}),
					(i.smoothChildTiming = !!e.smoothChildTiming),
					(i.autoRemoveChildren = !!e.autoRemoveChildren),
					(i._sort = Q(e.sortChildren)),
					i.parent && Jt(i.parent, L(i)),
					e.scrollTrigger && Qt(L(i), e.scrollTrigger),
					i
				);
			}
			P(e, t);
			var n = e.prototype;
			return (
				(n.to = function (t, e, n) {
					return (
						new $e(
							t,
							Rt(arguments, 0, this),
							ie(this, Z(e) ? arguments[3] : n)
						),
						this
					);
				}),
				(n.from = function (t, e, n) {
					return (
						new $e(
							t,
							Rt(arguments, 1, this),
							ie(this, Z(e) ? arguments[3] : n)
						),
						this
					);
				}),
				(n.fromTo = function (t, e, n, i) {
					return (
						new $e(
							t,
							Rt(arguments, 2, this),
							ie(this, Z(e) ? arguments[4] : i)
						),
						this
					);
				}),
				(n.set = function (t, e, n) {
					return (
						(e.duration = 0),
						(e.parent = this),
						Ht(e).repeatDelay || (e.repeat = 0),
						(e.immediateRender = !!e.immediateRender),
						new $e(t, e, ie(this, n), 1),
						this
					);
				}),
				(n.call = function (t, e, n) {
					return Kt(this, $e.delayedCall(0, t, e), ie(this, n));
				}),
				(n.staggerTo = function (t, e, n, i, r, o, s) {
					return (
						(n.duration = e),
						(n.stagger = n.stagger || i),
						(n.onComplete = o),
						(n.onCompleteParams = s),
						(n.parent = this),
						new $e(t, n, ie(this, r)),
						this
					);
				}),
				(n.staggerFrom = function (t, e, n, i, r, o, s) {
					return (
						(n.runBackwards = 1),
						(Ht(n).immediateRender = Q(n.immediateRender)),
						this.staggerTo(t, e, n, i, r, o, s)
					);
				}),
				(n.staggerFromTo = function (t, e, n, i, r, o, s, a) {
					return (
						(i.startAt = n),
						(Ht(i).immediateRender = Q(i.immediateRender)),
						this.staggerTo(t, e, i, r, o, s, a)
					);
				}),
				(n.render = function (t, e, n) {
					var i,
						r,
						o,
						s,
						a,
						c,
						l,
						h,
						u,
						d,
						p,
						f,
						m = this._time,
						g = this._dirty ? this.totalDuration() : this._tDur,
						v = this._dur,
						y = this !== R && t > g - H && t >= 0 ? g : t < H ? 0 : t,
						x = this._zTime < 0 != t < 0 && (this._initted || !v);
					if (y !== this._tTime || n || x) {
						if (
							(m !== this._time &&
								v &&
								((y += this._time - m), (t += this._time - m)),
							(i = y),
							(u = this._start),
							(c = !(h = this._ts)),
							x && (v || (m = this._zTime), (t || !e) && (this._zTime = t)),
							this._repeat &&
								((p = this._yoyo),
								(a = v + this._rDelay),
								(i = Lt(y % a)),
								y === g
									? ((s = this._repeat), (i = v))
									: ((s = ~~(y / a)) && s === y / a && ((i = v), s--),
									  i > v && (i = v)),
								(d = qt(this._tTime, a)),
								!m && this._tTime && d !== s && (d = s),
								p && 1 & s && ((i = v - i), (f = 1)),
								s !== d && !this._lock))
						) {
							var b = p && 1 & d,
								w = b === (p && 1 & s);
							if (
								(s < d && (b = !b),
								(m = b ? 0 : v),
								(this._lock = 1),
								(this.render(m || (f ? 0 : Lt(s * a)), e, !v)._lock = 0),
								!e && this.parent && be(this, "onRepeat"),
								this.vars.repeatRefresh && !f && (this.invalidate()._lock = 1),
								m !== this._time || c !== !this._ts)
							)
								return this;
							if (
								((v = this._dur),
								(g = this._tDur),
								w &&
									((this._lock = 2),
									(m = b ? v : -1e-4),
									this.render(m, !0),
									this.vars.repeatRefresh && !f && this.invalidate()),
								(this._lock = 0),
								!this._ts && !c)
							)
								return this;
							Be(this, f);
						}
						if (
							(this._hasPause &&
								!this._forcing &&
								this._lock < 2 &&
								(l = (function (t, e, n) {
									var i;
									if (n > e)
										for (i = t._first; i && i._start <= n; ) {
											if (!i._dur && "isPause" === i.data && i._start > e)
												return i;
											i = i._next;
										}
									else
										for (i = t._last; i && i._start >= n; ) {
											if (!i._dur && "isPause" === i.data && i._start < e)
												return i;
											i = i._prev;
										}
								})(this, Lt(m), Lt(i))) &&
								(y -= i - (i = l._start)),
							(this._tTime = y),
							(this._time = i),
							(this._act = !h),
							this._initted ||
								((this._onUpdate = this.vars.onUpdate),
								(this._initted = 1),
								(this._zTime = t)),
							!m && i && !e && be(this, "onStart"),
							i >= m && t >= 0)
						)
							for (r = this._first; r; ) {
								if (
									((o = r._next), (r._act || i >= r._start) && r._ts && l !== r)
								) {
									if (r.parent !== this) return this.render(t, e, n);
									if (
										(r.render(
											r._ts > 0
												? (i - r._start) * r._ts
												: (r._dirty ? r.totalDuration() : r._tDur) +
														(i - r._start) * r._ts,
											e,
											n
										),
										i !== this._time || (!this._ts && !c))
									) {
										(l = 0), o && (y += this._zTime = -H);
										break;
									}
								}
								r = o;
							}
						else {
							r = this._last;
							for (var _ = t < 0 ? t : i; r; ) {
								if (
									((o = r._prev), (r._act || _ <= r._end) && r._ts && l !== r)
								) {
									if (r.parent !== this) return this.render(t, e, n);
									if (
										(r.render(
											r._ts > 0
												? (_ - r._start) * r._ts
												: (r._dirty ? r.totalDuration() : r._tDur) +
														(_ - r._start) * r._ts,
											e,
											n
										),
										i !== this._time || (!this._ts && !c))
									) {
										(l = 0), o && (y += this._zTime = _ ? -H : H);
										break;
									}
								}
								r = o;
							}
						}
						if (
							l &&
							!e &&
							(this.pause(),
							(l.render(i >= m ? 0 : -H)._zTime = i >= m ? 1 : -1),
							this._ts)
						)
							return (this._start = u), Xt(this), this.render(t, e, n);
						this._onUpdate && !e && be(this, "onUpdate", !0),
							((y === g && g >= this.totalDuration()) || (!y && m)) &&
								((u !== this._start && Math.abs(h) === Math.abs(this._ts)) ||
									this._lock ||
									((t || !v) &&
										((y === g && this._ts > 0) || (!y && this._ts < 0)) &&
										Gt(this, 1),
									e ||
										(t < 0 && !m) ||
										(!y && !m) ||
										(be(this, y === g ? "onComplete" : "onReverseComplete", !0),
										this._prom &&
											!(y < g && this.timeScale() > 0) &&
											this._prom())));
					}
					return this;
				}),
				(n.add = function (t, e) {
					var n = this;
					if ((Z(e) || (e = ie(this, e)), !(t instanceof je))) {
						if (nt(t))
							return (
								t.forEach(function (t) {
									return n.add(t, e);
								}),
								this
							);
						if (Y(t)) return this.addLabel(t, e);
						if (!X(t)) return this;
						t = $e.delayedCall(0, t);
					}
					return this !== t ? Kt(this, t, e) : this;
				}),
				(n.getChildren = function (t, e, n, i) {
					void 0 === t && (t = !0),
						void 0 === e && (e = !0),
						void 0 === n && (n = !0),
						void 0 === i && (i = -1e8);
					for (var r = [], o = this._first; o; )
						o._start >= i &&
							(o instanceof $e
								? e && r.push(o)
								: (n && r.push(o),
								  t && r.push.apply(r, o.getChildren(!0, e, n)))),
							(o = o._next);
					return r;
				}),
				(n.getById = function (t) {
					for (var e = this.getChildren(1, 1, 1), n = e.length; n--; )
						if (e[n].vars.id === t) return e[n];
				}),
				(n.remove = function (t) {
					return Y(t)
						? this.removeLabel(t)
						: X(t)
						? this.killTweensOf(t)
						: (Ut(this, t),
						  t === this._recent && (this._recent = this._last),
						  Vt(this));
				}),
				(n.totalTime = function (e, n) {
					return arguments.length
						? ((this._forcing = 1),
						  !this._dp &&
								this._ts &&
								(this._start = Lt(
									Re.time -
										(this._ts > 0
											? e / this._ts
											: (this.totalDuration() - e) / -this._ts)
								)),
						  t.prototype.totalTime.call(this, e, n),
						  (this._forcing = 0),
						  this)
						: this._tTime;
				}),
				(n.addLabel = function (t, e) {
					return (this.labels[t] = ie(this, e)), this;
				}),
				(n.removeLabel = function (t) {
					return delete this.labels[t], this;
				}),
				(n.addPause = function (t, e, n) {
					var i = $e.delayedCall(0, e || mt, n);
					return (
						(i.data = "isPause"), (this._hasPause = 1), Kt(this, i, ie(this, t))
					);
				}),
				(n.removePause = function (t) {
					var e = this._first;
					for (t = ie(this, t); e; )
						e._start === t && "isPause" === e.data && Gt(e), (e = e._next);
				}),
				(n.killTweensOf = function (t, e, n) {
					for (var i = this.getTweensOf(t, n), r = i.length; r--; )
						qe !== i[r] && i[r].kill(t, e);
					return this;
				}),
				(n.getTweensOf = function (t, e) {
					for (var n, i = [], r = he(t), o = this._first, s = Z(e); o; )
						o instanceof $e
							? Pt(o._targets, r) &&
							  (s
									? (!qe || (o._initted && o._ts)) &&
									  o.globalTime(0) <= e &&
									  o.globalTime(o.totalDuration()) > e
									: !e || o.isActive()) &&
							  i.push(o)
							: (n = o.getTweensOf(r, e)).length && i.push.apply(i, n),
							(o = o._next);
					return i;
				}),
				(n.tweenTo = function (t, e) {
					e = e || {};
					var n = this,
						i = ie(n, t),
						r = e,
						o = r.startAt,
						s = r.onStart,
						a = r.onStartParams,
						c = $e.to(
							n,
							kt(e, {
								ease: "none",
								lazy: !1,
								time: i,
								overwrite: "auto",
								duration:
									e.duration ||
									Math.abs(
										(i - (o && "time" in o ? o.time : n._time)) / n.timeScale()
									) ||
									H,
								onStart: function () {
									n.pause();
									var t = e.duration || Math.abs((i - n._time) / n.timeScale());
									c._dur !== t && te(c, t, 0, 1).render(c._time, !0, !0),
										s && s.apply(c, a || []);
								},
							})
						);
					return c;
				}),
				(n.tweenFromTo = function (t, e, n) {
					return this.tweenTo(e, kt({ startAt: { time: ie(this, t) } }, n));
				}),
				(n.recent = function () {
					return this._recent;
				}),
				(n.nextLabel = function (t) {
					return void 0 === t && (t = this._time), xe(this, ie(this, t));
				}),
				(n.previousLabel = function (t) {
					return void 0 === t && (t = this._time), xe(this, ie(this, t), 1);
				}),
				(n.currentLabel = function (t) {
					return arguments.length
						? this.seek(t, !0)
						: this.previousLabel(this._time + H);
				}),
				(n.shiftChildren = function (t, e, n) {
					void 0 === n && (n = 0);
					for (var i, r = this._first, o = this.labels; r; )
						r._start >= n && ((r._start += t), (r._end += t)), (r = r._next);
					if (e) for (i in o) o[i] >= n && (o[i] += t);
					return Vt(this);
				}),
				(n.invalidate = function () {
					var e = this._first;
					for (this._lock = 0; e; ) e.invalidate(), (e = e._next);
					return t.prototype.invalidate.call(this);
				}),
				(n.clear = function (t) {
					void 0 === t && (t = !0);
					for (var e, n = this._first; n; )
						(e = n._next), this.remove(n), (n = e);
					return (
						(this._time = this._tTime = this._pTime = 0),
						t && (this.labels = {}),
						Vt(this)
					);
				}),
				(n.totalDuration = function (t) {
					var e,
						n,
						i,
						r = 0,
						o = this._last,
						s = 1e8;
					if (arguments.length)
						return this.timeScale(
							(this._repeat < 0 ? this.duration() : this.totalDuration()) /
								(this.reversed() ? -t : t)
						);
					if (this._dirty) {
						for (i = this.parent; o; )
							(e = o._prev),
								o._dirty && o.totalDuration(),
								(n = o._start) > s && this._sort && o._ts && !this._lock
									? ((this._lock = 1), (Kt(this, o, n - o._delay, 1)._lock = 0))
									: (s = n),
								n < 0 &&
									o._ts &&
									((r -= n),
									((!i && !this._dp) || (i && i.smoothChildTiming)) &&
										((this._start += n / this._ts),
										(this._time -= n),
										(this._tTime -= n)),
									this.shiftChildren(-n, !1, -Infinity),
									(s = 0)),
								o._end > r && o._ts && (r = o._end),
								(o = e);
						te(this, this === R && this._time > r ? this._time : r, 1, 1),
							(this._dirty = 0);
					}
					return this._tDur;
				}),
				(e.updateRoot = function (t) {
					if ((R._ts && (Ot(R, Yt(t, R)), (k = Re.frame)), Re.frame >= wt)) {
						wt += F.autoSleep || 120;
						var e = R._first;
						if ((!e || !e._ts) && F.autoSleep && Re._listeners.length < 2) {
							for (; e && !e._ts; ) e = e._next;
							e || Re.sleep();
						}
					}
				}),
				e
			);
		})(je);
		kt(We.prototype, { _lock: 0, _hasPause: 0, _forcing: 0 });
		var qe,
			Ye = function (t, e, n, i, r, o, s, a, c) {
				X(i) && (i = i(r || 0, t, o));
				var l,
					h = t[e],
					u =
						"get" !== n
							? n
							: X(h)
							? c
								? t[
										e.indexOf("set") || !X(t["get" + e.substr(3)])
											? e
											: "get" + e.substr(3)
								  ](c)
								: t[e]()
							: h,
					d = X(h) ? (c ? nn : en) : tn;
				if (
					(Y(i) &&
						(~i.indexOf("random(") && (i = ve(i)),
						"=" === i.charAt(1) &&
							(i =
								parseFloat(u) +
								parseFloat(i.substr(2)) * ("-" === i.charAt(0) ? -1 : 1) +
								(se(u) || 0))),
					u !== i)
				)
					return isNaN(u * i)
						? (!h && !(e in t) && dt(e, i),
						  function (t, e, n, i, r, o, s) {
								var a,
									c,
									l,
									h,
									u,
									d,
									p,
									f,
									m = new fn(this._pt, t, e, 0, 1, cn, null, r),
									g = 0,
									v = 0;
								for (
									m.b = n,
										m.e = i,
										n += "",
										(p = ~(i += "").indexOf("random(")) && (i = ve(i)),
										o && (o((f = [n, i]), t, e), (n = f[0]), (i = f[1])),
										c = n.match(st) || [];
									(a = st.exec(i));

								)
									(h = a[0]),
										(u = i.substring(g, a.index)),
										l ? (l = (l + 1) % 5) : "rgba(" === u.substr(-5) && (l = 1),
										h !== c[v++] &&
											((d = parseFloat(c[v - 1]) || 0),
											(m._pt = {
												_next: m._pt,
												p: u || 1 === v ? u : ",",
												s: d,
												c:
													"=" === h.charAt(1)
														? parseFloat(h.substr(2)) *
														  ("-" === h.charAt(0) ? -1 : 1)
														: parseFloat(h) - d,
												m: l && l < 4 ? Math.round : 0,
											}),
											(g = st.lastIndex));
								return (
									(m.c = g < i.length ? i.substring(g, i.length) : ""),
									(m.fp = s),
									(at.test(i) || p) && (m.e = 0),
									(this._pt = m),
									m
								);
						  }.call(this, t, e, u, i, d, a || F.stringFilter, c))
						: ((l = new fn(
								this._pt,
								t,
								e,
								+u || 0,
								i - (u || 0),
								"boolean" == typeof h ? an : sn,
								0,
								d
						  )),
						  c && (l.fp = c),
						  s && l.modifier(s, this, t),
						  (this._pt = l));
			},
			Xe = function (t, e, n, i, r, o) {
				var s, a, c, l;
				if (
					xt[t] &&
					!1 !==
						(s = new xt[t]()).init(
							r,
							s.rawVars
								? e[t]
								: (function (t, e, n, i, r) {
										if (
											(X(t) && (t = Je(t, r, e, n, i)),
											!K(t) || (t.style && t.nodeType) || nt(t) || et(t))
										)
											return Y(t) ? Je(t, r, e, n, i) : t;
										var o,
											s = {};
										for (o in t) s[o] = Je(t[o], r, e, n, i);
										return s;
								  })(e[t], i, r, o, n),
							n,
							i,
							o
						) &&
					((n._pt = a = new fn(n._pt, r, t, 0, 1, s.render, s, 0, s.priority)),
					n !== N)
				)
					for (
						c = n._ptLookup[n._targets.indexOf(r)], l = s._props.length;
						l--;

					)
						c[s._props[l]] = a;
				return s;
			},
			Ze = function t(e, n) {
				var i,
					r,
					o,
					s,
					a,
					c,
					l,
					h,
					u,
					d,
					p,
					f,
					m,
					g = e.vars,
					v = g.ease,
					y = g.startAt,
					x = g.immediateRender,
					b = g.lazy,
					w = g.onUpdate,
					_ = g.onUpdateParams,
					M = g.callbackScope,
					S = g.runBackwards,
					T = g.yoyoEase,
					E = g.keyframes,
					A = g.autoRevert,
					L = e._dur,
					P = e._startAt,
					C = e._targets,
					O = e.parent,
					D = O && "nested" === O.data ? O.parent._targets : C,
					I = "auto" === e._overwrite,
					k = e.timeline;
				if (
					(k && (!E || !v) && (v = "none"),
					(e._ease = Fe(v, z.ease)),
					(e._yEase = T ? Ne(Fe(!0 === T ? v : T, z.ease)) : 0),
					T &&
						e._yoyo &&
						!e._repeat &&
						((T = e._yEase), (e._yEase = e._ease), (e._ease = T)),
					!k)
				) {
					if (
						((f = (h = C[0] ? Tt(C[0]).harness : 0) && g[h.prop]),
						(i = zt(g, gt)),
						P && P.render(-1, !0).kill(),
						y)
					) {
						if (
							(Gt(
								(e._startAt = $e.set(
									C,
									kt(
										{
											data: "isStart",
											overwrite: !1,
											parent: O,
											immediateRender: !0,
											lazy: Q(b),
											startAt: null,
											delay: 0,
											onUpdate: w,
											onUpdateParams: _,
											callbackScope: M,
											stagger: 0,
										},
										y
									)
								))
							),
							x)
						)
							if (n > 0) A || (e._startAt = 0);
							else if (L && !(n < 0 && P)) return void (n && (e._zTime = n));
					} else if (S && L)
						if (P) !A && (e._startAt = 0);
						else if (
							(n && (x = !1),
							(o = kt(
								{
									overwrite: !1,
									data: "isFromStart",
									lazy: x && Q(b),
									immediateRender: x,
									stagger: 0,
									parent: O,
								},
								i
							)),
							f && (o[h.prop] = f),
							Gt((e._startAt = $e.set(C, o))),
							x)
						) {
							if (!n) return;
						} else t(e._startAt, H);
					for (
						e._pt = 0, b = (L && Q(b)) || (b && !L), r = 0;
						r < C.length;
						r++
					) {
						if (
							((l = (a = C[r])._gsap || St(C)[r]._gsap),
							(e._ptLookup[r] = d = {}),
							yt[l.id] && vt.length && Ct(),
							(p = D === C ? r : D.indexOf(a)),
							h &&
								!1 !== (u = new h()).init(a, f || i, e, p, D) &&
								((e._pt = s =
									new fn(e._pt, a, u.name, 0, 1, u.render, u, 0, u.priority)),
								u._props.forEach(function (t) {
									d[t] = s;
								}),
								u.priority && (c = 1)),
							!h || f)
						)
							for (o in i)
								xt[o] && (u = Xe(o, i, e, p, a, D))
									? u.priority && (c = 1)
									: (d[o] = s =
											Ye.call(e, a, o, "get", i[o], p, D, 0, g.stringFilter));
						e._op && e._op[r] && e.kill(a, e._op[r]),
							I &&
								e._pt &&
								((qe = e),
								R.killTweensOf(a, d, e.globalTime(0)),
								(m = !e.parent),
								(qe = 0)),
							e._pt && b && (yt[l.id] = 1);
					}
					c && pn(e), e._onInit && e._onInit(e);
				}
				(e._from = !k && !!g.runBackwards),
					(e._onUpdate = w),
					(e._initted = (!e._op || e._pt) && !m);
			},
			Je = function (t, e, n, i, r) {
				return X(t)
					? t.call(e, n, i, r)
					: Y(t) && ~t.indexOf("random(")
					? ve(t)
					: t;
			},
			Ke = Mt + "repeat,repeatDelay,yoyo,repeatRefresh,yoyoEase",
			Qe = (Ke + ",id,stagger,delay,duration,paused,scrollTrigger").split(","),
			$e = (function (t) {
				function e(e, n, i, r) {
					var o;
					"number" == typeof n && ((i.duration = n), (n = i), (i = null));
					var s,
						a,
						c,
						l,
						h,
						u,
						d,
						p,
						f = (o = t.call(this, r ? n : Ht(n), i) || this).vars,
						m = f.duration,
						g = f.delay,
						v = f.immediateRender,
						y = f.stagger,
						x = f.overwrite,
						b = f.keyframes,
						w = f.defaults,
						_ = f.scrollTrigger,
						M = f.yoyoEase,
						S = o.parent,
						T = (nt(e) || et(e) ? Z(e[0]) : "length" in n) ? [e] : he(e);
					if (
						((o._targets = T.length
							? St(T)
							: pt(
									"GSAP target " + e + " not found. https://greensock.com",
									!F.nullTargetWarn
							  ) || []),
						(o._ptLookup = []),
						(o._overwrite = x),
						b || y || tt(m) || tt(g))
					) {
						if (
							((n = o.vars),
							(s = o.timeline =
								new We({ data: "nested", defaults: w || {} })).kill(),
							(s.parent = L(o)),
							b)
						)
							kt(s.vars.defaults, { ease: "none" }),
								b.forEach(function (t) {
									return s.to(T, t, ">");
								});
						else {
							if (((l = T.length), (d = y ? de(y) : mt), K(y)))
								for (h in y) ~Ke.indexOf(h) && (p || (p = {}), (p[h] = y[h]));
							for (a = 0; a < l; a++) {
								for (h in ((c = {}), n)) Qe.indexOf(h) < 0 && (c[h] = n[h]);
								(c.stagger = 0),
									M && (c.yoyoEase = M),
									p && Bt(c, p),
									(u = T[a]),
									(c.duration = +Je(m, L(o), a, u, T)),
									(c.delay = (+Je(g, L(o), a, u, T) || 0) - o._delay),
									!y &&
										1 === l &&
										c.delay &&
										((o._delay = g = c.delay), (o._start += g), (c.delay = 0)),
									s.to(u, c, d(a, u, T));
							}
							s.duration() ? (m = g = 0) : (o.timeline = 0);
						}
						m || o.duration((m = s.duration()));
					} else o.timeline = 0;
					return (
						!0 === x && ((qe = L(o)), R.killTweensOf(T), (qe = 0)),
						S && Jt(S, L(o)),
						(v ||
							(!m &&
								!b &&
								o._start === Lt(S._time) &&
								Q(v) &&
								jt(L(o)) &&
								"nested" !== S.data)) &&
							((o._tTime = -H), o.render(Math.max(0, -g))),
						_ && Qt(L(o), _),
						o
					);
				}
				P(e, t);
				var n = e.prototype;
				return (
					(n.render = function (t, e, n) {
						var i,
							r,
							o,
							s,
							a,
							c,
							l,
							h,
							u,
							d = this._time,
							p = this._tDur,
							f = this._dur,
							m = t > p - H && t >= 0 ? p : t < H ? 0 : t;
						if (f) {
							if (
								m !== this._tTime ||
								!t ||
								n ||
								(this._startAt && this._zTime < 0 != t < 0)
							) {
								if (((i = m), (h = this.timeline), this._repeat)) {
									if (
										((s = f + this._rDelay),
										(i = Lt(m % s)),
										m === p
											? ((o = this._repeat), (i = f))
											: ((o = ~~(m / s)) && o === m / s && ((i = f), o--),
											  i > f && (i = f)),
										(c = this._yoyo && 1 & o) &&
											((u = this._yEase), (i = f - i)),
										(a = qt(this._tTime, s)),
										i === d && !n && this._initted)
									)
										return this;
									o !== a &&
										(h && this._yEase && Be(h, c),
										!this.vars.repeatRefresh ||
											c ||
											this._lock ||
											((this._lock = n = 1),
											(this.render(Lt(s * o), !0).invalidate()._lock = 0)));
								}
								if (!this._initted) {
									if ($t(this, t < 0 ? t : i, n, e))
										return (this._tTime = 0), this;
									if (f !== this._dur) return this.render(t, e, n);
								}
								for (
									this._tTime = m,
										this._time = i,
										!this._act &&
											this._ts &&
											((this._act = 1), (this._lazy = 0)),
										this.ratio = l = (u || this._ease)(i / f),
										this._from && (this.ratio = l = 1 - l),
										i && !d && !e && be(this, "onStart"),
										r = this._pt;
									r;

								)
									r.r(l, r.d), (r = r._next);
								(h && h.render(t < 0 ? t : !i && c ? -H : h._dur * l, e, n)) ||
									(this._startAt && (this._zTime = t)),
									this._onUpdate &&
										!e &&
										(t < 0 && this._startAt && this._startAt.render(t, !0, n),
										be(this, "onUpdate")),
									this._repeat &&
										o !== a &&
										this.vars.onRepeat &&
										!e &&
										this.parent &&
										be(this, "onRepeat"),
									(m !== this._tDur && m) ||
										this._tTime !== m ||
										(t < 0 &&
											this._startAt &&
											!this._onUpdate &&
											this._startAt.render(t, !0, !0),
										(t || !f) &&
											((m === this._tDur && this._ts > 0) ||
												(!m && this._ts < 0)) &&
											Gt(this, 1),
										e ||
											(t < 0 && !d) ||
											(!m && !d) ||
											(be(
												this,
												m === p ? "onComplete" : "onReverseComplete",
												!0
											),
											this._prom &&
												!(m < p && this.timeScale() > 0) &&
												this._prom()));
							}
						} else
							!(function (t, e, n, i) {
								var r,
									o,
									s = t.ratio,
									a =
										e < 0 ||
										(!e && s && !t._start && t._zTime > H && !t._dp._lock) ||
										((t._ts < 0 || t._dp._ts < 0) &&
											"isFromStart" !== t.data &&
											"isStart" !== t.data)
											? 0
											: 1,
									c = t._rDelay,
									l = 0;
								if (
									(c &&
										t._repeat &&
										((l = oe(0, t._tDur, e)),
										qt(l, c) !== (o = qt(t._tTime, c)) &&
											((s = 1 - a),
											t.vars.repeatRefresh && t._initted && t.invalidate())),
									a !== s || i || t._zTime === H || (!e && t._zTime))
								) {
									if (!t._initted && $t(t, e, i, n)) return;
									for (
										o = t._zTime,
											t._zTime = e || (n ? H : 0),
											n || (n = e && !o),
											t.ratio = a,
											t._from && (a = 1 - a),
											t._time = 0,
											t._tTime = l,
											n || be(t, "onStart"),
											r = t._pt;
										r;

									)
										r.r(a, r.d), (r = r._next);
									t._startAt && e < 0 && t._startAt.render(e, !0, !0),
										t._onUpdate && !n && be(t, "onUpdate"),
										l && t._repeat && !n && t.parent && be(t, "onRepeat"),
										(e >= t._tDur || e < 0) &&
											t.ratio === a &&
											(a && Gt(t, 1),
											n ||
												(be(t, a ? "onComplete" : "onReverseComplete", !0),
												t._prom && t._prom()));
								} else t._zTime || (t._zTime = e);
							})(this, t, e, n);
						return this;
					}),
					(n.targets = function () {
						return this._targets;
					}),
					(n.invalidate = function () {
						return (
							(this._pt =
								this._op =
								this._startAt =
								this._onUpdate =
								this._act =
								this._lazy =
									0),
							(this._ptLookup = []),
							this.timeline && this.timeline.invalidate(),
							t.prototype.invalidate.call(this)
						);
					}),
					(n.kill = function (t, e) {
						if (
							(void 0 === e && (e = "all"),
							!(t || (e && "all" !== e)) && ((this._lazy = 0), this.parent))
						)
							return we(this);
						if (this.timeline) {
							var n = this.timeline.totalDuration();
							return (
								this.timeline.killTweensOf(t, e, qe && !0 !== qe.vars.overwrite)
									._first || we(this),
								this.parent &&
									n !== this.timeline.totalDuration() &&
									te(this, (this._dur * this.timeline._tDur) / n, 0, 1),
								this
							);
						}
						var i,
							r,
							o,
							s,
							a,
							c,
							l,
							h = this._targets,
							u = t ? he(t) : h,
							d = this._ptLookup,
							p = this._pt;
						if (
							(!e || "all" === e) &&
							(function (t, e) {
								for (
									var n = t.length, i = n === e.length;
									i && n-- && t[n] === e[n];

								);
								return n < 0;
							})(h, u)
						)
							return "all" === e && (this._pt = 0), we(this);
						for (
							i = this._op = this._op || [],
								"all" !== e &&
									(Y(e) &&
										((a = {}),
										At(e, function (t) {
											return (a[t] = 1);
										}),
										(e = a)),
									(e = (function (t, e) {
										var n,
											i,
											r,
											o,
											s = t[0] ? Tt(t[0]).harness : 0,
											a = s && s.aliases;
										if (!a) return e;
										for (i in ((n = Bt({}, e)), a))
											if ((i in n))
												for (r = (o = a[i].split(",")).length; r--; )
													n[o[r]] = n[i];
										return n;
									})(h, e))),
								l = h.length;
							l--;

						)
							if (~u.indexOf(h[l]))
								for (a in ((r = d[l]),
								"all" === e
									? ((i[l] = e), (s = r), (o = {}))
									: ((o = i[l] = i[l] || {}), (s = e)),
								s))
									(c = r && r[a]) &&
										(("kill" in c.d && !0 !== c.d.kill(a)) ||
											Ut(this, c, "_pt"),
										delete r[a]),
										"all" !== o && (o[a] = 1);
						return this._initted && !this._pt && p && we(this), this;
					}),
					(e.to = function (t, n) {
						return new e(t, n, arguments[2]);
					}),
					(e.from = function (t, n) {
						return new e(t, Rt(arguments, 1));
					}),
					(e.delayedCall = function (t, n, i, r) {
						return new e(n, 0, {
							immediateRender: !1,
							lazy: !1,
							overwrite: !1,
							delay: t,
							onComplete: n,
							onReverseComplete: n,
							onCompleteParams: i,
							onReverseCompleteParams: i,
							callbackScope: r,
						});
					}),
					(e.fromTo = function (t, n, i) {
						return new e(t, Rt(arguments, 2));
					}),
					(e.set = function (t, n) {
						return (
							(n.duration = 0), n.repeatDelay || (n.repeat = 0), new e(t, n)
						);
					}),
					(e.killTweensOf = function (t, e, n) {
						return R.killTweensOf(t, e, n);
					}),
					e
				);
			})(je);
		kt($e.prototype, {
			_targets: [],
			_lazy: 0,
			_startAt: 0,
			_op: 0,
			_onInit: 0,
		}),
			At("staggerTo,staggerFrom,staggerFromTo", function (t) {
				$e[t] = function () {
					var e = new We(),
						n = ae.call(arguments, 0);
					return (
						n.splice("staggerFromTo" === t ? 5 : 4, 0, 0), e[t].apply(e, n)
					);
				};
			});
		var tn = function (t, e, n) {
				return (t[e] = n);
			},
			en = function (t, e, n) {
				return t[e](n);
			},
			nn = function (t, e, n, i) {
				return t[e](i.fp, n);
			},
			rn = function (t, e, n) {
				return t.setAttribute(e, n);
			},
			on = function (t, e) {
				return X(t[e]) ? en : J(t[e]) && t.setAttribute ? rn : tn;
			},
			sn = function (t, e) {
				return e.set(e.t, e.p, Math.round(1e4 * (e.s + e.c * t)) / 1e4, e);
			},
			an = function (t, e) {
				return e.set(e.t, e.p, !!(e.s + e.c * t), e);
			},
			cn = function (t, e) {
				var n = e._pt,
					i = "";
				if (!t && e.b) i = e.b;
				else if (1 === t && e.e) i = e.e;
				else {
					for (; n; )
						(i =
							n.p +
							(n.m
								? n.m(n.s + n.c * t)
								: Math.round(1e4 * (n.s + n.c * t)) / 1e4) +
							i),
							(n = n._next);
					i += e.c;
				}
				e.set(e.t, e.p, i, e);
			},
			ln = function (t, e) {
				for (var n = e._pt; n; ) n.r(t, n.d), (n = n._next);
			},
			hn = function (t, e, n, i) {
				for (var r, o = this._pt; o; )
					(r = o._next), o.p === i && o.modifier(t, e, n), (o = r);
			},
			un = function (t) {
				for (var e, n, i = this._pt; i; )
					(n = i._next),
						(i.p === t && !i.op) || i.op === t
							? Ut(this, i, "_pt")
							: i.dep || (e = 1),
						(i = n);
				return !e;
			},
			dn = function (t, e, n, i) {
				i.mSet(t, e, i.m.call(i.tween, n, i.mt), i);
			},
			pn = function (t) {
				for (var e, n, i, r, o = t._pt; o; ) {
					for (e = o._next, n = i; n && n.pr > o.pr; ) n = n._next;
					(o._prev = n ? n._prev : r) ? (o._prev._next = o) : (i = o),
						(o._next = n) ? (n._prev = o) : (r = o),
						(o = e);
				}
				t._pt = i;
			},
			fn = (function () {
				function t(t, e, n, i, r, o, s, a, c) {
					(this.t = e),
						(this.s = i),
						(this.c = r),
						(this.p = n),
						(this.r = o || sn),
						(this.d = s || this),
						(this.set = a || tn),
						(this.pr = c || 0),
						(this._next = t),
						t && (t._prev = this);
				}
				return (
					(t.prototype.modifier = function (t, e, n) {
						(this.mSet = this.mSet || this.set),
							(this.set = dn),
							(this.m = t),
							(this.mt = n),
							(this.tween = e);
					}),
					t
				);
			})();
		At(
			Mt +
				"parent,duration,ease,delay,overwrite,runBackwards,startAt,yoyo,immediateRender,repeat,repeatDelay,data,paused,reversed,lazy,callbackScope,stringFilter,id,yoyoEase,stagger,inherit,repeatRefresh,keyframes,autoRevert,scrollTrigger",
			function (t) {
				return (gt[t] = 1);
			}
		),
			(lt.TweenMax = lt.TweenLite = $e),
			(lt.TimelineLite = lt.TimelineMax = We),
			(R = new We({
				sortChildren: !1,
				defaults: z,
				autoRemoveChildren: !0,
				id: "root",
				smoothChildTiming: !0,
			})),
			(F.stringFilter = Pe);
		var mn = {
			registerPlugin: function () {
				for (var t = arguments.length, e = new Array(t), n = 0; n < t; n++)
					e[n] = arguments[n];
				e.forEach(function (t) {
					return (function (t) {
						var e = (t = (!t.name && t.default) || t).name,
							n = X(t),
							i =
								e && !n && t.init
									? function () {
											this._props = [];
									  }
									: t,
							r = {
								init: mt,
								render: ln,
								add: Ye,
								kill: un,
								modifier: hn,
								rawVars: 0,
							},
							o = {
								targetTest: 0,
								get: 0,
								getSetter: on,
								aliases: {},
								register: 0,
							};
						if ((Ce(), t !== i)) {
							if (xt[e]) return;
							kt(i, kt(zt(t, r), o)),
								Bt(i.prototype, Bt(r, zt(t, o))),
								(xt[(i.prop = e)] = i),
								t.targetTest && (_t.push(i), (gt[e] = 1)),
								(e =
									("css" === e
										? "CSS"
										: e.charAt(0).toUpperCase() + e.substr(1)) + "Plugin");
						}
						ft(e, i), t.register && t.register(yn, i, fn);
					})(t);
				});
			},
			timeline: function (t) {
				return new We(t);
			},
			getTweensOf: function (t, e) {
				return R.getTweensOf(t, e);
			},
			getProperty: function (t, e, n, i) {
				Y(t) && (t = he(t)[0]);
				var r = Tt(t || {}).get,
					o = n ? It : Dt;
				return (
					"native" === n && (n = ""),
					t
						? e
							? o(((xt[e] && xt[e].get) || r)(t, e, n, i))
							: function (e, n, i) {
									return o(((xt[e] && xt[e].get) || r)(t, e, n, i));
							  }
						: t
				);
			},
			quickSetter: function (t, e, n) {
				if ((t = he(t)).length > 1) {
					var i = t.map(function (t) {
							return yn.quickSetter(t, e, n);
						}),
						r = i.length;
					return function (t) {
						for (var e = r; e--; ) i[e](t);
					};
				}
				t = t[0] || {};
				var o = xt[e],
					s = Tt(t),
					a = (s.harness && (s.harness.aliases || {})[e]) || e,
					c = o
						? function (e) {
								var i = new o();
								(N._pt = 0),
									i.init(t, n ? e + n : e, N, 0, [t]),
									i.render(1, i),
									N._pt && ln(1, N);
						  }
						: s.set(t, a);
				return o
					? c
					: function (e) {
							return c(t, a, n ? e + n : e, s, 1);
					  };
			},
			isTweening: function (t) {
				return R.getTweensOf(t, !0).length > 0;
			},
			defaults: function (t) {
				return t && t.ease && (t.ease = Fe(t.ease, z.ease)), Ft(z, t || {});
			},
			config: function (t) {
				return Ft(F, t || {});
			},
			registerEffect: function (t) {
				var e = t.name,
					n = t.effect,
					i = t.plugins,
					r = t.defaults,
					o = t.extendTimeline;
				(i || "").split(",").forEach(function (t) {
					return (
						t &&
						!xt[t] &&
						!lt[t] &&
						pt(e + " effect requires " + t + " plugin.")
					);
				}),
					(bt[e] = function (t, e, i) {
						return n(he(t), kt(e || {}, r), i);
					}),
					o &&
						(We.prototype[e] = function (t, n, i) {
							return this.add(bt[e](t, K(n) ? n : (i = n) && {}, this), i);
						});
			},
			registerEase: function (t, e) {
				Oe[t] = Fe(e);
			},
			parseEase: function (t, e) {
				return arguments.length ? Fe(t, e) : Oe;
			},
			getById: function (t) {
				return R.getById(t);
			},
			exportRoot: function (t, e) {
				void 0 === t && (t = {});
				var n,
					i,
					r = new We(t);
				for (
					r.smoothChildTiming = Q(t.smoothChildTiming),
						R.remove(r),
						r._dp = 0,
						r._time = r._tTime = R._time,
						n = R._first;
					n;

				)
					(i = n._next),
						(!e &&
							!n._dur &&
							n instanceof $e &&
							n.vars.onComplete === n._targets[0]) ||
							Kt(r, n, n._start - n._delay),
						(n = i);
				return Kt(R, r, 0), r;
			},
			utils: {
				wrap: function t(e, n, i) {
					var r = n - e;
					return nt(e)
						? ge(e, t(0, e.length), n)
						: re(i, function (t) {
								return ((r + ((t - e) % r)) % r) + e;
						  });
				},
				wrapYoyo: function t(e, n, i) {
					var r = n - e,
						o = 2 * r;
					return nt(e)
						? ge(e, t(0, e.length - 1), n)
						: re(i, function (t) {
								return e + ((t = (o + ((t - e) % o)) % o || 0) > r ? o - t : t);
						  });
				},
				distribute: de,
				random: me,
				snap: fe,
				normalize: function (t, e, n) {
					return ye(t, e, 0, 1, n);
				},
				getUnit: se,
				clamp: function (t, e, n) {
					return re(n, function (n) {
						return oe(t, e, n);
					});
				},
				splitColor: Se,
				toArray: he,
				mapRange: ye,
				pipe: function () {
					for (var t = arguments.length, e = new Array(t), n = 0; n < t; n++)
						e[n] = arguments[n];
					return function (t) {
						return e.reduce(function (t, e) {
							return e(t);
						}, t);
					};
				},
				unitize: function (t, e) {
					return function (n) {
						return t(parseFloat(n)) + (e || se(n));
					};
				},
				interpolate: function t(e, n, i, r) {
					var o = isNaN(e + n)
						? 0
						: function (t) {
								return (1 - t) * e + t * n;
						  };
					if (!o) {
						var s,
							a,
							c,
							l,
							h,
							u = Y(e),
							d = {};
						if ((!0 === i && (r = 1) && (i = null), u))
							(e = { p: e }), (n = { p: n });
						else if (nt(e) && !nt(n)) {
							for (c = [], l = e.length, h = l - 2, a = 1; a < l; a++)
								c.push(t(e[a - 1], e[a]));
							l--,
								(o = function (t) {
									t *= l;
									var e = Math.min(h, ~~t);
									return c[e](t - e);
								}),
								(i = n);
						} else r || (e = Bt(nt(e) ? [] : {}, e));
						if (!c) {
							for (s in n) Ye.call(d, e, s, "get", n[s]);
							o = function (t) {
								return ln(t, d) || (u ? e.p : e);
							};
						}
					}
					return re(i, o);
				},
				shuffle: ue,
			},
			install: ut,
			effects: bt,
			ticker: Re,
			updateRoot: We.updateRoot,
			plugins: xt,
			globalTimeline: R,
			core: {
				PropTween: fn,
				globals: ft,
				Tween: $e,
				Timeline: We,
				Animation: je,
				getCache: Tt,
				_removeLinkedListItem: Ut,
			},
		};
		At("to,from,fromTo,delayedCall,set,killTweensOf", function (t) {
			return (mn[t] = $e[t]);
		}),
			Re.add(We.updateRoot),
			(N = mn.to({}, { duration: 0 }));
		var gn = function (t, e) {
				for (var n = t._pt; n && n.p !== e && n.op !== e && n.fp !== e; )
					n = n._next;
				return n;
			},
			vn = function (t, e) {
				return {
					name: t,
					rawVars: 1,
					init: function (t, n, i) {
						i._onInit = function (t) {
							var i, r;
							if (
								(Y(n) &&
									((i = {}),
									At(n, function (t) {
										return (i[t] = 1);
									}),
									(n = i)),
								e)
							) {
								for (r in ((i = {}), n)) i[r] = e(n[r]);
								n = i;
							}
							!(function (t, e) {
								var n,
									i,
									r,
									o = t._targets;
								for (n in e)
									for (i = o.length; i--; )
										(r = t._ptLookup[i][n]) &&
											(r = r.d) &&
											(r._pt && (r = gn(r, n)),
											r && r.modifier && r.modifier(e[n], t, o[i], n));
							})(t, n);
						};
					},
				};
			},
			yn =
				mn.registerPlugin(
					{
						name: "attr",
						init: function (t, e, n, i, r) {
							var o, s;
							for (o in e)
								(s = this.add(
									t,
									"setAttribute",
									(t.getAttribute(o) || 0) + "",
									e[o],
									i,
									r,
									0,
									0,
									o
								)) && (s.op = o),
									this._props.push(o);
						},
					},
					{
						name: "endArray",
						init: function (t, e) {
							for (var n = e.length; n--; ) this.add(t, n, t[n] || 0, e[n]);
						},
					},
					vn("roundProps", pe),
					vn("modifiers"),
					vn("snap", fe)
				) || mn;
		($e.version = We.version = yn.version = "3.5.1"), (I = 1), $() && Ce();
		Oe.Power0,
			Oe.Power1,
			Oe.Power2,
			Oe.Power3,
			Oe.Power4,
			Oe.Linear,
			Oe.Quad,
			Oe.Cubic,
			Oe.Quart,
			Oe.Quint,
			Oe.Strong,
			Oe.Elastic,
			Oe.Back,
			Oe.SteppedEase,
			Oe.Bounce,
			Oe.Sine,
			Oe.Expo,
			Oe.Circ;
		/*!
		 * CSSPlugin 3.5.1
		 * https://greensock.com
		 *
		 * Copyright 2008-2020, GreenSock. All rights reserved.
		 * Subject to the terms at https://greensock.com/standard-license or for
		 * Club GreenSock members, the agreement issued with that membership.
		 * @author: Jack Doyle, jack@greensock.com
		 */ var xn,
			bn,
			wn,
			_n,
			Mn,
			Sn,
			Tn,
			En,
			An = {},
			Ln = 180 / Math.PI,
			Pn = Math.PI / 180,
			Rn = Math.atan2,
			Cn = /([A-Z])/g,
			On = /(?:left|right|width|margin|padding|x)/i,
			Dn = /[\s,\(]\S/,
			In = {
				autoAlpha: "opacity,visibility",
				scale: "scaleX,scaleY",
				alpha: "opacity",
			},
			kn = function (t, e) {
				return e.set(
					e.t,
					e.p,
					Math.round(1e4 * (e.s + e.c * t)) / 1e4 + e.u,
					e
				);
			},
			Nn = function (t, e) {
				return e.set(
					e.t,
					e.p,
					1 === t ? e.e : Math.round(1e4 * (e.s + e.c * t)) / 1e4 + e.u,
					e
				);
			},
			Bn = function (t, e) {
				return e.set(
					e.t,
					e.p,
					t ? Math.round(1e4 * (e.s + e.c * t)) / 1e4 + e.u : e.b,
					e
				);
			},
			Fn = function (t, e) {
				var n = e.s + e.c * t;
				e.set(e.t, e.p, ~~(n + (n < 0 ? -0.5 : 0.5)) + e.u, e);
			},
			zn = function (t, e) {
				return e.set(e.t, e.p, t ? e.e : e.b, e);
			},
			Hn = function (t, e) {
				return e.set(e.t, e.p, 1 !== t ? e.b : e.e, e);
			},
			Un = function (t, e, n) {
				return (t.style[e] = n);
			},
			Gn = function (t, e, n) {
				return t.style.setProperty(e, n);
			},
			Vn = function (t, e, n) {
				return (t._gsap[e] = n);
			},
			jn = function (t, e, n) {
				return (t._gsap.scaleX = t._gsap.scaleY = n);
			},
			Wn = function (t, e, n, i, r) {
				var o = t._gsap;
				(o.scaleX = o.scaleY = n), o.renderTransform(r, o);
			},
			qn = function (t, e, n, i, r) {
				var o = t._gsap;
				(o[e] = n), o.renderTransform(r, o);
			},
			Yn = "transform",
			Xn = Yn + "Origin",
			Zn = function (t, e) {
				var n = bn.createElementNS
					? bn.createElementNS(
							(e || "http://www.w3.org/1999/xhtml").replace(/^https/, "http"),
							t
					  )
					: bn.createElement(t);
				return n.style ? n : bn.createElement(t);
			},
			Jn = function t(e, n, i) {
				var r = getComputedStyle(e);
				return (
					r[n] ||
					r.getPropertyValue(n.replace(Cn, "-$1").toLowerCase()) ||
					r.getPropertyValue(n) ||
					(!i && t(e, Qn(n) || n, 1)) ||
					""
				);
			},
			Kn = "O,Moz,ms,Ms,Webkit".split(","),
			Qn = function (t, e, n) {
				var i = (e || Mn).style,
					r = 5;
				if (t in i && !n) return t;
				for (
					t = t.charAt(0).toUpperCase() + t.substr(1);
					r-- && !(Kn[r] + t in i);

				);
				return r < 0 ? null : (3 === r ? "ms" : r >= 0 ? Kn[r] : "") + t;
			},
			$n = function () {
				"undefined" != typeof window &&
					window.document &&
					((xn = window),
					(bn = xn.document),
					(wn = bn.documentElement),
					(Mn = Zn("div") || { style: {} }),
					(Sn = Zn("div")),
					(Yn = Qn(Yn)),
					(Xn = Yn + "Origin"),
					(Mn.style.cssText =
						"border-width:0;line-height:0;position:absolute;padding:0"),
					(En = !!Qn("perspective")),
					(_n = 1));
			},
			ti = function t(e) {
				var n,
					i = Zn(
						"svg",
						(this.ownerSVGElement &&
							this.ownerSVGElement.getAttribute("xmlns")) ||
							"http://www.w3.org/2000/svg"
					),
					r = this.parentNode,
					o = this.nextSibling,
					s = this.style.cssText;
				if (
					(wn.appendChild(i),
					i.appendChild(this),
					(this.style.display = "block"),
					e)
				)
					try {
						(n = this.getBBox()),
							(this._gsapBBox = this.getBBox),
							(this.getBBox = t);
					} catch (t) {}
				else this._gsapBBox && (n = this._gsapBBox());
				return (
					r && (o ? r.insertBefore(this, o) : r.appendChild(this)),
					wn.removeChild(i),
					(this.style.cssText = s),
					n
				);
			},
			ei = function (t, e) {
				for (var n = e.length; n--; )
					if (t.hasAttribute(e[n])) return t.getAttribute(e[n]);
			},
			ni = function (t) {
				var e;
				try {
					e = t.getBBox();
				} catch (n) {
					e = ti.call(t, !0);
				}
				return (
					(e && (e.width || e.height)) ||
						t.getBBox === ti ||
						(e = ti.call(t, !0)),
					!e || e.width || e.x || e.y
						? e
						: {
								x: +ei(t, ["x", "cx", "x1"]) || 0,
								y: +ei(t, ["y", "cy", "y1"]) || 0,
								width: 0,
								height: 0,
						  }
				);
			},
			ii = function (t) {
				return !(!t.getCTM || (t.parentNode && !t.ownerSVGElement) || !ni(t));
			},
			ri = function (t, e) {
				if (e) {
					var n = t.style;
					e in An && e !== Xn && (e = Yn),
						n.removeProperty
							? (("ms" !== e.substr(0, 2) && "webkit" !== e.substr(0, 6)) ||
									(e = "-" + e),
							  n.removeProperty(e.replace(Cn, "-$1").toLowerCase()))
							: n.removeAttribute(e);
				}
			},
			oi = function (t, e, n, i, r, o) {
				var s = new fn(t._pt, e, n, 0, 1, o ? Hn : zn);
				return (t._pt = s), (s.b = i), (s.e = r), t._props.push(n), s;
			},
			si = { deg: 1, rad: 1, turn: 1 },
			ai = function t(e, n, i, r) {
				var o,
					s,
					a,
					c,
					l = parseFloat(i) || 0,
					h = (i + "").trim().substr((l + "").length) || "px",
					u = Mn.style,
					d = On.test(n),
					p = "svg" === e.tagName.toLowerCase(),
					f = (p ? "client" : "offset") + (d ? "Width" : "Height"),
					m = "px" === r,
					g = "%" === r;
				return r === h || !l || si[r] || si[h]
					? l
					: ("px" !== h && !m && (l = t(e, n, i, "px")),
					  (c = e.getCTM && ii(e)),
					  g && (An[n] || ~n.indexOf("adius"))
							? Lt((l / (c ? e.getBBox()[d ? "width" : "height"] : e[f])) * 100)
							: ((u[d ? "width" : "height"] = 100 + (m ? h : r)),
							  (s =
									~n.indexOf("adius") || ("em" === r && e.appendChild && !p)
										? e
										: e.parentNode),
							  c && (s = (e.ownerSVGElement || {}).parentNode),
							  (s && s !== bn && s.appendChild) || (s = bn.body),
							  (a = s._gsap) && g && a.width && d && a.time === Re.time
									? Lt((l / a.width) * 100)
									: ((g || "%" === h) && (u.position = Jn(e, "position")),
									  s === e && (u.position = "static"),
									  s.appendChild(Mn),
									  (o = Mn[f]),
									  s.removeChild(Mn),
									  (u.position = "absolute"),
									  d && g && (((a = Tt(s)).time = Re.time), (a.width = s[f])),
									  Lt(m ? (o * l) / 100 : o && l ? (100 / o) * l : 0))));
			},
			ci = function (t, e, n, i) {
				var r;
				return (
					_n || $n(),
					e in In &&
						"transform" !== e &&
						~(e = In[e]).indexOf(",") &&
						(e = e.split(",")[0]),
					An[e] && "transform" !== e
						? ((r = xi(t, i)),
						  (r =
								"transformOrigin" !== e
									? r[e]
									: bi(Jn(t, Xn)) + " " + r.zOrigin + "px"))
						: (!(r = t.style[e]) ||
								"auto" === r ||
								i ||
								~(r + "").indexOf("calc(")) &&
						  (r =
								(di[e] && di[e](t, e, n)) ||
								Jn(t, e) ||
								Et(t, e) ||
								("opacity" === e ? 1 : 0)),
					n && !~(r + "").indexOf(" ") ? ai(t, e, r, n) + n : r
				);
			},
			li = function (t, e, n, i) {
				if (!n || "none" === n) {
					var r = Qn(e, t, 1),
						o = r && Jn(t, r, 1);
					o && o !== n
						? ((e = r), (n = o))
						: "borderColor" === e && (n = Jn(t, "borderTopColor"));
				}
				var s,
					a,
					c,
					l,
					h,
					u,
					d,
					p,
					f,
					m,
					g,
					v,
					y = new fn(this._pt, t.style, e, 0, 1, cn),
					x = 0,
					b = 0;
				if (
					((y.b = n),
					(y.e = i),
					(n += ""),
					"auto" === (i += "") &&
						((t.style[e] = i), (i = Jn(t, e) || i), (t.style[e] = n)),
					Pe((s = [n, i])),
					(i = s[1]),
					(c = (n = s[0]).match(ot) || []),
					(i.match(ot) || []).length)
				) {
					for (; (a = ot.exec(i)); )
						(d = a[0]),
							(f = i.substring(x, a.index)),
							h
								? (h = (h + 1) % 5)
								: ("rgba(" !== f.substr(-5) && "hsla(" !== f.substr(-5)) ||
								  (h = 1),
							d !== (u = c[b++] || "") &&
								((l = parseFloat(u) || 0),
								(g = u.substr((l + "").length)),
								(v = "=" === d.charAt(1) ? +(d.charAt(0) + "1") : 0) &&
									(d = d.substr(2)),
								(p = parseFloat(d)),
								(m = d.substr((p + "").length)),
								(x = ot.lastIndex - m.length),
								m ||
									((m = m || F.units[e] || g),
									x === i.length && ((i += m), (y.e += m))),
								g !== m && (l = ai(t, e, u, m) || 0),
								(y._pt = {
									_next: y._pt,
									p: f || 1 === b ? f : ",",
									s: l,
									c: v ? v * p : p - l,
									m: h && h < 4 ? Math.round : 0,
								}));
					y.c = x < i.length ? i.substring(x, i.length) : "";
				} else y.r = "display" === e && "none" === i ? Hn : zn;
				return at.test(i) && (y.e = 0), (this._pt = y), y;
			},
			hi = {
				top: "0%",
				bottom: "100%",
				left: "0%",
				right: "100%",
				center: "50%",
			},
			ui = function (t, e) {
				if (e.tween && e.tween._time === e.tween._dur) {
					var n,
						i,
						r,
						o = e.t,
						s = o.style,
						a = e.u,
						c = o._gsap;
					if ("all" === a || !0 === a) (s.cssText = ""), (i = 1);
					else
						for (r = (a = a.split(",")).length; --r > -1; )
							(n = a[r]),
								An[n] && ((i = 1), (n = "transformOrigin" === n ? Xn : Yn)),
								ri(o, n);
					i &&
						(ri(o, Yn),
						c &&
							(c.svg && o.removeAttribute("transform"),
							xi(o, 1),
							(c.uncache = 1)));
				}
			},
			di = {
				clearProps: function (t, e, n, i, r) {
					if ("isFromStart" !== r.data) {
						var o = (t._pt = new fn(t._pt, e, n, 0, 0, ui));
						return (o.u = i), (o.pr = -10), (o.tween = r), t._props.push(n), 1;
					}
				},
			},
			pi = [1, 0, 0, 1, 0, 0],
			fi = {},
			mi = function (t) {
				return "matrix(1, 0, 0, 1, 0, 0)" === t || "none" === t || !t;
			},
			gi = function (t) {
				var e = Jn(t, Yn);
				return mi(e) ? pi : e.substr(7).match(rt).map(Lt);
			},
			vi = function (t, e) {
				var n,
					i,
					r,
					o,
					s = t._gsap || Tt(t),
					a = t.style,
					c = gi(t);
				return s.svg && t.getAttribute("transform")
					? "1,0,0,1,0,0" ===
					  (c = [
							(r = t.transform.baseVal.consolidate().matrix).a,
							r.b,
							r.c,
							r.d,
							r.e,
							r.f,
					  ]).join(",")
						? pi
						: c
					: (c !== pi ||
							t.offsetParent ||
							t === wn ||
							s.svg ||
							((r = a.display),
							(a.display = "block"),
							((n = t.parentNode) && t.offsetParent) ||
								((o = 1), (i = t.nextSibling), wn.appendChild(t)),
							(c = gi(t)),
							r ? (a.display = r) : ri(t, "display"),
							o &&
								(i
									? n.insertBefore(t, i)
									: n
									? n.appendChild(t)
									: wn.removeChild(t))),
					  e && c.length > 6 ? [c[0], c[1], c[4], c[5], c[12], c[13]] : c);
			},
			yi = function (t, e, n, i, r, o) {
				var s,
					a,
					c,
					l = t._gsap,
					h = r || vi(t, !0),
					u = l.xOrigin || 0,
					d = l.yOrigin || 0,
					p = l.xOffset || 0,
					f = l.yOffset || 0,
					m = h[0],
					g = h[1],
					v = h[2],
					y = h[3],
					x = h[4],
					b = h[5],
					w = e.split(" "),
					_ = parseFloat(w[0]) || 0,
					M = parseFloat(w[1]) || 0;
				n
					? h !== pi &&
					  (a = m * y - g * v) &&
					  ((c = _ * (-g / a) + M * (m / a) - (m * b - g * x) / a),
					  (_ = _ * (y / a) + M * (-v / a) + (v * b - y * x) / a),
					  (M = c))
					: ((_ =
							(s = ni(t)).x + (~w[0].indexOf("%") ? (_ / 100) * s.width : _)),
					  (M =
							s.y + (~(w[1] || w[0]).indexOf("%") ? (M / 100) * s.height : M))),
					i || (!1 !== i && l.smooth)
						? ((x = _ - u),
						  (b = M - d),
						  (l.xOffset = p + (x * m + b * v) - x),
						  (l.yOffset = f + (x * g + b * y) - b))
						: (l.xOffset = l.yOffset = 0),
					(l.xOrigin = _),
					(l.yOrigin = M),
					(l.smooth = !!i),
					(l.origin = e),
					(l.originIsAbsolute = !!n),
					(t.style[Xn] = "0px 0px"),
					o &&
						(oi(o, l, "xOrigin", u, _),
						oi(o, l, "yOrigin", d, M),
						oi(o, l, "xOffset", p, l.xOffset),
						oi(o, l, "yOffset", f, l.yOffset)),
					t.setAttribute("data-svg-origin", _ + " " + M);
			},
			xi = function (t, e) {
				var n = t._gsap || new Ve(t);
				if ("x" in n && !e && !n.uncache) return n;
				var i,
					r,
					o,
					s,
					a,
					c,
					l,
					h,
					u,
					d,
					p,
					f,
					m,
					g,
					v,
					y,
					x,
					b,
					w,
					_,
					M,
					S,
					T,
					E,
					A,
					L,
					P,
					R,
					C,
					O,
					D,
					I,
					k = t.style,
					N = n.scaleX < 0,
					B = Jn(t, Xn) || "0";
				return (
					(i = r = o = c = l = h = u = d = p = 0),
					(s = a = 1),
					(n.svg = !(!t.getCTM || !ii(t))),
					(g = vi(t, n.svg)),
					n.svg &&
						((E = !n.uncache && t.getAttribute("data-svg-origin")),
						yi(t, E || B, !!E || n.originIsAbsolute, !1 !== n.smooth, g)),
					(f = n.xOrigin || 0),
					(m = n.yOrigin || 0),
					g !== pi &&
						((b = g[0]),
						(w = g[1]),
						(_ = g[2]),
						(M = g[3]),
						(i = S = g[4]),
						(r = T = g[5]),
						6 === g.length
							? ((s = Math.sqrt(b * b + w * w)),
							  (a = Math.sqrt(M * M + _ * _)),
							  (c = b || w ? Rn(w, b) * Ln : 0),
							  (u = _ || M ? Rn(_, M) * Ln + c : 0) && (a *= Math.cos(u * Pn)),
							  n.svg &&
									((i -= f - (f * b + m * _)), (r -= m - (f * w + m * M))))
							: ((I = g[6]),
							  (O = g[7]),
							  (P = g[8]),
							  (R = g[9]),
							  (C = g[10]),
							  (D = g[11]),
							  (i = g[12]),
							  (r = g[13]),
							  (o = g[14]),
							  (l = (v = Rn(I, C)) * Ln),
							  v &&
									((E = S * (y = Math.cos(-v)) + P * (x = Math.sin(-v))),
									(A = T * y + R * x),
									(L = I * y + C * x),
									(P = S * -x + P * y),
									(R = T * -x + R * y),
									(C = I * -x + C * y),
									(D = O * -x + D * y),
									(S = E),
									(T = A),
									(I = L)),
							  (h = (v = Rn(-_, C)) * Ln),
							  v &&
									((y = Math.cos(-v)),
									(D = M * (x = Math.sin(-v)) + D * y),
									(b = E = b * y - P * x),
									(w = A = w * y - R * x),
									(_ = L = _ * y - C * x)),
							  (c = (v = Rn(w, b)) * Ln),
							  v &&
									((E = b * (y = Math.cos(v)) + w * (x = Math.sin(v))),
									(A = S * y + T * x),
									(w = w * y - b * x),
									(T = T * y - S * x),
									(b = E),
									(S = A)),
							  l &&
									Math.abs(l) + Math.abs(c) > 359.9 &&
									((l = c = 0), (h = 180 - h)),
							  (s = Lt(Math.sqrt(b * b + w * w + _ * _))),
							  (a = Lt(Math.sqrt(T * T + I * I))),
							  (v = Rn(S, T)),
							  (u = Math.abs(v) > 2e-4 ? v * Ln : 0),
							  (p = D ? 1 / (D < 0 ? -D : D) : 0)),
						n.svg &&
							((E = t.getAttribute("transform")),
							(n.forceCSS = t.setAttribute("transform", "") || !mi(Jn(t, Yn))),
							E && t.setAttribute("transform", E))),
					Math.abs(u) > 90 &&
						Math.abs(u) < 270 &&
						(N
							? ((s *= -1),
							  (u += c <= 0 ? 180 : -180),
							  (c += c <= 0 ? 180 : -180))
							: ((a *= -1), (u += u <= 0 ? 180 : -180))),
					(n.x =
						((n.xPercent =
							i && Math.round(t.offsetWidth / 2) === Math.round(-i) ? -50 : 0)
							? 0
							: i) + "px"),
					(n.y =
						((n.yPercent =
							r && Math.round(t.offsetHeight / 2) === Math.round(-r) ? -50 : 0)
							? 0
							: r) + "px"),
					(n.z = o + "px"),
					(n.scaleX = Lt(s)),
					(n.scaleY = Lt(a)),
					(n.rotation = Lt(c) + "deg"),
					(n.rotationX = Lt(l) + "deg"),
					(n.rotationY = Lt(h) + "deg"),
					(n.skewX = u + "deg"),
					(n.skewY = d + "deg"),
					(n.transformPerspective = p + "px"),
					(n.zOrigin = parseFloat(B.split(" ")[2]) || 0) && (k[Xn] = bi(B)),
					(n.xOffset = n.yOffset = 0),
					(n.force3D = F.force3D),
					(n.renderTransform = n.svg ? Si : En ? Mi : _i),
					(n.uncache = 0),
					n
				);
			},
			bi = function (t) {
				return (t = t.split(" "))[0] + " " + t[1];
			},
			wi = function (t, e, n) {
				var i = se(e);
				return Lt(parseFloat(e) + parseFloat(ai(t, "x", n + "px", i))) + i;
			},
			_i = function (t, e) {
				(e.z = "0px"),
					(e.rotationY = e.rotationX = "0deg"),
					(e.force3D = 0),
					Mi(t, e);
			},
			Mi = function (t, e) {
				var n = e || this,
					i = n.xPercent,
					r = n.yPercent,
					o = n.x,
					s = n.y,
					a = n.z,
					c = n.rotation,
					l = n.rotationY,
					h = n.rotationX,
					u = n.skewX,
					d = n.skewY,
					p = n.scaleX,
					f = n.scaleY,
					m = n.transformPerspective,
					g = n.force3D,
					v = n.target,
					y = n.zOrigin,
					x = "",
					b = ("auto" === g && t && 1 !== t) || !0 === g;
				if (y && ("0deg" !== h || "0deg" !== l)) {
					var w,
						_ = parseFloat(l) * Pn,
						M = Math.sin(_),
						S = Math.cos(_);
					(_ = parseFloat(h) * Pn),
						(w = Math.cos(_)),
						(o = wi(v, o, M * w * -y)),
						(s = wi(v, s, -Math.sin(_) * -y)),
						(a = wi(v, a, S * w * -y + y));
				}
				"0px" !== m && (x += "perspective(" + m + ") "),
					(i || r) && (x += "translate(" + i + "%, " + r + "%) "),
					(b || "0px" !== o || "0px" !== s || "0px" !== a) &&
						(x +=
							"0px" !== a || b
								? "translate3d(" + o + ", " + s + ", " + a + ") "
								: "translate(" + o + ", " + s + ") "),
					"0deg" !== c && (x += "rotate(" + c + ") "),
					"0deg" !== l && (x += "rotateY(" + l + ") "),
					"0deg" !== h && (x += "rotateX(" + h + ") "),
					("0deg" === u && "0deg" === d) ||
						(x += "skew(" + u + ", " + d + ") "),
					(1 === p && 1 === f) || (x += "scale(" + p + ", " + f + ") "),
					(v.style[Yn] = x || "translate(0, 0)");
			},
			Si = function (t, e) {
				var n,
					i,
					r,
					o,
					s,
					a = e || this,
					c = a.xPercent,
					l = a.yPercent,
					h = a.x,
					u = a.y,
					d = a.rotation,
					p = a.skewX,
					f = a.skewY,
					m = a.scaleX,
					g = a.scaleY,
					v = a.target,
					y = a.xOrigin,
					x = a.yOrigin,
					b = a.xOffset,
					w = a.yOffset,
					_ = a.forceCSS,
					M = parseFloat(h),
					S = parseFloat(u);
				(d = parseFloat(d)),
					(p = parseFloat(p)),
					(f = parseFloat(f)) && ((p += f = parseFloat(f)), (d += f)),
					d || p
						? ((d *= Pn),
						  (p *= Pn),
						  (n = Math.cos(d) * m),
						  (i = Math.sin(d) * m),
						  (r = Math.sin(d - p) * -g),
						  (o = Math.cos(d - p) * g),
						  p &&
								((f *= Pn),
								(s = Math.tan(p - f)),
								(r *= s = Math.sqrt(1 + s * s)),
								(o *= s),
								f &&
									((s = Math.tan(f)),
									(n *= s = Math.sqrt(1 + s * s)),
									(i *= s))),
						  (n = Lt(n)),
						  (i = Lt(i)),
						  (r = Lt(r)),
						  (o = Lt(o)))
						: ((n = m), (o = g), (i = r = 0)),
					((M && !~(h + "").indexOf("px")) ||
						(S && !~(u + "").indexOf("px"))) &&
						((M = ai(v, "x", h, "px")), (S = ai(v, "y", u, "px"))),
					(y || x || b || w) &&
						((M = Lt(M + y - (y * n + x * r) + b)),
						(S = Lt(S + x - (y * i + x * o) + w))),
					(c || l) &&
						((s = v.getBBox()),
						(M = Lt(M + (c / 100) * s.width)),
						(S = Lt(S + (l / 100) * s.height))),
					(s =
						"matrix(" +
						n +
						"," +
						i +
						"," +
						r +
						"," +
						o +
						"," +
						M +
						"," +
						S +
						")"),
					v.setAttribute("transform", s),
					_ && (v.style[Yn] = s);
			},
			Ti = function (t, e, n, i, r, o) {
				var s,
					a,
					c = Y(r),
					l = parseFloat(r) * (c && ~r.indexOf("rad") ? Ln : 1),
					h = o ? l * o : l - i,
					u = i + h + "deg";
				return (
					c &&
						("short" === (s = r.split("_")[1]) &&
							(h %= 360) !== h % 180 &&
							(h += h < 0 ? 360 : -360),
						"cw" === s && h < 0
							? (h = ((h + 36e9) % 360) - 360 * ~~(h / 360))
							: "ccw" === s &&
							  h > 0 &&
							  (h = ((h - 36e9) % 360) - 360 * ~~(h / 360))),
					(t._pt = a = new fn(t._pt, e, n, i, h, Nn)),
					(a.e = u),
					(a.u = "deg"),
					t._props.push(n),
					a
				);
			},
			Ei = function (t, e, n) {
				var i,
					r,
					o,
					s,
					a,
					c,
					l,
					h = Sn.style,
					u = n._gsap;
				for (r in ((h.cssText =
					getComputedStyle(n).cssText + ";position:absolute;display:block;"),
				(h[Yn] = e),
				bn.body.appendChild(Sn),
				(i = xi(Sn, 1)),
				An))
					(o = u[r]) !== (s = i[r]) &&
						"perspective,force3D,transformOrigin,svgOrigin".indexOf(r) < 0 &&
						((a = se(o) !== (l = se(s)) ? ai(n, r, o, l) : parseFloat(o)),
						(c = parseFloat(s)),
						(t._pt = new fn(t._pt, u, r, a, c - a, kn)),
						(t._pt.u = l || 0),
						t._props.push(r));
				bn.body.removeChild(Sn);
			};
		At("padding,margin,Width,Radius", function (t, e) {
			var n = "Top",
				i = "Right",
				r = "Bottom",
				o = "Left",
				s = (e < 3 ? [n, i, r, o] : [n + o, n + i, r + i, r + o]).map(function (
					n
				) {
					return e < 2 ? t + n : "border" + n + t;
				});
			di[e > 1 ? "border" + t : t] = function (t, e, n, i, r) {
				var o, a;
				if (arguments.length < 4)
					return (
						(o = s.map(function (e) {
							return ci(t, e, n);
						})),
						5 === (a = o.join(" ")).split(o[0]).length ? o[0] : a
					);
				(o = (i + "").split(" ")),
					(a = {}),
					s.forEach(function (t, e) {
						return (a[t] = o[e] = o[e] || o[((e - 1) / 2) | 0]);
					}),
					t.init(e, a, r);
			};
		});
		var Ai,
			Li,
			Pi = {
				name: "css",
				register: $n,
				targetTest: function (t) {
					return t.style && t.nodeType;
				},
				init: function (t, e, n, i, r) {
					var o,
						s,
						a,
						c,
						l,
						h,
						u,
						d,
						p,
						f,
						m,
						g,
						v,
						y,
						x,
						b,
						w,
						_,
						M,
						S = this._props,
						T = t.style;
					for (u in (_n || $n(), e))
						if (
							"autoRound" !== u &&
							((s = e[u]), !xt[u] || !Xe(u, e, n, i, t, r))
						)
							if (
								((l = typeof s),
								(h = di[u]),
								"function" === l && (l = typeof (s = s.call(n, i, t, r))),
								"string" === l && ~s.indexOf("random(") && (s = ve(s)),
								h)
							)
								h(this, t, u, s, n) && (x = 1);
							else if ("--" === u.substr(0, 2))
								this.add(
									T,
									"setProperty",
									getComputedStyle(t).getPropertyValue(u) + "",
									s + "",
									i,
									r,
									0,
									0,
									u
								);
							else if ("undefined" !== l) {
								if (
									((o = ci(t, u)),
									(c = parseFloat(o)),
									(f =
										"string" === l && "=" === s.charAt(1)
											? +(s.charAt(0) + "1")
											: 0) && (s = s.substr(2)),
									(a = parseFloat(s)),
									u in In &&
										("autoAlpha" === u &&
											(1 === c &&
												"hidden" === ci(t, "visibility") &&
												a &&
												(c = 0),
											oi(
												this,
												T,
												"visibility",
												c ? "inherit" : "hidden",
												a ? "inherit" : "hidden",
												!a
											)),
										"scale" !== u &&
											"transform" !== u &&
											~(u = In[u]).indexOf(",") &&
											(u = u.split(",")[0])),
									(m = u in An))
								)
									if (
										(g ||
											((v = t._gsap).renderTransform || xi(t),
											(y = !1 !== e.smoothOrigin && v.smooth),
											((g = this._pt =
												new fn(
													this._pt,
													T,
													Yn,
													0,
													1,
													v.renderTransform,
													v,
													0,
													-1
												)).dep = 1)),
										"scale" === u)
									)
										(this._pt = new fn(
											this._pt,
											v,
											"scaleY",
											v.scaleY,
											f ? f * a : a - v.scaleY
										)),
											S.push("scaleY", u),
											(u += "X");
									else {
										if ("transformOrigin" === u) {
											(w = void 0),
												(_ = void 0),
												(M = void 0),
												(w = (b = s).split(" ")),
												(_ = w[0]),
												(M = w[1] || "50%"),
												("top" !== _ &&
													"bottom" !== _ &&
													"left" !== M &&
													"right" !== M) ||
													((b = _), (_ = M), (M = b)),
												(w[0] = hi[_] || _),
												(w[1] = hi[M] || M),
												(s = w.join(" ")),
												v.svg
													? yi(t, s, 0, y, 0, this)
													: ((p = parseFloat(s.split(" ")[2]) || 0) !==
															v.zOrigin && oi(this, v, "zOrigin", v.zOrigin, p),
													  oi(this, T, u, bi(o), bi(s)));
											continue;
										}
										if ("svgOrigin" === u) {
											yi(t, s, 1, y, 0, this);
											continue;
										}
										if (u in fi) {
											Ti(this, v, u, c, s, f);
											continue;
										}
										if ("smoothOrigin" === u) {
											oi(this, v, "smooth", v.smooth, s);
											continue;
										}
										if ("force3D" === u) {
											v[u] = s;
											continue;
										}
										if ("transform" === u) {
											Ei(this, s, t);
											continue;
										}
									}
								else u in T || (u = Qn(u) || u);
								if (
									m ||
									((a || 0 === a) && (c || 0 === c) && !Dn.test(s) && u in T)
								)
									(d = (o + "").substr((c + "").length)),
										a || (a = 0),
										d !== (p = se(s) || (u in F.units ? F.units[u] : d)) &&
											(c = ai(t, u, o, p)),
										(this._pt = new fn(
											this._pt,
											m ? v : T,
											u,
											c,
											f ? f * a : a - c,
											"px" !== p || !1 === e.autoRound || m ? kn : Fn
										)),
										(this._pt.u = p || 0),
										d !== p && ((this._pt.b = o), (this._pt.r = Bn));
								else if (u in T) li.call(this, t, u, o, s);
								else {
									if (!(u in t)) {
										dt(u, s);
										continue;
									}
									this.add(t, u, t[u], s, i, r);
								}
								S.push(u);
							}
					x && pn(this);
				},
				get: ci,
				aliases: In,
				getSetter: function (t, e, n) {
					var i = In[e];
					return (
						i && i.indexOf(",") < 0 && (e = i),
						e in An && e !== Xn && (t._gsap.x || ci(t, "x"))
							? n && Tn === n
								? "scale" === e
									? jn
									: Vn
								: (Tn = n || {}) && ("scale" === e ? Wn : qn)
							: t.style && !J(t.style[e])
							? Un
							: ~e.indexOf("-")
							? Gn
							: on(t, e)
					);
				},
				core: { _removeProperty: ri, _getMatrix: vi },
			};
		(yn.utils.checkPrefix = Qn),
			(Li = At(
				"x,y,z,scale,scaleX,scaleY,xPercent,yPercent," +
					(Ai = "rotation,rotationX,rotationY,skewX,skewY") +
					",transform,transformOrigin,svgOrigin,force3D,smoothOrigin,transformPerspective",
				function (t) {
					An[t] = 1;
				}
			)),
			At(Ai, function (t) {
				(F.units[t] = "deg"), (fi[t] = 1);
			}),
			(In[Li[13]] = "x,y,z,scale,scaleX,scaleY,xPercent,yPercent," + Ai),
			At(
				"0:translateX,1:translateY,2:translateZ,8:rotate,8:rotationZ,8:rotateZ,9:rotateX,10:rotateY",
				function (t) {
					var e = t.split(":");
					In[e[1]] = Li[e[0]];
				}
			),
			At(
				"x,y,z,top,right,bottom,left,width,height,fontSize,padding,margin,perspective",
				function (t) {
					F.units[t] = "px";
				}
			),
			yn.registerPlugin(Pi);
		var Ri,
			Ci,
			Oi,
			Di,
			Ii,
			ki,
			Ni,
			Bi,
			Fi,
			zi,
			Hi,
			Ui,
			Gi,
			Vi,
			ji,
			Wi,
			qi,
			Yi,
			Xi,
			Zi,
			Ji,
			Ki,
			Qi,
			$i,
			tr,
			er = yn.registerPlugin(Pi) || yn,
			nr =
				(er.core.Tween,
				function (t, e) {
					var n = new er.timeline({ paused: !0 });
					if (_.firstLoad) {
						var i = document.querySelector(".drawer-trigger.work"),
							r = i.querySelector("span"),
							o = document.querySelector(".drawer-trigger.about"),
							s = o.querySelector("span"),
							a = new er.timeline({ paused: !0 });
						a
							.fromTo(
								i,
								0.5,
								{ opacity: 0, x: -30 },
								{
									opacity: 1,
									x: 0,
									clearProps: "transform",
									ease: "sine.inOut",
									force3D: !0,
								}
							)
							.fromTo(
								r,
								0.5,
								{ opacity: 0, x: -3 },
								{
									opacity: 1,
									x: 0,
									clearProps: "transform",
									ease: "sine.inOut",
									force3D: !0,
								},
								0.055
							)
							.fromTo(
								o,
								0.5,
								{ opacity: 0, x: 30 },
								{
									opacity: 1,
									x: 0,
									clearProps: "transform",
									ease: "sine.inOut",
									force3D: !0,
								},
								0
							)
							.fromTo(
								s,
								0.5,
								{ opacity: 0, x: 3 },
								{
									opacity: 1,
									x: 0,
									clearProps: "transform",
									ease: "sine.inOut",
									force3D: !0,
								},
								0.055
							),
							a.play();
					}
					switch (t) {
						case "home":
							var c = M.viewEl.querySelector(".hero h1"),
								l = M.viewEl.querySelector(".hero .scroll-indicator");
							(_.scrollIndicatorTl = new er.timeline({
								paused: !0,
								repeat: 4,
								repeatDelay: 1,
							})),
								_.scrollIndicatorTl
									.fromTo(
										l,
										1.6,
										{ scaleY: 0 },
										{ scaleY: 1, ease: "expo.out", transformOrigin: "50% 0%" }
									)
									.to(
										l,
										1.4,
										{
											scaleY: 0,
											ease: "expo.out",
											transformOrigin: "50% 100%",
										},
										">.2"
									);
							var h = M.viewEl.querySelectorAll(
								".work-grid .work-tile:first-child .bg"
							);
							n.fromTo(
								c,
								1.1,
								{ y: 20, opacity: 0 },
								{
									clearProps: "transform",
									y: 0,
									opacity: 1,
									ease: "power3.out",
									force3D: !0,
								}
							)
								.fromTo(
									h,
									1.1,
									{ scale: 1.05, y: 20, opacity: 0 },
									{
										scale: 1,
										y: 0,
										opacity: 1,
										clearProps: "transform",
										ease: "power3.out",
										force3D: !0,
									},
									0
								)
								.add(function () {
									er.delayedCall(1, function () {
										_.scrollIndicatorTl.play();
									});
								});
							break;
						case "work":
							var u,
								d,
								p = M.viewEl.querySelector(".headline-wrapper h1");
							_.isGreaterThan767
								? ((u = M.viewEl.querySelectorAll(
										".filter-wrapper .filter-el"
								  )),
								  (d = 0.1))
								: ((u = M.viewEl.querySelector(".mobile-filter-wrapper")),
								  (d = 0));
							var f = M.viewEl.querySelector(".featured-project video");
							f &&
								(f.play(),
								er.delayedCall(0.3, function () {
									Ax.videosData[0].playing = !0;
								}));
							var m,
								g = !(!_.queryParams || !_.queryParams.filter);
							n
								.fromTo(
									p,
									1.1,
									{ y: 20, opacity: 0 },
									{
										clearProps: "transform",
										opacity: 1,
										y: 0,
										ease: "power3.out",
										force3D: !0,
									}
								)
								.add("fadeIn", 0.12),
								_.isGreaterThan767
									? n.fromTo(
											u,
											0.9,
											{ rotation: 2.6, y: 20, opacity: 0 },
											{
												rotation: 0,
												y: 0,
												stagger: d,
												opacity: 1,
												clearProps: "transform",
												ease: "power3.out",
												force3D: !0,
											},
											"fadeIn"
									  )
									: n.fromTo(
											u,
											0.9,
											{ y: 20, opacity: 0 },
											{
												y: 0,
												stagger: d,
												opacity: 1,
												clearProps: "transform",
												ease: "power3.out",
												force3D: !0,
											},
											"fadeIn"
									  ),
								g
									? ((m = M.viewEl.querySelectorAll(
											".work-grid .work-tile:not(.is-hidden)"
									  )).length > 1 &&
											(m = Array.prototype.slice.call(m).slice(0, 2)),
									  n.fromTo(
											m,
											1.2,
											{ scale: 1.05, opacity: 0 },
											{
												scale: 1,
												opacity: 1,
												clearProps: "transform",
												ease: "power3.out",
												force3D: !0,
											},
											0.5
									  ))
									: ((m = M.viewEl.querySelectorAll(
											".work-grid .work-tile:first-child .bg"
									  )),
									  n.fromTo(
											m,
											1.2,
											{ scale: 1.05, opacity: 0 },
											{
												scale: 1,
												opacity: 1,
												clearProps: "transform",
												ease: "power3.out",
												force3D: !0,
											},
											0.5
									  ));
							break;
						case "category":
							var v = M.viewEl.querySelector(".cat-hero h1"),
								y = M.viewEl.querySelectorAll(".cat-hero .content p"),
								x = M.viewEl.querySelector(".cat-hero video"),
								b = !1;
							x
								? (x.play(),
								  er.delayedCall(0.3, function () {
										Ax.videosData[0].playing = !0;
								  }))
								: (b = M.viewEl.querySelector(".cat-hero img")),
								n
									.fromTo(
										v,
										1.1,
										{ y: 20, opacity: 0 },
										{
											clearProps: "transform",
											opacity: 1,
											y: 0,
											ease: "power3.out",
											force3D: !0,
										}
									)
									.add("fadeIn", 0.12),
								_.isGreaterThan767
									? n.fromTo(
											y,
											0.9,
											{ rotation: 2.6, y: 20, opacity: 0 },
											{
												rotation: 0,
												y: 0,
												stagger: 0.1,
												opacity: 1,
												clearProps: "transform",
												ease: "power3.out",
												force3D: !0,
											},
											"fadeIn"
									  )
									: n.fromTo(
											y,
											0.9,
											{ y: 20, opacity: 0 },
											{
												y: 0,
												stagger: 0.1,
												opacity: 1,
												clearProps: "transform",
												ease: "power3.out",
												force3D: !0,
											},
											"fadeIn"
									  ),
								b
									? n.fromTo(
											b,
											1.2,
											{ scale: 1.05, opacity: 0 },
											{
												scale: 1,
												opacity: 1,
												clearProps: "transform",
												ease: "power3.out",
												force3D: !0,
											},
											0.5
									  )
									: n.fromTo(
											x,
											1.2,
											{ scale: 1.05, opacity: 0 },
											{
												scale: 1,
												opacity: 1,
												clearProps: "transform",
												ease: "power3.out",
												force3D: !0,
											},
											0.5
									  );
							break;
						case "work-type":
							var w = M.viewEl.querySelector(".hero .copy"),
								T = M.viewEl.querySelector(".hero .bg");
							"VIDEO" === T.nodeName &&
								(T.play(),
								er.delayedCall(0.3, function () {
									Ax.videosData[0].playing = !0;
								})),
								n.fromTo(
									T,
									1.2,
									{ scale: 1.05, opacity: 0 },
									{
										scale: 1,
										opacity: 1,
										clearProps: "transform",
										ease: "power3.out",
										force3D: !0,
									}
								),
								w &&
									n.fromTo(
										w,
										1,
										{ scale: 0.965, opacity: 0 },
										{
											scale: 1,
											opacity: 1,
											clearProps: "transform",
											ease: "power3.out",
											force3D: !0,
										},
										0.5
									);
							break;
						case "about-us":
							var E = M.viewEl.querySelector(".top p"),
								A = document.querySelector(".full-width-img");
							(E.innerHTML = E.innerHTML.replace("-", "<span>-</span>")),
								n
									.fromTo(
										E,
										1.1,
										{ y: 20, opacity: 0 },
										{
											clearProps: "transform",
											opacity: 1,
											y: 0,
											ease: "power3.out",
											force3D: !0,
										},
										_.fromAboutDrawer ? 0 : 1
									)
									.fromTo(
										A,
										1.2,
										{ scale: 1.05, y: 20, opacity: 0 },
										{
											scale: 1,
											y: 0,
											opacity: 1,
											clearProps: "transform",
											ease: "power3.out",
											force3D: !0,
										},
										_.fromAboutDrawer ? 0 : 1
									);
							break;
						case "careers":
							var L = M.viewEl.querySelectorAll(".top h1, .top > p"),
								P = M.viewEl.querySelectorAll(".job");
							n.fromTo(
								L,
								1.1,
								{ y: 20, opacity: 0 },
								{
									clearProps: "transform",
									opacity: 1,
									y: 0,
									ease: "expo.out",
									force3D: !0,
								}
							)
								.add("fadeIn", 0.35)
								.fromTo(
									P,
									1.1,
									{ opacity: 0, y: 40 },
									{ stagger: 0.1, y: 0, opacity: 1, ease: "power3.out" },
									"fadeIn"
								);
							break;
						case "careers-type":
							var R = M.viewEl.querySelectorAll(
								".careers-backlink, .career-post > .flex-wrap"
							);
							n.fromTo(
								R,
								1.1,
								{ y: 20, opacity: 0 },
								{
									clearProps: "transform",
									opacity: 1,
									y: 0,
									ease: "expo.out",
									force3D: !0,
								}
							);
							break;
						case "contact":
							var C = M.viewEl.querySelectorAll(".top h1, .top p"),
								O = M.viewEl.querySelector(".wipe-bg"),
								D = M.viewEl.querySelectorAll(".quick-contact a");
							er.set(D, { opacity: 0 }),
								n
									.fromTo(
										C,
										1.1,
										{ y: 20, opacity: 0 },
										{
											clearProps: "transform",
											opacity: 1,
											y: 0,
											ease: "power3.out",
											force3D: !0,
										}
									)
									.to(
										O,
										0.7,
										{
											scaleY: 1,
											force3D: !0,
											ease: "expo.out",
											transformOrigin: "50% 0%",
										},
										"-=.5"
									)
									.set(D, { opacity: 1 })
									.to(O, 0.82, {
										scaleY: 0,
										ease: "expo.out",
										clearProps: "transform",
										force3D: !0,
										transformOrigin: "50% 100%",
									});
							break;
						case "privacy-policy":
							var I = M.viewEl.querySelector("h1"),
								k = M.viewEl.querySelectorAll(".content-wrapper > section");
							n.fromTo(
								I,
								1.1,
								{ y: 20, opacity: 0 },
								{
									clearProps: "transform",
									opacity: 1,
									y: 0,
									ease: "power3.out",
									force3D: !0,
								}
							)
								.add("fadeIn", 0.35)
								.fromTo(
									k,
									1.1,
									{ opacity: 0, y: 40 },
									{ stagger: 0.1, y: 0, opacity: 1, ease: "power3.out" },
									"fadeIn"
								);
					}
					var N = _.firstLoad;
					n.add(function () {
						N && Ox.show(0.8);
					}, ">+3"),
						_.tripMode
							? er.set(M.tieDieEl, { zIndex: 1 })
							: er.set(M.globalMask, { pointerEvents: "none", autoAlpha: 0 }),
						_.firstLoad
							? (n.add(
									function () {
										var t = setInterval(function () {
											Cx.modelsLoaded === (_.isGreaterThan767 ? 4 : 3) &&
												(clearInterval(t),
												(Cx.headerIn = !0),
												S.renderer.render(S.scene, S.camera),
												Cx.showHeader());
										}, 20);
									},
									"about-us" === _.namespace ? "-=3.33" : "-=3.65"
							  ),
							  "about-us" === _.namespace &&
									(_.fromAboutDrawer || Dx.aboutPageEntrance(),
									(_.fromAboutDrawer = !1)),
							  er.delayedCall(0.46, function () {
									n.play();
							  }),
							  (_.firstLoad = !1))
							: ("about-us" === _.namespace &&
									(_.fromAboutDrawer || Dx.aboutPageEntrance(),
									(_.fromAboutDrawer = !1)),
							  n.play());
				}),
			ir = function () {
				!1 !== _.firstLoad && (_.transitionFinished = !0);
			},
			rr = function () {
				var t = document.querySelector(".back-to-top"),
					e = document.querySelector("a, button");
				t &&
					t.addEventListener("click", function () {
						Ax.scrollTo(0, 1.2, "expo.inOut"),
							_.keyToggle &&
								setTimeout(function () {
									e.focus();
								}, 1200);
					});
			},
			or = function (t) {
				if (t && t.href && (_.isMobile || navigator.clipboard)) {
					var e = t.href.replace("mailto:", ""),
						n = t.textContent;
					(t.href = ""),
						(t.ariaLabel = "Copy contact email to clipboard: ".concat(e)),
						(t.ariaLive = "polite"),
						t.addEventListener("click", function (i) {
							i.preventDefault(),
								navigator.clipboard.writeText(e),
								(t.innerText = "Copied to clipboard!"),
								er.delayedCall(1.8, function () {
									t.innerText = n;
								});
						});
				}
			},
			sr = function () {
				_.firstLoad &&
					document.addEventListener("click", function () {
						if (!event.target.classList.toString().includes("dropdown")) {
							var t = document.querySelectorAll(".dropdown.open");
							t &&
								t.forEach(function (t) {
									t.classList.remove("open"),
										er.to(t.querySelector(".options-wrapper"), 0.4, {
											height: 0,
										});
								});
						}
					}),
					document
						.querySelectorAll(".dropdown:not(.bound)")
						.forEach(function (t) {
							var e = t.querySelector(".dropdown-value"),
								n = t.querySelector(".options-wrapper"),
								i = n.querySelectorAll(".option"),
								r = t.querySelector("input");
							er.set(n, { height: 0 }),
								e.addEventListener("click", function () {
									t.classList.contains("open")
										? (er.to(n, { height: 0, duration: 0.4 }),
										  t.classList.remove("open"))
										: (er.set(n, { height: "auto" }),
										  er.from(n, { height: 0, duration: 0.4 }),
										  t.classList.add("open"));
								}),
								i.forEach(function (i) {
									i.addEventListener("click", function (o) {
										o.target.classList.contains("disabled")
											? o.stopPropagation()
											: ((e.children[0].innerHTML = i.children[0].innerHTML),
											  r && (r.value = i.children[0].innerHTML),
											  er.to(n, { height: 0, duration: 0.4 }),
											  t.classList.remove("open"));
									});
								});
						});
			},
			ar = function (t) {
				if (t) {
					t.classList.add("is-bound");
					var e = !1,
						n = t.querySelector(".first-text"),
						i = t.querySelector(".second-text");
					t.addEventListener("click", function () {
						e
							? ((n.style.display = "block"), (i.style.display = "none"))
							: ((n.style.display = "none"), (i.style.display = "block")),
							(e = !e);
					});
				}
			},
			cr = 1,
			lr = [],
			hr = [],
			ur = Date.now,
			dr = ur(),
			pr = 0,
			fr = 1,
			mr = function (t) {
				return t;
			},
			gr = function () {
				return "undefined" != typeof window;
			},
			vr = function () {
				return Ri || (gr() && (Ri = window.gsap) && Ri.registerPlugin && Ri);
			},
			yr = function (t) {
				return !!~Ni.indexOf(t);
			},
			xr = function (t, e) {
				return ~lr.indexOf(t) && lr[lr.indexOf(t) + 1][e];
			},
			br = function (t, e) {
				var n = e.s,
					i = e.sc,
					r = hr.indexOf(t),
					o = i === Ir.sc ? 1 : 2;
				return (
					!~r && (r = hr.push(t) - 1),
					hr[r + o] ||
						(hr[r + o] =
							xr(t, n) ||
							(yr(t)
								? i
								: function (e) {
										return arguments.length ? (t[n] = e) : t[n];
								  }))
				);
			},
			wr = function (t) {
				return (
					xr(t, "getBoundingClientRect") ||
					(yr(t)
						? function () {
								return (
									(xo.width = Oi.innerWidth), (xo.height = Oi.innerHeight), xo
								);
						  }
						: function () {
								return Br(t);
						  })
				);
			},
			_r = function (t, e) {
				var n = e.s,
					i = e.d2,
					r = e.d,
					o = e.a;
				return (n = "scroll" + i) && (o = xr(t, n))
					? o() - wr(t)()[r]
					: yr(t)
					? Math.max(Ii[n], ki[n]) -
					  (Oi["inner" + i] || Ii["client" + i] || ki["client" + i])
					: t[n] - t["offset" + i];
			},
			Mr = function (t, e) {
				for (var n = 0; n < Ji.length; n += 3)
					(!e || ~e.indexOf(Ji[n + 1])) && t(Ji[n], Ji[n + 1], Ji[n + 2]);
			},
			Sr = function (t) {
				return "string" == typeof t;
			},
			Tr = function (t) {
				return "function" == typeof t;
			},
			Er = function (t) {
				return "number" == typeof t;
			},
			Ar = function (t) {
				return "object" == typeof t;
			},
			Lr = function (t) {
				return Tr(t) && t();
			},
			Pr = function (t, e) {
				return function () {
					var n = Lr(t),
						i = Lr(e);
					return function () {
						Lr(n), Lr(i);
					};
				};
			},
			Rr = Math.abs,
			Cr = "padding",
			Or = "px",
			Dr = {
				s: "scrollLeft",
				p: "left",
				p2: "Left",
				os: "right",
				os2: "Right",
				d: "width",
				d2: "Width",
				a: "x",
				sc: function (t) {
					return arguments.length
						? Oi.scrollTo(t, Ir.sc())
						: Oi.pageXOffset ||
								Di.scrollLeft ||
								Ii.scrollLeft ||
								ki.scrollLeft ||
								0;
				},
			},
			Ir = {
				s: "scrollTop",
				p: "top",
				p2: "Top",
				os: "bottom",
				os2: "Bottom",
				d: "height",
				d2: "Height",
				a: "y",
				op: Dr,
				sc: function (t) {
					return arguments.length
						? Oi.scrollTo(Dr.sc(), t)
						: Oi.pageYOffset ||
								Di.scrollTop ||
								Ii.scrollTop ||
								ki.scrollTop ||
								0;
				},
			},
			kr = function (t) {
				return Oi.getComputedStyle(t);
			},
			Nr = function (t, e) {
				for (var n in e) n in t || (t[n] = e[n]);
				return t;
			},
			Br = function (t, e) {
				var n =
						e &&
						"matrix(1, 0, 0, 1, 0, 0)" !== kr(t)[qi] &&
						Ri.to(t, {
							x: 0,
							y: 0,
							xPercent: 0,
							yPercent: 0,
							rotation: 0,
							rotationX: 0,
							rotationY: 0,
							scale: 1,
							skewX: 0,
							skewY: 0,
						}).progress(1),
					i = t.getBoundingClientRect();
				return n && n.progress(0).kill(), i;
			},
			Fr = function (t, e) {
				var n = e.d2;
				return t["offset" + n] || t["client" + n] || 0;
			},
			zr = function (t, e, n, i) {
				return n.split(",").forEach(function (n) {
					return t(e, n, i);
				});
			},
			Hr = function (t, e, n) {
				return t.addEventListener(e, n, { passive: !0 });
			},
			Ur = function (t, e, n) {
				return t.removeEventListener(e, n);
			},
			Gr = {
				startColor: "green",
				endColor: "red",
				indent: 0,
				fontSize: "16px",
				fontWeight: "normal",
			},
			Vr = { toggleActions: "play", anticipatePin: 0 },
			jr = { top: 0, left: 0, center: 0.5, bottom: 1, right: 1 },
			Wr = function (t, e) {
				if (Sr(t)) {
					var n = t.indexOf("="),
						i = ~n ? +(t.charAt(n - 1) + 1) * parseFloat(t.substr(n + 1)) : 0;
					i && (t.indexOf("%") > n && (i *= e / 100), (t = t.substr(0, n - 1))),
						(t =
							i +
							(t in jr
								? jr[t] * e
								: ~t.indexOf("%")
								? (parseFloat(t) * e) / 100
								: parseFloat(t) || 0));
				}
				return t;
			},
			qr = function (t, e, n, i, r, o, s) {
				var a = r.startColor,
					c = r.endColor,
					l = r.fontSize,
					h = r.indent,
					u = r.fontWeight,
					d = Di.createElement("div"),
					p = yr(n) || "fixed" === xr(n, "pinType"),
					f = -1 !== t.indexOf("scroller"),
					m = p ? ki : n,
					g = -1 !== t.indexOf("start"),
					v = g ? a : c,
					y =
						"border-color:" +
						v +
						";font-size:" +
						l +
						";color:" +
						v +
						";font-weight:" +
						u +
						";pointer-events:none;white-space:nowrap;font-family:sans-serif,Arial;z-index:1000;padding:4px 8px;border-width:0;border-style:solid;";
				return (
					(y += "position:" + (f && p ? "fixed;" : "absolute;")),
					(f || !p) &&
						(y +=
							(i === Ir ? "right" : "bottom") +
							":" +
							(o + parseFloat(h)) +
							"px;"),
					s &&
						(y +=
							"box-sizing:border-box;text-align:left;width:" +
							s.offsetWidth +
							"px;"),
					(d._isStart = g),
					d.setAttribute("class", "gsap-marker-" + t),
					(d.style.cssText = y),
					(d.innerText = e || 0 === e ? t + "-" + e : t),
					m.insertBefore(d, m.children[0]),
					(d._offset = d["offset" + i.op.d2]),
					Yr(d, 0, i, g),
					d
				);
			},
			Yr = function (t, e, n, i) {
				var r = { display: "block" },
					o = n[i ? "os2" : "p2"],
					s = n[i ? "p2" : "os2"];
				(t._isFlipped = i),
					(r[n.a + "Percent"] = i ? -100 : 0),
					(r[n.a] = i ? 1 : 0),
					(r["border" + o + "Width"] = 1),
					(r["border" + s + "Width"] = 0),
					(r[n.p] = e),
					Ri.set(t, r);
			},
			Xr = [],
			Zr = {},
			Jr = function () {
				return zi || (zi = Fi(uo));
			},
			Kr = function () {
				zi || ((zi = Fi(uo)), pr || ro("scrollStart"), (pr = ur()));
			},
			Qr = function () {
				return !ji && Bi.restart(!0);
			},
			$r = {},
			to = [],
			eo = [],
			no = function (t) {
				var e,
					n = Ri.ticker.frame,
					i = [],
					r = 0;
				if (tr !== n || cr) {
					for (ao(); r < eo.length; r += 4)
						(e = Oi.matchMedia(eo[r]).matches) !== eo[r + 3] &&
							((eo[r + 3] = e),
							e ? i.push(r) : ao(1, eo[r]) || (Tr(eo[r + 2]) && eo[r + 2]()));
					for (so(), r = 0; r < i.length; r++)
						(e = i[r]), ($i = eo[e]), (eo[e + 2] = eo[e + 1](t));
					($i = 0), co(0, 1), (tr = n), ro("matchMedia");
				}
			},
			io = function t() {
				return Ur(So, "scrollEnd", t) || co(!0);
			},
			ro = function (t) {
				return (
					($r[t] &&
						$r[t].map(function (t) {
							return t();
						})) ||
					to
				);
			},
			oo = [],
			so = function (t) {
				for (var e = 0; e < oo.length; e += 4)
					(t && oo[e + 3] !== t) ||
						((oo[e].style.cssText = oo[e + 1]), (oo[e + 2].uncache = 1));
			},
			ao = function (t, e) {
				var n;
				for (Yi = 0; Yi < Xr.length; Yi++)
					(n = Xr[Yi]),
						(e && n.media !== e) ||
							(t
								? n.kill(1)
								: (n.scroll.rec || (n.scroll.rec = n.scroll()), n.revert()));
				so(e), e || ro("revert");
			},
			co = function (t, e) {
				if (!pr || t) {
					var n = ro("refreshInit");
					for (Ki && So.sort(), e || ao(), Yi = 0; Yi < Xr.length; Yi++)
						Xr[Yi].refresh();
					for (
						n.forEach(function (t) {
							return t && t.render && t.render(-1);
						}),
							Yi = Xr.length;
						Yi--;

					)
						Xr[Yi].scroll.rec = 0;
					Bi.pause(), ro("refresh");
				} else Hr(So, "scrollEnd", io);
			},
			lo = 0,
			ho = 1,
			uo = function () {
				var t = Xr.length,
					e = ur(),
					n = e - dr >= 50,
					i = t && Xr[0].scroll();
				if (
					((ho = lo > i ? -1 : 1),
					(lo = i),
					n &&
						(pr && !Wi && e - pr > 200 && ((pr = 0), ro("scrollEnd")),
						(Gi = dr),
						(dr = e)),
					ho < 0)
				) {
					for (Yi = t; Yi--; ) Xr[Yi] && Xr[Yi].update(0, n);
					ho = 1;
				} else for (Yi = 0; Yi < t; Yi++) Xr[Yi] && Xr[Yi].update(0, n);
				zi = 0;
			},
			po = [
				"left",
				"top",
				"bottom",
				"right",
				"marginBottom",
				"marginRight",
				"marginTop",
				"marginLeft",
				"display",
				"flexShrink",
				"float",
			],
			fo = po.concat([
				"width",
				"height",
				"boxSizing",
				"maxWidth",
				"maxHeight",
				"position",
				"margin",
				Cr,
				"paddingTop",
				"paddingRight",
				"paddingBottom",
				"paddingLeft",
			]),
			mo = function (t, e, n, i) {
				if (t.parentNode !== e) {
					for (var r, o = po.length, s = e.style, a = t.style; o--; )
						s[(r = po[o])] = n[r];
					(s.position = "absolute" === n.position ? "absolute" : "relative"),
						"inline" === n.display && (s.display = "inline-block"),
						(a.bottom = a.right = "auto"),
						(s.overflow = "visible"),
						(s.boxSizing = "border-box"),
						(s.width = Fr(t, Dr) + Or),
						(s.height = Fr(t, Ir) + Or),
						(s.padding = a.margin = a.top = a.left = "0"),
						vo(i),
						(a.width = a.maxWidth = n.width),
						(a.height = a.maxHeight = n.height),
						(a.padding = n.padding),
						t.parentNode.insertBefore(e, t),
						e.appendChild(t);
				}
			},
			go = /([A-Z])/g,
			vo = function (t) {
				if (t)
					for (var e, n, i = t.t.style, r = t.length, o = 0; o < r; o += 2)
						(n = t[o + 1]),
							(e = t[o]),
							n
								? (i[e] = n)
								: i[e] && i.removeProperty(e.replace(go, "-$1").toLowerCase());
			},
			yo = function (t) {
				for (var e = fo.length, n = t.style, i = [], r = 0; r < e; r++)
					i.push(fo[r], n[fo[r]]);
				return (i.t = t), i;
			},
			xo = { left: 0, top: 0 },
			bo = function (t, e, n, i, r, o, s, a, c, l, h, u) {
				if (
					(Tr(t) && (t = t(a)),
					Sr(t) &&
						"max" === t.substr(0, 3) &&
						(t = u + ("=" === t.charAt(4) ? Wr("0" + t.substr(3), n) : 0)),
					Er(t))
				)
					s && Yr(s, n, i, !0);
				else {
					Tr(e) && (e = e(a));
					var d,
						p,
						f,
						m = Hi(e)[0] || ki,
						g = Br(m) || {},
						v = t.split(" ");
					(g && (g.left || g.top)) ||
						"none" !== kr(m).display ||
						((f = m.style.display),
						(m.style.display = "block"),
						(g = Br(m)),
						f ? (m.style.display = f) : m.style.removeProperty("display")),
						(d = Wr(v[0], g[i.d])),
						(p = Wr(v[1] || "0", n)),
						(t = g[i.p] - c[i.p] - l + d + r - p),
						s && Yr(s, p, i, n - p < 20 || (s._isStart && p > 20)),
						(n -= n - p);
				}
				if (o) {
					var y = t + n,
						x = o._isStart;
					(u = "scroll" + i.d2),
						Yr(
							o,
							y,
							i,
							(x && y > 20) ||
								(!x && (h ? Math.max(ki[u], Ii[u]) : o.parentNode[u]) <= y + 1)
						),
						h &&
							((c = Br(s)),
							h && (o.style[i.op.p] = c[i.op.p] - i.op.m - o._offset + Or));
				}
				return Math.round(t);
			},
			wo = /(?:webkit|moz|length|cssText)/i,
			_o = function (t, e, n, i) {
				if (t.parentNode !== e) {
					var r,
						o,
						s = t.style;
					if (e === ki) {
						for (r in ((t._stOrig = s.cssText), (o = kr(t))))
							+r ||
								wo.test(r) ||
								!o[r] ||
								"string" != typeof s[r] ||
								"0" === r ||
								(s[r] = o[r]);
						(s.top = n), (s.left = i);
					} else s.cssText = t._stOrig;
					(Ri.core.getCache(t).uncache = 1), e.appendChild(t);
				}
			},
			Mo = function (t, e) {
				var n,
					i,
					r = br(t, e),
					o = "_scroll" + e.p2;
				return (
					(t[o] = r),
					function e(s, a, c, l, h) {
						var u = e.tween,
							d = a.onComplete,
							p = {};
						return (
							u && u.kill(),
							(n = Math.round(c)),
							(a[o] = s),
							(a.modifiers = p),
							(p[o] = function (t) {
								return (
									(t = Math.round(r())) !== n && t !== i
										? (u.kill(), (e.tween = 0))
										: (t = c + l * u.ratio + h * u.ratio * u.ratio),
									(i = n),
									(n = Math.round(t))
								);
							}),
							(a.onComplete = function () {
								(e.tween = 0), d && d.call(u);
							}),
							(u = e.tween = Ri.to(t, a))
						);
					}
				);
			};
		Dr.op = Ir;
		var So = (function () {
			function t(e, n) {
				Ci ||
					t.register(Ri) ||
					console.warn("Please gsap.registerPlugin(ScrollTrigger)"),
					this.init(e, n);
			}
			return (
				(t.prototype.init = function (e, n) {
					if (((this.progress = 0), this.vars && this.kill(1), fr)) {
						var i,
							r,
							o,
							s,
							a,
							c,
							l,
							h,
							u,
							d,
							p,
							f,
							m,
							g,
							v,
							y,
							x,
							b,
							w,
							_,
							M,
							S,
							T,
							E,
							A,
							L,
							P,
							R,
							C,
							O,
							D,
							I,
							k,
							N,
							B,
							F,
							z,
							H,
							U = (e = Nr(
								Sr(e) || Er(e) || e.nodeType ? { trigger: e } : e,
								Vr
							)).horizontal
								? Dr
								: Ir,
							G = e,
							V = G.onUpdate,
							j = G.toggleClass,
							W = G.id,
							q = G.onToggle,
							Y = G.onRefresh,
							X = G.scrub,
							Z = G.trigger,
							J = G.pin,
							K = G.pinSpacing,
							Q = G.invalidateOnRefresh,
							$ = G.anticipatePin,
							tt = G.onScrubComplete,
							et = G.onSnapComplete,
							nt = G.once,
							it = G.snap,
							rt = G.pinReparent,
							ot = !X && 0 !== X,
							st = Hi(e.scroller || Oi)[0],
							at = Ri.core.getCache(st),
							ct = yr(st),
							lt =
								"pinType" in e
									? "fixed" === e.pinType
									: ct || "fixed" === xr(st, "pinType"),
							ht = [e.onEnter, e.onLeave, e.onEnterBack, e.onLeaveBack],
							ut = ot && e.toggleActions.split(" "),
							dt = "markers" in e ? e.markers : Vr.markers,
							pt = ct ? 0 : parseFloat(kr(st)["border" + U.p2 + "Width"]) || 0,
							ft = this,
							mt =
								e.onRefreshInit &&
								function () {
									return e.onRefreshInit(ft);
								},
							gt = (function (t, e, n) {
								var i = n.d,
									r = n.d2,
									o = n.a;
								return (o = xr(t, "getBoundingClientRect"))
									? function () {
											return o()[i];
									  }
									: function () {
											return (e ? Oi["inner" + r] : t["client" + r]) || 0;
									  };
							})(st, ct, U),
							vt = (function (t, e) {
								return !e || ~lr.indexOf(t)
									? wr(t)
									: function () {
											return xo;
									  };
							})(st, ct);
						(ft.media = $i),
							($ *= 45),
							Xr.push(ft),
							(ft.scroller = st),
							(ft.scroll = br(st, U)),
							(a = ft.scroll()),
							(ft.vars = e),
							(n = n || e.animation),
							"refreshPriority" in e && (Ki = 1),
							(at.tweenScroll = at.tweenScroll || {
								top: Mo(st, Ir),
								left: Mo(st, Dr),
							}),
							(ft.tweenTo = i = at.tweenScroll[U.p]),
							n &&
								((n.vars.lazy = !1),
								n._initted ||
									(!1 !== n.vars.immediateRender &&
										!1 !== e.immediateRender &&
										n.render(0, !0, !0)),
								(ft.animation = n.pause()),
								(n.scrollTrigger = ft),
								(I = Er(X) && X) &&
									(D = Ri.to(n, {
										ease: "power3",
										duration: I,
										onComplete: function () {
											return tt && tt(ft);
										},
									})),
								(C = 0),
								W || (W = n.vars.id)),
							it &&
								(Ar(it) || (it = { snapTo: it }),
								Ri.set(ct ? [ki, Ii] : st, { scrollBehavior: "auto" }),
								(o = Tr(it.snapTo)
									? it.snapTo
									: "labels" === it.snapTo
									? (function (t) {
											return function (e) {
												var n,
													i = [],
													r = t.labels,
													o = t.duration();
												for (n in r) i.push(r[n] / o);
												return Ri.utils.snap(i, e);
											};
									  })(n)
									: Ri.utils.snap(it.snapTo)),
								(k = it.duration || { min: 0.1, max: 2 }),
								(k = Ar(k) ? Ui(k.min, k.max) : Ui(k, k)),
								(N = Ri.delayedCall(it.delay || I / 2 || 0.1, function () {
									if (Math.abs(ft.getVelocity()) < 10 && !Wi) {
										var t = n && !ot ? n.totalProgress() : ft.progress,
											e = ((t - O) / (ur() - Gi)) * 1e3 || 0,
											r = (Rr(e / 2) * e) / 0.185,
											s = t + r,
											a = Ui(0, 1, o(s, ft)),
											c = ft.scroll(),
											u = Math.round(l + a * g),
											d = i.tween;
										if (c <= h && c >= l && u !== c) {
											if (d && !d._initted && d.data <= Math.abs(u - c)) return;
											i(
												u,
												{
													duration: k(
														Rr(
															(0.185 * Math.max(Rr(s - t), Rr(a - t))) /
																e /
																0.05 || 0
														)
													),
													ease: it.ease || "power3",
													data: Math.abs(u - c),
													onComplete: function () {
														(C = O =
															n && !ot ? n.totalProgress() : ft.progress),
															et && et(ft);
													},
												},
												c,
												r * g,
												u - c - r * g
											);
										}
									} else ft.isActive && N.restart(!0);
								}).pause())),
							W && (Zr[W] = ft),
							(Z = ft.trigger = Hi(Z || J)[0]),
							(J = !0 === J ? Z : Hi(J)[0]),
							Sr(j) && (j = { targets: Z, className: j }),
							J &&
								(!1 === K ||
									"margin" === K ||
									(K = !(!K && "flex" === kr(J.parentNode).display) && Cr),
								(ft.pin = J),
								!1 !== e.force3D && Ri.set(J, { force3D: !0 }),
								(r = Ri.core.getCache(J)).spacer
									? (v = r.pinState)
									: ((r.spacer = b = Di.createElement("div")),
									  b.setAttribute(
											"class",
											"pin-spacer" + (W ? " pin-spacer-" + W : "")
									  ),
									  (r.pinState = v = yo(J))),
								(ft.spacer = b = r.spacer),
								(R = kr(J)),
								(E = R[K + U.os2]),
								(_ = Ri.getProperty(J)),
								(M = Ri.quickSetter(J, U.a, Or)),
								mo(J, b, R),
								(x = yo(J))),
							dt &&
								((m = Ar(dt) ? Nr(dt, Gr) : Gr),
								(p = qr("scroller-start", W, st, U, m, 0)),
								(f = qr("scroller-end", W, st, U, m, 0, p)),
								(w = p["offset" + U.op.d2]),
								(u = qr("start", W, st, U, m, w)),
								(d = qr("end", W, st, U, m, w)),
								lt ||
									(((H = st).style.position =
										"absolute" === kr(H).position ? "absolute" : "relative"),
									Ri.set([p, f], { force3D: !0 }),
									(L = Ri.quickSetter(p, U.a, Or)),
									(P = Ri.quickSetter(f, U.a, Or)))),
							(ft.revert = function (t) {
								var e = !1 !== t || !ft.enabled,
									i = ji;
								e !== s &&
									(e &&
										((F = Math.max(ft.scroll(), ft.scroll.rec || 0)),
										(B = ft.progress),
										(z = n && n.progress())),
									u &&
										[u, d, p, f].forEach(function (t) {
											return (t.style.display = e ? "none" : "block");
										}),
									e && (ji = 1),
									ft.update(e),
									(ji = i),
									J &&
										(e
											? (function (t, e, n) {
													if ((vo(n), t.parentNode === e)) {
														var i = e.parentNode;
														i && (i.insertBefore(t, e), i.removeChild(e));
													}
											  })(J, b, v)
											: (!rt || !ft.isActive) && mo(J, b, kr(J), A)),
									(s = e));
							}),
							(ft.refresh = function (i) {
								if (!ji && ft.enabled)
									if (J && i && pr) Hr(t, "scrollEnd", io);
									else {
										(ji = 1),
											D && D.kill(),
											Q && n && n.progress(0).invalidate(),
											s || ft.revert();
										for (
											var r,
												o,
												m,
												w,
												M,
												E,
												L,
												P,
												R = gt(),
												C = vt(),
												O = _r(st, U),
												I = 0,
												k = 0,
												N = e.end,
												H = e.endTrigger || Z,
												G =
													e.start ||
													(0 === e.start ? 0 : J || !Z ? "0 0" : "0 100%"),
												V = (Z && Math.max(0, Xr.indexOf(ft))) || 0,
												j = V;
											j--;

										)
											(L = Xr[j].pin) && (L === Z || L === J) && Xr[j].revert();
										for (
											l =
												bo(G, Z, R, U, ft.scroll(), u, p, ft, C, pt, lt, O) ||
												(J ? -0.001 : 0),
												Tr(N) && (N = N(ft)),
												Sr(N) &&
													!N.indexOf("+=") &&
													(~N.indexOf(" ")
														? (N = (Sr(G) ? G.split(" ")[0] : "") + N)
														: ((I = Wr(N.substr(2), R)),
														  (N = Sr(G) ? G : l + I),
														  (H = Z))),
												h =
													Math.max(
														l,
														bo(
															N || (H ? "100% 0" : O),
															H,
															R,
															U,
															ft.scroll() + I,
															d,
															f,
															ft,
															C,
															pt,
															lt,
															O
														)
													) || -0.001,
												g = h - l || ((l -= 0.01) && 0.001),
												I = 0,
												j = V;
											j--;

										)
											(L = (E = Xr[j]).pin) &&
												E.start - E._pinPush < l &&
												((r = E.end - E.start),
												L === Z && (I += r),
												L === J && (k += r));
										if (
											((l += I),
											(h += I),
											(ft._pinPush = k),
											u && I && (((r = {})[U.a] = "+=" + I), Ri.set([u, d], r)),
											J)
										)
											(r = kr(J)),
												(w = U === Ir),
												(m = ft.scroll()),
												(S = parseFloat(_(U.a)) + k),
												!O &&
													h > 1 &&
													((ct ? ki : st).style["overflow-" + U.a] = "scroll"),
												mo(J, b, r),
												(x = yo(J)),
												(o = Br(J, !0)),
												(P = lt && br(st, w ? Dr : Ir)()),
												K &&
													(((A = [K + U.os2, g + k + Or]).t = b),
													(j = K === Cr ? Fr(J, U) + g + k : 0) &&
														A.push(U.d, j + Or),
													vo(A),
													lt && ft.scroll(F)),
												lt &&
													(((M = {
														top: o.top + (w ? m - l : P) + Or,
														left: o.left + (w ? P : m - l) + Or,
														boxSizing: "border-box",
														position: "fixed",
													}).width = M.maxWidth =
														Math.ceil(o.width) + Or),
													(M.height = M.maxHeight = Math.ceil(o.height) + Or),
													(M.margin =
														M.marginTop =
														M.marginRight =
														M.marginBottom =
														M.marginLeft =
															"0"),
													(M.padding = r.padding),
													(M.paddingTop = r.paddingTop),
													(M.paddingRight = r.paddingRight),
													(M.paddingBottom = r.paddingBottom),
													(M.paddingLeft = r.paddingLeft),
													(y = (function (t, e, n) {
														for (
															var i, r = [], o = t.length, s = n ? 8 : 0;
															s < o;
															s += 2
														)
															(i = t[s]), r.push(i, i in e ? e[i] : t[s + 1]);
														return (r.t = t.t), r;
													})(v, M, rt))),
												n
													? (n.progress(1, !0),
													  (T = _(U.a) - S + g + k),
													  g !== T && y.splice(y.length - 2, 2),
													  n.progress(0, !0))
													: (T = g);
										else if (Z && ft.scroll())
											for (o = Z.parentNode; o && o !== ki; )
												o._pinOffset &&
													((l -= o._pinOffset), (h -= o._pinOffset)),
													(o = o.parentNode);
										for (j = 0; j < V; j++)
											(E = Xr[j].pin) &&
												(E === Z || E === J) &&
												Xr[j].revert(!1);
										(ft.start = l),
											(ft.end = h),
											(a = c = ft.scroll()) < F && ft.scroll(F),
											ft.revert(!1),
											(ji = 0),
											z && ot && n.progress(z, !0),
											B !== ft.progress &&
												(D && n.totalProgress(B, !0),
												(ft.progress = B),
												ft.update()),
											J && K && (b._pinOffset = Math.round(ft.progress * T)),
											Y && Y(ft);
									}
							}),
							(ft.getVelocity = function () {
								return ((ft.scroll() - c) / (ur() - Gi)) * 1e3 || 0;
							}),
							(ft.update = function (t, e) {
								var r,
									o,
									s,
									u,
									d,
									f = ft.scroll(),
									m = t ? 0 : (f - l) / g,
									v = m < 0 ? 0 : m > 1 ? 1 : m || 0,
									w = ft.progress;
								if (
									(e &&
										((c = a),
										(a = f),
										it && ((O = C), (C = n && !ot ? n.totalProgress() : v))),
									$ &&
										!v &&
										J &&
										!ji &&
										!cr &&
										pr &&
										l < f + ((f - c) / (ur() - Gi)) * $ &&
										(v = 1e-4),
									v !== w && ft.enabled)
								) {
									if (
										((u =
											(d =
												(r = ft.isActive = !!v && v < 1) !== (!!w && w < 1)) ||
											!!v != !!w),
										(ft.direction = v > w ? 1 : -1),
										(ft.progress = v),
										ot ||
											(!D || ji || cr
												? n && n.totalProgress(v, !!ji)
												: ((D.vars.totalProgress = v),
												  D.invalidate().restart())),
										J)
									)
										if ((t && K && (b.style[K + U.os2] = E), lt)) {
											if (u) {
												if (
													((s = !t && v > w && h + 1 > f && f + 1 >= _r(st, U)),
													rt)
												)
													if (t || (!r && !s)) _o(J, b);
													else {
														var _ = Br(J, !0),
															A = f - l;
														_o(
															J,
															ki,
															_.top + (U === Ir ? A : 0) + Or,
															_.left + (U === Ir ? 0 : A) + Or
														);
													}
												vo(r || s ? y : x),
													(T !== g && v < 1 && r) ||
														M(S + (1 !== v || s ? 0 : T));
											}
										} else M(S + T * v);
									it && !i.tween && !ji && !cr && N.restart(!0),
										j &&
											(d || (nt && v && (v < 1 || !Qi))) &&
											Hi(j.targets).forEach(function (t) {
												return t.classList[r || nt ? "add" : "remove"](
													j.className
												);
											}),
										V && !ot && !t && V(ft),
										u && !ji
											? ((o = v && !w ? 0 : 1 === v ? 1 : 1 === w ? 2 : 3),
											  ot &&
													((s =
														(!d && "none" !== ut[o + 1] && ut[o + 1]) || ut[o]),
													n &&
														("complete" === s || "reset" === s || s in n) &&
														("complete" === s
															? n.pause().totalProgress(1)
															: "reset" === s
															? n.restart(!0).pause()
															: n[s]()),
													V && V(ft)),
											  (!d && Qi) ||
													(q && d && q(ft),
													ht[o] && ht[o](ft),
													nt && (1 === v ? ft.kill(!1, 1) : (ht[o] = 0)),
													d || (ht[(o = 1 === v ? 1 : 3)] && ht[o](ft))))
											: ot && V && !ji && V(ft);
								}
								P && (L(f + (p._isFlipped ? 1 : 0)), P(f));
							}),
							(ft.enable = function () {
								ft.enabled ||
									((ft.enabled = !0),
									Hr(st, "resize", Qr),
									Hr(st, "scroll", Kr),
									mt && Hr(t, "refreshInit", mt),
									n && n.add
										? Ri.delayedCall(0.01, function () {
												return l || h || ft.refresh();
										  }) &&
										  (g = 0.01) &&
										  (l = h = 0)
										: ft.refresh());
							}),
							(ft.disable = function (e, n) {
								if (
									ft.enabled &&
									(!1 !== e && ft.revert(),
									(ft.enabled = ft.isActive = !1),
									n || (D && D.pause()),
									(F = 0),
									r && (r.uncache = 1),
									mt && Ur(t, "refreshInit", mt),
									N && (N.pause(), i.tween && i.tween.kill() && (i.tween = 0)),
									!ct)
								) {
									for (var o = Xr.length; o--; )
										if (Xr[o].scroller === st && Xr[o] !== ft) return;
									Ur(st, "resize", Qr), Ur(st, "scroll", Kr);
								}
							}),
							(ft.kill = function (t, e) {
								ft.disable(t, e), W && delete Zr[W];
								var i = Xr.indexOf(ft);
								Xr.splice(i, 1),
									i === Yi && ho > 0 && Yi--,
									n &&
										((n.scrollTrigger = null),
										t && n.render(-1),
										e || n.kill()),
									u &&
										[u, d, p, f].forEach(function (t) {
											return t.parentNode.removeChild(t);
										}),
									r && (r.uncache = 1);
							}),
							ft.enable();
					} else this.update = this.refresh = this.kill = mr;
				}),
				(t.register = function (e) {
					if (
						!Ci &&
						((Ri = e || vr()),
						gr() &&
							window.document &&
							((Oi = window),
							(Di = document),
							(Ii = Di.documentElement),
							(ki = Di.body)),
						Ri &&
							((Hi = Ri.utils.toArray),
							(Ui = Ri.utils.clamp),
							Ri.core.globals("ScrollTrigger", t),
							ki))
					) {
						(Fi =
							Oi.requestAnimationFrame ||
							function (t) {
								return setTimeout(t, 16);
							}),
							Hr(Oi, "mousewheel", Kr),
							(Ni = [Oi, Di, Ii, ki]),
							Hr(Di, "scroll", Kr);
						var n,
							i = ki.style,
							r = i.borderTop;
						(i.borderTop = "1px solid #000"),
							(n = Br(ki)),
							(Ir.m = Math.round(n.top + Ir.sc()) || 0),
							(Dr.m = Math.round(n.left + Dr.sc()) || 0),
							r ? (i.borderTop = r) : i.removeProperty("border-top"),
							(Vi = setInterval(Jr, 200)),
							Ri.delayedCall(0.5, function () {
								return (cr = 0);
							}),
							Hr(Di, "touchcancel", mr),
							Hr(ki, "touchstart", mr),
							zr(Hr, Di, "pointerdown,touchstart,mousedown", function () {
								return (Wi = 1);
							}),
							zr(Hr, Di, "pointerup,touchend,mouseup", function () {
								return (Wi = 0);
							}),
							(qi = Ri.utils.checkPrefix("transform")),
							fo.push(qi),
							(Ci = ur()),
							(Bi = Ri.delayedCall(0.2, co).pause()),
							(Ji = [
								Di,
								"visibilitychange",
								function () {
									var t = Oi.innerWidth,
										e = Oi.innerHeight;
									Di.hidden
										? ((Xi = t), (Zi = e))
										: (Xi === t && Zi === e) || Qr();
								},
								Di,
								"DOMContentLoaded",
								co,
								Oi,
								"load",
								function () {
									return pr || co();
								},
								Oi,
								"resize",
								Qr,
							]),
							Mr(Hr);
					}
					return Ci;
				}),
				(t.defaults = function (t) {
					for (var e in t) Vr[e] = t[e];
				}),
				(t.kill = function () {
					(fr = 0),
						Xr.slice(0).forEach(function (t) {
							return t.kill(1);
						});
				}),
				(t.config = function (t) {
					"limitCallbacks" in t && (Qi = !!t.limitCallbacks);
					var e = t.syncInterval;
					(e && clearInterval(Vi)) || ((Vi = e) && setInterval(Jr, e)),
						"autoRefreshEvents" in t &&
							(Mr(Ur) || Mr(Hr, t.autoRefreshEvents || "none"));
				}),
				(t.scrollerProxy = function (t, e) {
					var n = Hi(t)[0];
					yr(n) ? lr.unshift(Oi, e, ki, e, Ii, e) : lr.unshift(n, e);
				}),
				(t.matchMedia = function (t) {
					var e, n, i, r, o;
					for (n in t)
						(i = eo.indexOf(n)),
							(r = t[n]),
							($i = n),
							"all" === n
								? r()
								: (e = Oi.matchMedia(n)) &&
								  (e.matches && (o = r()),
								  ~i
										? ((eo[i + 1] = Pr(eo[i + 1], r)),
										  (eo[i + 2] = Pr(eo[i + 2], o)))
										: ((i = eo.length),
										  eo.push(n, r, o),
										  e.addListener
												? e.addListener(no)
												: e.addEventListener("change", no)),
								  (eo[i + 3] = e.matches)),
							($i = 0);
					return eo;
				}),
				(t.clearMatchMedia = function (t) {
					t || (eo.length = 0), (t = eo.indexOf(t)) >= 0 && eo.splice(t, 4);
				}),
				t
			);
		})();
		(So.version = "3.5.1"),
			(So.saveStyles = function (t) {
				return t
					? Hi(t).forEach(function (t) {
							var e = oo.indexOf(t);
							e >= 0 && oo.splice(e, 4),
								oo.push(t, t.style.cssText, Ri.core.getCache(t), $i);
					  })
					: oo;
			}),
			(So.revert = function (t, e) {
				return ao(!t, e);
			}),
			(So.create = function (t, e) {
				return new So(t, e);
			}),
			(So.refresh = function (t) {
				return t ? Qr() : co(!0);
			}),
			(So.update = uo),
			(So.maxScroll = function (t, e) {
				return _r(t, e ? Dr : Ir);
			}),
			(So.getScrollFunc = function (t, e) {
				return br(Hi(t)[0], e ? Dr : Ir);
			}),
			(So.getById = function (t) {
				return Zr[t];
			}),
			(So.getAll = function () {
				return Xr.slice(0);
			}),
			(So.isScrolling = function () {
				return !!pr;
			}),
			(So.addEventListener = function (t, e) {
				var n = $r[t] || ($r[t] = []);
				~n.indexOf(e) || n.push(e);
			}),
			(So.removeEventListener = function (t, e) {
				var n = $r[t],
					i = n && n.indexOf(e);
				i >= 0 && n.splice(i, 1);
			}),
			(So.batch = function (t, e) {
				var n,
					i = [],
					r = {},
					o = e.interval || 0.016,
					s = e.batchMax || 1e9,
					a = function (t, e) {
						var n = [],
							i = [],
							r = Ri.delayedCall(o, function () {
								e(n, i), (n = []), (i = []);
							}).pause();
						return function (t) {
							n.length || r.restart(!0),
								n.push(t.trigger),
								i.push(t),
								s <= n.length && r.progress(1);
						};
					};
				for (n in e)
					r[n] =
						"on" === n.substr(0, 2) && Tr(e[n]) && "onRefreshInit" !== n
							? a(0, e[n])
							: e[n];
				return (
					Tr(s) &&
						((s = s()),
						Hr(So, "refresh", function () {
							return (s = e.batchMax());
						})),
					Hi(t).forEach(function (t) {
						var e = {};
						for (n in r) e[n] = r[n];
						(e.trigger = t), i.push(So.create(e));
					}),
					i
				);
			}),
			(So.sort = function (t) {
				return Xr.sort(
					t ||
						function (t, e) {
							return (
								-1e6 * (t.vars.refreshPriority || 0) +
								t.start -
								(e.start + -1e6 * (e.vars.refreshPriority || 0))
							);
						}
				);
			}),
			vr() && Ri.registerPlugin(So);
		/*!
		 * DrawSVGPlugin 3.0.0
		 * https://greensock.com
		 *
		 * @license Copyright 2008-2019, GreenSock. All rights reserved.
		 * Subject to the terms at https://greensock.com/standard-license or for
		 * Club GreenSock members, the agreement issued with that membership.
		 * @author: Jack Doyle, jack@greensock.com
		 */
		var To,
			Eo,
			Ao,
			Lo,
			Po,
			Ro = function () {
				return "undefined" != typeof window;
			},
			Co = function () {
				return To || (Ro() && (To = window.gsap) && To.registerPlugin && To);
			},
			Oo = /[-+=\.]*\d+[\.e\-\+]*\d*[e\-\+]*\d*/gi,
			Do = {
				rect: ["width", "height"],
				circle: ["r", "r"],
				ellipse: ["rx", "ry"],
				line: ["x2", "y2"],
			},
			Io = function (t) {
				return Math.round(1e4 * t) / 1e4;
			},
			ko = function (t) {
				return parseFloat(t || 0);
			},
			No = function (t, e) {
				return ko(t.getAttribute(e));
			},
			Bo = Math.sqrt,
			Fo = function (t, e, n, i, r, o) {
				return Bo(
					Math.pow((ko(n) - ko(t)) * r, 2) + Math.pow((ko(i) - ko(e)) * o, 2)
				);
			},
			zo = function (t) {
				return console.warn(t);
			},
			Ho = function (t) {
				return "non-scaling-stroke" === t.getAttribute("vector-effect");
			},
			Uo = function (t) {
				if (!(t = Eo(t)[0])) return 0;
				var e,
					n,
					i,
					r,
					o,
					s,
					a,
					c = t.tagName.toLowerCase(),
					l = t.style,
					h = 1,
					u = 1;
				Ho(t) &&
					((u = t.getScreenCTM()),
					(h = Bo(u.a * u.a + u.b * u.b)),
					(u = Bo(u.d * u.d + u.c * u.c)));
				try {
					n = t.getBBox();
				} catch (t) {
					zo(
						"Some browsers won't measure invisible elements (like display:none or masks inside defs)."
					);
				}
				var d = n || { x: 0, y: 0, width: 0, height: 0 },
					p = d.x,
					f = d.y,
					m = d.width,
					g = d.height;
				if (
					((n && (m || g)) ||
						!Do[c] ||
						((m = No(t, Do[c][0])),
						(g = No(t, Do[c][1])),
						"rect" !== c && "line" !== c && ((m *= 2), (g *= 2)),
						"line" === c &&
							((p = No(t, "x1")),
							(f = No(t, "y1")),
							(m = Math.abs(m - p)),
							(g = Math.abs(g - f)))),
					"path" === c)
				)
					(r = l.strokeDasharray),
						(l.strokeDasharray = "none"),
						(e = t.getTotalLength() || 0),
						h !== u &&
							zo(
								"Warning: <path> length cannot be measured when vector-effect is non-scaling-stroke and the element isn't proportionally scaled."
							),
						(e *= (h + u) / 2),
						(l.strokeDasharray = r);
				else if ("rect" === c) e = 2 * m * h + 2 * g * u;
				else if ("line" === c) e = Fo(p, f, p + m, f + g, h, u);
				else if ("polyline" === c || "polygon" === c)
					for (
						i = t.getAttribute("points").match(Oo) || [],
							"polygon" === c && i.push(i[0], i[1]),
							e = 0,
							o = 2;
						o < i.length;
						o += 2
					)
						e += Fo(i[o - 2], i[o - 1], i[o], i[o + 1], h, u) || 0;
				else
					("circle" !== c && "ellipse" !== c) ||
						((s = (m / 2) * h),
						(a = (g / 2) * u),
						(e = Math.PI * (3 * (s + a) - Bo((3 * s + a) * (s + 3 * a)))));
				return e || 0;
			},
			Go = function (t, e) {
				if (!(t = Eo(t)[0])) return [0, 0];
				e || (e = Uo(t) + 1);
				var n = Ao.getComputedStyle(t),
					i = n.strokeDasharray || "",
					r = ko(n.strokeDashoffset),
					o = i.indexOf(",");
				return (
					o < 0 && (o = i.indexOf(" ")),
					(i = o < 0 ? e : ko(i.substr(0, o)) || 1e-5) > e && (i = e),
					[Math.max(0, -r), Math.max(0, i - r)]
				);
			},
			Vo = function () {
				Ro() &&
					(document,
					(Ao = window),
					(Po = To = Co()),
					(Eo = To.utils.toArray),
					(Lo = -1 !== ((Ao.navigator || {}).userAgent || "").indexOf("Edge")));
			},
			jo = {
				version: "3.0.0",
				name: "drawSVG",
				register: function (t) {
					(To = t), Vo();
				},
				init: function (t, e, n, i, r) {
					if (!t.getBBox) return !1;
					Po || Vo();
					var o,
						s,
						a,
						c,
						l = Uo(t) + 1;
					return (
						(this._style = t.style),
						(this._target = t),
						e + "" == "true"
							? (e = "0 100%")
							: e
							? -1 === (e + "").indexOf(" ") && (e = "0 " + e)
							: (e = "0 0"),
						(s = (function (t, e, n) {
							var i,
								r,
								o = t.indexOf(" ");
							return (
								o < 0
									? ((i = void 0 !== n ? n + "" : t), (r = t))
									: ((i = t.substr(0, o)), (r = t.substr(o + 1))),
								(i = ~i.indexOf("%") ? (ko(i) / 100) * e : ko(i)) >
								(r = ~r.indexOf("%") ? (ko(r) / 100) * e : ko(r))
									? [r, i]
									: [i, r]
							);
						})(e, l, (o = Go(t, l))[0])),
						(this._length = Io(l + 10)),
						0 === o[0] && 0 === s[0]
							? ((a = Math.max(1e-5, s[1] - l)),
							  (this._dash = Io(l + a)),
							  (this._offset = Io(l - o[1] + a)),
							  (this._offsetPT = this.add(
									this,
									"_offset",
									this._offset,
									Io(l - s[1] + a)
							  )))
							: ((this._dash = Io(o[1] - o[0]) || 1e-6),
							  (this._offset = Io(-o[0])),
							  (this._dashPT = this.add(
									this,
									"_dash",
									this._dash,
									Io(s[1] - s[0]) || 1e-5
							  )),
							  (this._offsetPT = this.add(
									this,
									"_offset",
									this._offset,
									Io(-s[0])
							  ))),
						Lo &&
							(c = Ao.getComputedStyle(t)).strokeLinecap !== c.strokeLinejoin &&
							((s = ko(c.strokeMiterlimit)),
							this.add(t.style, "strokeMiterlimit", s, s + 0.01)),
						(this._live = Ho(t) || ~(e + "").indexOf("live")),
						this._props.push("drawSVG"),
						1
					);
				},
				render: function (t, e) {
					var n,
						i,
						r,
						o,
						s = e._pt,
						a = e._style;
					if (s) {
						for (
							e._live &&
							(n = Uo(e._target) + 11) !== e._length &&
							((i = n / e._length),
							(e._length = n),
							(e._offsetPT.s *= i),
							(e._offsetPT.c *= i),
							e._dashPT
								? ((e._dashPT.s *= i), (e._dashPT.c *= i))
								: (e._dash *= i));
							s;

						)
							s.r(t, s.d), (s = s._next);
						(r = e._dash),
							(o = e._offset),
							(n = e._length),
							(a.strokeDashoffset = e._offset),
							1 !== t && t
								? (a.strokeDasharray = r + "px," + n + "px")
								: (r - o < 0.001 && n - r <= 10 && (a.strokeDashoffset = o + 1),
								  (a.strokeDasharray =
										o < 0.001 && n - r <= 10
											? "none"
											: o === r
											? "0px, 999999px"
											: r + "px," + n + "px"));
					}
				},
				getLength: Uo,
				getPosition: Go,
			};
		Co() && To.registerPlugin(jo), er.registerPlugin(jo);
		var Wo,
			qo = function (t, e) {
				new er.timeline({ delay: e })
					.to(t, 2.4, { drawSVG: "0% 0%", ease: "expo.inOut" })
					.to(t, 2.4, { drawSVG: "0% 100%", ease: "expo.inOut" }, ">.4");
			};
		er.registerPlugin(So);
		var Yo = (function () {
				function t() {
					var e =
						arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {};
					p()(this, t),
						(this.isMobile = _.isMobile),
						this.bindMethods(),
						(this.el = document.documentElement),
						(this.thisPagesTLs = []),
						(this.offsetVal = 0),
						(this.body = document.body),
						(this.direction = "untouched"),
						(this.transitioning = !1),
						(this.scrollDists = []),
						(this.overflowOffset = 0.01),
						(this.velocity = 0),
						(this.headerScrolled = !1);
					var n = e.dataFromElems,
						i = void 0 === n ? this.el.querySelectorAll("[data-from]") : n,
						r = e.dataHeroFromElems,
						o = void 0 === r ? document.querySelectorAll("[data-h-from]") : r,
						s = e.heroMeasureEl,
						a = void 0 === s ? this.el.querySelector(".hero .measure-el") : s,
						c = e.scrollBasedElems,
						l =
							void 0 === c
								? !_.isGreaterThan767 ||
								  this.el.querySelectorAll("[data-entrance]:not(.is-hidden)")
								: c,
						h = e.overflowImageWrappers,
						u =
							void 0 === h
								? this.el.querySelectorAll(".overflows .ar-wrapper")
								: h,
						d = e.overflowImages,
						f = void 0 === d ? this.el.querySelectorAll(".overflows .bg") : d,
						m = e.threshold,
						g = void 0 === m ? 200 : m;
					(this.dom = {
						el: this.el,
						dataFromElems: i,
						dataHeroFromElems: o,
						scrollBasedElems: l,
						heroMeasureEl: a,
						overflowImages: f,
						overflowImageWrappers: u,
						aboutPortraitsWrapper: this.el.querySelector(".staff-svgs"),
					}),
						(this.dataFromElems = null),
						(this.dataHeroFromElems = null),
						(this.scrollBasedElems = null),
						(this.raf = null),
						(this.state = { resizing: !1 }),
						(this.data = {
							threshold: g,
							current: 0,
							last: 0,
							height: 0,
							max: 0,
							currentScrollY: 0,
						}),
						(this.window2x = 2 * _.windowHeight);
					for (var v = 0; v < this.dom.overflowImages.length; v++) {
						var y =
							this.dom.overflowImages[v].offsetHeight -
							this.dom.overflowImageWrappers[v].offsetHeight;
						this.scrollDists.push(y);
					}
					this.init();
				}
				return (
					m()(t, [
						{
							key: "bindMethods",
							value: function () {
								var t = this;
								["run", "resize"].forEach(function (e) {
									return (t[e] = t[e].bind(t));
								});
							},
						},
						{
							key: "init",
							value: function () {
								this.on();
							},
						},
						{
							key: "on",
							value: function () {
								this.getBounding(),
									this.getCache(),
									this.requestAnimationFrame();
							},
						},
						{
							key: "run",
							value: function () {
								this.state.resizing ||
									this.transitioning ||
									(_.drawerOpen ||
										((this.data.currentScrollY = this.data.current),
										(this.data.last = this.data.current),
										this.scrollTrigger.update(),
										this.hideShowHeader(),
										this.checkScrollBasedLoadins(),
										this.animateDataHeroFromElems(),
										this.animateDataFromElems(),
										this.animateOverflowImages(),
										this.checkScrolledMedia(),
										this.hidePencilBar(),
										this.checkBball(),
										this.playPauseVideos(),
										this.playPauseAboutPortraits()),
									this.requestAnimationFrame());
							},
						},
						{
							key: "hideShowHeader",
							value: function () {
								"untouched" !== this.direction &&
									Cx.headerIn &&
									("down" === this.direction &&
									!this.headerScrolled &&
									this.data.current >= this.adjustHeaderDist
										? ((this.headerScrolled = !0), Cx.hideHeader())
										: "up" === this.direction &&
										  this.headerScrolled &&
										  ((this.headerScrolled = !1), Cx.showHeader()));
							},
						},
						{
							key: "hidePencilBar",
							value: function () {
								Ox && this.data.current > Ox.fadeOutPoint && Ox.hide();
							},
						},
						{
							key: "cancelMouseEnters",
							value: function () {
								switch (_.mouseEnterContext) {
									case "aboutBrandHover":
										_.mouseEnterData.onMouseLeave(), (_.mouseEnterContext = !1);
								}
							},
						},
						{
							key: "playPauseVideos",
							value: function () {
								if ("untouched" !== this.direction) {
									for (var t = 0; t < this.videosDataLength; t++) {
										var e = this.videosData[t],
											n = this.isVisible(e, 50).isVisible;
										n
											? e.playing || (e.el.play(), (e.playing = !0))
											: !n &&
											  e.playing &&
											  (e.el.pause(),
											  (e.el.currentTime = 0),
											  (e.playing = !1));
									}
									for (var i = 0; i < this.clickToPlayVideosLength; i++) {
										var r = this.clickToPlayVideos[i];
										if (r.playing)
											this.isVisible(r, 50).isVisible ||
												(r.el.pause(),
												this.clickToPlayVideos[i].iconTL.clear(),
												_.isMobile
													? er.set(this.clickToPlayVideos[i].playIcon, {
															scale: 1,
													  })
													: (er.set(this.clickToPlayVideos[i].pauseIcon, {
															scaleY: 0,
													  }),
													  er.set(this.clickToPlayVideos[i].playIcon, {
															scale: 1,
													  })),
												(r.playing = !1));
									}
								}
							},
						},
						{
							key: "getPotentialSections",
							value: function () {
								if (
									((this.potentialSections = []),
									(M.potentialFadeEls =
										M.viewEl.querySelectorAll("[data-out=fade]")),
									M.potentialFadeEls && M.potentialFadeEls.length > 0)
								)
									for (var t = 0; t < M.potentialFadeEls.length; t++) {
										var e = M.potentialFadeEls[t],
											n = e.getBoundingClientRect();
										this.potentialSections.push({
											el: e,
											top: n.top + this.data.currentScrollY,
											bottom: n.bottom + this.data.currentScrollY,
											anim: "fade",
										});
									}
								if ("not-found" !== _.namespace) {
									var i = M.footer.getBoundingClientRect();
									this.potentialSections.push({
										el: M.bttEls,
										top: i.top + this.data.currentScrollY,
										bottom: i.bottom + this.data.currentScrollY,
										anim: "footer",
									});
								}
							},
						},
						{
							key: "returnVisibleParts",
							value: function () {
								if (this.potentialSections) {
									for (
										var t = [], e = 0;
										e < this.potentialSections.length;
										e++
									) {
										var n = this.potentialSections[e];
										this.isVisible(n, 0.01).isVisible && t.push(n);
									}
									return t;
								}
							},
						},
						{
							key: "getVideos",
							value: function () {
								var t = this,
									e = document.querySelectorAll("video.auto");
								this.videosData = [];
								for (var n = 0; n < e.length; n++) {
									var i = e[n].getBoundingClientRect();
									this.videosData.push({
										el: e[n],
										playing: !1,
										top: i.top + this.data.currentScrollY,
										bottom: i.bottom + this.data.currentScrollY,
									});
								}
								this.videosDataLength = this.videosData.length;
								var r = this.dom.el.querySelectorAll("video.manual");
								this.clickToPlayVideos = [];
								for (
									var o = function (e) {
											var n = r[e].getBoundingClientRect();
											t.clickToPlayVideos.push({
												el: r[e],
												iconTL: new er.timeline(),
												playing: !1,
												top: n.top + t.data.currentScrollY,
												bottom: n.bottom + t.data.currentScrollY,
												height: n.bottom - n.top,
												posterFaded: !1,
												iconVisible: !0,
												playIcon:
													r[e].previousElementSibling.querySelector(".play"),
												pauseIcon:
													r[e].previousElementSibling.querySelector(".pause"),
											});
											var i = !1;
											r[e].addEventListener("click", function () {
												var n = t.clickToPlayVideos[e];
												if (!n.posterFaded) {
													n.posterFaded = !0;
													var r = n.el.parentElement.querySelector(".poster");
													r &&
														er.to(r, 0.3, {
															opacity: 0,
															ease: "sine.out",
															clearProps: "transform",
															force3D: !0,
														});
												}
												n.playing &&
													((n.playing = !1),
													(i = !0),
													t.clickToPlayVideos[e].iconTL.clear(),
													_.isMobile
														? t.clickToPlayVideos[e].iconTL.to(
																t.clickToPlayVideos[e].playIcon,
																0.7,
																{ scale: 1, ease: "expo.out", force3D: !0 }
														  )
														: t.clickToPlayVideos[e].iconTL
																.to(t.clickToPlayVideos[e].pauseIcon, 0.3, {
																	opacity: 0,
																	ease: "sine.out",
																	force3D: !0,
																})
																.to(
																	t.clickToPlayVideos[e].playIcon,
																	0.7,
																	{ scale: 1, ease: "expo.out", force3D: !0 },
																	"-=.1"
																),
													n.el.pause()),
													n.playing || !i
														? ((n.playing = !0),
														  t.clickToPlayVideos[e].iconTL.clear(),
														  t.clickToPlayVideos[e].iconTL.to(
																t.clickToPlayVideos[e].playIcon,
																0.7,
																{ scale: 0, ease: "expo.out", force3D: !0 }
														  ),
														  n.el.play())
														: (i = !1);
											});
										},
										s = 0;
									s < r.length;
									s++
								)
									o(s);
								this.clickToPlayVideosLength = this.clickToPlayVideos.length;
							},
						},
						{
							key: "getScrollBasedSections",
							value: function () {
								if (
									((this.thisPagesTLs = []),
									(this.offsetVal = 0),
									(this.dom.scrollBasedElems =
										!_.isGreaterThan767 ||
										this.el.querySelectorAll(
											"[data-entrance]:not(.is-hidden)"
										)),
									this.dom.scrollBasedElems)
								) {
									if (_.isGreaterThan767)
										for (
											var t = this.dom.scrollBasedElems.length, e = 0;
											e < t;
											e++
										) {
											var n = this.dom.scrollBasedElems[e],
												i = n.dataset.entrance,
												r = new er.timeline({ paused: !0 });
											switch (i) {
												case "stagger-fade":
													var o = n.querySelectorAll(".s-el");
													r.fromTo(
														o,
														0.98,
														{ y: 20, opacity: 0 },
														{
															y: 0,
															opacity: 1,
															clearProps: "transform",
															ease: "sine.inOut",
															stagger: 0.12,
															force3D: !0,
														}
													),
														this.thisPagesTLs.push(r);
													break;
												case "cover-copy":
													var s = n.querySelector(".miq"),
														a = n.querySelector(".copy");
													r
														.fromTo(
															s,
															1.25,
															{ scale: 1.07, opacity: 0 },
															{
																scale: 1,
																opacity: 1,
																clearProps: "transform",
																ease: "power3.out",
																force3D: !0,
															}
														)
														.fromTo(
															a,
															1.1,
															{ scale: 0.965, opacity: 0 },
															{
																scale: 1,
																opacity: 1,
																clearProps: "transform",
																ease: "power3.out",
																force3D: !0,
															},
															0.5
														),
														this.thisPagesTLs.push(r);
													break;
												case "basic-fade":
													r.fromTo(
														n,
														0.98,
														{ y: 20, opacity: 0 },
														{
															y: 0,
															opacity: 1,
															clearProps: "transform",
															ease: "sine.inOut",
															force3D: !0,
														}
													),
														this.thisPagesTLs.push(r);
													break;
												case "basic-fade-up":
													r.fromTo(
														n,
														1,
														{ scale: 0.965, opacity: 0 },
														{
															scale: 1,
															opacity: 1,
															clearProps: "transform",
															ease: "sine.inOut",
															force3D: !0,
														}
													),
														this.thisPagesTLs.push(r);
													break;
												case "wipe-bg":
													var c = n.querySelector(".wipe-bg"),
														l = n.querySelectorAll("a");
													er.set(l, { opacity: 0 }),
														r
															.to(c, 0.7, {
																scaleY: 1,
																ease: "expo.out",
																force3D: !0,
																transformOrigin: "50% 0%",
															})
															.set(l, { opacity: 1 })
															.to(c, 0.82, {
																scaleY: 0,
																ease: "expo.out",
																clearProps: "transform",
																force3D: !0,
																transformOrigin: "50% 100%",
															}),
														this.thisPagesTLs.push(r);
													break;
												case "footer":
													er.set(M.bttEls, { clearProps: "transform" }),
														r.fromTo(
															M.bttEls,
															1.1,
															{ yPercent: 100 },
															{
																yPercent: 0,
																ease: "expo.out",
																force3D: !0,
																stagger: 0.1,
															}
														),
														this.thisPagesTLs.push(r);
											}
										}
									else {
										var h = new er.timeline({ paused: !0 });
										er.set(M.bttEls, { clearProps: "transform" }),
											h.fromTo(
												M.bttEls,
												1.1,
												{ yPercent: 100 },
												{
													yPercent: 0,
													ease: "expo.out",
													force3D: !0,
													stagger: 0.1,
												}
											),
											this.thisPagesTLs.push(h);
									}
									(this.dom.scrollBasedElems = this.el.querySelectorAll(
										"[data-entrance]:not(.is-hidden)"
									)),
										(this.scrollBasedElems = []);
									var u = this.dom.scrollBasedElems.length;
									if (_.isGreaterThan767) {
										for (var d = 0; d < u; d++)
											if (!(d < this.offsetVal)) {
												var p = this.dom.scrollBasedElems[d],
													f = p.getBoundingClientRect();
												this.scrollBasedElems.push({
													el: p,
													played: !1,
													top: f.top + this.data.currentScrollY,
													bottom: f.bottom + this.data.currentScrollY,
													height: f.bottom - f.top,
													offset:
														_.windowWidth < 768
															? p.dataset.offsetMobile * _.windowHeight
															: p.dataset.offset * _.windowHeight,
												});
											}
									} else {
										var m = document.querySelector(".back-to-top"),
											g = m.getBoundingClientRect();
										this.scrollBasedElems.push({
											el: m,
											played: !1,
											top: g.top + this.data.currentScrollY,
											bottom: g.bottom + this.data.currentScrollY,
											height: g.bottom - g.top,
											offset:
												_.windowWidth < 768
													? m.dataset.offsetMobile * _.windowHeight
													: m.dataset.offset * _.windowHeight,
										});
									}
								}
							},
						},
						{
							key: "getDataFromElems",
							value: function () {
								if (this.dom.dataFromElems) {
									this.dataFromElems = [];
									for (
										var t = _.windowWidth < 768,
											e = this.dom.dataFromElems.length,
											n = 0;
										n < e;
										n++
									) {
										var i = this.dom.dataFromElems[n],
											r = void 0,
											o = void 0,
											s = void 0,
											a = i.getBoundingClientRect(),
											c = new er.timeline({ paused: !0 });
										t
											? ((r = i.dataset.mobileFrom
													? JSON.parse(i.dataset.mobileFrom)
													: JSON.parse(i.dataset.from)),
											  (o = i.dataset.mobileTo
													? JSON.parse(i.dataset.mobileTo)
													: JSON.parse(i.dataset.to)),
											  (s = i.dataset.mobileDur
													? i.dataset.mobileDur
													: i.dataset.dur
													? i.dataset.dur
													: 1))
											: ((r = JSON.parse(i.dataset.from)),
											  (o = JSON.parse(i.dataset.to)),
											  (s = i.dataset.dur ? i.dataset.dur : 1)),
											c.fromTo(i, 1, r, o),
											this.dataFromElems.push({
												el: i,
												tl: c,
												top: a.top + this.data.currentScrollY,
												bottom: a.bottom + this.data.currentScrollY,
												height: a.bottom - a.top,
												from: r,
												duration: s,
												progress: { current: 0 },
											});
									}
								}
							},
						},
						{
							key: "getHeroMeasureEl",
							value: function () {
								if (this.dom.heroMeasureEl) {
									var t = this.dom.heroMeasureEl.getBoundingClientRect();
									this.heroMeasureData = {
										top: t.top + this.data.currentScrollY,
										bottom: t.bottom + this.data.currentScrollY,
										height: t.bottom - t.top,
										progress: { current: 0 },
									};
								}
							},
						},
						{
							key: "getDataHeroFromElems",
							value: function () {
								if (this.dom.dataHeroFromElems) {
									this.dataHeroFromElems = [];
									for (
										var t = _.windowWidth < 768, e = 0;
										e < this.dom.dataHeroFromElems.length;
										e++
									) {
										var n = this.dom.dataHeroFromElems[e],
											i = void 0,
											r = void 0,
											o = new er.timeline({ paused: !0 });
										t
											? ((i = n.dataset.hMobileFrom
													? JSON.parse(n.dataset.hMobileFrom)
													: JSON.parse(n.dataset.hFrom)),
											  (r = n.dataset.mobileTo
													? JSON.parse(n.dataset.mobileTo)
													: JSON.parse(n.dataset.to)))
											: ((i = JSON.parse(n.dataset.hFrom)),
											  (r = JSON.parse(n.dataset.to))),
											o.fromTo(n, 1, i, r),
											this.dataHeroFromElems.push({
												el: n,
												tl: o,
												progress: { current: 0 },
											});
									}
								}
							},
						},
						{
							key: "getAboutPortraits",
							value: function () {
								if (this.dom.aboutPortraitsWrapper) {
									var t =
										this.dom.aboutPortraitsWrapper.getBoundingClientRect();
									this.aboutPortraitsData = {
										top: t.top + this.data.currentScrollY,
										bottom: t.bottom + this.data.currentScrollY,
										height: t.bottom - t.top,
										isPlaying: !1,
									};
								}
							},
						},
						{
							key: "getBBallTrigger",
							value: function () {
								if ("about-us" === _.namespace) {
									var t = document
										.querySelector(".quick-contact")
										.getBoundingClientRect();
									this.bballTrigger = {
										top: t.top + this.data.currentScrollY,
										bottom: t.bottom + this.data.currentScrollY,
										height: t.bottom - t.top,
										isTriggered: !1,
									};
								}
							},
						},
						{
							key: "checkBball",
							value: function () {
								if (this.bballTrigger && !this.bballTrigger.isTriggered) {
									var t = this.bballTrigger;
									this.isVisible(t).isVisible &&
										(this.bballTrigger.isTriggered = !0);
								}
							},
						},
						{
							key: "playPauseAboutPortraits",
							value: function () {
								if (this.aboutPortraitsData) {
									var t = this.aboutPortraitsData,
										e = this.isVisible(t).isVisible;
									e && !this.aboutPortraitsData.isPlaying
										? (Wo.play(), (this.aboutPortraitsData.isPlaying = !0))
										: !e &&
										  this.aboutPortraitsData.isPlaying &&
										  (Wo.pause(), (this.aboutPortraitsData.isPlaying = !1));
								}
							},
						},
						{
							key: "animateDataHeroFromElems",
							value: function () {
								if (
									"untouched" !== this.direction &&
									this.heroMeasureData &&
									this.isVisible(this.heroMeasureData).isVisible
								) {
									var t = (
										this.data.current / this.heroMeasureData.height
									).toFixed(3);
									t <= 0 ? (t = 0) : t >= 1 && (t = 1);
									for (
										var e = this.dataHeroFromElems.length, n = 0;
										n < e;
										n++
									) {
										this.dataHeroFromElems[n].tl.progress(t);
									}
								}
							},
						},
						{
							key: "animateDataFromElems",
							value: function () {
								if ("untouched" !== this.direction && this.dataFromElems)
									for (var t = this.dataFromElems.length, e = 0; e < t; e++) {
										var n = this.dataFromElems[e],
											i = this.isVisible(n, 0.01),
											r = i.isVisible,
											o = i.start,
											s = i.end;
										r &&
											(this.intersectRatio(n, o, s),
											n.tl.progress(n.progress.current));
									}
							},
						},
						{
							key: "getOverflowImgData",
							value: function () {
								if (this.dom.overflowImages) {
									this.overflowImgData = [];
									for (
										var t = 0;
										t < this.dom.overflowImageWrappers.length;
										t++
									) {
										var e = this.dom.overflowImageWrappers[t],
											n = new er.timeline({ paused: !0 }),
											i = e.getBoundingClientRect(),
											r = this.dom.overflowImages[t];
										n.fromTo(
											r,
											1,
											{ y: 0 },
											{
												delay: 0.05,
												y: -(r.offsetHeight - (i.bottom - i.top)),
												ease: "none",
												force3D: !0,
											}
										),
											this.overflowImgData.push({
												innerImg: r,
												top: i.top + this.data.currentScrollY,
												bottom: i.bottom + this.data.currentScrollY,
												height: i.bottom - i.top,
												tl: n,
												duration: 0.8,
												progress: { current: 0 },
											});
									}
								}
							},
						},
						{
							key: "animateOverflowImages",
							value: function () {
								if (this.overflowImgData && "untouched" !== this.direction)
									for (var t = 0; t < this.overflowImgData.length; t++) {
										var e = this.overflowImgData[t],
											n = this.isVisible(e, 0.01),
											i = n.isVisible,
											r = n.start,
											o = n.end;
										i &&
											(this.intersectRatio(e, r, o),
											e.tl.progress(e.progress.current));
									}
							},
						},
						{
							key: "checkScrollBasedLoadins",
							value: function () {
								var t =
									arguments.length > 0 &&
									void 0 !== arguments[0] &&
									arguments[0];
								if (
									("untouched" !== this.direction || t) &&
									this.scrollBasedElems
								)
									if (this.thisPagesTLs.length !== this.offsetVal)
										for (
											var e = this.scrollBasedElems.length, n = 0;
											n < e;
											n++
										) {
											var i = this.scrollBasedElems[n];
											i.played ||
												(this.data.current + i.offset > i.top &&
													(this.thisPagesTLs[this.offsetVal].play(),
													this.offsetVal++,
													(i.played = !0)));
										}
									else {
										var r =
											this.scrollBasedElems[this.scrollBasedElems.length - 1];
										this.data.current + r.offset > r.top
											? r.played ||
											  (this.thisPagesTLs[this.offsetVal - 1].play(),
											  (r.played = !0))
											: r.played &&
											  (this.thisPagesTLs[this.offsetVal - 1]
													.progress(0)
													.pause(),
											  (r.played = !1));
									}
							},
						},
						{
							key: "getScrolledMedia",
							value: function () {
								if (
									((this.dom.scrolledMedia = this.el.querySelectorAll(
										".media-within:not(.is-hidden)"
									)),
									this.dom.scrolledMedia)
								) {
									this.scrolledMediaData = [];
									for (var t = 0; t < this.dom.scrolledMedia.length; t++) {
										var e = this.dom.scrolledMedia[t],
											n = e.getBoundingClientRect();
										this.scrolledMediaCount++,
											this.scrolledMediaData.push({
												el: e,
												mediaEls: e.querySelectorAll(".preload"),
												loaded: !1,
												top: n.top + this.data.currentScrollY,
												bottom: n.bottom + this.data.currentScrollY,
												height: n.bottom - n.top,
											});
									}
								}
							},
						},
						{
							key: "checkScrolledMedia",
							value: function () {
								var t =
									arguments.length > 0 &&
									void 0 !== arguments[0] &&
									arguments[0];
								if (
									("untouched" !== this.direction || t) &&
									this.scrolledMediaData &&
									this.scrolledMediaFired !== this.scrolledMediaCount
								)
									for (var e = 0; e < this.scrolledMediaData.length; e++) {
										var n = this.scrolledMediaData[e];
										n.loaded ||
											(this.data.current +
												(t ? _.windowHeight : this.window2x) >
												n.top &&
												(Ix.loadImages(n.mediaEls, "nodeList", function () {}),
												this.scrolledMediaFired++,
												(n.loaded = !0)));
									}
							},
						},
						{
							key: "intersectRatio",
							value: function (t, e, n) {
								var i = e - this.data.height;
								if (!(i > 0)) {
									var r = (this.data.height + n + t.height) * t.duration;
									(t.progress.current = Math.abs(i / r)),
										(t.progress.current = Math.max(
											0,
											Math.min(1, t.progress.current)
										));
								}
							},
						},
						{
							key: "isVisible",
							value: function (t, e) {
								var n = e || this.data.threshold,
									i = t.top - this.data.current,
									r = t.bottom - this.data.current,
									o = i < n + this.data.height && r > -n;
								return { isVisible: o, start: i, end: r };
							},
						},
						{
							key: "requestAnimationFrame",
							value: (function (t) {
								function e() {
									return t.apply(this, arguments);
								}
								return (
									(e.toString = function () {
										return t.toString();
									}),
									e
								);
							})(function () {
								this.raf = requestAnimationFrame(this.run);
							}),
						},
						{
							key: "cancelAnimationFrame",
							value: (function (t) {
								function e() {
									return t.apply(this, arguments);
								}
								return (
									(e.toString = function () {
										return t.toString();
									}),
									e
								);
							})(function () {
								cancelAnimationFrame(this.raf);
							}),
						},
						{
							key: "getCache",
							value: function () {
								var t = this;
								(this.splitCount = 0),
									(this.splitsFired = 0),
									(this.scrolledMediaCount = 0),
									(this.scrolledMediaFired = 0),
									(this.adjustHeaderDist = (_.windowWidth, 150)),
									this.getVideos(),
									this.getScrolledMedia(),
									this.getScrollBasedSections(),
									this.getDataHeroFromElems(),
									this.getDataFromElems(),
									this.getOverflowImgData(),
									this.getHeroMeasureEl(),
									this.getPotentialSections(),
									this.getAboutPortraits(),
									this.getBBallTrigger(),
									(this.scrollTrigger = So.create({
										trigger: this.el,
										start: "top top",
										end: "bottom bottom",
										scrub: 0.6,
										animation: er.to(this.data, 1, {
											current: this.data.max,
											ease: "none",
										}),
										onUpdate: function (e) {
											(t.direction = -1 === e.direction ? "up" : "down"),
												_.mouseEnterContext && t.cancelMouseEnters();
										},
									})),
									er.delayedCall(1, function () {
										t.checkScrollBasedLoadins(!0);
									});
							},
						},
						{
							key: "getBounding",
							value: function () {
								(this.data.height = _.windowHeight),
									(this.data.max =
										this.el.getBoundingClientRect().height - this.data.height);
							},
						},
						{
							key: "resize",
							value: function () {
								var t =
									arguments.length > 0 &&
									void 0 !== arguments[0] &&
									arguments[0];
								(this.state.resizing = !0),
									t || (this.getCache(), this.getBounding()),
									(this.data.currentScrollY =
										document.documentElement.scrollTop),
									(this.state.resizing = !1);
							},
						},
						{
							key: "scrollTo",
							value: function (t) {
								var e = this,
									n =
										arguments.length > 1 && void 0 !== arguments[1]
											? arguments[1]
											: 0.8,
									i =
										arguments.length > 2 && void 0 !== arguments[2]
											? arguments[2]
											: "sine.inOut";
								(this.state.scrollingTo = !0),
									er.to(document.documentElement, n, {
										scrollTop: t,
										ease: i,
										onComplete: function () {
											e.state.scrollingTo = !1;
										},
									});
							},
						},
						{
							key: "destroy",
							value: function () {
								(this.transitioning = !0),
									(this.state.rafCancelled = !0),
									this.cancelAnimationFrame(),
									(this.resize = null),
									(this.dom = null),
									(this.data = null),
									(this.raf = null);
							},
						},
					]),
					t
				);
			})(),
			Xo = (function () {
				function t(e) {
					p()(this, t),
						e &&
							(x(this, ["open", "close", "toggle", "checkLinkOnClick"]),
							(this.dom = {
								el: e,
								hammy: document.querySelector(".hammy"),
								background: e.querySelector(".background"),
								contentWrapper: e.querySelector(".content-wrapper"),
								mainLinksWrapper: e.querySelector(".main-links-wrapper"),
								mainLinks: e.querySelectorAll(".main-link"),
							}),
							(M.hammy = this.dom.hammy),
							(this.state = { isOpen: !1 }),
							this._addEvents());
				}
				return (
					m()(t, [
						{
							key: "_addEvents",
							value: function () {
								var t = this,
									e = this;
								this.dom.hammy.addEventListener("click", this.toggle),
									this.dom.mainLinks.forEach(function (n, i) {
										var r = n.getAttribute("href");
										r &&
											n.addEventListener(
												"click",
												function () {
													e.checkLinkOnClick(i, r);
												},
												!1
											);
										var o = n.querySelector("span");
										o && t.setupMarquee(n, o);
									}),
									this.dom.el.addEventListener(
										"wheel",
										function (t) {
											t.stopPropagation();
										},
										{ passive: !0 }
									);
							},
						},
						{
							key: "setupMarquee",
							value: function (t, e) {
								t.style.cssText = "";
								var n =
										(100 *
											(2 *
												(e.getBoundingClientRect().width -
													e.querySelector("span").getBoundingClientRect()
														.width))) /
										_.windowWidth,
									i = 12 - (50 / n) * 2;
								t.style.cssText = "--tw: "
									.concat(n, "vw; --ad: ")
									.concat(i, "s;");
							},
						},
						{
							key: "checkLinkOnClick",
							value: function (t, e) {
								e && e === window.location.pathname && this.close();
							},
						},
						{
							key: "toggle",
							value: function () {
								this.state.isOpen ? this.close() : this.open();
							},
						},
						{
							key: "open",
							value: function () {
								this.state.isOpen ||
									((this.state.isOpen = !0),
									Cx.revealOtherEmojis(),
									this.dom.hammy.classList.add("is-open"),
									this.dom.contentWrapper.scrollTo(0, 0),
									er.set([this.dom.background, this.dom.contentWrapper], {
										autoAlpha: 1,
										pointerEvents: "all",
										force3D: !0,
									}),
									this.dom.mainLinks.forEach(function (t, e) {
										t.classList.add("is-animating");
										var n = e % 2 == 0,
											i = n ? 0 : -100,
											r = n ? 35 : -35;
										er.fromTo(
											t.querySelector(".link-wrapper"),
											2,
											{ xPercent: -50, skewX: r, force3D: !0 },
											{ xPercent: i, skewX: 0, ease: "expo.out", force3D: !0 }
										);
									}));
							},
						},
						{
							key: "close",
							value: function () {
								!(arguments.length > 0 && void 0 !== arguments[0]) ||
									arguments[0];
								this.state.isOpen &&
									((this.state.isOpen = !1),
									Cx.hideOtherEmojis(),
									this.dom.hammy.classList.remove("is-open"),
									this.dom.mainLinks.forEach(function (t, e) {
										t.classList.remove("is-animating");
									}),
									er
										.timeline()
										.set([this.dom.background, this.dom.contentWrapper], {
											autoAlpha: 0,
											pointerEvents: "none",
											force3D: !0,
										}));
							},
						},
					]),
					t
				);
			})(),
			Zo = (function () {
				function t(e) {
					if ((p()(this, t), e)) {
						x(this, [
							"kill",
							"onMouseEnter",
							"onMouseLeave",
							"onMouseMove",
							"run",
							"stop",
						]),
							(this.dom = { el: e, moveEl: e.querySelector(".move-el") });
						var n = e.querySelector("video.manual");
						n &&
							((this.playPauseVideo = !0),
							(this.video = n),
							(this.pauseIcon =
								n.previousElementSibling.querySelector(".pause")),
							(this.showingPause = !0),
							(this.hidePauseTimeout = setTimeout(function () {}, 0))),
							er.set(this.dom.moveEl, { pointerEvents: "none" }),
							(this.state = { isHover: !1, isRunning: !1 }),
							(this.bcr = this.dom.el.getBoundingClientRect()),
							(this.cur = {
								x: 0.5 * this.bcr.width,
								y: 0.5 * this.bcr.height,
								z: 30,
							}),
							(this.last = { x: this.cur.x, y: this.cur.y }),
							(this.xMin = -0.1 * this.bcr.width),
							(this.xMax = 0.1 * this.bcr.width),
							(this.yMin = -0.1 * this.bcr.height),
							(this.yMax = 0.1 * this.bcr.height),
							(this.ease = 0.05),
							this.addEvents();
					}
				}
				return (
					m()(t, [
						{
							key: "addEvents",
							value: function () {
								var t = this;
								this.dom.el.addEventListener("mouseenter", this.onMouseEnter),
									this.dom.el.addEventListener("mouseleave", this.onMouseLeave),
									this.dom.el.addEventListener("mousemove", this.onMouseMove, {
										passive: !0,
									}),
									this.playPauseVideo &&
										this.dom.el.addEventListener("click", function () {
											t.showingPause = !0;
										});
							},
						},
						{
							key: "onResize",
							value: function () {
								this.bcr = this.dom.el.getBoundingClientRect();
							},
						},
						{
							key: "onMouseEnter",
							value: function () {
								(this.state.isHover = !0),
									this.state.isRunning ||
										((this.state.isRunning = !0), this.run()),
									er.to(this.cur, 0.4, { z: 100, ease: "sine.out" }),
									(this.ease = 0.12),
									(this.cur.x = event.layerX),
									(this.cur.y = event.layerY);
							},
						},
						{
							key: "onMouseLeave",
							value: function () {
								(this.state.isHover = !1),
									(this.ease = 0.15),
									er.to(this.cur, 0.3, { z: 30, ease: "sine.out" }),
									(this.cur.x = 0.5 * this.bcr.width),
									(this.cur.y = 0.5 * this.bcr.height),
									er.delayedCall(0.4, this.stop);
							},
						},
						{
							key: "onMouseMove",
							value: function () {
								var t = this;
								this.playPauseVideo &&
									(this.video.paused ||
										(clearTimeout(this.hidePauseTimeout),
										this.showingPause ||
											((this.showingPause = !0),
											er.to(this.pauseIcon, 0.35, {
												opacity: 1,
												ease: "sine.out",
											})),
										(this.hidePauseTimeout = setTimeout(function () {
											t.showingPause &&
												((t.showingPause = !1),
												er.to(t.pauseIcon, 0.3, {
													opacity: 0,
													ease: "sine.out",
												}));
										}, 300)))),
									(this.cur.x = event.layerX),
									(this.cur.y = event.layerY);
							},
						},
						{
							key: "run",
							value: function () {
								(this.last.x = y(this.last.x, this.cur.x, this.ease)),
									(this.last.y = y(this.last.y, this.cur.y, this.ease));
								var t = v(this.last.x, 0, this.bcr.width, this.xMin, this.xMax),
									e = v(this.last.y, 0, this.bcr.height, this.yMin, this.yMax),
									n = v(this.last.y, 0, this.bcr.height, 25, -25),
									i = v(this.last.x, 0, this.bcr.width, -25, 25);
								er.set(this.dom.moveEl, {
									x: t,
									y: e,
									z: this.cur.z,
									scale: 0.9,
									rotateX: n,
									rotateY: i,
								}),
									(this.raf = window.requestAnimationFrame(this.run));
							},
						},
						{
							key: "stop",
							value: function () {
								this.state.isHover ||
									((this.state.isRunning = !1),
									window.cancelAnimationFrame(this.raf),
									(this.raf = null));
							},
						},
						{
							key: "kill",
							value: function () {
								this.raf && window.cancelAnimationFrame(this.raf),
									(this.dom = null),
									(this.state = null),
									(this.cur = null),
									(this.last = null),
									(this.cur = null),
									(this.xMin = null),
									(this.xMax = null),
									(this.yMin = null),
									(this.yMax = null),
									(this.ease = null);
							},
						},
					]),
					t
				);
			})(),
			Jo = function (t) {
				var e = t.querySelectorAll("a, button, input, select, textarea");
				Array.prototype.slice.call(e).forEach(function (t) {
					t.setAttribute("tabindex", "-1");
				});
			},
			Ko = (function () {
				function t(e, n) {
					if ((p()(this, t), e)) {
						if (
							(x(this, ["checkLinkOnClick"]),
							(this.type = n),
							(this.el = e),
							(this.pageLinks = e.querySelectorAll(
								'[href="/'
									.concat(n, '/"], [href*="/')
									.concat(n, '/?"], [href="/about-us/"]')
							)),
							(this.isOpen = !1),
							(this.direction = "work" === n ? -1 : 1),
							(this.xPercent = 25 * this.direction),
							(this.trigger = document.querySelector(
								".drawer-trigger.".concat(n)
							)),
							(this.closeTrigger = e.querySelector(".drawer-close")),
							(this.content = e.querySelector(".drawer-content")),
							(this.backdrop = document.getElementById("drawer-backdrop")),
							(this.otherDrawer =
								"work" === n
									? document.getElementById("about-drawer")
									: document.getElementById("work-drawer")),
							(this.interactiveEls =
								this.content.querySelectorAll("a, button")),
							(this.interactiveElFirst = this.interactiveEls[0]),
							(this.interactiveElLast =
								this.interactiveEls[this.interactiveEls.length - 1]),
							(this.timeline = new er.timeline()),
							(this.videoInFirstPos = !1),
							"work" === n)
						) {
							var i = this.el.querySelector(".work-tile.fw video");
							i && ((this.firstVideo = i), (this.videoInFirstPos = !0));
						}
						this.init();
					}
				}
				return (
					m()(t, [
						{
							key: "init",
							value: function () {
								var t,
									e = this;
								this.setupDom(),
									this.trigger.addEventListener("click", function () {
										e.isOpen || e.open();
									}),
									"about" !== this.type || _.aboutHandLoaded
										? (t = this.el.querySelectorAll(".preload"))
										: ((t = document.querySelectorAll("#about-hand")),
										  (_.aboutHandLoaded = !0));
								var n = function n() {
									Ix.loadImages(t, "nodeList", function () {}),
										e.trigger.removeEventListener("mouseenter", n),
										e.trigger.removeEventListener("focus", n);
								};
								this.trigger.addEventListener("mouseenter", n),
									this.trigger.addEventListener("focus", n),
									this.closeTrigger.addEventListener("click", function () {
										e.isOpen && e.close();
									}),
									this.backdrop.addEventListener("click", function () {
										e.isOpen && e.close();
									}),
									this.interactiveElLast.addEventListener("blur", function () {
										e.isOpen && e.close();
									}),
									Array.prototype.slice
										.call(this.pageLinks)
										.forEach(function (t) {
											var n = t.getAttribute("href");
											t.addEventListener("click", function () {
												e.checkLinkOnClick(n);
											});
										});
							},
						},
						{
							key: "setupDom",
							value: function () {
								er.set(this.content, {
									opacity: 0,
									xPercent: this.xPercent,
									force3D: !0,
								}),
									er.set(this.closeTrigger, { scale: 0, force3D: !0 });
							},
						},
						{
							key: "reset",
							value: function () {
								(this.isOpen = !1), this.timeline.clear(), this.setupDom();
							},
						},
						{
							key: "checkLinkOnClick",
							value: function (t) {
								t &&
									("/about-us/" === t &&
										"about-us" !== _.namespace &&
										(_.fromAboutDrawer = !0),
									t === "/".concat(_.namespace, "/") && this.close(!0));
							},
						},
						{
							key: "open",
							value: function () {
								if (!this.isOpen) {
									var t, e;
									(this.isOpen = !0),
										(_.drawerOpen = !0),
										(t = this.content),
										(e = t.querySelectorAll(
											"a, button, input, select, textarea"
										)),
										Array.prototype.slice.call(e).forEach(function (t) {
											t.setAttribute("tabindex", "0");
										}),
										_.keyToggle && this.interactiveElFirst.focus(),
										(this.playingVideos = []),
										(this.ctpPlayingVideos = []);
									for (var n = 0; n < Ax.videosDataLength; n++)
										Ax.videosData[n].playing &&
											(Ax.videosData[n].el.pause(),
											(Ax.videosData[n].playing = !1),
											this.playingVideos.push(n));
									for (var i = 0; i < Ax.clickToPlayVideosLength; i++)
										Ax.clickToPlayVideos[i].playing &&
											(Ax.clickToPlayVideos[i].el.pause(),
											(Ax.clickToPlayVideos[i].playing = !1),
											this.ctpPlayingVideos.push(i));
									Ox.hide(0.2, "none"),
										Ax.cancelAnimationFrame(),
										this.timeline.clear(),
										"work" === this.type
											? (_.workDrawerScroll.requestAnimationFrame(),
											  this.videoInFirstPos && this.firstVideo.play(),
											  this.timeline
													.set(this.el, { pointerEvents: "all", zIndex: 1001 })
													.set(this.otherDrawer, { zIndex: 97 })
													.to(
														this.content,
														1.1,
														{ xPercent: 0, ease: "expo.out", force3D: !0 },
														0
													)
													.to(
														this.content,
														0.6,
														{ autoAlpha: 1, ease: "sine.out", force3D: !0 },
														0
													)
													.to(
														this.backdrop,
														0.25,
														{
															autoAlpha: 1,
															pointerEvents: "all",
															ease: "sine.out",
															force3D: !0,
														},
														0.05
													))
											: "about" === this.type &&
											  (Dx.openAboutMenu(),
											  _.aboutDrawerScroll.requestAnimationFrame(),
											  this.timeline
													.set(this.el, { pointerEvents: "all", zIndex: 1001 })
													.set(this.otherDrawer, { zIndex: 97 })
													.to(
														this.content,
														1.1,
														{ xPercent: 0, ease: "expo.out", force3D: !0 },
														0
													)
													.to(
														this.content,
														0.6,
														{ autoAlpha: 1, ease: "sine.out", force3D: !0 },
														0
													)
													.to(
														this.backdrop,
														0.25,
														{
															autoAlpha: 1,
															pointerEvents: "all",
															ease: "sine.out",
															force3D: !0,
														},
														0.05
													)),
										this.timeline.to(
											this.closeTrigger,
											0.9,
											{ scale: 1, ease: "back.out(1.7)", force3D: !0 },
											0.42
										);
								}
							},
						},
						{
							key: "close",
							value: function () {
								var t = this;
								if (this.isOpen) {
									if (
										((this.isOpen = !1),
										(_.drawerOpen = !1),
										this.timeline.clear(),
										_.keyToggle)
									) {
										var e;
										if ("about" === this.type) {
											if (
												!(e = document.querySelector("#main a, #main button"))
											) {
												var n = document.querySelector("h1");
												(n.tabIndex = 0), (e = n);
											}
										} else e = this.otherDrawer.querySelector(".trigger");
										e.focus();
									}
									if ((Jo(this.content), "about" === this.type))
										Dx.closeAboutMenu(),
											_.aboutDrawerScroll.cancelAnimationFrame();
									else {
										_.workDrawerScroll.cancelAnimationFrame();
										for (
											var i = _.workDrawerScroll.videosData, r = 0;
											r < i.length;
											r++
										)
											i[r].playing && (i[r].el.pause(), (i[r].playing = !1));
									}
									Ax.requestAnimationFrame();
									for (var o = 0; o < this.playingVideos.length; o++)
										Ax.videosData[this.playingVideos[o]].el.play(),
											(Ax.videosData[this.playingVideos[o]].playing = !0);
									for (var s = 0; s < this.ctpPlayingVideos.length; s++)
										Ax.clickToPlayVideos[this.ctpPlayingVideos[s]].el.play(),
											(Ax.clickToPlayVideos[this.ctpPlayingVideos[s]].playing =
												!0);
									this.timeline
										.set(this.otherDrawer, { zIndex: 1001 })
										.set(this.el, { pointerEvents: "none" }, 0.1)
										.to(
											this.backdrop,
											0.25,
											{
												autoAlpha: 0,
												pointerEvents: "none",
												ease: "sine.out",
												force3D: !0,
											},
											0
										)
										.to(
											this.content,
											1.1,
											{
												xPercent: this.xPercent,
												ease: "expo.out",
												force3D: !0,
											},
											0.03
										)
										.to(
											this.closeTrigger,
											0.4,
											{ scale: 0, ease: "sine.in", force3D: !0 },
											0
										)
										.to(
											this.content,
											0.4,
											{
												autoAlpha: 0,
												ease: "sine.out",
												force3D: !0,
												onComplete: function () {
													t.content.scrollTop = 0;
												},
											},
											0.03
										);
								}
							},
						},
					]),
					t
				);
			})(),
			Qo = {};
		function $o(t) {
			return new Promise(function (e, n) {
				var i = new XMLHttpRequest();
				i.open("GET", t, (i.withCredentials = !0)),
					(i.onload = function () {
						200 === i.status ? e() : n();
					}),
					i.send();
			});
		}
		var ts,
			es =
				("prefetch",
				(ts = document.createElement("link")).relList &&
				ts.relList.supports &&
				ts.relList.supports("prefetch")
					? function (t) {
							return new Promise(function (e, n) {
								var i = document.createElement("link");
								(i.rel = "prefetch"),
									(i.href = t),
									(i.onload = e),
									(i.onerror = n),
									document.head.appendChild(i);
							});
					  }
					: $o);
		var ns =
				window.requestIdleCallback ||
				function (t) {
					var e = Date.now();
					return setTimeout(function () {
						t({
							didTimeout: !1,
							timeRemaining: function () {
								return Math.max(0, 50 - (Date.now() - e));
							},
						});
					}, 1);
				},
			is = new Set(),
			rs =
				window.IntersectionObserver &&
				new IntersectionObserver(function (t) {
					t.forEach(function (t) {
						if (t.isIntersecting) {
							var e = t.target;
							is.has(e.href) && (rs.unobserve(e), os(e.href));
						}
					});
				});
		function os(t) {
			is.delete(t),
				(function (t, e, n) {
					if (
						!(
							Qo[t] ||
							((n = navigator.connection) &&
								((n.effectiveType || "").includes("2g") || n.saveData))
						)
					)
						(e
							? function (t) {
									return null == self.fetch
										? $o(t)
										: fetch(t, { credentials: "include" });
							  }
							: es)(t).then(function () {
							Qo[t] = !0;
						});
				})(new URL(t, location.href).toString(), rs.priority);
		}
		var ss = function (t) {
			t || (t = {}), rs && (rs.priority = t.priority || !1);
			var e = t.origins || [location.hostname],
				n = t.ignores || [];
			(t.timeoutFn || ns)(
				function () {
					t.urls
						? t.urls.forEach(os)
						: rs &&
						  Array.from(
								(t.el || document).querySelectorAll("a"),
								function (t) {
									rs.observe(t),
										(e.length && !e.includes(t.hostname)) ||
											(function t(e, n) {
												return Array.isArray(n)
													? n.some(function (n) {
															return t(e, n);
													  })
													: (n.test || n).call(n, e.href, e);
											})(t, n) ||
											is.add(t.href);
								}
						  );
				},
				{ timeout: t.timeout || 2e3 }
			);
		};
		void 0 === Number.EPSILON && (Number.EPSILON = Math.pow(2, -52)),
			void 0 === Number.isInteger &&
				(Number.isInteger = function (t) {
					return "number" == typeof t && isFinite(t) && Math.floor(t) === t;
				}),
			void 0 === Math.sign &&
				(Math.sign = function (t) {
					return t < 0 ? -1 : t > 0 ? 1 : +t;
				}),
			"name" in Function.prototype == !1 &&
				Object.defineProperty(Function.prototype, "name", {
					get: function () {
						return this.toString().match(/^\s*function\s*([^\(\s]*)/)[1];
					},
				}),
			void 0 === Object.assign &&
				(Object.assign = function (t) {
					if (void 0 === t || null === t)
						throw new TypeError("Cannot convert undefined or null to object");
					const e = Object(t);
					for (let t = 1; t < arguments.length; t++) {
						const n = arguments[t];
						if (void 0 !== n && null !== n)
							for (const t in n)
								Object.prototype.hasOwnProperty.call(n, t) && (e[t] = n[t]);
					}
					return e;
				});
		const as = 0,
			cs = 1,
			ls = 2,
			hs = 1,
			us = 2,
			ds = 3,
			ps = 0,
			fs = 1,
			ms = 2,
			gs = 0,
			vs = 1,
			ys = 2,
			xs = 3,
			bs = 4,
			ws = 5,
			_s = 100,
			Ms = 101,
			Ss = 102,
			Ts = 103,
			Es = 104,
			As = 200,
			Ls = 201,
			Ps = 202,
			Rs = 203,
			Cs = 204,
			Os = 205,
			Ds = 206,
			Is = 207,
			ks = 208,
			Ns = 209,
			Bs = 210,
			Fs = 0,
			zs = 1,
			Hs = 2,
			Us = 3,
			Gs = 4,
			Vs = 5,
			js = 6,
			Ws = 7,
			qs = 0,
			Ys = 1,
			Xs = 2,
			Zs = 0,
			Js = 1,
			Ks = 2,
			Qs = 3,
			$s = 4,
			ta = 5,
			ea = 301,
			na = 302,
			ia = 303,
			ra = 304,
			oa = 306,
			sa = 307,
			aa = 1e3,
			ca = 1001,
			la = 1002,
			ha = 1003,
			ua = 1004,
			da = 1005,
			pa = 1006,
			fa = 1007,
			ma = 1008,
			ga = 1009,
			va = 1010,
			ya = 1011,
			xa = 1012,
			ba = 1013,
			wa = 1014,
			_a = 1015,
			Ma = 1016,
			Sa = 1017,
			Ta = 1018,
			Ea = 1019,
			Aa = 1020,
			La = 1021,
			Pa = 1022,
			Ra = 1023,
			Ca = 1024,
			Oa = 1025,
			Da = Ra,
			Ia = 1026,
			ka = 1027,
			Na = 1028,
			Ba = 1029,
			Fa = 1030,
			za = 1031,
			Ha = 1032,
			Ua = 1033,
			Ga = 33776,
			Va = 33777,
			ja = 33778,
			Wa = 33779,
			qa = 35840,
			Ya = 35841,
			Xa = 35842,
			Za = 35843,
			Ja = 36196,
			Ka = 37492,
			Qa = 37496,
			$a = 37808,
			tc = 37809,
			ec = 37810,
			nc = 37811,
			ic = 37812,
			rc = 37813,
			oc = 37814,
			sc = 37815,
			ac = 37816,
			cc = 37817,
			lc = 37818,
			hc = 37819,
			uc = 37820,
			dc = 37821,
			pc = 36492,
			fc = 37840,
			mc = 37841,
			gc = 37842,
			vc = 37843,
			yc = 37844,
			xc = 37845,
			bc = 37846,
			wc = 37847,
			_c = 37848,
			Mc = 37849,
			Sc = 37850,
			Tc = 37851,
			Ec = 37852,
			Ac = 37853,
			Lc = 2201,
			Pc = 2400,
			Rc = 2500,
			Cc = 2,
			Oc = 3e3,
			Dc = 3001,
			Ic = 3007,
			kc = 3002,
			Nc = 3003,
			Bc = 3004,
			Fc = 3005,
			zc = 3006,
			Hc = 3200,
			Uc = 3201,
			Gc = 0,
			Vc = 1,
			jc = 7680,
			Wc = 519,
			qc = 35044,
			Yc = 35048;
		function Xc() {}
		Object.assign(Xc.prototype, {
			addEventListener: function (t, e) {
				void 0 === this._listeners && (this._listeners = {});
				const n = this._listeners;
				void 0 === n[t] && (n[t] = []), -1 === n[t].indexOf(e) && n[t].push(e);
			},
			hasEventListener: function (t, e) {
				if (void 0 === this._listeners) return !1;
				const n = this._listeners;
				return void 0 !== n[t] && -1 !== n[t].indexOf(e);
			},
			removeEventListener: function (t, e) {
				if (void 0 === this._listeners) return;
				const n = this._listeners[t];
				if (void 0 !== n) {
					const t = n.indexOf(e);
					-1 !== t && n.splice(t, 1);
				}
			},
			dispatchEvent: function (t) {
				if (void 0 === this._listeners) return;
				const e = this._listeners[t.type];
				if (void 0 !== e) {
					t.target = this;
					const n = e.slice(0);
					for (let e = 0, i = n.length; e < i; e++) n[e].call(this, t);
				}
			},
		});
		const Zc = [];
		for (let t = 0; t < 256; t++) Zc[t] = (t < 16 ? "0" : "") + t.toString(16);
		const Jc = {
			DEG2RAD: Math.PI / 180,
			RAD2DEG: 180 / Math.PI,
			generateUUID: function () {
				const t = (4294967295 * Math.random()) | 0,
					e = (4294967295 * Math.random()) | 0,
					n = (4294967295 * Math.random()) | 0,
					i = (4294967295 * Math.random()) | 0;
				return (
					Zc[255 & t] +
					Zc[(t >> 8) & 255] +
					Zc[(t >> 16) & 255] +
					Zc[(t >> 24) & 255] +
					"-" +
					Zc[255 & e] +
					Zc[(e >> 8) & 255] +
					"-" +
					Zc[((e >> 16) & 15) | 64] +
					Zc[(e >> 24) & 255] +
					"-" +
					Zc[(63 & n) | 128] +
					Zc[(n >> 8) & 255] +
					"-" +
					Zc[(n >> 16) & 255] +
					Zc[(n >> 24) & 255] +
					Zc[255 & i] +
					Zc[(i >> 8) & 255] +
					Zc[(i >> 16) & 255] +
					Zc[(i >> 24) & 255]
				).toUpperCase();
			},
			clamp: function (t, e, n) {
				return Math.max(e, Math.min(n, t));
			},
			euclideanModulo: function (t, e) {
				return ((t % e) + e) % e;
			},
			mapLinear: function (t, e, n, i, r) {
				return i + ((t - e) * (r - i)) / (n - e);
			},
			lerp: function (t, e, n) {
				return (1 - n) * t + n * e;
			},
			smoothstep: function (t, e, n) {
				return t <= e
					? 0
					: t >= n
					? 1
					: (t = (t - e) / (n - e)) * t * (3 - 2 * t);
			},
			smootherstep: function (t, e, n) {
				return t <= e
					? 0
					: t >= n
					? 1
					: (t = (t - e) / (n - e)) * t * t * (t * (6 * t - 15) + 10);
			},
			randInt: function (t, e) {
				return t + Math.floor(Math.random() * (e - t + 1));
			},
			randFloat: function (t, e) {
				return t + Math.random() * (e - t);
			},
			randFloatSpread: function (t) {
				return t * (0.5 - Math.random());
			},
			degToRad: function (t) {
				return t * Jc.DEG2RAD;
			},
			radToDeg: function (t) {
				return t * Jc.RAD2DEG;
			},
			isPowerOfTwo: function (t) {
				return 0 == (t & (t - 1)) && 0 !== t;
			},
			ceilPowerOfTwo: function (t) {
				return Math.pow(2, Math.ceil(Math.log(t) / Math.LN2));
			},
			floorPowerOfTwo: function (t) {
				return Math.pow(2, Math.floor(Math.log(t) / Math.LN2));
			},
			setQuaternionFromProperEuler: function (t, e, n, i, r) {
				const o = Math.cos,
					s = Math.sin,
					a = o(n / 2),
					c = s(n / 2),
					l = o((e + i) / 2),
					h = s((e + i) / 2),
					u = o((e - i) / 2),
					d = s((e - i) / 2),
					p = o((i - e) / 2),
					f = s((i - e) / 2);
				switch (r) {
					case "XYX":
						t.set(a * h, c * u, c * d, a * l);
						break;
					case "YZY":
						t.set(c * d, a * h, c * u, a * l);
						break;
					case "ZXZ":
						t.set(c * u, c * d, a * h, a * l);
						break;
					case "XZX":
						t.set(a * h, c * f, c * p, a * l);
						break;
					case "YXY":
						t.set(c * p, a * h, c * f, a * l);
						break;
					case "ZYZ":
						t.set(c * f, c * p, a * h, a * l);
						break;
					default:
						console.warn(
							"THREE.MathUtils: .setQuaternionFromProperEuler() encountered an unknown order: " +
								r
						);
				}
			},
		};
		function Kc(t = 0, e = 0) {
			(this.x = t), (this.y = e);
		}
		function Qc() {
			(this.elements = [1, 0, 0, 0, 1, 0, 0, 0, 1]),
				arguments.length > 0 &&
					console.error(
						"THREE.Matrix3: the constructor no longer reads arguments. use .set() instead."
					);
		}
		let $c;
		Object.defineProperties(Kc.prototype, {
			width: {
				get: function () {
					return this.x;
				},
				set: function (t) {
					this.x = t;
				},
			},
			height: {
				get: function () {
					return this.y;
				},
				set: function (t) {
					this.y = t;
				},
			},
		}),
			Object.assign(Kc.prototype, {
				isVector2: !0,
				set: function (t, e) {
					return (this.x = t), (this.y = e), this;
				},
				setScalar: function (t) {
					return (this.x = t), (this.y = t), this;
				},
				setX: function (t) {
					return (this.x = t), this;
				},
				setY: function (t) {
					return (this.y = t), this;
				},
				setComponent: function (t, e) {
					switch (t) {
						case 0:
							this.x = e;
							break;
						case 1:
							this.y = e;
							break;
						default:
							throw new Error("index is out of range: " + t);
					}
					return this;
				},
				getComponent: function (t) {
					switch (t) {
						case 0:
							return this.x;
						case 1:
							return this.y;
						default:
							throw new Error("index is out of range: " + t);
					}
				},
				clone: function () {
					return new this.constructor(this.x, this.y);
				},
				copy: function (t) {
					return (this.x = t.x), (this.y = t.y), this;
				},
				add: function (t, e) {
					return void 0 !== e
						? (console.warn(
								"THREE.Vector2: .add() now only accepts one argument. Use .addVectors( a, b ) instead."
						  ),
						  this.addVectors(t, e))
						: ((this.x += t.x), (this.y += t.y), this);
				},
				addScalar: function (t) {
					return (this.x += t), (this.y += t), this;
				},
				addVectors: function (t, e) {
					return (this.x = t.x + e.x), (this.y = t.y + e.y), this;
				},
				addScaledVector: function (t, e) {
					return (this.x += t.x * e), (this.y += t.y * e), this;
				},
				sub: function (t, e) {
					return void 0 !== e
						? (console.warn(
								"THREE.Vector2: .sub() now only accepts one argument. Use .subVectors( a, b ) instead."
						  ),
						  this.subVectors(t, e))
						: ((this.x -= t.x), (this.y -= t.y), this);
				},
				subScalar: function (t) {
					return (this.x -= t), (this.y -= t), this;
				},
				subVectors: function (t, e) {
					return (this.x = t.x - e.x), (this.y = t.y - e.y), this;
				},
				multiply: function (t) {
					return (this.x *= t.x), (this.y *= t.y), this;
				},
				multiplyScalar: function (t) {
					return (this.x *= t), (this.y *= t), this;
				},
				divide: function (t) {
					return (this.x /= t.x), (this.y /= t.y), this;
				},
				divideScalar: function (t) {
					return this.multiplyScalar(1 / t);
				},
				applyMatrix3: function (t) {
					const e = this.x,
						n = this.y,
						i = t.elements;
					return (
						(this.x = i[0] * e + i[3] * n + i[6]),
						(this.y = i[1] * e + i[4] * n + i[7]),
						this
					);
				},
				min: function (t) {
					return (
						(this.x = Math.min(this.x, t.x)),
						(this.y = Math.min(this.y, t.y)),
						this
					);
				},
				max: function (t) {
					return (
						(this.x = Math.max(this.x, t.x)),
						(this.y = Math.max(this.y, t.y)),
						this
					);
				},
				clamp: function (t, e) {
					return (
						(this.x = Math.max(t.x, Math.min(e.x, this.x))),
						(this.y = Math.max(t.y, Math.min(e.y, this.y))),
						this
					);
				},
				clampScalar: function (t, e) {
					return (
						(this.x = Math.max(t, Math.min(e, this.x))),
						(this.y = Math.max(t, Math.min(e, this.y))),
						this
					);
				},
				clampLength: function (t, e) {
					const n = this.length();
					return this.divideScalar(n || 1).multiplyScalar(
						Math.max(t, Math.min(e, n))
					);
				},
				floor: function () {
					return (
						(this.x = Math.floor(this.x)), (this.y = Math.floor(this.y)), this
					);
				},
				ceil: function () {
					return (
						(this.x = Math.ceil(this.x)), (this.y = Math.ceil(this.y)), this
					);
				},
				round: function () {
					return (
						(this.x = Math.round(this.x)), (this.y = Math.round(this.y)), this
					);
				},
				roundToZero: function () {
					return (
						(this.x = this.x < 0 ? Math.ceil(this.x) : Math.floor(this.x)),
						(this.y = this.y < 0 ? Math.ceil(this.y) : Math.floor(this.y)),
						this
					);
				},
				negate: function () {
					return (this.x = -this.x), (this.y = -this.y), this;
				},
				dot: function (t) {
					return this.x * t.x + this.y * t.y;
				},
				cross: function (t) {
					return this.x * t.y - this.y * t.x;
				},
				lengthSq: function () {
					return this.x * this.x + this.y * this.y;
				},
				length: function () {
					return Math.sqrt(this.x * this.x + this.y * this.y);
				},
				manhattanLength: function () {
					return Math.abs(this.x) + Math.abs(this.y);
				},
				normalize: function () {
					return this.divideScalar(this.length() || 1);
				},
				angle: function () {
					return Math.atan2(-this.y, -this.x) + Math.PI;
				},
				distanceTo: function (t) {
					return Math.sqrt(this.distanceToSquared(t));
				},
				distanceToSquared: function (t) {
					const e = this.x - t.x,
						n = this.y - t.y;
					return e * e + n * n;
				},
				manhattanDistanceTo: function (t) {
					return Math.abs(this.x - t.x) + Math.abs(this.y - t.y);
				},
				setLength: function (t) {
					return this.normalize().multiplyScalar(t);
				},
				lerp: function (t, e) {
					return (
						(this.x += (t.x - this.x) * e), (this.y += (t.y - this.y) * e), this
					);
				},
				lerpVectors: function (t, e, n) {
					return (
						(this.x = t.x + (e.x - t.x) * n),
						(this.y = t.y + (e.y - t.y) * n),
						this
					);
				},
				equals: function (t) {
					return t.x === this.x && t.y === this.y;
				},
				fromArray: function (t, e) {
					return (
						void 0 === e && (e = 0), (this.x = t[e]), (this.y = t[e + 1]), this
					);
				},
				toArray: function (t, e) {
					return (
						void 0 === t && (t = []),
						void 0 === e && (e = 0),
						(t[e] = this.x),
						(t[e + 1] = this.y),
						t
					);
				},
				fromBufferAttribute: function (t, e, n) {
					return (
						void 0 !== n &&
							console.warn(
								"THREE.Vector2: offset has been removed from .fromBufferAttribute()."
							),
						(this.x = t.getX(e)),
						(this.y = t.getY(e)),
						this
					);
				},
				rotateAround: function (t, e) {
					const n = Math.cos(e),
						i = Math.sin(e),
						r = this.x - t.x,
						o = this.y - t.y;
					return (
						(this.x = r * n - o * i + t.x), (this.y = r * i + o * n + t.y), this
					);
				},
				random: function () {
					return (this.x = Math.random()), (this.y = Math.random()), this;
				},
			}),
			Object.assign(Qc.prototype, {
				isMatrix3: !0,
				set: function (t, e, n, i, r, o, s, a, c) {
					const l = this.elements;
					return (
						(l[0] = t),
						(l[1] = i),
						(l[2] = s),
						(l[3] = e),
						(l[4] = r),
						(l[5] = a),
						(l[6] = n),
						(l[7] = o),
						(l[8] = c),
						this
					);
				},
				identity: function () {
					return this.set(1, 0, 0, 0, 1, 0, 0, 0, 1), this;
				},
				clone: function () {
					return new this.constructor().fromArray(this.elements);
				},
				copy: function (t) {
					const e = this.elements,
						n = t.elements;
					return (
						(e[0] = n[0]),
						(e[1] = n[1]),
						(e[2] = n[2]),
						(e[3] = n[3]),
						(e[4] = n[4]),
						(e[5] = n[5]),
						(e[6] = n[6]),
						(e[7] = n[7]),
						(e[8] = n[8]),
						this
					);
				},
				extractBasis: function (t, e, n) {
					return (
						t.setFromMatrix3Column(this, 0),
						e.setFromMatrix3Column(this, 1),
						n.setFromMatrix3Column(this, 2),
						this
					);
				},
				setFromMatrix4: function (t) {
					const e = t.elements;
					return (
						this.set(e[0], e[4], e[8], e[1], e[5], e[9], e[2], e[6], e[10]),
						this
					);
				},
				multiply: function (t) {
					return this.multiplyMatrices(this, t);
				},
				premultiply: function (t) {
					return this.multiplyMatrices(t, this);
				},
				multiplyMatrices: function (t, e) {
					const n = t.elements,
						i = e.elements,
						r = this.elements,
						o = n[0],
						s = n[3],
						a = n[6],
						c = n[1],
						l = n[4],
						h = n[7],
						u = n[2],
						d = n[5],
						p = n[8],
						f = i[0],
						m = i[3],
						g = i[6],
						v = i[1],
						y = i[4],
						x = i[7],
						b = i[2],
						w = i[5],
						_ = i[8];
					return (
						(r[0] = o * f + s * v + a * b),
						(r[3] = o * m + s * y + a * w),
						(r[6] = o * g + s * x + a * _),
						(r[1] = c * f + l * v + h * b),
						(r[4] = c * m + l * y + h * w),
						(r[7] = c * g + l * x + h * _),
						(r[2] = u * f + d * v + p * b),
						(r[5] = u * m + d * y + p * w),
						(r[8] = u * g + d * x + p * _),
						this
					);
				},
				multiplyScalar: function (t) {
					const e = this.elements;
					return (
						(e[0] *= t),
						(e[3] *= t),
						(e[6] *= t),
						(e[1] *= t),
						(e[4] *= t),
						(e[7] *= t),
						(e[2] *= t),
						(e[5] *= t),
						(e[8] *= t),
						this
					);
				},
				determinant: function () {
					const t = this.elements,
						e = t[0],
						n = t[1],
						i = t[2],
						r = t[3],
						o = t[4],
						s = t[5],
						a = t[6],
						c = t[7],
						l = t[8];
					return (
						e * o * l -
						e * s * c -
						n * r * l +
						n * s * a +
						i * r * c -
						i * o * a
					);
				},
				getInverse: function (t, e) {
					void 0 !== e &&
						console.warn(
							"THREE.Matrix3: .getInverse() can no longer be configured to throw on degenerate."
						);
					const n = t.elements,
						i = this.elements,
						r = n[0],
						o = n[1],
						s = n[2],
						a = n[3],
						c = n[4],
						l = n[5],
						h = n[6],
						u = n[7],
						d = n[8],
						p = d * c - l * u,
						f = l * h - d * a,
						m = u * a - c * h,
						g = r * p + o * f + s * m;
					if (0 === g) return this.set(0, 0, 0, 0, 0, 0, 0, 0, 0);
					const v = 1 / g;
					return (
						(i[0] = p * v),
						(i[1] = (s * u - d * o) * v),
						(i[2] = (l * o - s * c) * v),
						(i[3] = f * v),
						(i[4] = (d * r - s * h) * v),
						(i[5] = (s * a - l * r) * v),
						(i[6] = m * v),
						(i[7] = (o * h - u * r) * v),
						(i[8] = (c * r - o * a) * v),
						this
					);
				},
				transpose: function () {
					let t;
					const e = this.elements;
					return (
						(t = e[1]),
						(e[1] = e[3]),
						(e[3] = t),
						(t = e[2]),
						(e[2] = e[6]),
						(e[6] = t),
						(t = e[5]),
						(e[5] = e[7]),
						(e[7] = t),
						this
					);
				},
				getNormalMatrix: function (t) {
					return this.setFromMatrix4(t).getInverse(this).transpose();
				},
				transposeIntoArray: function (t) {
					const e = this.elements;
					return (
						(t[0] = e[0]),
						(t[1] = e[3]),
						(t[2] = e[6]),
						(t[3] = e[1]),
						(t[4] = e[4]),
						(t[5] = e[7]),
						(t[6] = e[2]),
						(t[7] = e[5]),
						(t[8] = e[8]),
						this
					);
				},
				setUvTransform: function (t, e, n, i, r, o, s) {
					const a = Math.cos(r),
						c = Math.sin(r);
					this.set(
						n * a,
						n * c,
						-n * (a * o + c * s) + o + t,
						-i * c,
						i * a,
						-i * (-c * o + a * s) + s + e,
						0,
						0,
						1
					);
				},
				scale: function (t, e) {
					const n = this.elements;
					return (
						(n[0] *= t),
						(n[3] *= t),
						(n[6] *= t),
						(n[1] *= e),
						(n[4] *= e),
						(n[7] *= e),
						this
					);
				},
				rotate: function (t) {
					const e = Math.cos(t),
						n = Math.sin(t),
						i = this.elements,
						r = i[0],
						o = i[3],
						s = i[6],
						a = i[1],
						c = i[4],
						l = i[7];
					return (
						(i[0] = e * r + n * a),
						(i[3] = e * o + n * c),
						(i[6] = e * s + n * l),
						(i[1] = -n * r + e * a),
						(i[4] = -n * o + e * c),
						(i[7] = -n * s + e * l),
						this
					);
				},
				translate: function (t, e) {
					const n = this.elements;
					return (
						(n[0] += t * n[2]),
						(n[3] += t * n[5]),
						(n[6] += t * n[8]),
						(n[1] += e * n[2]),
						(n[4] += e * n[5]),
						(n[7] += e * n[8]),
						this
					);
				},
				equals: function (t) {
					const e = this.elements,
						n = t.elements;
					for (let t = 0; t < 9; t++) if (e[t] !== n[t]) return !1;
					return !0;
				},
				fromArray: function (t, e) {
					void 0 === e && (e = 0);
					for (let n = 0; n < 9; n++) this.elements[n] = t[n + e];
					return this;
				},
				toArray: function (t, e) {
					void 0 === t && (t = []), void 0 === e && (e = 0);
					const n = this.elements;
					return (
						(t[e] = n[0]),
						(t[e + 1] = n[1]),
						(t[e + 2] = n[2]),
						(t[e + 3] = n[3]),
						(t[e + 4] = n[4]),
						(t[e + 5] = n[5]),
						(t[e + 6] = n[6]),
						(t[e + 7] = n[7]),
						(t[e + 8] = n[8]),
						t
					);
				},
			});
		const tl = {
			getDataURL: function (t) {
				if (/^data:/i.test(t.src)) return t.src;
				if ("undefined" == typeof HTMLCanvasElement) return t.src;
				let e;
				if (t instanceof HTMLCanvasElement) e = t;
				else {
					void 0 === $c &&
						($c = document.createElementNS(
							"http://www.w3.org/1999/xhtml",
							"canvas"
						)),
						($c.width = t.width),
						($c.height = t.height);
					const n = $c.getContext("2d");
					t instanceof ImageData
						? n.putImageData(t, 0, 0)
						: n.drawImage(t, 0, 0, t.width, t.height),
						(e = $c);
				}
				return e.width > 2048 || e.height > 2048
					? e.toDataURL("image/jpeg", 0.6)
					: e.toDataURL("image/png");
			},
		};
		let el = 0;
		function nl(t, e, n, i, r, o, s, a, c, l) {
			Object.defineProperty(this, "id", { value: el++ }),
				(this.uuid = Jc.generateUUID()),
				(this.name = ""),
				(this.image = void 0 !== t ? t : nl.DEFAULT_IMAGE),
				(this.mipmaps = []),
				(this.mapping = void 0 !== e ? e : nl.DEFAULT_MAPPING),
				(this.wrapS = void 0 !== n ? n : ca),
				(this.wrapT = void 0 !== i ? i : ca),
				(this.magFilter = void 0 !== r ? r : pa),
				(this.minFilter = void 0 !== o ? o : ma),
				(this.anisotropy = void 0 !== c ? c : 1),
				(this.format = void 0 !== s ? s : Ra),
				(this.internalFormat = null),
				(this.type = void 0 !== a ? a : ga),
				(this.offset = new Kc(0, 0)),
				(this.repeat = new Kc(1, 1)),
				(this.center = new Kc(0, 0)),
				(this.rotation = 0),
				(this.matrixAutoUpdate = !0),
				(this.matrix = new Qc()),
				(this.generateMipmaps = !0),
				(this.premultiplyAlpha = !1),
				(this.flipY = !0),
				(this.unpackAlignment = 4),
				(this.encoding = void 0 !== l ? l : Oc),
				(this.version = 0),
				(this.onUpdate = null);
		}
		function il(t = 0, e = 0, n = 0, i = 1) {
			(this.x = t), (this.y = e), (this.z = n), (this.w = i);
		}
		function rl(t, e, n) {
			(this.width = t),
				(this.height = e),
				(this.scissor = new il(0, 0, t, e)),
				(this.scissorTest = !1),
				(this.viewport = new il(0, 0, t, e)),
				(n = n || {}),
				(this.texture = new nl(
					void 0,
					n.mapping,
					n.wrapS,
					n.wrapT,
					n.magFilter,
					n.minFilter,
					n.format,
					n.type,
					n.anisotropy,
					n.encoding
				)),
				(this.texture.image = {}),
				(this.texture.image.width = t),
				(this.texture.image.height = e),
				(this.texture.generateMipmaps =
					void 0 !== n.generateMipmaps && n.generateMipmaps),
				(this.texture.minFilter = void 0 !== n.minFilter ? n.minFilter : pa),
				(this.depthBuffer = void 0 === n.depthBuffer || n.depthBuffer),
				(this.stencilBuffer = void 0 === n.stencilBuffer || n.stencilBuffer),
				(this.depthTexture = void 0 !== n.depthTexture ? n.depthTexture : null);
		}
		function ol(t, e, n) {
			rl.call(this, t, e, n), (this.samples = 4);
		}
		function sl(t = 0, e = 0, n = 0, i = 1) {
			(this._x = t), (this._y = e), (this._z = n), (this._w = i);
		}
		(nl.DEFAULT_IMAGE = void 0),
			(nl.DEFAULT_MAPPING = 300),
			(nl.prototype = Object.assign(Object.create(Xc.prototype), {
				constructor: nl,
				isTexture: !0,
				updateMatrix: function () {
					this.matrix.setUvTransform(
						this.offset.x,
						this.offset.y,
						this.repeat.x,
						this.repeat.y,
						this.rotation,
						this.center.x,
						this.center.y
					);
				},
				clone: function () {
					return new this.constructor().copy(this);
				},
				copy: function (t) {
					return (
						(this.name = t.name),
						(this.image = t.image),
						(this.mipmaps = t.mipmaps.slice(0)),
						(this.mapping = t.mapping),
						(this.wrapS = t.wrapS),
						(this.wrapT = t.wrapT),
						(this.magFilter = t.magFilter),
						(this.minFilter = t.minFilter),
						(this.anisotropy = t.anisotropy),
						(this.format = t.format),
						(this.internalFormat = t.internalFormat),
						(this.type = t.type),
						this.offset.copy(t.offset),
						this.repeat.copy(t.repeat),
						this.center.copy(t.center),
						(this.rotation = t.rotation),
						(this.matrixAutoUpdate = t.matrixAutoUpdate),
						this.matrix.copy(t.matrix),
						(this.generateMipmaps = t.generateMipmaps),
						(this.premultiplyAlpha = t.premultiplyAlpha),
						(this.flipY = t.flipY),
						(this.unpackAlignment = t.unpackAlignment),
						(this.encoding = t.encoding),
						this
					);
				},
				toJSON: function (t) {
					const e = void 0 === t || "string" == typeof t;
					if (!e && void 0 !== t.textures[this.uuid])
						return t.textures[this.uuid];
					const n = {
						metadata: {
							version: 4.5,
							type: "Texture",
							generator: "Texture.toJSON",
						},
						uuid: this.uuid,
						name: this.name,
						mapping: this.mapping,
						repeat: [this.repeat.x, this.repeat.y],
						offset: [this.offset.x, this.offset.y],
						center: [this.center.x, this.center.y],
						rotation: this.rotation,
						wrap: [this.wrapS, this.wrapT],
						format: this.format,
						type: this.type,
						encoding: this.encoding,
						minFilter: this.minFilter,
						magFilter: this.magFilter,
						anisotropy: this.anisotropy,
						flipY: this.flipY,
						premultiplyAlpha: this.premultiplyAlpha,
						unpackAlignment: this.unpackAlignment,
					};
					if (void 0 !== this.image) {
						const i = this.image;
						if (
							(void 0 === i.uuid && (i.uuid = Jc.generateUUID()),
							!e && void 0 === t.images[i.uuid])
						) {
							let e;
							if (Array.isArray(i)) {
								e = [];
								for (let t = 0, n = i.length; t < n; t++)
									e.push(tl.getDataURL(i[t]));
							} else e = tl.getDataURL(i);
							t.images[i.uuid] = { uuid: i.uuid, url: e };
						}
						n.image = i.uuid;
					}
					return e || (t.textures[this.uuid] = n), n;
				},
				dispose: function () {
					this.dispatchEvent({ type: "dispose" });
				},
				transformUv: function (t) {
					if (300 !== this.mapping) return t;
					if ((t.applyMatrix3(this.matrix), t.x < 0 || t.x > 1))
						switch (this.wrapS) {
							case aa:
								t.x = t.x - Math.floor(t.x);
								break;
							case ca:
								t.x = t.x < 0 ? 0 : 1;
								break;
							case la:
								1 === Math.abs(Math.floor(t.x) % 2)
									? (t.x = Math.ceil(t.x) - t.x)
									: (t.x = t.x - Math.floor(t.x));
						}
					if (t.y < 0 || t.y > 1)
						switch (this.wrapT) {
							case aa:
								t.y = t.y - Math.floor(t.y);
								break;
							case ca:
								t.y = t.y < 0 ? 0 : 1;
								break;
							case la:
								1 === Math.abs(Math.floor(t.y) % 2)
									? (t.y = Math.ceil(t.y) - t.y)
									: (t.y = t.y - Math.floor(t.y));
						}
					return this.flipY && (t.y = 1 - t.y), t;
				},
			})),
			Object.defineProperty(nl.prototype, "needsUpdate", {
				set: function (t) {
					!0 === t && this.version++;
				},
			}),
			Object.defineProperties(il.prototype, {
				width: {
					get: function () {
						return this.z;
					},
					set: function (t) {
						this.z = t;
					},
				},
				height: {
					get: function () {
						return this.w;
					},
					set: function (t) {
						this.w = t;
					},
				},
			}),
			Object.assign(il.prototype, {
				isVector4: !0,
				set: function (t, e, n, i) {
					return (this.x = t), (this.y = e), (this.z = n), (this.w = i), this;
				},
				setScalar: function (t) {
					return (this.x = t), (this.y = t), (this.z = t), (this.w = t), this;
				},
				setX: function (t) {
					return (this.x = t), this;
				},
				setY: function (t) {
					return (this.y = t), this;
				},
				setZ: function (t) {
					return (this.z = t), this;
				},
				setW: function (t) {
					return (this.w = t), this;
				},
				setComponent: function (t, e) {
					switch (t) {
						case 0:
							this.x = e;
							break;
						case 1:
							this.y = e;
							break;
						case 2:
							this.z = e;
							break;
						case 3:
							this.w = e;
							break;
						default:
							throw new Error("index is out of range: " + t);
					}
					return this;
				},
				getComponent: function (t) {
					switch (t) {
						case 0:
							return this.x;
						case 1:
							return this.y;
						case 2:
							return this.z;
						case 3:
							return this.w;
						default:
							throw new Error("index is out of range: " + t);
					}
				},
				clone: function () {
					return new this.constructor(this.x, this.y, this.z, this.w);
				},
				copy: function (t) {
					return (
						(this.x = t.x),
						(this.y = t.y),
						(this.z = t.z),
						(this.w = void 0 !== t.w ? t.w : 1),
						this
					);
				},
				add: function (t, e) {
					return void 0 !== e
						? (console.warn(
								"THREE.Vector4: .add() now only accepts one argument. Use .addVectors( a, b ) instead."
						  ),
						  this.addVectors(t, e))
						: ((this.x += t.x),
						  (this.y += t.y),
						  (this.z += t.z),
						  (this.w += t.w),
						  this);
				},
				addScalar: function (t) {
					return (
						(this.x += t), (this.y += t), (this.z += t), (this.w += t), this
					);
				},
				addVectors: function (t, e) {
					return (
						(this.x = t.x + e.x),
						(this.y = t.y + e.y),
						(this.z = t.z + e.z),
						(this.w = t.w + e.w),
						this
					);
				},
				addScaledVector: function (t, e) {
					return (
						(this.x += t.x * e),
						(this.y += t.y * e),
						(this.z += t.z * e),
						(this.w += t.w * e),
						this
					);
				},
				sub: function (t, e) {
					return void 0 !== e
						? (console.warn(
								"THREE.Vector4: .sub() now only accepts one argument. Use .subVectors( a, b ) instead."
						  ),
						  this.subVectors(t, e))
						: ((this.x -= t.x),
						  (this.y -= t.y),
						  (this.z -= t.z),
						  (this.w -= t.w),
						  this);
				},
				subScalar: function (t) {
					return (
						(this.x -= t), (this.y -= t), (this.z -= t), (this.w -= t), this
					);
				},
				subVectors: function (t, e) {
					return (
						(this.x = t.x - e.x),
						(this.y = t.y - e.y),
						(this.z = t.z - e.z),
						(this.w = t.w - e.w),
						this
					);
				},
				multiplyScalar: function (t) {
					return (
						(this.x *= t), (this.y *= t), (this.z *= t), (this.w *= t), this
					);
				},
				applyMatrix4: function (t) {
					const e = this.x,
						n = this.y,
						i = this.z,
						r = this.w,
						o = t.elements;
					return (
						(this.x = o[0] * e + o[4] * n + o[8] * i + o[12] * r),
						(this.y = o[1] * e + o[5] * n + o[9] * i + o[13] * r),
						(this.z = o[2] * e + o[6] * n + o[10] * i + o[14] * r),
						(this.w = o[3] * e + o[7] * n + o[11] * i + o[15] * r),
						this
					);
				},
				divideScalar: function (t) {
					return this.multiplyScalar(1 / t);
				},
				setAxisAngleFromQuaternion: function (t) {
					this.w = 2 * Math.acos(t.w);
					const e = Math.sqrt(1 - t.w * t.w);
					return (
						e < 1e-4
							? ((this.x = 1), (this.y = 0), (this.z = 0))
							: ((this.x = t.x / e), (this.y = t.y / e), (this.z = t.z / e)),
						this
					);
				},
				setAxisAngleFromRotationMatrix: function (t) {
					let e, n, i, r;
					const o = t.elements,
						s = o[0],
						a = o[4],
						c = o[8],
						l = o[1],
						h = o[5],
						u = o[9],
						d = o[2],
						p = o[6],
						f = o[10];
					if (
						Math.abs(a - l) < 0.01 &&
						Math.abs(c - d) < 0.01 &&
						Math.abs(u - p) < 0.01
					) {
						if (
							Math.abs(a + l) < 0.1 &&
							Math.abs(c + d) < 0.1 &&
							Math.abs(u + p) < 0.1 &&
							Math.abs(s + h + f - 3) < 0.1
						)
							return this.set(1, 0, 0, 0), this;
						e = Math.PI;
						const t = (s + 1) / 2,
							o = (h + 1) / 2,
							m = (f + 1) / 2,
							g = (a + l) / 4,
							v = (c + d) / 4,
							y = (u + p) / 4;
						return (
							t > o && t > m
								? t < 0.01
									? ((n = 0), (i = 0.707106781), (r = 0.707106781))
									: ((i = g / (n = Math.sqrt(t))), (r = v / n))
								: o > m
								? o < 0.01
									? ((n = 0.707106781), (i = 0), (r = 0.707106781))
									: ((n = g / (i = Math.sqrt(o))), (r = y / i))
								: m < 0.01
								? ((n = 0.707106781), (i = 0.707106781), (r = 0))
								: ((n = v / (r = Math.sqrt(m))), (i = y / r)),
							this.set(n, i, r, e),
							this
						);
					}
					let m = Math.sqrt(
						(p - u) * (p - u) + (c - d) * (c - d) + (l - a) * (l - a)
					);
					return (
						Math.abs(m) < 0.001 && (m = 1),
						(this.x = (p - u) / m),
						(this.y = (c - d) / m),
						(this.z = (l - a) / m),
						(this.w = Math.acos((s + h + f - 1) / 2)),
						this
					);
				},
				min: function (t) {
					return (
						(this.x = Math.min(this.x, t.x)),
						(this.y = Math.min(this.y, t.y)),
						(this.z = Math.min(this.z, t.z)),
						(this.w = Math.min(this.w, t.w)),
						this
					);
				},
				max: function (t) {
					return (
						(this.x = Math.max(this.x, t.x)),
						(this.y = Math.max(this.y, t.y)),
						(this.z = Math.max(this.z, t.z)),
						(this.w = Math.max(this.w, t.w)),
						this
					);
				},
				clamp: function (t, e) {
					return (
						(this.x = Math.max(t.x, Math.min(e.x, this.x))),
						(this.y = Math.max(t.y, Math.min(e.y, this.y))),
						(this.z = Math.max(t.z, Math.min(e.z, this.z))),
						(this.w = Math.max(t.w, Math.min(e.w, this.w))),
						this
					);
				},
				clampScalar: function (t, e) {
					return (
						(this.x = Math.max(t, Math.min(e, this.x))),
						(this.y = Math.max(t, Math.min(e, this.y))),
						(this.z = Math.max(t, Math.min(e, this.z))),
						(this.w = Math.max(t, Math.min(e, this.w))),
						this
					);
				},
				clampLength: function (t, e) {
					const n = this.length();
					return this.divideScalar(n || 1).multiplyScalar(
						Math.max(t, Math.min(e, n))
					);
				},
				floor: function () {
					return (
						(this.x = Math.floor(this.x)),
						(this.y = Math.floor(this.y)),
						(this.z = Math.floor(this.z)),
						(this.w = Math.floor(this.w)),
						this
					);
				},
				ceil: function () {
					return (
						(this.x = Math.ceil(this.x)),
						(this.y = Math.ceil(this.y)),
						(this.z = Math.ceil(this.z)),
						(this.w = Math.ceil(this.w)),
						this
					);
				},
				round: function () {
					return (
						(this.x = Math.round(this.x)),
						(this.y = Math.round(this.y)),
						(this.z = Math.round(this.z)),
						(this.w = Math.round(this.w)),
						this
					);
				},
				roundToZero: function () {
					return (
						(this.x = this.x < 0 ? Math.ceil(this.x) : Math.floor(this.x)),
						(this.y = this.y < 0 ? Math.ceil(this.y) : Math.floor(this.y)),
						(this.z = this.z < 0 ? Math.ceil(this.z) : Math.floor(this.z)),
						(this.w = this.w < 0 ? Math.ceil(this.w) : Math.floor(this.w)),
						this
					);
				},
				negate: function () {
					return (
						(this.x = -this.x),
						(this.y = -this.y),
						(this.z = -this.z),
						(this.w = -this.w),
						this
					);
				},
				dot: function (t) {
					return this.x * t.x + this.y * t.y + this.z * t.z + this.w * t.w;
				},
				lengthSq: function () {
					return (
						this.x * this.x +
						this.y * this.y +
						this.z * this.z +
						this.w * this.w
					);
				},
				length: function () {
					return Math.sqrt(
						this.x * this.x +
							this.y * this.y +
							this.z * this.z +
							this.w * this.w
					);
				},
				manhattanLength: function () {
					return (
						Math.abs(this.x) +
						Math.abs(this.y) +
						Math.abs(this.z) +
						Math.abs(this.w)
					);
				},
				normalize: function () {
					return this.divideScalar(this.length() || 1);
				},
				setLength: function (t) {
					return this.normalize().multiplyScalar(t);
				},
				lerp: function (t, e) {
					return (
						(this.x += (t.x - this.x) * e),
						(this.y += (t.y - this.y) * e),
						(this.z += (t.z - this.z) * e),
						(this.w += (t.w - this.w) * e),
						this
					);
				},
				lerpVectors: function (t, e, n) {
					return (
						(this.x = t.x + (e.x - t.x) * n),
						(this.y = t.y + (e.y - t.y) * n),
						(this.z = t.z + (e.z - t.z) * n),
						(this.w = t.w + (e.w - t.w) * n),
						this
					);
				},
				equals: function (t) {
					return (
						t.x === this.x && t.y === this.y && t.z === this.z && t.w === this.w
					);
				},
				fromArray: function (t, e) {
					return (
						void 0 === e && (e = 0),
						(this.x = t[e]),
						(this.y = t[e + 1]),
						(this.z = t[e + 2]),
						(this.w = t[e + 3]),
						this
					);
				},
				toArray: function (t, e) {
					return (
						void 0 === t && (t = []),
						void 0 === e && (e = 0),
						(t[e] = this.x),
						(t[e + 1] = this.y),
						(t[e + 2] = this.z),
						(t[e + 3] = this.w),
						t
					);
				},
				fromBufferAttribute: function (t, e, n) {
					return (
						void 0 !== n &&
							console.warn(
								"THREE.Vector4: offset has been removed from .fromBufferAttribute()."
							),
						(this.x = t.getX(e)),
						(this.y = t.getY(e)),
						(this.z = t.getZ(e)),
						(this.w = t.getW(e)),
						this
					);
				},
				random: function () {
					return (
						(this.x = Math.random()),
						(this.y = Math.random()),
						(this.z = Math.random()),
						(this.w = Math.random()),
						this
					);
				},
			}),
			(rl.prototype = Object.assign(Object.create(Xc.prototype), {
				constructor: rl,
				isWebGLRenderTarget: !0,
				setSize: function (t, e) {
					(this.width === t && this.height === e) ||
						((this.width = t),
						(this.height = e),
						(this.texture.image.width = t),
						(this.texture.image.height = e),
						this.dispose()),
						this.viewport.set(0, 0, t, e),
						this.scissor.set(0, 0, t, e);
				},
				clone: function () {
					return new this.constructor().copy(this);
				},
				copy: function (t) {
					return (
						(this.width = t.width),
						(this.height = t.height),
						this.viewport.copy(t.viewport),
						(this.texture = t.texture.clone()),
						(this.depthBuffer = t.depthBuffer),
						(this.stencilBuffer = t.stencilBuffer),
						(this.depthTexture = t.depthTexture),
						this
					);
				},
				dispose: function () {
					this.dispatchEvent({ type: "dispose" });
				},
			})),
			(ol.prototype = Object.assign(Object.create(rl.prototype), {
				constructor: ol,
				isWebGLMultisampleRenderTarget: !0,
				copy: function (t) {
					return (
						rl.prototype.copy.call(this, t), (this.samples = t.samples), this
					);
				},
			})),
			Object.assign(sl, {
				slerp: function (t, e, n, i) {
					return n.copy(t).slerp(e, i);
				},
				slerpFlat: function (t, e, n, i, r, o, s) {
					let a = n[i + 0],
						c = n[i + 1],
						l = n[i + 2],
						h = n[i + 3];
					const u = r[o + 0],
						d = r[o + 1],
						p = r[o + 2],
						f = r[o + 3];
					if (h !== f || a !== u || c !== d || l !== p) {
						let t = 1 - s,
							e = a * u + c * d + l * p + h * f,
							n = e >= 0 ? 1 : -1,
							i = 1 - e * e;
						if (i > Number.EPSILON) {
							const r = Math.sqrt(i),
								o = Math.atan2(r, e * n);
							(t = Math.sin(t * o) / r), (s = Math.sin(s * o) / r);
						}
						const r = s * n;
						if (
							((a = a * t + u * r),
							(c = c * t + d * r),
							(l = l * t + p * r),
							(h = h * t + f * r),
							t === 1 - s)
						) {
							const t = 1 / Math.sqrt(a * a + c * c + l * l + h * h);
							(a *= t), (c *= t), (l *= t), (h *= t);
						}
					}
					(t[e] = a), (t[e + 1] = c), (t[e + 2] = l), (t[e + 3] = h);
				},
				multiplyQuaternionsFlat: function (t, e, n, i, r, o) {
					const s = n[i],
						a = n[i + 1],
						c = n[i + 2],
						l = n[i + 3],
						h = r[o],
						u = r[o + 1],
						d = r[o + 2],
						p = r[o + 3];
					return (
						(t[e] = s * p + l * h + a * d - c * u),
						(t[e + 1] = a * p + l * u + c * h - s * d),
						(t[e + 2] = c * p + l * d + s * u - a * h),
						(t[e + 3] = l * p - s * h - a * u - c * d),
						t
					);
				},
			}),
			Object.defineProperties(sl.prototype, {
				x: {
					get: function () {
						return this._x;
					},
					set: function (t) {
						(this._x = t), this._onChangeCallback();
					},
				},
				y: {
					get: function () {
						return this._y;
					},
					set: function (t) {
						(this._y = t), this._onChangeCallback();
					},
				},
				z: {
					get: function () {
						return this._z;
					},
					set: function (t) {
						(this._z = t), this._onChangeCallback();
					},
				},
				w: {
					get: function () {
						return this._w;
					},
					set: function (t) {
						(this._w = t), this._onChangeCallback();
					},
				},
			}),
			Object.assign(sl.prototype, {
				isQuaternion: !0,
				set: function (t, e, n, i) {
					return (
						(this._x = t),
						(this._y = e),
						(this._z = n),
						(this._w = i),
						this._onChangeCallback(),
						this
					);
				},
				clone: function () {
					return new this.constructor(this._x, this._y, this._z, this._w);
				},
				copy: function (t) {
					return (
						(this._x = t.x),
						(this._y = t.y),
						(this._z = t.z),
						(this._w = t.w),
						this._onChangeCallback(),
						this
					);
				},
				setFromEuler: function (t, e) {
					if (!t || !t.isEuler)
						throw new Error(
							"THREE.Quaternion: .setFromEuler() now expects an Euler rotation rather than a Vector3 and order."
						);
					const n = t._x,
						i = t._y,
						r = t._z,
						o = t.order,
						s = Math.cos,
						a = Math.sin,
						c = s(n / 2),
						l = s(i / 2),
						h = s(r / 2),
						u = a(n / 2),
						d = a(i / 2),
						p = a(r / 2);
					switch (o) {
						case "XYZ":
							(this._x = u * l * h + c * d * p),
								(this._y = c * d * h - u * l * p),
								(this._z = c * l * p + u * d * h),
								(this._w = c * l * h - u * d * p);
							break;
						case "YXZ":
							(this._x = u * l * h + c * d * p),
								(this._y = c * d * h - u * l * p),
								(this._z = c * l * p - u * d * h),
								(this._w = c * l * h + u * d * p);
							break;
						case "ZXY":
							(this._x = u * l * h - c * d * p),
								(this._y = c * d * h + u * l * p),
								(this._z = c * l * p + u * d * h),
								(this._w = c * l * h - u * d * p);
							break;
						case "ZYX":
							(this._x = u * l * h - c * d * p),
								(this._y = c * d * h + u * l * p),
								(this._z = c * l * p - u * d * h),
								(this._w = c * l * h + u * d * p);
							break;
						case "YZX":
							(this._x = u * l * h + c * d * p),
								(this._y = c * d * h + u * l * p),
								(this._z = c * l * p - u * d * h),
								(this._w = c * l * h - u * d * p);
							break;
						case "XZY":
							(this._x = u * l * h - c * d * p),
								(this._y = c * d * h - u * l * p),
								(this._z = c * l * p + u * d * h),
								(this._w = c * l * h + u * d * p);
							break;
						default:
							console.warn(
								"THREE.Quaternion: .setFromEuler() encountered an unknown order: " +
									o
							);
					}
					return !1 !== e && this._onChangeCallback(), this;
				},
				setFromAxisAngle: function (t, e) {
					const n = e / 2,
						i = Math.sin(n);
					return (
						(this._x = t.x * i),
						(this._y = t.y * i),
						(this._z = t.z * i),
						(this._w = Math.cos(n)),
						this._onChangeCallback(),
						this
					);
				},
				setFromRotationMatrix: function (t) {
					const e = t.elements,
						n = e[0],
						i = e[4],
						r = e[8],
						o = e[1],
						s = e[5],
						a = e[9],
						c = e[2],
						l = e[6],
						h = e[10],
						u = n + s + h;
					if (u > 0) {
						const t = 0.5 / Math.sqrt(u + 1);
						(this._w = 0.25 / t),
							(this._x = (l - a) * t),
							(this._y = (r - c) * t),
							(this._z = (o - i) * t);
					} else if (n > s && n > h) {
						const t = 2 * Math.sqrt(1 + n - s - h);
						(this._w = (l - a) / t),
							(this._x = 0.25 * t),
							(this._y = (i + o) / t),
							(this._z = (r + c) / t);
					} else if (s > h) {
						const t = 2 * Math.sqrt(1 + s - n - h);
						(this._w = (r - c) / t),
							(this._x = (i + o) / t),
							(this._y = 0.25 * t),
							(this._z = (a + l) / t);
					} else {
						const t = 2 * Math.sqrt(1 + h - n - s);
						(this._w = (o - i) / t),
							(this._x = (r + c) / t),
							(this._y = (a + l) / t),
							(this._z = 0.25 * t);
					}
					return this._onChangeCallback(), this;
				},
				setFromUnitVectors: function (t, e) {
					let n = t.dot(e) + 1;
					return (
						n < 1e-6
							? ((n = 0),
							  Math.abs(t.x) > Math.abs(t.z)
									? ((this._x = -t.y),
									  (this._y = t.x),
									  (this._z = 0),
									  (this._w = n))
									: ((this._x = 0),
									  (this._y = -t.z),
									  (this._z = t.y),
									  (this._w = n)))
							: ((this._x = t.y * e.z - t.z * e.y),
							  (this._y = t.z * e.x - t.x * e.z),
							  (this._z = t.x * e.y - t.y * e.x),
							  (this._w = n)),
						this.normalize()
					);
				},
				angleTo: function (t) {
					return 2 * Math.acos(Math.abs(Jc.clamp(this.dot(t), -1, 1)));
				},
				rotateTowards: function (t, e) {
					const n = this.angleTo(t);
					if (0 === n) return this;
					const i = Math.min(1, e / n);
					return this.slerp(t, i), this;
				},
				inverse: function () {
					return this.conjugate();
				},
				conjugate: function () {
					return (
						(this._x *= -1),
						(this._y *= -1),
						(this._z *= -1),
						this._onChangeCallback(),
						this
					);
				},
				dot: function (t) {
					return (
						this._x * t._x + this._y * t._y + this._z * t._z + this._w * t._w
					);
				},
				lengthSq: function () {
					return (
						this._x * this._x +
						this._y * this._y +
						this._z * this._z +
						this._w * this._w
					);
				},
				length: function () {
					return Math.sqrt(
						this._x * this._x +
							this._y * this._y +
							this._z * this._z +
							this._w * this._w
					);
				},
				normalize: function () {
					let t = this.length();
					return (
						0 === t
							? ((this._x = 0), (this._y = 0), (this._z = 0), (this._w = 1))
							: ((t = 1 / t),
							  (this._x = this._x * t),
							  (this._y = this._y * t),
							  (this._z = this._z * t),
							  (this._w = this._w * t)),
						this._onChangeCallback(),
						this
					);
				},
				multiply: function (t, e) {
					return void 0 !== e
						? (console.warn(
								"THREE.Quaternion: .multiply() now only accepts one argument. Use .multiplyQuaternions( a, b ) instead."
						  ),
						  this.multiplyQuaternions(t, e))
						: this.multiplyQuaternions(this, t);
				},
				premultiply: function (t) {
					return this.multiplyQuaternions(t, this);
				},
				multiplyQuaternions: function (t, e) {
					const n = t._x,
						i = t._y,
						r = t._z,
						o = t._w,
						s = e._x,
						a = e._y,
						c = e._z,
						l = e._w;
					return (
						(this._x = n * l + o * s + i * c - r * a),
						(this._y = i * l + o * a + r * s - n * c),
						(this._z = r * l + o * c + n * a - i * s),
						(this._w = o * l - n * s - i * a - r * c),
						this._onChangeCallback(),
						this
					);
				},
				slerp: function (t, e) {
					if (0 === e) return this;
					if (1 === e) return this.copy(t);
					const n = this._x,
						i = this._y,
						r = this._z,
						o = this._w;
					let s = o * t._w + n * t._x + i * t._y + r * t._z;
					if (
						(s < 0
							? ((this._w = -t._w),
							  (this._x = -t._x),
							  (this._y = -t._y),
							  (this._z = -t._z),
							  (s = -s))
							: this.copy(t),
						s >= 1)
					)
						return (
							(this._w = o), (this._x = n), (this._y = i), (this._z = r), this
						);
					const a = 1 - s * s;
					if (a <= Number.EPSILON) {
						const t = 1 - e;
						return (
							(this._w = t * o + e * this._w),
							(this._x = t * n + e * this._x),
							(this._y = t * i + e * this._y),
							(this._z = t * r + e * this._z),
							this.normalize(),
							this._onChangeCallback(),
							this
						);
					}
					const c = Math.sqrt(a),
						l = Math.atan2(c, s),
						h = Math.sin((1 - e) * l) / c,
						u = Math.sin(e * l) / c;
					return (
						(this._w = o * h + this._w * u),
						(this._x = n * h + this._x * u),
						(this._y = i * h + this._y * u),
						(this._z = r * h + this._z * u),
						this._onChangeCallback(),
						this
					);
				},
				equals: function (t) {
					return (
						t._x === this._x &&
						t._y === this._y &&
						t._z === this._z &&
						t._w === this._w
					);
				},
				fromArray: function (t, e) {
					return (
						void 0 === e && (e = 0),
						(this._x = t[e]),
						(this._y = t[e + 1]),
						(this._z = t[e + 2]),
						(this._w = t[e + 3]),
						this._onChangeCallback(),
						this
					);
				},
				toArray: function (t, e) {
					return (
						void 0 === t && (t = []),
						void 0 === e && (e = 0),
						(t[e] = this._x),
						(t[e + 1] = this._y),
						(t[e + 2] = this._z),
						(t[e + 3] = this._w),
						t
					);
				},
				fromBufferAttribute: function (t, e) {
					return (
						(this._x = t.getX(e)),
						(this._y = t.getY(e)),
						(this._z = t.getZ(e)),
						(this._w = t.getW(e)),
						this
					);
				},
				_onChange: function (t) {
					return (this._onChangeCallback = t), this;
				},
				_onChangeCallback: function () {},
			});
		const al = new ll(),
			cl = new sl();
		function ll(t = 0, e = 0, n = 0) {
			(this.x = t), (this.y = e), (this.z = n);
		}
		Object.assign(ll.prototype, {
			isVector3: !0,
			set: function (t, e, n) {
				return (this.x = t), (this.y = e), (this.z = n), this;
			},
			setScalar: function (t) {
				return (this.x = t), (this.y = t), (this.z = t), this;
			},
			setX: function (t) {
				return (this.x = t), this;
			},
			setY: function (t) {
				return (this.y = t), this;
			},
			setZ: function (t) {
				return (this.z = t), this;
			},
			setComponent: function (t, e) {
				switch (t) {
					case 0:
						this.x = e;
						break;
					case 1:
						this.y = e;
						break;
					case 2:
						this.z = e;
						break;
					default:
						throw new Error("index is out of range: " + t);
				}
				return this;
			},
			getComponent: function (t) {
				switch (t) {
					case 0:
						return this.x;
					case 1:
						return this.y;
					case 2:
						return this.z;
					default:
						throw new Error("index is out of range: " + t);
				}
			},
			clone: function () {
				return new this.constructor(this.x, this.y, this.z);
			},
			copy: function (t) {
				return (this.x = t.x), (this.y = t.y), (this.z = t.z), this;
			},
			add: function (t, e) {
				return void 0 !== e
					? (console.warn(
							"THREE.Vector3: .add() now only accepts one argument. Use .addVectors( a, b ) instead."
					  ),
					  this.addVectors(t, e))
					: ((this.x += t.x), (this.y += t.y), (this.z += t.z), this);
			},
			addScalar: function (t) {
				return (this.x += t), (this.y += t), (this.z += t), this;
			},
			addVectors: function (t, e) {
				return (
					(this.x = t.x + e.x), (this.y = t.y + e.y), (this.z = t.z + e.z), this
				);
			},
			addScaledVector: function (t, e) {
				return (
					(this.x += t.x * e), (this.y += t.y * e), (this.z += t.z * e), this
				);
			},
			sub: function (t, e) {
				return void 0 !== e
					? (console.warn(
							"THREE.Vector3: .sub() now only accepts one argument. Use .subVectors( a, b ) instead."
					  ),
					  this.subVectors(t, e))
					: ((this.x -= t.x), (this.y -= t.y), (this.z -= t.z), this);
			},
			subScalar: function (t) {
				return (this.x -= t), (this.y -= t), (this.z -= t), this;
			},
			subVectors: function (t, e) {
				return (
					(this.x = t.x - e.x), (this.y = t.y - e.y), (this.z = t.z - e.z), this
				);
			},
			multiply: function (t, e) {
				return void 0 !== e
					? (console.warn(
							"THREE.Vector3: .multiply() now only accepts one argument. Use .multiplyVectors( a, b ) instead."
					  ),
					  this.multiplyVectors(t, e))
					: ((this.x *= t.x), (this.y *= t.y), (this.z *= t.z), this);
			},
			multiplyScalar: function (t) {
				return (this.x *= t), (this.y *= t), (this.z *= t), this;
			},
			multiplyVectors: function (t, e) {
				return (
					(this.x = t.x * e.x), (this.y = t.y * e.y), (this.z = t.z * e.z), this
				);
			},
			applyEuler: function (t) {
				return (
					(t && t.isEuler) ||
						console.error(
							"THREE.Vector3: .applyEuler() now expects an Euler rotation rather than a Vector3 and order."
						),
					this.applyQuaternion(cl.setFromEuler(t))
				);
			},
			applyAxisAngle: function (t, e) {
				return this.applyQuaternion(cl.setFromAxisAngle(t, e));
			},
			applyMatrix3: function (t) {
				const e = this.x,
					n = this.y,
					i = this.z,
					r = t.elements;
				return (
					(this.x = r[0] * e + r[3] * n + r[6] * i),
					(this.y = r[1] * e + r[4] * n + r[7] * i),
					(this.z = r[2] * e + r[5] * n + r[8] * i),
					this
				);
			},
			applyNormalMatrix: function (t) {
				return this.applyMatrix3(t).normalize();
			},
			applyMatrix4: function (t) {
				const e = this.x,
					n = this.y,
					i = this.z,
					r = t.elements,
					o = 1 / (r[3] * e + r[7] * n + r[11] * i + r[15]);
				return (
					(this.x = (r[0] * e + r[4] * n + r[8] * i + r[12]) * o),
					(this.y = (r[1] * e + r[5] * n + r[9] * i + r[13]) * o),
					(this.z = (r[2] * e + r[6] * n + r[10] * i + r[14]) * o),
					this
				);
			},
			applyQuaternion: function (t) {
				const e = this.x,
					n = this.y,
					i = this.z,
					r = t.x,
					o = t.y,
					s = t.z,
					a = t.w,
					c = a * e + o * i - s * n,
					l = a * n + s * e - r * i,
					h = a * i + r * n - o * e,
					u = -r * e - o * n - s * i;
				return (
					(this.x = c * a + u * -r + l * -s - h * -o),
					(this.y = l * a + u * -o + h * -r - c * -s),
					(this.z = h * a + u * -s + c * -o - l * -r),
					this
				);
			},
			project: function (t) {
				return this.applyMatrix4(t.matrixWorldInverse).applyMatrix4(
					t.projectionMatrix
				);
			},
			unproject: function (t) {
				return this.applyMatrix4(t.projectionMatrixInverse).applyMatrix4(
					t.matrixWorld
				);
			},
			transformDirection: function (t) {
				const e = this.x,
					n = this.y,
					i = this.z,
					r = t.elements;
				return (
					(this.x = r[0] * e + r[4] * n + r[8] * i),
					(this.y = r[1] * e + r[5] * n + r[9] * i),
					(this.z = r[2] * e + r[6] * n + r[10] * i),
					this.normalize()
				);
			},
			divide: function (t) {
				return (this.x /= t.x), (this.y /= t.y), (this.z /= t.z), this;
			},
			divideScalar: function (t) {
				return this.multiplyScalar(1 / t);
			},
			min: function (t) {
				return (
					(this.x = Math.min(this.x, t.x)),
					(this.y = Math.min(this.y, t.y)),
					(this.z = Math.min(this.z, t.z)),
					this
				);
			},
			max: function (t) {
				return (
					(this.x = Math.max(this.x, t.x)),
					(this.y = Math.max(this.y, t.y)),
					(this.z = Math.max(this.z, t.z)),
					this
				);
			},
			clamp: function (t, e) {
				return (
					(this.x = Math.max(t.x, Math.min(e.x, this.x))),
					(this.y = Math.max(t.y, Math.min(e.y, this.y))),
					(this.z = Math.max(t.z, Math.min(e.z, this.z))),
					this
				);
			},
			clampScalar: function (t, e) {
				return (
					(this.x = Math.max(t, Math.min(e, this.x))),
					(this.y = Math.max(t, Math.min(e, this.y))),
					(this.z = Math.max(t, Math.min(e, this.z))),
					this
				);
			},
			clampLength: function (t, e) {
				const n = this.length();
				return this.divideScalar(n || 1).multiplyScalar(
					Math.max(t, Math.min(e, n))
				);
			},
			floor: function () {
				return (
					(this.x = Math.floor(this.x)),
					(this.y = Math.floor(this.y)),
					(this.z = Math.floor(this.z)),
					this
				);
			},
			ceil: function () {
				return (
					(this.x = Math.ceil(this.x)),
					(this.y = Math.ceil(this.y)),
					(this.z = Math.ceil(this.z)),
					this
				);
			},
			round: function () {
				return (
					(this.x = Math.round(this.x)),
					(this.y = Math.round(this.y)),
					(this.z = Math.round(this.z)),
					this
				);
			},
			roundToZero: function () {
				return (
					(this.x = this.x < 0 ? Math.ceil(this.x) : Math.floor(this.x)),
					(this.y = this.y < 0 ? Math.ceil(this.y) : Math.floor(this.y)),
					(this.z = this.z < 0 ? Math.ceil(this.z) : Math.floor(this.z)),
					this
				);
			},
			negate: function () {
				return (this.x = -this.x), (this.y = -this.y), (this.z = -this.z), this;
			},
			dot: function (t) {
				return this.x * t.x + this.y * t.y + this.z * t.z;
			},
			lengthSq: function () {
				return this.x * this.x + this.y * this.y + this.z * this.z;
			},
			length: function () {
				return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z);
			},
			manhattanLength: function () {
				return Math.abs(this.x) + Math.abs(this.y) + Math.abs(this.z);
			},
			normalize: function () {
				return this.divideScalar(this.length() || 1);
			},
			setLength: function (t) {
				return this.normalize().multiplyScalar(t);
			},
			lerp: function (t, e) {
				return (
					(this.x += (t.x - this.x) * e),
					(this.y += (t.y - this.y) * e),
					(this.z += (t.z - this.z) * e),
					this
				);
			},
			lerpVectors: function (t, e, n) {
				return (
					(this.x = t.x + (e.x - t.x) * n),
					(this.y = t.y + (e.y - t.y) * n),
					(this.z = t.z + (e.z - t.z) * n),
					this
				);
			},
			cross: function (t, e) {
				return void 0 !== e
					? (console.warn(
							"THREE.Vector3: .cross() now only accepts one argument. Use .crossVectors( a, b ) instead."
					  ),
					  this.crossVectors(t, e))
					: this.crossVectors(this, t);
			},
			crossVectors: function (t, e) {
				const n = t.x,
					i = t.y,
					r = t.z,
					o = e.x,
					s = e.y,
					a = e.z;
				return (
					(this.x = i * a - r * s),
					(this.y = r * o - n * a),
					(this.z = n * s - i * o),
					this
				);
			},
			projectOnVector: function (t) {
				const e = t.lengthSq();
				if (0 === e) return this.set(0, 0, 0);
				const n = t.dot(this) / e;
				return this.copy(t).multiplyScalar(n);
			},
			projectOnPlane: function (t) {
				return al.copy(this).projectOnVector(t), this.sub(al);
			},
			reflect: function (t) {
				return this.sub(al.copy(t).multiplyScalar(2 * this.dot(t)));
			},
			angleTo: function (t) {
				const e = Math.sqrt(this.lengthSq() * t.lengthSq());
				if (0 === e) return Math.PI / 2;
				const n = this.dot(t) / e;
				return Math.acos(Jc.clamp(n, -1, 1));
			},
			distanceTo: function (t) {
				return Math.sqrt(this.distanceToSquared(t));
			},
			distanceToSquared: function (t) {
				const e = this.x - t.x,
					n = this.y - t.y,
					i = this.z - t.z;
				return e * e + n * n + i * i;
			},
			manhattanDistanceTo: function (t) {
				return (
					Math.abs(this.x - t.x) +
					Math.abs(this.y - t.y) +
					Math.abs(this.z - t.z)
				);
			},
			setFromSpherical: function (t) {
				return this.setFromSphericalCoords(t.radius, t.phi, t.theta);
			},
			setFromSphericalCoords: function (t, e, n) {
				const i = Math.sin(e) * t;
				return (
					(this.x = i * Math.sin(n)),
					(this.y = Math.cos(e) * t),
					(this.z = i * Math.cos(n)),
					this
				);
			},
			setFromCylindrical: function (t) {
				return this.setFromCylindricalCoords(t.radius, t.theta, t.y);
			},
			setFromCylindricalCoords: function (t, e, n) {
				return (
					(this.x = t * Math.sin(e)),
					(this.y = n),
					(this.z = t * Math.cos(e)),
					this
				);
			},
			setFromMatrixPosition: function (t) {
				const e = t.elements;
				return (this.x = e[12]), (this.y = e[13]), (this.z = e[14]), this;
			},
			setFromMatrixScale: function (t) {
				const e = this.setFromMatrixColumn(t, 0).length(),
					n = this.setFromMatrixColumn(t, 1).length(),
					i = this.setFromMatrixColumn(t, 2).length();
				return (this.x = e), (this.y = n), (this.z = i), this;
			},
			setFromMatrixColumn: function (t, e) {
				return this.fromArray(t.elements, 4 * e);
			},
			setFromMatrix3Column: function (t, e) {
				return this.fromArray(t.elements, 3 * e);
			},
			equals: function (t) {
				return t.x === this.x && t.y === this.y && t.z === this.z;
			},
			fromArray: function (t, e) {
				return (
					void 0 === e && (e = 0),
					(this.x = t[e]),
					(this.y = t[e + 1]),
					(this.z = t[e + 2]),
					this
				);
			},
			toArray: function (t, e) {
				return (
					void 0 === t && (t = []),
					void 0 === e && (e = 0),
					(t[e] = this.x),
					(t[e + 1] = this.y),
					(t[e + 2] = this.z),
					t
				);
			},
			fromBufferAttribute: function (t, e, n) {
				return (
					void 0 !== n &&
						console.warn(
							"THREE.Vector3: offset has been removed from .fromBufferAttribute()."
						),
					(this.x = t.getX(e)),
					(this.y = t.getY(e)),
					(this.z = t.getZ(e)),
					this
				);
			},
			random: function () {
				return (
					(this.x = Math.random()),
					(this.y = Math.random()),
					(this.z = Math.random()),
					this
				);
			},
		});
		const hl = new ll(),
			ul = new vl(),
			dl = new ll(0, 0, 0),
			pl = new ll(1, 1, 1),
			fl = new ll(),
			ml = new ll(),
			gl = new ll();
		function vl() {
			(this.elements = [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1]),
				arguments.length > 0 &&
					console.error(
						"THREE.Matrix4: the constructor no longer reads arguments. use .set() instead."
					);
		}
		Object.assign(vl.prototype, {
			isMatrix4: !0,
			set: function (t, e, n, i, r, o, s, a, c, l, h, u, d, p, f, m) {
				const g = this.elements;
				return (
					(g[0] = t),
					(g[4] = e),
					(g[8] = n),
					(g[12] = i),
					(g[1] = r),
					(g[5] = o),
					(g[9] = s),
					(g[13] = a),
					(g[2] = c),
					(g[6] = l),
					(g[10] = h),
					(g[14] = u),
					(g[3] = d),
					(g[7] = p),
					(g[11] = f),
					(g[15] = m),
					this
				);
			},
			identity: function () {
				return this.set(1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1), this;
			},
			clone: function () {
				return new vl().fromArray(this.elements);
			},
			copy: function (t) {
				const e = this.elements,
					n = t.elements;
				return (
					(e[0] = n[0]),
					(e[1] = n[1]),
					(e[2] = n[2]),
					(e[3] = n[3]),
					(e[4] = n[4]),
					(e[5] = n[5]),
					(e[6] = n[6]),
					(e[7] = n[7]),
					(e[8] = n[8]),
					(e[9] = n[9]),
					(e[10] = n[10]),
					(e[11] = n[11]),
					(e[12] = n[12]),
					(e[13] = n[13]),
					(e[14] = n[14]),
					(e[15] = n[15]),
					this
				);
			},
			copyPosition: function (t) {
				const e = this.elements,
					n = t.elements;
				return (e[12] = n[12]), (e[13] = n[13]), (e[14] = n[14]), this;
			},
			extractBasis: function (t, e, n) {
				return (
					t.setFromMatrixColumn(this, 0),
					e.setFromMatrixColumn(this, 1),
					n.setFromMatrixColumn(this, 2),
					this
				);
			},
			makeBasis: function (t, e, n) {
				return (
					this.set(
						t.x,
						e.x,
						n.x,
						0,
						t.y,
						e.y,
						n.y,
						0,
						t.z,
						e.z,
						n.z,
						0,
						0,
						0,
						0,
						1
					),
					this
				);
			},
			extractRotation: function (t) {
				const e = this.elements,
					n = t.elements,
					i = 1 / hl.setFromMatrixColumn(t, 0).length(),
					r = 1 / hl.setFromMatrixColumn(t, 1).length(),
					o = 1 / hl.setFromMatrixColumn(t, 2).length();
				return (
					(e[0] = n[0] * i),
					(e[1] = n[1] * i),
					(e[2] = n[2] * i),
					(e[3] = 0),
					(e[4] = n[4] * r),
					(e[5] = n[5] * r),
					(e[6] = n[6] * r),
					(e[7] = 0),
					(e[8] = n[8] * o),
					(e[9] = n[9] * o),
					(e[10] = n[10] * o),
					(e[11] = 0),
					(e[12] = 0),
					(e[13] = 0),
					(e[14] = 0),
					(e[15] = 1),
					this
				);
			},
			makeRotationFromEuler: function (t) {
				(t && t.isEuler) ||
					console.error(
						"THREE.Matrix4: .makeRotationFromEuler() now expects a Euler rotation rather than a Vector3 and order."
					);
				const e = this.elements,
					n = t.x,
					i = t.y,
					r = t.z,
					o = Math.cos(n),
					s = Math.sin(n),
					a = Math.cos(i),
					c = Math.sin(i),
					l = Math.cos(r),
					h = Math.sin(r);
				if ("XYZ" === t.order) {
					const t = o * l,
						n = o * h,
						i = s * l,
						r = s * h;
					(e[0] = a * l),
						(e[4] = -a * h),
						(e[8] = c),
						(e[1] = n + i * c),
						(e[5] = t - r * c),
						(e[9] = -s * a),
						(e[2] = r - t * c),
						(e[6] = i + n * c),
						(e[10] = o * a);
				} else if ("YXZ" === t.order) {
					const t = a * l,
						n = a * h,
						i = c * l,
						r = c * h;
					(e[0] = t + r * s),
						(e[4] = i * s - n),
						(e[8] = o * c),
						(e[1] = o * h),
						(e[5] = o * l),
						(e[9] = -s),
						(e[2] = n * s - i),
						(e[6] = r + t * s),
						(e[10] = o * a);
				} else if ("ZXY" === t.order) {
					const t = a * l,
						n = a * h,
						i = c * l,
						r = c * h;
					(e[0] = t - r * s),
						(e[4] = -o * h),
						(e[8] = i + n * s),
						(e[1] = n + i * s),
						(e[5] = o * l),
						(e[9] = r - t * s),
						(e[2] = -o * c),
						(e[6] = s),
						(e[10] = o * a);
				} else if ("ZYX" === t.order) {
					const t = o * l,
						n = o * h,
						i = s * l,
						r = s * h;
					(e[0] = a * l),
						(e[4] = i * c - n),
						(e[8] = t * c + r),
						(e[1] = a * h),
						(e[5] = r * c + t),
						(e[9] = n * c - i),
						(e[2] = -c),
						(e[6] = s * a),
						(e[10] = o * a);
				} else if ("YZX" === t.order) {
					const t = o * a,
						n = o * c,
						i = s * a,
						r = s * c;
					(e[0] = a * l),
						(e[4] = r - t * h),
						(e[8] = i * h + n),
						(e[1] = h),
						(e[5] = o * l),
						(e[9] = -s * l),
						(e[2] = -c * l),
						(e[6] = n * h + i),
						(e[10] = t - r * h);
				} else if ("XZY" === t.order) {
					const t = o * a,
						n = o * c,
						i = s * a,
						r = s * c;
					(e[0] = a * l),
						(e[4] = -h),
						(e[8] = c * l),
						(e[1] = t * h + r),
						(e[5] = o * l),
						(e[9] = n * h - i),
						(e[2] = i * h - n),
						(e[6] = s * l),
						(e[10] = r * h + t);
				}
				return (
					(e[3] = 0),
					(e[7] = 0),
					(e[11] = 0),
					(e[12] = 0),
					(e[13] = 0),
					(e[14] = 0),
					(e[15] = 1),
					this
				);
			},
			makeRotationFromQuaternion: function (t) {
				return this.compose(dl, t, pl);
			},
			lookAt: function (t, e, n) {
				const i = this.elements;
				return (
					gl.subVectors(t, e),
					0 === gl.lengthSq() && (gl.z = 1),
					gl.normalize(),
					fl.crossVectors(n, gl),
					0 === fl.lengthSq() &&
						(1 === Math.abs(n.z) ? (gl.x += 1e-4) : (gl.z += 1e-4),
						gl.normalize(),
						fl.crossVectors(n, gl)),
					fl.normalize(),
					ml.crossVectors(gl, fl),
					(i[0] = fl.x),
					(i[4] = ml.x),
					(i[8] = gl.x),
					(i[1] = fl.y),
					(i[5] = ml.y),
					(i[9] = gl.y),
					(i[2] = fl.z),
					(i[6] = ml.z),
					(i[10] = gl.z),
					this
				);
			},
			multiply: function (t, e) {
				return void 0 !== e
					? (console.warn(
							"THREE.Matrix4: .multiply() now only accepts one argument. Use .multiplyMatrices( a, b ) instead."
					  ),
					  this.multiplyMatrices(t, e))
					: this.multiplyMatrices(this, t);
			},
			premultiply: function (t) {
				return this.multiplyMatrices(t, this);
			},
			multiplyMatrices: function (t, e) {
				const n = t.elements,
					i = e.elements,
					r = this.elements,
					o = n[0],
					s = n[4],
					a = n[8],
					c = n[12],
					l = n[1],
					h = n[5],
					u = n[9],
					d = n[13],
					p = n[2],
					f = n[6],
					m = n[10],
					g = n[14],
					v = n[3],
					y = n[7],
					x = n[11],
					b = n[15],
					w = i[0],
					_ = i[4],
					M = i[8],
					S = i[12],
					T = i[1],
					E = i[5],
					A = i[9],
					L = i[13],
					P = i[2],
					R = i[6],
					C = i[10],
					O = i[14],
					D = i[3],
					I = i[7],
					k = i[11],
					N = i[15];
				return (
					(r[0] = o * w + s * T + a * P + c * D),
					(r[4] = o * _ + s * E + a * R + c * I),
					(r[8] = o * M + s * A + a * C + c * k),
					(r[12] = o * S + s * L + a * O + c * N),
					(r[1] = l * w + h * T + u * P + d * D),
					(r[5] = l * _ + h * E + u * R + d * I),
					(r[9] = l * M + h * A + u * C + d * k),
					(r[13] = l * S + h * L + u * O + d * N),
					(r[2] = p * w + f * T + m * P + g * D),
					(r[6] = p * _ + f * E + m * R + g * I),
					(r[10] = p * M + f * A + m * C + g * k),
					(r[14] = p * S + f * L + m * O + g * N),
					(r[3] = v * w + y * T + x * P + b * D),
					(r[7] = v * _ + y * E + x * R + b * I),
					(r[11] = v * M + y * A + x * C + b * k),
					(r[15] = v * S + y * L + x * O + b * N),
					this
				);
			},
			multiplyScalar: function (t) {
				const e = this.elements;
				return (
					(e[0] *= t),
					(e[4] *= t),
					(e[8] *= t),
					(e[12] *= t),
					(e[1] *= t),
					(e[5] *= t),
					(e[9] *= t),
					(e[13] *= t),
					(e[2] *= t),
					(e[6] *= t),
					(e[10] *= t),
					(e[14] *= t),
					(e[3] *= t),
					(e[7] *= t),
					(e[11] *= t),
					(e[15] *= t),
					this
				);
			},
			determinant: function () {
				const t = this.elements,
					e = t[0],
					n = t[4],
					i = t[8],
					r = t[12],
					o = t[1],
					s = t[5],
					a = t[9],
					c = t[13],
					l = t[2],
					h = t[6],
					u = t[10],
					d = t[14];
				return (
					t[3] *
						(+r * a * h -
							i * c * h -
							r * s * u +
							n * c * u +
							i * s * d -
							n * a * d) +
					t[7] *
						(+e * a * d -
							e * c * u +
							r * o * u -
							i * o * d +
							i * c * l -
							r * a * l) +
					t[11] *
						(+e * c * h -
							e * s * d -
							r * o * h +
							n * o * d +
							r * s * l -
							n * c * l) +
					t[15] *
						(-i * s * l -
							e * a * h +
							e * s * u +
							i * o * h -
							n * o * u +
							n * a * l)
				);
			},
			transpose: function () {
				const t = this.elements;
				let e;
				return (
					(e = t[1]),
					(t[1] = t[4]),
					(t[4] = e),
					(e = t[2]),
					(t[2] = t[8]),
					(t[8] = e),
					(e = t[6]),
					(t[6] = t[9]),
					(t[9] = e),
					(e = t[3]),
					(t[3] = t[12]),
					(t[12] = e),
					(e = t[7]),
					(t[7] = t[13]),
					(t[13] = e),
					(e = t[11]),
					(t[11] = t[14]),
					(t[14] = e),
					this
				);
			},
			setPosition: function (t, e, n) {
				const i = this.elements;
				return (
					t.isVector3
						? ((i[12] = t.x), (i[13] = t.y), (i[14] = t.z))
						: ((i[12] = t), (i[13] = e), (i[14] = n)),
					this
				);
			},
			getInverse: function (t, e) {
				void 0 !== e &&
					console.warn(
						"THREE.Matrix4: .getInverse() can no longer be configured to throw on degenerate."
					);
				const n = this.elements,
					i = t.elements,
					r = i[0],
					o = i[1],
					s = i[2],
					a = i[3],
					c = i[4],
					l = i[5],
					h = i[6],
					u = i[7],
					d = i[8],
					p = i[9],
					f = i[10],
					m = i[11],
					g = i[12],
					v = i[13],
					y = i[14],
					x = i[15],
					b =
						p * y * u -
						v * f * u +
						v * h * m -
						l * y * m -
						p * h * x +
						l * f * x,
					w =
						g * f * u -
						d * y * u -
						g * h * m +
						c * y * m +
						d * h * x -
						c * f * x,
					_ =
						d * v * u -
						g * p * u +
						g * l * m -
						c * v * m -
						d * l * x +
						c * p * x,
					M =
						g * p * h -
						d * v * h -
						g * l * f +
						c * v * f +
						d * l * y -
						c * p * y,
					S = r * b + o * w + s * _ + a * M;
				if (0 === S)
					return this.set(0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0);
				const T = 1 / S;
				return (
					(n[0] = b * T),
					(n[1] =
						(v * f * a -
							p * y * a -
							v * s * m +
							o * y * m +
							p * s * x -
							o * f * x) *
						T),
					(n[2] =
						(l * y * a -
							v * h * a +
							v * s * u -
							o * y * u -
							l * s * x +
							o * h * x) *
						T),
					(n[3] =
						(p * h * a -
							l * f * a -
							p * s * u +
							o * f * u +
							l * s * m -
							o * h * m) *
						T),
					(n[4] = w * T),
					(n[5] =
						(d * y * a -
							g * f * a +
							g * s * m -
							r * y * m -
							d * s * x +
							r * f * x) *
						T),
					(n[6] =
						(g * h * a -
							c * y * a -
							g * s * u +
							r * y * u +
							c * s * x -
							r * h * x) *
						T),
					(n[7] =
						(c * f * a -
							d * h * a +
							d * s * u -
							r * f * u -
							c * s * m +
							r * h * m) *
						T),
					(n[8] = _ * T),
					(n[9] =
						(g * p * a -
							d * v * a -
							g * o * m +
							r * v * m +
							d * o * x -
							r * p * x) *
						T),
					(n[10] =
						(c * v * a -
							g * l * a +
							g * o * u -
							r * v * u -
							c * o * x +
							r * l * x) *
						T),
					(n[11] =
						(d * l * a -
							c * p * a -
							d * o * u +
							r * p * u +
							c * o * m -
							r * l * m) *
						T),
					(n[12] = M * T),
					(n[13] =
						(d * v * s -
							g * p * s +
							g * o * f -
							r * v * f -
							d * o * y +
							r * p * y) *
						T),
					(n[14] =
						(g * l * s -
							c * v * s -
							g * o * h +
							r * v * h +
							c * o * y -
							r * l * y) *
						T),
					(n[15] =
						(c * p * s -
							d * l * s +
							d * o * h -
							r * p * h -
							c * o * f +
							r * l * f) *
						T),
					this
				);
			},
			scale: function (t) {
				const e = this.elements,
					n = t.x,
					i = t.y,
					r = t.z;
				return (
					(e[0] *= n),
					(e[4] *= i),
					(e[8] *= r),
					(e[1] *= n),
					(e[5] *= i),
					(e[9] *= r),
					(e[2] *= n),
					(e[6] *= i),
					(e[10] *= r),
					(e[3] *= n),
					(e[7] *= i),
					(e[11] *= r),
					this
				);
			},
			getMaxScaleOnAxis: function () {
				const t = this.elements,
					e = t[0] * t[0] + t[1] * t[1] + t[2] * t[2],
					n = t[4] * t[4] + t[5] * t[5] + t[6] * t[6],
					i = t[8] * t[8] + t[9] * t[9] + t[10] * t[10];
				return Math.sqrt(Math.max(e, n, i));
			},
			makeTranslation: function (t, e, n) {
				return this.set(1, 0, 0, t, 0, 1, 0, e, 0, 0, 1, n, 0, 0, 0, 1), this;
			},
			makeRotationX: function (t) {
				const e = Math.cos(t),
					n = Math.sin(t);
				return this.set(1, 0, 0, 0, 0, e, -n, 0, 0, n, e, 0, 0, 0, 0, 1), this;
			},
			makeRotationY: function (t) {
				const e = Math.cos(t),
					n = Math.sin(t);
				return this.set(e, 0, n, 0, 0, 1, 0, 0, -n, 0, e, 0, 0, 0, 0, 1), this;
			},
			makeRotationZ: function (t) {
				const e = Math.cos(t),
					n = Math.sin(t);
				return this.set(e, -n, 0, 0, n, e, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1), this;
			},
			makeRotationAxis: function (t, e) {
				const n = Math.cos(e),
					i = Math.sin(e),
					r = 1 - n,
					o = t.x,
					s = t.y,
					a = t.z,
					c = r * o,
					l = r * s;
				return (
					this.set(
						c * o + n,
						c * s - i * a,
						c * a + i * s,
						0,
						c * s + i * a,
						l * s + n,
						l * a - i * o,
						0,
						c * a - i * s,
						l * a + i * o,
						r * a * a + n,
						0,
						0,
						0,
						0,
						1
					),
					this
				);
			},
			makeScale: function (t, e, n) {
				return this.set(t, 0, 0, 0, 0, e, 0, 0, 0, 0, n, 0, 0, 0, 0, 1), this;
			},
			makeShear: function (t, e, n) {
				return this.set(1, e, n, 0, t, 1, n, 0, t, e, 1, 0, 0, 0, 0, 1), this;
			},
			compose: function (t, e, n) {
				const i = this.elements,
					r = e._x,
					o = e._y,
					s = e._z,
					a = e._w,
					c = r + r,
					l = o + o,
					h = s + s,
					u = r * c,
					d = r * l,
					p = r * h,
					f = o * l,
					m = o * h,
					g = s * h,
					v = a * c,
					y = a * l,
					x = a * h,
					b = n.x,
					w = n.y,
					_ = n.z;
				return (
					(i[0] = (1 - (f + g)) * b),
					(i[1] = (d + x) * b),
					(i[2] = (p - y) * b),
					(i[3] = 0),
					(i[4] = (d - x) * w),
					(i[5] = (1 - (u + g)) * w),
					(i[6] = (m + v) * w),
					(i[7] = 0),
					(i[8] = (p + y) * _),
					(i[9] = (m - v) * _),
					(i[10] = (1 - (u + f)) * _),
					(i[11] = 0),
					(i[12] = t.x),
					(i[13] = t.y),
					(i[14] = t.z),
					(i[15] = 1),
					this
				);
			},
			decompose: function (t, e, n) {
				const i = this.elements;
				let r = hl.set(i[0], i[1], i[2]).length(),
					o = hl.set(i[4], i[5], i[6]).length(),
					s = hl.set(i[8], i[9], i[10]).length();
				this.determinant() < 0 && (r = -r),
					(t.x = i[12]),
					(t.y = i[13]),
					(t.z = i[14]),
					ul.copy(this);
				const a = 1 / r,
					c = 1 / o,
					l = 1 / s;
				return (
					(ul.elements[0] *= a),
					(ul.elements[1] *= a),
					(ul.elements[2] *= a),
					(ul.elements[4] *= c),
					(ul.elements[5] *= c),
					(ul.elements[6] *= c),
					(ul.elements[8] *= l),
					(ul.elements[9] *= l),
					(ul.elements[10] *= l),
					e.setFromRotationMatrix(ul),
					(n.x = r),
					(n.y = o),
					(n.z = s),
					this
				);
			},
			makePerspective: function (t, e, n, i, r, o) {
				void 0 === o &&
					console.warn(
						"THREE.Matrix4: .makePerspective() has been redefined and has a new signature. Please check the docs."
					);
				const s = this.elements,
					a = (2 * r) / (e - t),
					c = (2 * r) / (n - i),
					l = (e + t) / (e - t),
					h = (n + i) / (n - i),
					u = -(o + r) / (o - r),
					d = (-2 * o * r) / (o - r);
				return (
					(s[0] = a),
					(s[4] = 0),
					(s[8] = l),
					(s[12] = 0),
					(s[1] = 0),
					(s[5] = c),
					(s[9] = h),
					(s[13] = 0),
					(s[2] = 0),
					(s[6] = 0),
					(s[10] = u),
					(s[14] = d),
					(s[3] = 0),
					(s[7] = 0),
					(s[11] = -1),
					(s[15] = 0),
					this
				);
			},
			makeOrthographic: function (t, e, n, i, r, o) {
				const s = this.elements,
					a = 1 / (e - t),
					c = 1 / (n - i),
					l = 1 / (o - r),
					h = (e + t) * a,
					u = (n + i) * c,
					d = (o + r) * l;
				return (
					(s[0] = 2 * a),
					(s[4] = 0),
					(s[8] = 0),
					(s[12] = -h),
					(s[1] = 0),
					(s[5] = 2 * c),
					(s[9] = 0),
					(s[13] = -u),
					(s[2] = 0),
					(s[6] = 0),
					(s[10] = -2 * l),
					(s[14] = -d),
					(s[3] = 0),
					(s[7] = 0),
					(s[11] = 0),
					(s[15] = 1),
					this
				);
			},
			equals: function (t) {
				const e = this.elements,
					n = t.elements;
				for (let t = 0; t < 16; t++) if (e[t] !== n[t]) return !1;
				return !0;
			},
			fromArray: function (t, e) {
				void 0 === e && (e = 0);
				for (let n = 0; n < 16; n++) this.elements[n] = t[n + e];
				return this;
			},
			toArray: function (t, e) {
				void 0 === t && (t = []), void 0 === e && (e = 0);
				const n = this.elements;
				return (
					(t[e] = n[0]),
					(t[e + 1] = n[1]),
					(t[e + 2] = n[2]),
					(t[e + 3] = n[3]),
					(t[e + 4] = n[4]),
					(t[e + 5] = n[5]),
					(t[e + 6] = n[6]),
					(t[e + 7] = n[7]),
					(t[e + 8] = n[8]),
					(t[e + 9] = n[9]),
					(t[e + 10] = n[10]),
					(t[e + 11] = n[11]),
					(t[e + 12] = n[12]),
					(t[e + 13] = n[13]),
					(t[e + 14] = n[14]),
					(t[e + 15] = n[15]),
					t
				);
			},
		});
		const yl = new vl(),
			xl = new sl();
		function bl(t = 0, e = 0, n = 0, i = bl.DefaultOrder) {
			(this._x = t), (this._y = e), (this._z = n), (this._order = i);
		}
		function wl() {
			this.mask = 1;
		}
		(bl.RotationOrders = ["XYZ", "YZX", "ZXY", "XZY", "YXZ", "ZYX"]),
			(bl.DefaultOrder = "XYZ"),
			Object.defineProperties(bl.prototype, {
				x: {
					get: function () {
						return this._x;
					},
					set: function (t) {
						(this._x = t), this._onChangeCallback();
					},
				},
				y: {
					get: function () {
						return this._y;
					},
					set: function (t) {
						(this._y = t), this._onChangeCallback();
					},
				},
				z: {
					get: function () {
						return this._z;
					},
					set: function (t) {
						(this._z = t), this._onChangeCallback();
					},
				},
				order: {
					get: function () {
						return this._order;
					},
					set: function (t) {
						(this._order = t), this._onChangeCallback();
					},
				},
			}),
			Object.assign(bl.prototype, {
				isEuler: !0,
				set: function (t, e, n, i) {
					return (
						(this._x = t),
						(this._y = e),
						(this._z = n),
						(this._order = i || this._order),
						this._onChangeCallback(),
						this
					);
				},
				clone: function () {
					return new this.constructor(this._x, this._y, this._z, this._order);
				},
				copy: function (t) {
					return (
						(this._x = t._x),
						(this._y = t._y),
						(this._z = t._z),
						(this._order = t._order),
						this._onChangeCallback(),
						this
					);
				},
				setFromRotationMatrix: function (t, e, n) {
					const i = Jc.clamp,
						r = t.elements,
						o = r[0],
						s = r[4],
						a = r[8],
						c = r[1],
						l = r[5],
						h = r[9],
						u = r[2],
						d = r[6],
						p = r[10];
					switch ((e = e || this._order)) {
						case "XYZ":
							(this._y = Math.asin(i(a, -1, 1))),
								Math.abs(a) < 0.9999999
									? ((this._x = Math.atan2(-h, p)),
									  (this._z = Math.atan2(-s, o)))
									: ((this._x = Math.atan2(d, l)), (this._z = 0));
							break;
						case "YXZ":
							(this._x = Math.asin(-i(h, -1, 1))),
								Math.abs(h) < 0.9999999
									? ((this._y = Math.atan2(a, p)), (this._z = Math.atan2(c, l)))
									: ((this._y = Math.atan2(-u, o)), (this._z = 0));
							break;
						case "ZXY":
							(this._x = Math.asin(i(d, -1, 1))),
								Math.abs(d) < 0.9999999
									? ((this._y = Math.atan2(-u, p)),
									  (this._z = Math.atan2(-s, l)))
									: ((this._y = 0), (this._z = Math.atan2(c, o)));
							break;
						case "ZYX":
							(this._y = Math.asin(-i(u, -1, 1))),
								Math.abs(u) < 0.9999999
									? ((this._x = Math.atan2(d, p)), (this._z = Math.atan2(c, o)))
									: ((this._x = 0), (this._z = Math.atan2(-s, l)));
							break;
						case "YZX":
							(this._z = Math.asin(i(c, -1, 1))),
								Math.abs(c) < 0.9999999
									? ((this._x = Math.atan2(-h, l)),
									  (this._y = Math.atan2(-u, o)))
									: ((this._x = 0), (this._y = Math.atan2(a, p)));
							break;
						case "XZY":
							(this._z = Math.asin(-i(s, -1, 1))),
								Math.abs(s) < 0.9999999
									? ((this._x = Math.atan2(d, l)), (this._y = Math.atan2(a, o)))
									: ((this._x = Math.atan2(-h, p)), (this._y = 0));
							break;
						default:
							console.warn(
								"THREE.Euler: .setFromRotationMatrix() encountered an unknown order: " +
									e
							);
					}
					return (this._order = e), !1 !== n && this._onChangeCallback(), this;
				},
				setFromQuaternion: function (t, e, n) {
					return (
						yl.makeRotationFromQuaternion(t),
						this.setFromRotationMatrix(yl, e, n)
					);
				},
				setFromVector3: function (t, e) {
					return this.set(t.x, t.y, t.z, e || this._order);
				},
				reorder: function (t) {
					return xl.setFromEuler(this), this.setFromQuaternion(xl, t);
				},
				equals: function (t) {
					return (
						t._x === this._x &&
						t._y === this._y &&
						t._z === this._z &&
						t._order === this._order
					);
				},
				fromArray: function (t) {
					return (
						(this._x = t[0]),
						(this._y = t[1]),
						(this._z = t[2]),
						void 0 !== t[3] && (this._order = t[3]),
						this._onChangeCallback(),
						this
					);
				},
				toArray: function (t, e) {
					return (
						void 0 === t && (t = []),
						void 0 === e && (e = 0),
						(t[e] = this._x),
						(t[e + 1] = this._y),
						(t[e + 2] = this._z),
						(t[e + 3] = this._order),
						t
					);
				},
				toVector3: function (t) {
					return t
						? t.set(this._x, this._y, this._z)
						: new ll(this._x, this._y, this._z);
				},
				_onChange: function (t) {
					return (this._onChangeCallback = t), this;
				},
				_onChangeCallback: function () {},
			}),
			Object.assign(wl.prototype, {
				set: function (t) {
					this.mask = (1 << t) | 0;
				},
				enable: function (t) {
					this.mask |= (1 << t) | 0;
				},
				enableAll: function () {
					this.mask = -1;
				},
				toggle: function (t) {
					this.mask ^= (1 << t) | 0;
				},
				disable: function (t) {
					this.mask &= ~((1 << t) | 0);
				},
				disableAll: function () {
					this.mask = 0;
				},
				test: function (t) {
					return 0 != (this.mask & t.mask);
				},
			});
		let _l = 0;
		const Ml = new ll(),
			Sl = new sl(),
			Tl = new vl(),
			El = new ll(),
			Al = new ll(),
			Ll = new ll(),
			Pl = new sl(),
			Rl = new ll(1, 0, 0),
			Cl = new ll(0, 1, 0),
			Ol = new ll(0, 0, 1),
			Dl = { type: "added" },
			Il = { type: "removed" };
		function kl() {
			Object.defineProperty(this, "id", { value: _l++ }),
				(this.uuid = Jc.generateUUID()),
				(this.name = ""),
				(this.type = "Object3D"),
				(this.parent = null),
				(this.children = []),
				(this.up = kl.DefaultUp.clone());
			const t = new ll(),
				e = new bl(),
				n = new sl(),
				i = new ll(1, 1, 1);
			e._onChange(function () {
				n.setFromEuler(e, !1);
			}),
				n._onChange(function () {
					e.setFromQuaternion(n, void 0, !1);
				}),
				Object.defineProperties(this, {
					position: { configurable: !0, enumerable: !0, value: t },
					rotation: { configurable: !0, enumerable: !0, value: e },
					quaternion: { configurable: !0, enumerable: !0, value: n },
					scale: { configurable: !0, enumerable: !0, value: i },
					modelViewMatrix: { value: new vl() },
					normalMatrix: { value: new Qc() },
				}),
				(this.matrix = new vl()),
				(this.matrixWorld = new vl()),
				(this.matrixAutoUpdate = kl.DefaultMatrixAutoUpdate),
				(this.matrixWorldNeedsUpdate = !1),
				(this.layers = new wl()),
				(this.visible = !0),
				(this.castShadow = !1),
				(this.receiveShadow = !1),
				(this.frustumCulled = !0),
				(this.renderOrder = 0),
				(this.userData = {});
		}
		function Nl() {
			kl.call(this),
				(this.type = "Scene"),
				(this.background = null),
				(this.environment = null),
				(this.fog = null),
				(this.overrideMaterial = null),
				(this.autoUpdate = !0),
				"undefined" != typeof __THREE_DEVTOOLS__ &&
					__THREE_DEVTOOLS__.dispatchEvent(
						new CustomEvent("observe", { detail: this })
					);
		}
		(kl.DefaultUp = new ll(0, 1, 0)),
			(kl.DefaultMatrixAutoUpdate = !0),
			(kl.prototype = Object.assign(Object.create(Xc.prototype), {
				constructor: kl,
				isObject3D: !0,
				onBeforeRender: function () {},
				onAfterRender: function () {},
				applyMatrix4: function (t) {
					this.matrixAutoUpdate && this.updateMatrix(),
						this.matrix.premultiply(t),
						this.matrix.decompose(this.position, this.quaternion, this.scale);
				},
				applyQuaternion: function (t) {
					return this.quaternion.premultiply(t), this;
				},
				setRotationFromAxisAngle: function (t, e) {
					this.quaternion.setFromAxisAngle(t, e);
				},
				setRotationFromEuler: function (t) {
					this.quaternion.setFromEuler(t, !0);
				},
				setRotationFromMatrix: function (t) {
					this.quaternion.setFromRotationMatrix(t);
				},
				setRotationFromQuaternion: function (t) {
					this.quaternion.copy(t);
				},
				rotateOnAxis: function (t, e) {
					return Sl.setFromAxisAngle(t, e), this.quaternion.multiply(Sl), this;
				},
				rotateOnWorldAxis: function (t, e) {
					return (
						Sl.setFromAxisAngle(t, e), this.quaternion.premultiply(Sl), this
					);
				},
				rotateX: function (t) {
					return this.rotateOnAxis(Rl, t);
				},
				rotateY: function (t) {
					return this.rotateOnAxis(Cl, t);
				},
				rotateZ: function (t) {
					return this.rotateOnAxis(Ol, t);
				},
				translateOnAxis: function (t, e) {
					return (
						Ml.copy(t).applyQuaternion(this.quaternion),
						this.position.add(Ml.multiplyScalar(e)),
						this
					);
				},
				translateX: function (t) {
					return this.translateOnAxis(Rl, t);
				},
				translateY: function (t) {
					return this.translateOnAxis(Cl, t);
				},
				translateZ: function (t) {
					return this.translateOnAxis(Ol, t);
				},
				localToWorld: function (t) {
					return t.applyMatrix4(this.matrixWorld);
				},
				worldToLocal: function (t) {
					return t.applyMatrix4(Tl.getInverse(this.matrixWorld));
				},
				lookAt: function (t, e, n) {
					t.isVector3 ? El.copy(t) : El.set(t, e, n);
					const i = this.parent;
					this.updateWorldMatrix(!0, !1),
						Al.setFromMatrixPosition(this.matrixWorld),
						this.isCamera || this.isLight
							? Tl.lookAt(Al, El, this.up)
							: Tl.lookAt(El, Al, this.up),
						this.quaternion.setFromRotationMatrix(Tl),
						i &&
							(Tl.extractRotation(i.matrixWorld),
							Sl.setFromRotationMatrix(Tl),
							this.quaternion.premultiply(Sl.inverse()));
				},
				add: function (t) {
					if (arguments.length > 1) {
						for (let t = 0; t < arguments.length; t++) this.add(arguments[t]);
						return this;
					}
					return t === this
						? (console.error(
								"THREE.Object3D.add: object can't be added as a child of itself.",
								t
						  ),
						  this)
						: (t && t.isObject3D
								? (null !== t.parent && t.parent.remove(t),
								  (t.parent = this),
								  this.children.push(t),
								  t.dispatchEvent(Dl))
								: console.error(
										"THREE.Object3D.add: object not an instance of THREE.Object3D.",
										t
								  ),
						  this);
				},
				remove: function (t) {
					if (arguments.length > 1) {
						for (let t = 0; t < arguments.length; t++)
							this.remove(arguments[t]);
						return this;
					}
					const e = this.children.indexOf(t);
					return (
						-1 !== e &&
							((t.parent = null),
							this.children.splice(e, 1),
							t.dispatchEvent(Il)),
						this
					);
				},
				attach: function (t) {
					return (
						this.updateWorldMatrix(!0, !1),
						Tl.getInverse(this.matrixWorld),
						null !== t.parent &&
							(t.parent.updateWorldMatrix(!0, !1),
							Tl.multiply(t.parent.matrixWorld)),
						t.applyMatrix4(Tl),
						t.updateWorldMatrix(!1, !1),
						this.add(t),
						this
					);
				},
				getObjectById: function (t) {
					return this.getObjectByProperty("id", t);
				},
				getObjectByName: function (t) {
					return this.getObjectByProperty("name", t);
				},
				getObjectByProperty: function (t, e) {
					if (this[t] === e) return this;
					for (let n = 0, i = this.children.length; n < i; n++) {
						const i = this.children[n].getObjectByProperty(t, e);
						if (void 0 !== i) return i;
					}
				},
				getWorldPosition: function (t) {
					return (
						void 0 === t &&
							(console.warn(
								"THREE.Object3D: .getWorldPosition() target is now required"
							),
							(t = new ll())),
						this.updateMatrixWorld(!0),
						t.setFromMatrixPosition(this.matrixWorld)
					);
				},
				getWorldQuaternion: function (t) {
					return (
						void 0 === t &&
							(console.warn(
								"THREE.Object3D: .getWorldQuaternion() target is now required"
							),
							(t = new sl())),
						this.updateMatrixWorld(!0),
						this.matrixWorld.decompose(Al, t, Ll),
						t
					);
				},
				getWorldScale: function (t) {
					return (
						void 0 === t &&
							(console.warn(
								"THREE.Object3D: .getWorldScale() target is now required"
							),
							(t = new ll())),
						this.updateMatrixWorld(!0),
						this.matrixWorld.decompose(Al, Pl, t),
						t
					);
				},
				getWorldDirection: function (t) {
					void 0 === t &&
						(console.warn(
							"THREE.Object3D: .getWorldDirection() target is now required"
						),
						(t = new ll())),
						this.updateMatrixWorld(!0);
					const e = this.matrixWorld.elements;
					return t.set(e[8], e[9], e[10]).normalize();
				},
				raycast: function () {},
				traverse: function (t) {
					t(this);
					const e = this.children;
					for (let n = 0, i = e.length; n < i; n++) e[n].traverse(t);
				},
				traverseVisible: function (t) {
					if (!1 === this.visible) return;
					t(this);
					const e = this.children;
					for (let n = 0, i = e.length; n < i; n++) e[n].traverseVisible(t);
				},
				traverseAncestors: function (t) {
					const e = this.parent;
					null !== e && (t(e), e.traverseAncestors(t));
				},
				updateMatrix: function () {
					this.matrix.compose(this.position, this.quaternion, this.scale),
						(this.matrixWorldNeedsUpdate = !0);
				},
				updateMatrixWorld: function (t) {
					this.matrixAutoUpdate && this.updateMatrix(),
						(this.matrixWorldNeedsUpdate || t) &&
							(null === this.parent
								? this.matrixWorld.copy(this.matrix)
								: this.matrixWorld.multiplyMatrices(
										this.parent.matrixWorld,
										this.matrix
								  ),
							(this.matrixWorldNeedsUpdate = !1),
							(t = !0));
					const e = this.children;
					for (let n = 0, i = e.length; n < i; n++) e[n].updateMatrixWorld(t);
				},
				updateWorldMatrix: function (t, e) {
					const n = this.parent;
					if (
						(!0 === t && null !== n && n.updateWorldMatrix(!0, !1),
						this.matrixAutoUpdate && this.updateMatrix(),
						null === this.parent
							? this.matrixWorld.copy(this.matrix)
							: this.matrixWorld.multiplyMatrices(
									this.parent.matrixWorld,
									this.matrix
							  ),
						!0 === e)
					) {
						const t = this.children;
						for (let e = 0, n = t.length; e < n; e++)
							t[e].updateWorldMatrix(!1, !0);
					}
				},
				toJSON: function (t) {
					const e = void 0 === t || "string" == typeof t,
						n = {};
					e &&
						((t = {
							geometries: {},
							materials: {},
							textures: {},
							images: {},
							shapes: {},
						}),
						(n.metadata = {
							version: 4.5,
							type: "Object",
							generator: "Object3D.toJSON",
						}));
					const i = {};
					function r(e, n) {
						return void 0 === e[n.uuid] && (e[n.uuid] = n.toJSON(t)), n.uuid;
					}
					if (
						((i.uuid = this.uuid),
						(i.type = this.type),
						"" !== this.name && (i.name = this.name),
						!0 === this.castShadow && (i.castShadow = !0),
						!0 === this.receiveShadow && (i.receiveShadow = !0),
						!1 === this.visible && (i.visible = !1),
						!1 === this.frustumCulled && (i.frustumCulled = !1),
						0 !== this.renderOrder && (i.renderOrder = this.renderOrder),
						"{}" !== JSON.stringify(this.userData) &&
							(i.userData = this.userData),
						(i.layers = this.layers.mask),
						(i.matrix = this.matrix.toArray()),
						!1 === this.matrixAutoUpdate && (i.matrixAutoUpdate = !1),
						this.isInstancedMesh &&
							((i.type = "InstancedMesh"),
							(i.count = this.count),
							(i.instanceMatrix = this.instanceMatrix.toJSON())),
						this.isMesh || this.isLine || this.isPoints)
					) {
						i.geometry = r(t.geometries, this.geometry);
						const e = this.geometry.parameters;
						if (void 0 !== e && void 0 !== e.shapes) {
							const n = e.shapes;
							if (Array.isArray(n))
								for (let e = 0, i = n.length; e < i; e++) {
									const i = n[e];
									r(t.shapes, i);
								}
							else r(t.shapes, n);
						}
					}
					if (void 0 !== this.material)
						if (Array.isArray(this.material)) {
							const e = [];
							for (let n = 0, i = this.material.length; n < i; n++)
								e.push(r(t.materials, this.material[n]));
							i.material = e;
						} else i.material = r(t.materials, this.material);
					if (this.children.length > 0) {
						i.children = [];
						for (let e = 0; e < this.children.length; e++)
							i.children.push(this.children[e].toJSON(t).object);
					}
					if (e) {
						const e = o(t.geometries),
							i = o(t.materials),
							r = o(t.textures),
							s = o(t.images),
							a = o(t.shapes);
						e.length > 0 && (n.geometries = e),
							i.length > 0 && (n.materials = i),
							r.length > 0 && (n.textures = r),
							s.length > 0 && (n.images = s),
							a.length > 0 && (n.shapes = a);
					}
					return (n.object = i), n;
					function o(t) {
						const e = [];
						for (const n in t) {
							const i = t[n];
							delete i.metadata, e.push(i);
						}
						return e;
					}
				},
				clone: function (t) {
					return new this.constructor().copy(this, t);
				},
				copy: function (t, e) {
					if (
						(void 0 === e && (e = !0),
						(this.name = t.name),
						this.up.copy(t.up),
						this.position.copy(t.position),
						this.quaternion.copy(t.quaternion),
						this.scale.copy(t.scale),
						this.matrix.copy(t.matrix),
						this.matrixWorld.copy(t.matrixWorld),
						(this.matrixAutoUpdate = t.matrixAutoUpdate),
						(this.matrixWorldNeedsUpdate = t.matrixWorldNeedsUpdate),
						(this.layers.mask = t.layers.mask),
						(this.visible = t.visible),
						(this.castShadow = t.castShadow),
						(this.receiveShadow = t.receiveShadow),
						(this.frustumCulled = t.frustumCulled),
						(this.renderOrder = t.renderOrder),
						(this.userData = JSON.parse(JSON.stringify(t.userData))),
						!0 === e)
					)
						for (let e = 0; e < t.children.length; e++) {
							const n = t.children[e];
							this.add(n.clone());
						}
					return this;
				},
			})),
			(Nl.prototype = Object.assign(Object.create(kl.prototype), {
				constructor: Nl,
				isScene: !0,
				copy: function (t, e) {
					return (
						kl.prototype.copy.call(this, t, e),
						null !== t.background && (this.background = t.background.clone()),
						null !== t.environment &&
							(this.environment = t.environment.clone()),
						null !== t.fog && (this.fog = t.fog.clone()),
						null !== t.overrideMaterial &&
							(this.overrideMaterial = t.overrideMaterial.clone()),
						(this.autoUpdate = t.autoUpdate),
						(this.matrixAutoUpdate = t.matrixAutoUpdate),
						this
					);
				},
				toJSON: function (t) {
					const e = kl.prototype.toJSON.call(this, t);
					return (
						null !== this.background &&
							(e.object.background = this.background.toJSON(t)),
						null !== this.environment &&
							(e.object.environment = this.environment.toJSON(t)),
						null !== this.fog && (e.object.fog = this.fog.toJSON()),
						e
					);
				},
				dispose: function () {
					this.dispatchEvent({ type: "dispose" });
				},
			}));
		const Bl = [
				new ll(),
				new ll(),
				new ll(),
				new ll(),
				new ll(),
				new ll(),
				new ll(),
				new ll(),
			],
			Fl = new ll(),
			zl = new Jl(),
			Hl = new ll(),
			Ul = new ll(),
			Gl = new ll(),
			Vl = new ll(),
			jl = new ll(),
			Wl = new ll(),
			ql = new ll(),
			Yl = new ll(),
			Xl = new ll(),
			Zl = new ll();
		function Jl(t, e) {
			(this.min = void 0 !== t ? t : new ll(1 / 0, 1 / 0, 1 / 0)),
				(this.max = void 0 !== e ? e : new ll(-1 / 0, -1 / 0, -1 / 0));
		}
		function Kl(t, e, n, i, r) {
			for (let o = 0, s = t.length - 3; o <= s; o += 3) {
				Zl.fromArray(t, o);
				const s =
						r.x * Math.abs(Zl.x) + r.y * Math.abs(Zl.y) + r.z * Math.abs(Zl.z),
					a = e.dot(Zl),
					c = n.dot(Zl),
					l = i.dot(Zl);
				if (Math.max(-Math.max(a, c, l), Math.min(a, c, l)) > s) return !1;
			}
			return !0;
		}
		Object.assign(Jl.prototype, {
			isBox3: !0,
			set: function (t, e) {
				return this.min.copy(t), this.max.copy(e), this;
			},
			setFromArray: function (t) {
				let e = 1 / 0,
					n = 1 / 0,
					i = 1 / 0,
					r = -1 / 0,
					o = -1 / 0,
					s = -1 / 0;
				for (let a = 0, c = t.length; a < c; a += 3) {
					const c = t[a],
						l = t[a + 1],
						h = t[a + 2];
					c < e && (e = c),
						l < n && (n = l),
						h < i && (i = h),
						c > r && (r = c),
						l > o && (o = l),
						h > s && (s = h);
				}
				return this.min.set(e, n, i), this.max.set(r, o, s), this;
			},
			setFromBufferAttribute: function (t) {
				let e = 1 / 0,
					n = 1 / 0,
					i = 1 / 0,
					r = -1 / 0,
					o = -1 / 0,
					s = -1 / 0;
				for (let a = 0, c = t.count; a < c; a++) {
					const c = t.getX(a),
						l = t.getY(a),
						h = t.getZ(a);
					c < e && (e = c),
						l < n && (n = l),
						h < i && (i = h),
						c > r && (r = c),
						l > o && (o = l),
						h > s && (s = h);
				}
				return this.min.set(e, n, i), this.max.set(r, o, s), this;
			},
			setFromPoints: function (t) {
				this.makeEmpty();
				for (let e = 0, n = t.length; e < n; e++) this.expandByPoint(t[e]);
				return this;
			},
			setFromCenterAndSize: function (t, e) {
				const n = Fl.copy(e).multiplyScalar(0.5);
				return this.min.copy(t).sub(n), this.max.copy(t).add(n), this;
			},
			setFromObject: function (t) {
				return this.makeEmpty(), this.expandByObject(t);
			},
			clone: function () {
				return new this.constructor().copy(this);
			},
			copy: function (t) {
				return this.min.copy(t.min), this.max.copy(t.max), this;
			},
			makeEmpty: function () {
				return (
					(this.min.x = this.min.y = this.min.z = 1 / 0),
					(this.max.x = this.max.y = this.max.z = -1 / 0),
					this
				);
			},
			isEmpty: function () {
				return (
					this.max.x < this.min.x ||
					this.max.y < this.min.y ||
					this.max.z < this.min.z
				);
			},
			getCenter: function (t) {
				return (
					void 0 === t &&
						(console.warn("THREE.Box3: .getCenter() target is now required"),
						(t = new ll())),
					this.isEmpty()
						? t.set(0, 0, 0)
						: t.addVectors(this.min, this.max).multiplyScalar(0.5)
				);
			},
			getSize: function (t) {
				return (
					void 0 === t &&
						(console.warn("THREE.Box3: .getSize() target is now required"),
						(t = new ll())),
					this.isEmpty() ? t.set(0, 0, 0) : t.subVectors(this.max, this.min)
				);
			},
			expandByPoint: function (t) {
				return this.min.min(t), this.max.max(t), this;
			},
			expandByVector: function (t) {
				return this.min.sub(t), this.max.add(t), this;
			},
			expandByScalar: function (t) {
				return this.min.addScalar(-t), this.max.addScalar(t), this;
			},
			expandByObject: function (t) {
				t.updateWorldMatrix(!1, !1);
				const e = t.geometry;
				void 0 !== e &&
					(null === e.boundingBox && e.computeBoundingBox(),
					zl.copy(e.boundingBox),
					zl.applyMatrix4(t.matrixWorld),
					this.union(zl));
				const n = t.children;
				for (let t = 0, e = n.length; t < e; t++) this.expandByObject(n[t]);
				return this;
			},
			containsPoint: function (t) {
				return !(
					t.x < this.min.x ||
					t.x > this.max.x ||
					t.y < this.min.y ||
					t.y > this.max.y ||
					t.z < this.min.z ||
					t.z > this.max.z
				);
			},
			containsBox: function (t) {
				return (
					this.min.x <= t.min.x &&
					t.max.x <= this.max.x &&
					this.min.y <= t.min.y &&
					t.max.y <= this.max.y &&
					this.min.z <= t.min.z &&
					t.max.z <= this.max.z
				);
			},
			getParameter: function (t, e) {
				return (
					void 0 === e &&
						(console.warn("THREE.Box3: .getParameter() target is now required"),
						(e = new ll())),
					e.set(
						(t.x - this.min.x) / (this.max.x - this.min.x),
						(t.y - this.min.y) / (this.max.y - this.min.y),
						(t.z - this.min.z) / (this.max.z - this.min.z)
					)
				);
			},
			intersectsBox: function (t) {
				return !(
					t.max.x < this.min.x ||
					t.min.x > this.max.x ||
					t.max.y < this.min.y ||
					t.min.y > this.max.y ||
					t.max.z < this.min.z ||
					t.min.z > this.max.z
				);
			},
			intersectsSphere: function (t) {
				return (
					this.clampPoint(t.center, Fl),
					Fl.distanceToSquared(t.center) <= t.radius * t.radius
				);
			},
			intersectsPlane: function (t) {
				let e, n;
				return (
					t.normal.x > 0
						? ((e = t.normal.x * this.min.x), (n = t.normal.x * this.max.x))
						: ((e = t.normal.x * this.max.x), (n = t.normal.x * this.min.x)),
					t.normal.y > 0
						? ((e += t.normal.y * this.min.y), (n += t.normal.y * this.max.y))
						: ((e += t.normal.y * this.max.y), (n += t.normal.y * this.min.y)),
					t.normal.z > 0
						? ((e += t.normal.z * this.min.z), (n += t.normal.z * this.max.z))
						: ((e += t.normal.z * this.max.z), (n += t.normal.z * this.min.z)),
					e <= -t.constant && n >= -t.constant
				);
			},
			intersectsTriangle: function (t) {
				if (this.isEmpty()) return !1;
				this.getCenter(ql),
					Yl.subVectors(this.max, ql),
					Hl.subVectors(t.a, ql),
					Ul.subVectors(t.b, ql),
					Gl.subVectors(t.c, ql),
					Vl.subVectors(Ul, Hl),
					jl.subVectors(Gl, Ul),
					Wl.subVectors(Hl, Gl);
				let e = [
					0,
					-Vl.z,
					Vl.y,
					0,
					-jl.z,
					jl.y,
					0,
					-Wl.z,
					Wl.y,
					Vl.z,
					0,
					-Vl.x,
					jl.z,
					0,
					-jl.x,
					Wl.z,
					0,
					-Wl.x,
					-Vl.y,
					Vl.x,
					0,
					-jl.y,
					jl.x,
					0,
					-Wl.y,
					Wl.x,
					0,
				];
				return (
					!!Kl(e, Hl, Ul, Gl, Yl) &&
					!!Kl((e = [1, 0, 0, 0, 1, 0, 0, 0, 1]), Hl, Ul, Gl, Yl) &&
					(Xl.crossVectors(Vl, jl),
					Kl((e = [Xl.x, Xl.y, Xl.z]), Hl, Ul, Gl, Yl))
				);
			},
			clampPoint: function (t, e) {
				return (
					void 0 === e &&
						(console.warn("THREE.Box3: .clampPoint() target is now required"),
						(e = new ll())),
					e.copy(t).clamp(this.min, this.max)
				);
			},
			distanceToPoint: function (t) {
				return Fl.copy(t).clamp(this.min, this.max).sub(t).length();
			},
			getBoundingSphere: function (t) {
				return (
					void 0 === t &&
						console.error(
							"THREE.Box3: .getBoundingSphere() target is now required"
						),
					this.getCenter(t.center),
					(t.radius = 0.5 * this.getSize(Fl).length()),
					t
				);
			},
			intersect: function (t) {
				return (
					this.min.max(t.min),
					this.max.min(t.max),
					this.isEmpty() && this.makeEmpty(),
					this
				);
			},
			union: function (t) {
				return this.min.min(t.min), this.max.max(t.max), this;
			},
			applyMatrix4: function (t) {
				return this.isEmpty()
					? this
					: (Bl[0].set(this.min.x, this.min.y, this.min.z).applyMatrix4(t),
					  Bl[1].set(this.min.x, this.min.y, this.max.z).applyMatrix4(t),
					  Bl[2].set(this.min.x, this.max.y, this.min.z).applyMatrix4(t),
					  Bl[3].set(this.min.x, this.max.y, this.max.z).applyMatrix4(t),
					  Bl[4].set(this.max.x, this.min.y, this.min.z).applyMatrix4(t),
					  Bl[5].set(this.max.x, this.min.y, this.max.z).applyMatrix4(t),
					  Bl[6].set(this.max.x, this.max.y, this.min.z).applyMatrix4(t),
					  Bl[7].set(this.max.x, this.max.y, this.max.z).applyMatrix4(t),
					  this.setFromPoints(Bl),
					  this);
			},
			translate: function (t) {
				return this.min.add(t), this.max.add(t), this;
			},
			equals: function (t) {
				return t.min.equals(this.min) && t.max.equals(this.max);
			},
		});
		const Ql = new Jl();
		function $l(t, e) {
			(this.center = void 0 !== t ? t : new ll()),
				(this.radius = void 0 !== e ? e : -1);
		}
		Object.assign($l.prototype, {
			set: function (t, e) {
				return this.center.copy(t), (this.radius = e), this;
			},
			setFromPoints: function (t, e) {
				const n = this.center;
				void 0 !== e ? n.copy(e) : Ql.setFromPoints(t).getCenter(n);
				let i = 0;
				for (let e = 0, r = t.length; e < r; e++)
					i = Math.max(i, n.distanceToSquared(t[e]));
				return (this.radius = Math.sqrt(i)), this;
			},
			clone: function () {
				return new this.constructor().copy(this);
			},
			copy: function (t) {
				return this.center.copy(t.center), (this.radius = t.radius), this;
			},
			isEmpty: function () {
				return this.radius < 0;
			},
			makeEmpty: function () {
				return this.center.set(0, 0, 0), (this.radius = -1), this;
			},
			containsPoint: function (t) {
				return t.distanceToSquared(this.center) <= this.radius * this.radius;
			},
			distanceToPoint: function (t) {
				return t.distanceTo(this.center) - this.radius;
			},
			intersectsSphere: function (t) {
				const e = this.radius + t.radius;
				return t.center.distanceToSquared(this.center) <= e * e;
			},
			intersectsBox: function (t) {
				return t.intersectsSphere(this);
			},
			intersectsPlane: function (t) {
				return Math.abs(t.distanceToPoint(this.center)) <= this.radius;
			},
			clampPoint: function (t, e) {
				const n = this.center.distanceToSquared(t);
				return (
					void 0 === e &&
						(console.warn("THREE.Sphere: .clampPoint() target is now required"),
						(e = new ll())),
					e.copy(t),
					n > this.radius * this.radius &&
						(e.sub(this.center).normalize(),
						e.multiplyScalar(this.radius).add(this.center)),
					e
				);
			},
			getBoundingBox: function (t) {
				return (
					void 0 === t &&
						(console.warn(
							"THREE.Sphere: .getBoundingBox() target is now required"
						),
						(t = new Jl())),
					this.isEmpty()
						? (t.makeEmpty(), t)
						: (t.set(this.center, this.center),
						  t.expandByScalar(this.radius),
						  t)
				);
			},
			applyMatrix4: function (t) {
				return (
					this.center.applyMatrix4(t),
					(this.radius = this.radius * t.getMaxScaleOnAxis()),
					this
				);
			},
			translate: function (t) {
				return this.center.add(t), this;
			},
			equals: function (t) {
				return t.center.equals(this.center) && t.radius === this.radius;
			},
		});
		const th = new ll(),
			eh = new ll(),
			nh = new ll(),
			ih = new ll(),
			rh = new ll(),
			oh = new ll(),
			sh = new ll();
		function ah(t, e) {
			(this.origin = void 0 !== t ? t : new ll()),
				(this.direction = void 0 !== e ? e : new ll(0, 0, -1));
		}
		Object.assign(ah.prototype, {
			set: function (t, e) {
				return this.origin.copy(t), this.direction.copy(e), this;
			},
			clone: function () {
				return new this.constructor().copy(this);
			},
			copy: function (t) {
				return (
					this.origin.copy(t.origin), this.direction.copy(t.direction), this
				);
			},
			at: function (t, e) {
				return (
					void 0 === e &&
						(console.warn("THREE.Ray: .at() target is now required"),
						(e = new ll())),
					e.copy(this.direction).multiplyScalar(t).add(this.origin)
				);
			},
			lookAt: function (t) {
				return this.direction.copy(t).sub(this.origin).normalize(), this;
			},
			recast: function (t) {
				return this.origin.copy(this.at(t, th)), this;
			},
			closestPointToPoint: function (t, e) {
				void 0 === e &&
					(console.warn(
						"THREE.Ray: .closestPointToPoint() target is now required"
					),
					(e = new ll())),
					e.subVectors(t, this.origin);
				const n = e.dot(this.direction);
				return n < 0
					? e.copy(this.origin)
					: e.copy(this.direction).multiplyScalar(n).add(this.origin);
			},
			distanceToPoint: function (t) {
				return Math.sqrt(this.distanceSqToPoint(t));
			},
			distanceSqToPoint: function (t) {
				const e = th.subVectors(t, this.origin).dot(this.direction);
				return e < 0
					? this.origin.distanceToSquared(t)
					: (th.copy(this.direction).multiplyScalar(e).add(this.origin),
					  th.distanceToSquared(t));
			},
			distanceSqToSegment: function (t, e, n, i) {
				eh.copy(t).add(e).multiplyScalar(0.5),
					nh.copy(e).sub(t).normalize(),
					ih.copy(this.origin).sub(eh);
				const r = 0.5 * t.distanceTo(e),
					o = -this.direction.dot(nh),
					s = ih.dot(this.direction),
					a = -ih.dot(nh),
					c = ih.lengthSq(),
					l = Math.abs(1 - o * o);
				let h, u, d, p;
				if (l > 0)
					if (((u = o * s - a), (p = r * l), (h = o * a - s) >= 0))
						if (u >= -p)
							if (u <= p) {
								const t = 1 / l;
								d =
									(h *= t) * (h + o * (u *= t) + 2 * s) +
									u * (o * h + u + 2 * a) +
									c;
							} else
								(u = r),
									(d =
										-(h = Math.max(0, -(o * u + s))) * h + u * (u + 2 * a) + c);
						else
							(u = -r),
								(d =
									-(h = Math.max(0, -(o * u + s))) * h + u * (u + 2 * a) + c);
					else
						u <= -p
							? (d =
									-(h = Math.max(0, -(-o * r + s))) * h +
									(u = h > 0 ? -r : Math.min(Math.max(-r, -a), r)) *
										(u + 2 * a) +
									c)
							: u <= p
							? ((h = 0),
							  (d = (u = Math.min(Math.max(-r, -a), r)) * (u + 2 * a) + c))
							: (d =
									-(h = Math.max(0, -(o * r + s))) * h +
									(u = h > 0 ? r : Math.min(Math.max(-r, -a), r)) *
										(u + 2 * a) +
									c);
				else
					(u = o > 0 ? -r : r),
						(d = -(h = Math.max(0, -(o * u + s))) * h + u * (u + 2 * a) + c);
				return (
					n && n.copy(this.direction).multiplyScalar(h).add(this.origin),
					i && i.copy(nh).multiplyScalar(u).add(eh),
					d
				);
			},
			intersectSphere: function (t, e) {
				th.subVectors(t.center, this.origin);
				const n = th.dot(this.direction),
					i = th.dot(th) - n * n,
					r = t.radius * t.radius;
				if (i > r) return null;
				const o = Math.sqrt(r - i),
					s = n - o,
					a = n + o;
				return s < 0 && a < 0 ? null : s < 0 ? this.at(a, e) : this.at(s, e);
			},
			intersectsSphere: function (t) {
				return this.distanceSqToPoint(t.center) <= t.radius * t.radius;
			},
			distanceToPlane: function (t) {
				const e = t.normal.dot(this.direction);
				if (0 === e) return 0 === t.distanceToPoint(this.origin) ? 0 : null;
				const n = -(this.origin.dot(t.normal) + t.constant) / e;
				return n >= 0 ? n : null;
			},
			intersectPlane: function (t, e) {
				const n = this.distanceToPlane(t);
				return null === n ? null : this.at(n, e);
			},
			intersectsPlane: function (t) {
				const e = t.distanceToPoint(this.origin);
				return 0 === e || t.normal.dot(this.direction) * e < 0;
			},
			intersectBox: function (t, e) {
				let n, i, r, o, s, a;
				const c = 1 / this.direction.x,
					l = 1 / this.direction.y,
					h = 1 / this.direction.z,
					u = this.origin;
				return (
					c >= 0
						? ((n = (t.min.x - u.x) * c), (i = (t.max.x - u.x) * c))
						: ((n = (t.max.x - u.x) * c), (i = (t.min.x - u.x) * c)),
					l >= 0
						? ((r = (t.min.y - u.y) * l), (o = (t.max.y - u.y) * l))
						: ((r = (t.max.y - u.y) * l), (o = (t.min.y - u.y) * l)),
					n > o || r > i
						? null
						: ((r > n || n != n) && (n = r),
						  (o < i || i != i) && (i = o),
						  h >= 0
								? ((s = (t.min.z - u.z) * h), (a = (t.max.z - u.z) * h))
								: ((s = (t.max.z - u.z) * h), (a = (t.min.z - u.z) * h)),
						  n > a || s > i
								? null
								: ((s > n || n != n) && (n = s),
								  (a < i || i != i) && (i = a),
								  i < 0 ? null : this.at(n >= 0 ? n : i, e)))
				);
			},
			intersectsBox: function (t) {
				return null !== this.intersectBox(t, th);
			},
			intersectTriangle: function (t, e, n, i, r) {
				rh.subVectors(e, t), oh.subVectors(n, t), sh.crossVectors(rh, oh);
				let o,
					s = this.direction.dot(sh);
				if (s > 0) {
					if (i) return null;
					o = 1;
				} else {
					if (!(s < 0)) return null;
					(o = -1), (s = -s);
				}
				ih.subVectors(this.origin, t);
				const a = o * this.direction.dot(oh.crossVectors(ih, oh));
				if (a < 0) return null;
				const c = o * this.direction.dot(rh.cross(ih));
				if (c < 0) return null;
				if (a + c > s) return null;
				const l = -o * ih.dot(sh);
				return l < 0 ? null : this.at(l / s, r);
			},
			applyMatrix4: function (t) {
				return (
					this.origin.applyMatrix4(t),
					this.direction.transformDirection(t),
					this
				);
			},
			equals: function (t) {
				return (
					t.origin.equals(this.origin) && t.direction.equals(this.direction)
				);
			},
		});
		const ch = new ll(),
			lh = new ll(),
			hh = new Qc();
		function uh(t, e) {
			(this.normal = void 0 !== t ? t : new ll(1, 0, 0)),
				(this.constant = void 0 !== e ? e : 0);
		}
		Object.assign(uh.prototype, {
			isPlane: !0,
			set: function (t, e) {
				return this.normal.copy(t), (this.constant = e), this;
			},
			setComponents: function (t, e, n, i) {
				return this.normal.set(t, e, n), (this.constant = i), this;
			},
			setFromNormalAndCoplanarPoint: function (t, e) {
				return this.normal.copy(t), (this.constant = -e.dot(this.normal)), this;
			},
			setFromCoplanarPoints: function (t, e, n) {
				const i = ch.subVectors(n, e).cross(lh.subVectors(t, e)).normalize();
				return this.setFromNormalAndCoplanarPoint(i, t), this;
			},
			clone: function () {
				return new this.constructor().copy(this);
			},
			copy: function (t) {
				return this.normal.copy(t.normal), (this.constant = t.constant), this;
			},
			normalize: function () {
				const t = 1 / this.normal.length();
				return this.normal.multiplyScalar(t), (this.constant *= t), this;
			},
			negate: function () {
				return (this.constant *= -1), this.normal.negate(), this;
			},
			distanceToPoint: function (t) {
				return this.normal.dot(t) + this.constant;
			},
			distanceToSphere: function (t) {
				return this.distanceToPoint(t.center) - t.radius;
			},
			projectPoint: function (t, e) {
				return (
					void 0 === e &&
						(console.warn(
							"THREE.Plane: .projectPoint() target is now required"
						),
						(e = new ll())),
					e.copy(this.normal).multiplyScalar(-this.distanceToPoint(t)).add(t)
				);
			},
			intersectLine: function (t, e) {
				void 0 === e &&
					(console.warn("THREE.Plane: .intersectLine() target is now required"),
					(e = new ll()));
				const n = t.delta(ch),
					i = this.normal.dot(n);
				if (0 === i)
					return 0 === this.distanceToPoint(t.start) ? e.copy(t.start) : void 0;
				const r = -(t.start.dot(this.normal) + this.constant) / i;
				return r < 0 || r > 1
					? void 0
					: e.copy(n).multiplyScalar(r).add(t.start);
			},
			intersectsLine: function (t) {
				const e = this.distanceToPoint(t.start),
					n = this.distanceToPoint(t.end);
				return (e < 0 && n > 0) || (n < 0 && e > 0);
			},
			intersectsBox: function (t) {
				return t.intersectsPlane(this);
			},
			intersectsSphere: function (t) {
				return t.intersectsPlane(this);
			},
			coplanarPoint: function (t) {
				return (
					void 0 === t &&
						(console.warn(
							"THREE.Plane: .coplanarPoint() target is now required"
						),
						(t = new ll())),
					t.copy(this.normal).multiplyScalar(-this.constant)
				);
			},
			applyMatrix4: function (t, e) {
				const n = e || hh.getNormalMatrix(t),
					i = this.coplanarPoint(ch).applyMatrix4(t),
					r = this.normal.applyMatrix3(n).normalize();
				return (this.constant = -i.dot(r)), this;
			},
			translate: function (t) {
				return (this.constant -= t.dot(this.normal)), this;
			},
			equals: function (t) {
				return t.normal.equals(this.normal) && t.constant === this.constant;
			},
		});
		const dh = new ll(),
			ph = new ll(),
			fh = new ll(),
			mh = new ll(),
			gh = new ll(),
			vh = new ll(),
			yh = new ll(),
			xh = new ll(),
			bh = new ll(),
			wh = new ll();
		function _h(t, e, n) {
			(this.a = void 0 !== t ? t : new ll()),
				(this.b = void 0 !== e ? e : new ll()),
				(this.c = void 0 !== n ? n : new ll());
		}
		Object.assign(_h, {
			getNormal: function (t, e, n, i) {
				void 0 === i &&
					(console.warn("THREE.Triangle: .getNormal() target is now required"),
					(i = new ll())),
					i.subVectors(n, e),
					dh.subVectors(t, e),
					i.cross(dh);
				const r = i.lengthSq();
				return r > 0 ? i.multiplyScalar(1 / Math.sqrt(r)) : i.set(0, 0, 0);
			},
			getBarycoord: function (t, e, n, i, r) {
				dh.subVectors(i, e), ph.subVectors(n, e), fh.subVectors(t, e);
				const o = dh.dot(dh),
					s = dh.dot(ph),
					a = dh.dot(fh),
					c = ph.dot(ph),
					l = ph.dot(fh),
					h = o * c - s * s;
				if (
					(void 0 === r &&
						(console.warn(
							"THREE.Triangle: .getBarycoord() target is now required"
						),
						(r = new ll())),
					0 === h)
				)
					return r.set(-2, -1, -1);
				const u = 1 / h,
					d = (c * a - s * l) * u,
					p = (o * l - s * a) * u;
				return r.set(1 - d - p, p, d);
			},
			containsPoint: function (t, e, n, i) {
				return (
					_h.getBarycoord(t, e, n, i, mh),
					mh.x >= 0 && mh.y >= 0 && mh.x + mh.y <= 1
				);
			},
			getUV: function (t, e, n, i, r, o, s, a) {
				return (
					this.getBarycoord(t, e, n, i, mh),
					a.set(0, 0),
					a.addScaledVector(r, mh.x),
					a.addScaledVector(o, mh.y),
					a.addScaledVector(s, mh.z),
					a
				);
			},
			isFrontFacing: function (t, e, n, i) {
				return (
					dh.subVectors(n, e), ph.subVectors(t, e), dh.cross(ph).dot(i) < 0
				);
			},
		}),
			Object.assign(_h.prototype, {
				set: function (t, e, n) {
					return this.a.copy(t), this.b.copy(e), this.c.copy(n), this;
				},
				setFromPointsAndIndices: function (t, e, n, i) {
					return this.a.copy(t[e]), this.b.copy(t[n]), this.c.copy(t[i]), this;
				},
				clone: function () {
					return new this.constructor().copy(this);
				},
				copy: function (t) {
					return this.a.copy(t.a), this.b.copy(t.b), this.c.copy(t.c), this;
				},
				getArea: function () {
					return (
						dh.subVectors(this.c, this.b),
						ph.subVectors(this.a, this.b),
						0.5 * dh.cross(ph).length()
					);
				},
				getMidpoint: function (t) {
					return (
						void 0 === t &&
							(console.warn(
								"THREE.Triangle: .getMidpoint() target is now required"
							),
							(t = new ll())),
						t
							.addVectors(this.a, this.b)
							.add(this.c)
							.multiplyScalar(1 / 3)
					);
				},
				getNormal: function (t) {
					return _h.getNormal(this.a, this.b, this.c, t);
				},
				getPlane: function (t) {
					return (
						void 0 === t &&
							(console.warn(
								"THREE.Triangle: .getPlane() target is now required"
							),
							(t = new uh())),
						t.setFromCoplanarPoints(this.a, this.b, this.c)
					);
				},
				getBarycoord: function (t, e) {
					return _h.getBarycoord(t, this.a, this.b, this.c, e);
				},
				getUV: function (t, e, n, i, r) {
					return _h.getUV(t, this.a, this.b, this.c, e, n, i, r);
				},
				containsPoint: function (t) {
					return _h.containsPoint(t, this.a, this.b, this.c);
				},
				isFrontFacing: function (t) {
					return _h.isFrontFacing(this.a, this.b, this.c, t);
				},
				intersectsBox: function (t) {
					return t.intersectsTriangle(this);
				},
				closestPointToPoint: function (t, e) {
					void 0 === e &&
						(console.warn(
							"THREE.Triangle: .closestPointToPoint() target is now required"
						),
						(e = new ll()));
					const n = this.a,
						i = this.b,
						r = this.c;
					let o, s;
					gh.subVectors(i, n), vh.subVectors(r, n), xh.subVectors(t, n);
					const a = gh.dot(xh),
						c = vh.dot(xh);
					if (a <= 0 && c <= 0) return e.copy(n);
					bh.subVectors(t, i);
					const l = gh.dot(bh),
						h = vh.dot(bh);
					if (l >= 0 && h <= l) return e.copy(i);
					const u = a * h - l * c;
					if (u <= 0 && a >= 0 && l <= 0)
						return (o = a / (a - l)), e.copy(n).addScaledVector(gh, o);
					wh.subVectors(t, r);
					const d = gh.dot(wh),
						p = vh.dot(wh);
					if (p >= 0 && d <= p) return e.copy(r);
					const f = d * c - a * p;
					if (f <= 0 && c >= 0 && p <= 0)
						return (s = c / (c - p)), e.copy(n).addScaledVector(vh, s);
					const m = l * p - d * h;
					if (m <= 0 && h - l >= 0 && d - p >= 0)
						return (
							yh.subVectors(r, i),
							(s = (h - l) / (h - l + (d - p))),
							e.copy(i).addScaledVector(yh, s)
						);
					const g = 1 / (m + f + u);
					return (
						(o = f * g),
						(s = u * g),
						e.copy(n).addScaledVector(gh, o).addScaledVector(vh, s)
					);
				},
				equals: function (t) {
					return t.a.equals(this.a) && t.b.equals(this.b) && t.c.equals(this.c);
				},
			});
		const Mh = {
				aliceblue: 15792383,
				antiquewhite: 16444375,
				aqua: 65535,
				aquamarine: 8388564,
				azure: 15794175,
				beige: 16119260,
				bisque: 16770244,
				black: 0,
				blanchedalmond: 16772045,
				blue: 255,
				blueviolet: 9055202,
				brown: 10824234,
				burlywood: 14596231,
				cadetblue: 6266528,
				chartreuse: 8388352,
				chocolate: 13789470,
				coral: 16744272,
				cornflowerblue: 6591981,
				cornsilk: 16775388,
				crimson: 14423100,
				cyan: 65535,
				darkblue: 139,
				darkcyan: 35723,
				darkgoldenrod: 12092939,
				darkgray: 11119017,
				darkgreen: 25600,
				darkgrey: 11119017,
				darkkhaki: 12433259,
				darkmagenta: 9109643,
				darkolivegreen: 5597999,
				darkorange: 16747520,
				darkorchid: 10040012,
				darkred: 9109504,
				darksalmon: 15308410,
				darkseagreen: 9419919,
				darkslateblue: 4734347,
				darkslategray: 3100495,
				darkslategrey: 3100495,
				darkturquoise: 52945,
				darkviolet: 9699539,
				deeppink: 16716947,
				deepskyblue: 49151,
				dimgray: 6908265,
				dimgrey: 6908265,
				dodgerblue: 2003199,
				firebrick: 11674146,
				floralwhite: 16775920,
				forestgreen: 2263842,
				fuchsia: 16711935,
				gainsboro: 14474460,
				ghostwhite: 16316671,
				gold: 16766720,
				goldenrod: 14329120,
				gray: 8421504,
				green: 32768,
				greenyellow: 11403055,
				grey: 8421504,
				honeydew: 15794160,
				hotpink: 16738740,
				indianred: 13458524,
				indigo: 4915330,
				ivory: 16777200,
				khaki: 15787660,
				lavender: 15132410,
				lavenderblush: 16773365,
				lawngreen: 8190976,
				lemonchiffon: 16775885,
				lightblue: 11393254,
				lightcoral: 15761536,
				lightcyan: 14745599,
				lightgoldenrodyellow: 16448210,
				lightgray: 13882323,
				lightgreen: 9498256,
				lightgrey: 13882323,
				lightpink: 16758465,
				lightsalmon: 16752762,
				lightseagreen: 2142890,
				lightskyblue: 8900346,
				lightslategray: 7833753,
				lightslategrey: 7833753,
				lightsteelblue: 11584734,
				lightyellow: 16777184,
				lime: 65280,
				limegreen: 3329330,
				linen: 16445670,
				magenta: 16711935,
				maroon: 8388608,
				mediumaquamarine: 6737322,
				mediumblue: 205,
				mediumorchid: 12211667,
				mediumpurple: 9662683,
				mediumseagreen: 3978097,
				mediumslateblue: 8087790,
				mediumspringgreen: 64154,
				mediumturquoise: 4772300,
				mediumvioletred: 13047173,
				midnightblue: 1644912,
				mintcream: 16121850,
				mistyrose: 16770273,
				moccasin: 16770229,
				navajowhite: 16768685,
				navy: 128,
				oldlace: 16643558,
				olive: 8421376,
				olivedrab: 7048739,
				orange: 16753920,
				orangered: 16729344,
				orchid: 14315734,
				palegoldenrod: 15657130,
				palegreen: 10025880,
				paleturquoise: 11529966,
				palevioletred: 14381203,
				papayawhip: 16773077,
				peachpuff: 16767673,
				peru: 13468991,
				pink: 16761035,
				plum: 14524637,
				powderblue: 11591910,
				purple: 8388736,
				rebeccapurple: 6697881,
				red: 16711680,
				rosybrown: 12357519,
				royalblue: 4286945,
				saddlebrown: 9127187,
				salmon: 16416882,
				sandybrown: 16032864,
				seagreen: 3050327,
				seashell: 16774638,
				sienna: 10506797,
				silver: 12632256,
				skyblue: 8900331,
				slateblue: 6970061,
				slategray: 7372944,
				slategrey: 7372944,
				snow: 16775930,
				springgreen: 65407,
				steelblue: 4620980,
				tan: 13808780,
				teal: 32896,
				thistle: 14204888,
				tomato: 16737095,
				turquoise: 4251856,
				violet: 15631086,
				wheat: 16113331,
				white: 16777215,
				whitesmoke: 16119285,
				yellow: 16776960,
				yellowgreen: 10145074,
			},
			Sh = { h: 0, s: 0, l: 0 },
			Th = { h: 0, s: 0, l: 0 };
		function Eh(t, e, n) {
			return void 0 === e && void 0 === n ? this.set(t) : this.setRGB(t, e, n);
		}
		function Ah(t, e, n) {
			return (
				n < 0 && (n += 1),
				n > 1 && (n -= 1),
				n < 1 / 6
					? t + 6 * (e - t) * n
					: n < 0.5
					? e
					: n < 2 / 3
					? t + 6 * (e - t) * (2 / 3 - n)
					: t
			);
		}
		function Lh(t) {
			return t < 0.04045
				? 0.0773993808 * t
				: Math.pow(0.9478672986 * t + 0.0521327014, 2.4);
		}
		function Ph(t) {
			return t < 0.0031308 ? 12.92 * t : 1.055 * Math.pow(t, 0.41666) - 0.055;
		}
		function Rh(t, e, n, i, r, o) {
			(this.a = t),
				(this.b = e),
				(this.c = n),
				(this.normal = i && i.isVector3 ? i : new ll()),
				(this.vertexNormals = Array.isArray(i) ? i : []),
				(this.color = r && r.isColor ? r : new Eh()),
				(this.vertexColors = Array.isArray(r) ? r : []),
				(this.materialIndex = void 0 !== o ? o : 0);
		}
		Object.assign(Eh.prototype, {
			isColor: !0,
			r: 1,
			g: 1,
			b: 1,
			set: function (t) {
				return (
					t && t.isColor
						? this.copy(t)
						: "number" == typeof t
						? this.setHex(t)
						: "string" == typeof t && this.setStyle(t),
					this
				);
			},
			setScalar: function (t) {
				return (this.r = t), (this.g = t), (this.b = t), this;
			},
			setHex: function (t) {
				return (
					(t = Math.floor(t)),
					(this.r = ((t >> 16) & 255) / 255),
					(this.g = ((t >> 8) & 255) / 255),
					(this.b = (255 & t) / 255),
					this
				);
			},
			setRGB: function (t, e, n) {
				return (this.r = t), (this.g = e), (this.b = n), this;
			},
			setHSL: function (t, e, n) {
				if (
					((t = Jc.euclideanModulo(t, 1)),
					(e = Jc.clamp(e, 0, 1)),
					(n = Jc.clamp(n, 0, 1)),
					0 === e)
				)
					this.r = this.g = this.b = n;
				else {
					const i = n <= 0.5 ? n * (1 + e) : n + e - n * e,
						r = 2 * n - i;
					(this.r = Ah(r, i, t + 1 / 3)),
						(this.g = Ah(r, i, t)),
						(this.b = Ah(r, i, t - 1 / 3));
				}
				return this;
			},
			setStyle: function (t) {
				function e(e) {
					void 0 !== e &&
						parseFloat(e) < 1 &&
						console.warn(
							"THREE.Color: Alpha component of " + t + " will be ignored."
						);
				}
				let n;
				if ((n = /^((?:rgb|hsl)a?)\(\s*([^\)]*)\)/.exec(t))) {
					let t;
					const i = n[1],
						r = n[2];
					switch (i) {
						case "rgb":
						case "rgba":
							if (
								(t =
									/^(\d+)\s*,\s*(\d+)\s*,\s*(\d+)\s*(,\s*([0-9]*\.?[0-9]+)\s*)?$/.exec(
										r
									))
							)
								return (
									(this.r = Math.min(255, parseInt(t[1], 10)) / 255),
									(this.g = Math.min(255, parseInt(t[2], 10)) / 255),
									(this.b = Math.min(255, parseInt(t[3], 10)) / 255),
									e(t[5]),
									this
								);
							if (
								(t =
									/^(\d+)\%\s*,\s*(\d+)\%\s*,\s*(\d+)\%\s*(,\s*([0-9]*\.?[0-9]+)\s*)?$/.exec(
										r
									))
							)
								return (
									(this.r = Math.min(100, parseInt(t[1], 10)) / 100),
									(this.g = Math.min(100, parseInt(t[2], 10)) / 100),
									(this.b = Math.min(100, parseInt(t[3], 10)) / 100),
									e(t[5]),
									this
								);
							break;
						case "hsl":
						case "hsla":
							if (
								(t =
									/^([0-9]*\.?[0-9]+)\s*,\s*(\d+)\%\s*,\s*(\d+)\%\s*(,\s*([0-9]*\.?[0-9]+)\s*)?$/.exec(
										r
									))
							) {
								const n = parseFloat(t[1]) / 360,
									i = parseInt(t[2], 10) / 100,
									r = parseInt(t[3], 10) / 100;
								return e(t[5]), this.setHSL(n, i, r);
							}
					}
				} else if ((n = /^\#([A-Fa-f0-9]+)$/.exec(t))) {
					const t = n[1],
						e = t.length;
					if (3 === e)
						return (
							(this.r = parseInt(t.charAt(0) + t.charAt(0), 16) / 255),
							(this.g = parseInt(t.charAt(1) + t.charAt(1), 16) / 255),
							(this.b = parseInt(t.charAt(2) + t.charAt(2), 16) / 255),
							this
						);
					if (6 === e)
						return (
							(this.r = parseInt(t.charAt(0) + t.charAt(1), 16) / 255),
							(this.g = parseInt(t.charAt(2) + t.charAt(3), 16) / 255),
							(this.b = parseInt(t.charAt(4) + t.charAt(5), 16) / 255),
							this
						);
				}
				return t && t.length > 0 ? this.setColorName(t) : this;
			},
			setColorName: function (t) {
				const e = Mh[t];
				return (
					void 0 !== e
						? this.setHex(e)
						: console.warn("THREE.Color: Unknown color " + t),
					this
				);
			},
			clone: function () {
				return new this.constructor(this.r, this.g, this.b);
			},
			copy: function (t) {
				return (this.r = t.r), (this.g = t.g), (this.b = t.b), this;
			},
			copyGammaToLinear: function (t, e) {
				return (
					void 0 === e && (e = 2),
					(this.r = Math.pow(t.r, e)),
					(this.g = Math.pow(t.g, e)),
					(this.b = Math.pow(t.b, e)),
					this
				);
			},
			copyLinearToGamma: function (t, e) {
				void 0 === e && (e = 2);
				const n = e > 0 ? 1 / e : 1;
				return (
					(this.r = Math.pow(t.r, n)),
					(this.g = Math.pow(t.g, n)),
					(this.b = Math.pow(t.b, n)),
					this
				);
			},
			convertGammaToLinear: function (t) {
				return this.copyGammaToLinear(this, t), this;
			},
			convertLinearToGamma: function (t) {
				return this.copyLinearToGamma(this, t), this;
			},
			copySRGBToLinear: function (t) {
				return (this.r = Lh(t.r)), (this.g = Lh(t.g)), (this.b = Lh(t.b)), this;
			},
			copyLinearToSRGB: function (t) {
				return (this.r = Ph(t.r)), (this.g = Ph(t.g)), (this.b = Ph(t.b)), this;
			},
			convertSRGBToLinear: function () {
				return this.copySRGBToLinear(this), this;
			},
			convertLinearToSRGB: function () {
				return this.copyLinearToSRGB(this), this;
			},
			getHex: function () {
				return (
					((255 * this.r) << 16) ^ ((255 * this.g) << 8) ^ ((255 * this.b) << 0)
				);
			},
			getHexString: function () {
				return ("000000" + this.getHex().toString(16)).slice(-6);
			},
			getHSL: function (t) {
				void 0 === t &&
					(console.warn("THREE.Color: .getHSL() target is now required"),
					(t = { h: 0, s: 0, l: 0 }));
				const e = this.r,
					n = this.g,
					i = this.b,
					r = Math.max(e, n, i),
					o = Math.min(e, n, i);
				let s, a;
				const c = (o + r) / 2;
				if (o === r) (s = 0), (a = 0);
				else {
					const t = r - o;
					switch (((a = c <= 0.5 ? t / (r + o) : t / (2 - r - o)), r)) {
						case e:
							s = (n - i) / t + (n < i ? 6 : 0);
							break;
						case n:
							s = (i - e) / t + 2;
							break;
						case i:
							s = (e - n) / t + 4;
					}
					s /= 6;
				}
				return (t.h = s), (t.s = a), (t.l = c), t;
			},
			getStyle: function () {
				return (
					"rgb(" +
					((255 * this.r) | 0) +
					"," +
					((255 * this.g) | 0) +
					"," +
					((255 * this.b) | 0) +
					")"
				);
			},
			offsetHSL: function (t, e, n) {
				return (
					this.getHSL(Sh),
					(Sh.h += t),
					(Sh.s += e),
					(Sh.l += n),
					this.setHSL(Sh.h, Sh.s, Sh.l),
					this
				);
			},
			add: function (t) {
				return (this.r += t.r), (this.g += t.g), (this.b += t.b), this;
			},
			addColors: function (t, e) {
				return (
					(this.r = t.r + e.r), (this.g = t.g + e.g), (this.b = t.b + e.b), this
				);
			},
			addScalar: function (t) {
				return (this.r += t), (this.g += t), (this.b += t), this;
			},
			sub: function (t) {
				return (
					(this.r = Math.max(0, this.r - t.r)),
					(this.g = Math.max(0, this.g - t.g)),
					(this.b = Math.max(0, this.b - t.b)),
					this
				);
			},
			multiply: function (t) {
				return (this.r *= t.r), (this.g *= t.g), (this.b *= t.b), this;
			},
			multiplyScalar: function (t) {
				return (this.r *= t), (this.g *= t), (this.b *= t), this;
			},
			lerp: function (t, e) {
				return (
					(this.r += (t.r - this.r) * e),
					(this.g += (t.g - this.g) * e),
					(this.b += (t.b - this.b) * e),
					this
				);
			},
			lerpHSL: function (t, e) {
				this.getHSL(Sh), t.getHSL(Th);
				const n = Jc.lerp(Sh.h, Th.h, e),
					i = Jc.lerp(Sh.s, Th.s, e),
					r = Jc.lerp(Sh.l, Th.l, e);
				return this.setHSL(n, i, r), this;
			},
			equals: function (t) {
				return t.r === this.r && t.g === this.g && t.b === this.b;
			},
			fromArray: function (t, e) {
				return (
					void 0 === e && (e = 0),
					(this.r = t[e]),
					(this.g = t[e + 1]),
					(this.b = t[e + 2]),
					this
				);
			},
			toArray: function (t, e) {
				return (
					void 0 === t && (t = []),
					void 0 === e && (e = 0),
					(t[e] = this.r),
					(t[e + 1] = this.g),
					(t[e + 2] = this.b),
					t
				);
			},
			fromBufferAttribute: function (t, e) {
				return (
					(this.r = t.getX(e)),
					(this.g = t.getY(e)),
					(this.b = t.getZ(e)),
					!0 === t.normalized &&
						((this.r /= 255), (this.g /= 255), (this.b /= 255)),
					this
				);
			},
			toJSON: function () {
				return this.getHex();
			},
		}),
			(Eh.NAMES = Mh),
			Object.assign(Rh.prototype, {
				clone: function () {
					return new this.constructor().copy(this);
				},
				copy: function (t) {
					(this.a = t.a),
						(this.b = t.b),
						(this.c = t.c),
						this.normal.copy(t.normal),
						this.color.copy(t.color),
						(this.materialIndex = t.materialIndex);
					for (let e = 0, n = t.vertexNormals.length; e < n; e++)
						this.vertexNormals[e] = t.vertexNormals[e].clone();
					for (let e = 0, n = t.vertexColors.length; e < n; e++)
						this.vertexColors[e] = t.vertexColors[e].clone();
					return this;
				},
			});
		let Ch = 0;
		function Oh() {
			Object.defineProperty(this, "id", { value: Ch++ }),
				(this.uuid = Jc.generateUUID()),
				(this.name = ""),
				(this.type = "Material"),
				(this.fog = !0),
				(this.blending = vs),
				(this.side = ps),
				(this.flatShading = !1),
				(this.vertexColors = !1),
				(this.opacity = 1),
				(this.transparent = !1),
				(this.blendSrc = Cs),
				(this.blendDst = Os),
				(this.blendEquation = _s),
				(this.blendSrcAlpha = null),
				(this.blendDstAlpha = null),
				(this.blendEquationAlpha = null),
				(this.depthFunc = Us),
				(this.depthTest = !0),
				(this.depthWrite = !0),
				(this.stencilWriteMask = 255),
				(this.stencilFunc = Wc),
				(this.stencilRef = 0),
				(this.stencilFuncMask = 255),
				(this.stencilFail = jc),
				(this.stencilZFail = jc),
				(this.stencilZPass = jc),
				(this.stencilWrite = !1),
				(this.clippingPlanes = null),
				(this.clipIntersection = !1),
				(this.clipShadows = !1),
				(this.shadowSide = null),
				(this.colorWrite = !0),
				(this.precision = null),
				(this.polygonOffset = !1),
				(this.polygonOffsetFactor = 0),
				(this.polygonOffsetUnits = 0),
				(this.dithering = !1),
				(this.alphaTest = 0),
				(this.premultipliedAlpha = !1),
				(this.visible = !0),
				(this.toneMapped = !0),
				(this.userData = {}),
				(this.version = 0);
		}
		function Dh(t) {
			Oh.call(this),
				(this.type = "MeshBasicMaterial"),
				(this.color = new Eh(16777215)),
				(this.map = null),
				(this.lightMap = null),
				(this.lightMapIntensity = 1),
				(this.aoMap = null),
				(this.aoMapIntensity = 1),
				(this.specularMap = null),
				(this.alphaMap = null),
				(this.envMap = null),
				(this.combine = qs),
				(this.reflectivity = 1),
				(this.refractionRatio = 0.98),
				(this.wireframe = !1),
				(this.wireframeLinewidth = 1),
				(this.wireframeLinecap = "round"),
				(this.wireframeLinejoin = "round"),
				(this.skinning = !1),
				(this.morphTargets = !1),
				this.setValues(t);
		}
		(Oh.prototype = Object.assign(Object.create(Xc.prototype), {
			constructor: Oh,
			isMaterial: !0,
			onBeforeCompile: function () {},
			customProgramCacheKey: function () {
				return this.onBeforeCompile.toString();
			},
			setValues: function (t) {
				if (void 0 !== t)
					for (const e in t) {
						const n = t[e];
						if (void 0 === n) {
							console.warn(
								"THREE.Material: '" + e + "' parameter is undefined."
							);
							continue;
						}
						if ("shading" === e) {
							console.warn(
								"THREE." +
									this.type +
									": .shading has been removed. Use the boolean .flatShading instead."
							),
								(this.flatShading = 1 === n);
							continue;
						}
						const i = this[e];
						void 0 !== i
							? i && i.isColor
								? i.set(n)
								: i && i.isVector3 && n && n.isVector3
								? i.copy(n)
								: (this[e] = n)
							: console.warn(
									"THREE." +
										this.type +
										": '" +
										e +
										"' is not a property of this material."
							  );
					}
			},
			toJSON: function (t) {
				const e = void 0 === t || "string" == typeof t;
				e && (t = { textures: {}, images: {} });
				const n = {
					metadata: {
						version: 4.5,
						type: "Material",
						generator: "Material.toJSON",
					},
				};
				function i(t) {
					const e = [];
					for (const n in t) {
						const i = t[n];
						delete i.metadata, e.push(i);
					}
					return e;
				}
				if (
					((n.uuid = this.uuid),
					(n.type = this.type),
					"" !== this.name && (n.name = this.name),
					this.color && this.color.isColor && (n.color = this.color.getHex()),
					void 0 !== this.roughness && (n.roughness = this.roughness),
					void 0 !== this.metalness && (n.metalness = this.metalness),
					this.sheen && this.sheen.isColor && (n.sheen = this.sheen.getHex()),
					this.emissive &&
						this.emissive.isColor &&
						(n.emissive = this.emissive.getHex()),
					this.emissiveIntensity &&
						1 !== this.emissiveIntensity &&
						(n.emissiveIntensity = this.emissiveIntensity),
					this.specular &&
						this.specular.isColor &&
						(n.specular = this.specular.getHex()),
					void 0 !== this.shininess && (n.shininess = this.shininess),
					void 0 !== this.clearcoat && (n.clearcoat = this.clearcoat),
					void 0 !== this.clearcoatRoughness &&
						(n.clearcoatRoughness = this.clearcoatRoughness),
					this.clearcoatMap &&
						this.clearcoatMap.isTexture &&
						(n.clearcoatMap = this.clearcoatMap.toJSON(t).uuid),
					this.clearcoatRoughnessMap &&
						this.clearcoatRoughnessMap.isTexture &&
						(n.clearcoatRoughnessMap =
							this.clearcoatRoughnessMap.toJSON(t).uuid),
					this.clearcoatNormalMap &&
						this.clearcoatNormalMap.isTexture &&
						((n.clearcoatNormalMap = this.clearcoatNormalMap.toJSON(t).uuid),
						(n.clearcoatNormalScale = this.clearcoatNormalScale.toArray())),
					this.map && this.map.isTexture && (n.map = this.map.toJSON(t).uuid),
					this.matcap &&
						this.matcap.isTexture &&
						(n.matcap = this.matcap.toJSON(t).uuid),
					this.alphaMap &&
						this.alphaMap.isTexture &&
						(n.alphaMap = this.alphaMap.toJSON(t).uuid),
					this.lightMap &&
						this.lightMap.isTexture &&
						(n.lightMap = this.lightMap.toJSON(t).uuid),
					this.aoMap &&
						this.aoMap.isTexture &&
						((n.aoMap = this.aoMap.toJSON(t).uuid),
						(n.aoMapIntensity = this.aoMapIntensity)),
					this.bumpMap &&
						this.bumpMap.isTexture &&
						((n.bumpMap = this.bumpMap.toJSON(t).uuid),
						(n.bumpScale = this.bumpScale)),
					this.normalMap &&
						this.normalMap.isTexture &&
						((n.normalMap = this.normalMap.toJSON(t).uuid),
						(n.normalMapType = this.normalMapType),
						(n.normalScale = this.normalScale.toArray())),
					this.displacementMap &&
						this.displacementMap.isTexture &&
						((n.displacementMap = this.displacementMap.toJSON(t).uuid),
						(n.displacementScale = this.displacementScale),
						(n.displacementBias = this.displacementBias)),
					this.roughnessMap &&
						this.roughnessMap.isTexture &&
						(n.roughnessMap = this.roughnessMap.toJSON(t).uuid),
					this.metalnessMap &&
						this.metalnessMap.isTexture &&
						(n.metalnessMap = this.metalnessMap.toJSON(t).uuid),
					this.emissiveMap &&
						this.emissiveMap.isTexture &&
						(n.emissiveMap = this.emissiveMap.toJSON(t).uuid),
					this.specularMap &&
						this.specularMap.isTexture &&
						(n.specularMap = this.specularMap.toJSON(t).uuid),
					this.envMap &&
						this.envMap.isTexture &&
						((n.envMap = this.envMap.toJSON(t).uuid),
						(n.reflectivity = this.reflectivity),
						(n.refractionRatio = this.refractionRatio),
						void 0 !== this.combine && (n.combine = this.combine),
						void 0 !== this.envMapIntensity &&
							(n.envMapIntensity = this.envMapIntensity)),
					this.gradientMap &&
						this.gradientMap.isTexture &&
						(n.gradientMap = this.gradientMap.toJSON(t).uuid),
					void 0 !== this.size && (n.size = this.size),
					void 0 !== this.sizeAttenuation &&
						(n.sizeAttenuation = this.sizeAttenuation),
					this.blending !== vs && (n.blending = this.blending),
					!0 === this.flatShading && (n.flatShading = this.flatShading),
					this.side !== ps && (n.side = this.side),
					this.vertexColors && (n.vertexColors = !0),
					this.opacity < 1 && (n.opacity = this.opacity),
					!0 === this.transparent && (n.transparent = this.transparent),
					(n.depthFunc = this.depthFunc),
					(n.depthTest = this.depthTest),
					(n.depthWrite = this.depthWrite),
					(n.stencilWrite = this.stencilWrite),
					(n.stencilWriteMask = this.stencilWriteMask),
					(n.stencilFunc = this.stencilFunc),
					(n.stencilRef = this.stencilRef),
					(n.stencilFuncMask = this.stencilFuncMask),
					(n.stencilFail = this.stencilFail),
					(n.stencilZFail = this.stencilZFail),
					(n.stencilZPass = this.stencilZPass),
					this.rotation && 0 !== this.rotation && (n.rotation = this.rotation),
					!0 === this.polygonOffset && (n.polygonOffset = !0),
					0 !== this.polygonOffsetFactor &&
						(n.polygonOffsetFactor = this.polygonOffsetFactor),
					0 !== this.polygonOffsetUnits &&
						(n.polygonOffsetUnits = this.polygonOffsetUnits),
					this.linewidth &&
						1 !== this.linewidth &&
						(n.linewidth = this.linewidth),
					void 0 !== this.dashSize && (n.dashSize = this.dashSize),
					void 0 !== this.gapSize && (n.gapSize = this.gapSize),
					void 0 !== this.scale && (n.scale = this.scale),
					!0 === this.dithering && (n.dithering = !0),
					this.alphaTest > 0 && (n.alphaTest = this.alphaTest),
					!0 === this.premultipliedAlpha &&
						(n.premultipliedAlpha = this.premultipliedAlpha),
					!0 === this.wireframe && (n.wireframe = this.wireframe),
					this.wireframeLinewidth > 1 &&
						(n.wireframeLinewidth = this.wireframeLinewidth),
					"round" !== this.wireframeLinecap &&
						(n.wireframeLinecap = this.wireframeLinecap),
					"round" !== this.wireframeLinejoin &&
						(n.wireframeLinejoin = this.wireframeLinejoin),
					!0 === this.morphTargets && (n.morphTargets = !0),
					!0 === this.morphNormals && (n.morphNormals = !0),
					!0 === this.skinning && (n.skinning = !0),
					!1 === this.visible && (n.visible = !1),
					!1 === this.toneMapped && (n.toneMapped = !1),
					"{}" !== JSON.stringify(this.userData) &&
						(n.userData = this.userData),
					e)
				) {
					const e = i(t.textures),
						r = i(t.images);
					e.length > 0 && (n.textures = e), r.length > 0 && (n.images = r);
				}
				return n;
			},
			clone: function () {
				return new this.constructor().copy(this);
			},
			copy: function (t) {
				(this.name = t.name),
					(this.fog = t.fog),
					(this.blending = t.blending),
					(this.side = t.side),
					(this.flatShading = t.flatShading),
					(this.vertexColors = t.vertexColors),
					(this.opacity = t.opacity),
					(this.transparent = t.transparent),
					(this.blendSrc = t.blendSrc),
					(this.blendDst = t.blendDst),
					(this.blendEquation = t.blendEquation),
					(this.blendSrcAlpha = t.blendSrcAlpha),
					(this.blendDstAlpha = t.blendDstAlpha),
					(this.blendEquationAlpha = t.blendEquationAlpha),
					(this.depthFunc = t.depthFunc),
					(this.depthTest = t.depthTest),
					(this.depthWrite = t.depthWrite),
					(this.stencilWriteMask = t.stencilWriteMask),
					(this.stencilFunc = t.stencilFunc),
					(this.stencilRef = t.stencilRef),
					(this.stencilFuncMask = t.stencilFuncMask),
					(this.stencilFail = t.stencilFail),
					(this.stencilZFail = t.stencilZFail),
					(this.stencilZPass = t.stencilZPass),
					(this.stencilWrite = t.stencilWrite);
				const e = t.clippingPlanes;
				let n = null;
				if (null !== e) {
					const t = e.length;
					n = new Array(t);
					for (let i = 0; i !== t; ++i) n[i] = e[i].clone();
				}
				return (
					(this.clippingPlanes = n),
					(this.clipIntersection = t.clipIntersection),
					(this.clipShadows = t.clipShadows),
					(this.shadowSide = t.shadowSide),
					(this.colorWrite = t.colorWrite),
					(this.precision = t.precision),
					(this.polygonOffset = t.polygonOffset),
					(this.polygonOffsetFactor = t.polygonOffsetFactor),
					(this.polygonOffsetUnits = t.polygonOffsetUnits),
					(this.dithering = t.dithering),
					(this.alphaTest = t.alphaTest),
					(this.premultipliedAlpha = t.premultipliedAlpha),
					(this.visible = t.visible),
					(this.toneMapped = t.toneMapped),
					(this.userData = JSON.parse(JSON.stringify(t.userData))),
					this
				);
			},
			dispose: function () {
				this.dispatchEvent({ type: "dispose" });
			},
		})),
			Object.defineProperty(Oh.prototype, "needsUpdate", {
				set: function (t) {
					!0 === t && this.version++;
				},
			}),
			(Dh.prototype = Object.create(Oh.prototype)),
			(Dh.prototype.constructor = Dh),
			(Dh.prototype.isMeshBasicMaterial = !0),
			(Dh.prototype.copy = function (t) {
				return (
					Oh.prototype.copy.call(this, t),
					this.color.copy(t.color),
					(this.map = t.map),
					(this.lightMap = t.lightMap),
					(this.lightMapIntensity = t.lightMapIntensity),
					(this.aoMap = t.aoMap),
					(this.aoMapIntensity = t.aoMapIntensity),
					(this.specularMap = t.specularMap),
					(this.alphaMap = t.alphaMap),
					(this.envMap = t.envMap),
					(this.combine = t.combine),
					(this.reflectivity = t.reflectivity),
					(this.refractionRatio = t.refractionRatio),
					(this.wireframe = t.wireframe),
					(this.wireframeLinewidth = t.wireframeLinewidth),
					(this.wireframeLinecap = t.wireframeLinecap),
					(this.wireframeLinejoin = t.wireframeLinejoin),
					(this.skinning = t.skinning),
					(this.morphTargets = t.morphTargets),
					this
				);
			});
		const Ih = new ll(),
			kh = new Kc();
		function Nh(t, e, n) {
			if (Array.isArray(t))
				throw new TypeError(
					"THREE.BufferAttribute: array should be a Typed Array."
				);
			(this.name = ""),
				(this.array = t),
				(this.itemSize = e),
				(this.count = void 0 !== t ? t.length / e : 0),
				(this.normalized = !0 === n),
				(this.usage = qc),
				(this.updateRange = { offset: 0, count: -1 }),
				(this.version = 0);
		}
		function Bh(t, e, n) {
			Nh.call(this, new Int8Array(t), e, n);
		}
		function Fh(t, e, n) {
			Nh.call(this, new Uint8Array(t), e, n);
		}
		function zh(t, e, n) {
			Nh.call(this, new Uint8ClampedArray(t), e, n);
		}
		function Hh(t, e, n) {
			Nh.call(this, new Int16Array(t), e, n);
		}
		function Uh(t, e, n) {
			Nh.call(this, new Uint16Array(t), e, n);
		}
		function Gh(t, e, n) {
			Nh.call(this, new Int32Array(t), e, n);
		}
		function Vh(t, e, n) {
			Nh.call(this, new Uint32Array(t), e, n);
		}
		function jh(t, e, n) {
			Nh.call(this, new Float32Array(t), e, n);
		}
		function Wh(t, e, n) {
			Nh.call(this, new Float64Array(t), e, n);
		}
		function qh() {
			(this.vertices = []),
				(this.normals = []),
				(this.colors = []),
				(this.uvs = []),
				(this.uvs2 = []),
				(this.groups = []),
				(this.morphTargets = {}),
				(this.skinWeights = []),
				(this.skinIndices = []),
				(this.boundingBox = null),
				(this.boundingSphere = null),
				(this.verticesNeedUpdate = !1),
				(this.normalsNeedUpdate = !1),
				(this.colorsNeedUpdate = !1),
				(this.uvsNeedUpdate = !1),
				(this.groupsNeedUpdate = !1);
		}
		function Yh(t) {
			if (0 === t.length) return -1 / 0;
			let e = t[0];
			for (let n = 1, i = t.length; n < i; ++n) t[n] > e && (e = t[n]);
			return e;
		}
		Object.defineProperty(Nh.prototype, "needsUpdate", {
			set: function (t) {
				!0 === t && this.version++;
			},
		}),
			Object.assign(Nh.prototype, {
				isBufferAttribute: !0,
				onUploadCallback: function () {},
				setUsage: function (t) {
					return (this.usage = t), this;
				},
				copy: function (t) {
					return (
						(this.name = t.name),
						(this.array = new t.array.constructor(t.array)),
						(this.itemSize = t.itemSize),
						(this.count = t.count),
						(this.normalized = t.normalized),
						(this.usage = t.usage),
						this
					);
				},
				copyAt: function (t, e, n) {
					(t *= this.itemSize), (n *= e.itemSize);
					for (let i = 0, r = this.itemSize; i < r; i++)
						this.array[t + i] = e.array[n + i];
					return this;
				},
				copyArray: function (t) {
					return this.array.set(t), this;
				},
				copyColorsArray: function (t) {
					const e = this.array;
					let n = 0;
					for (let i = 0, r = t.length; i < r; i++) {
						let r = t[i];
						void 0 === r &&
							(console.warn(
								"THREE.BufferAttribute.copyColorsArray(): color is undefined",
								i
							),
							(r = new Eh())),
							(e[n++] = r.r),
							(e[n++] = r.g),
							(e[n++] = r.b);
					}
					return this;
				},
				copyVector2sArray: function (t) {
					const e = this.array;
					let n = 0;
					for (let i = 0, r = t.length; i < r; i++) {
						let r = t[i];
						void 0 === r &&
							(console.warn(
								"THREE.BufferAttribute.copyVector2sArray(): vector is undefined",
								i
							),
							(r = new Kc())),
							(e[n++] = r.x),
							(e[n++] = r.y);
					}
					return this;
				},
				copyVector3sArray: function (t) {
					const e = this.array;
					let n = 0;
					for (let i = 0, r = t.length; i < r; i++) {
						let r = t[i];
						void 0 === r &&
							(console.warn(
								"THREE.BufferAttribute.copyVector3sArray(): vector is undefined",
								i
							),
							(r = new ll())),
							(e[n++] = r.x),
							(e[n++] = r.y),
							(e[n++] = r.z);
					}
					return this;
				},
				copyVector4sArray: function (t) {
					const e = this.array;
					let n = 0;
					for (let i = 0, r = t.length; i < r; i++) {
						let r = t[i];
						void 0 === r &&
							(console.warn(
								"THREE.BufferAttribute.copyVector4sArray(): vector is undefined",
								i
							),
							(r = new il())),
							(e[n++] = r.x),
							(e[n++] = r.y),
							(e[n++] = r.z),
							(e[n++] = r.w);
					}
					return this;
				},
				applyMatrix3: function (t) {
					if (2 === this.itemSize)
						for (let e = 0, n = this.count; e < n; e++)
							kh.fromBufferAttribute(this, e),
								kh.applyMatrix3(t),
								this.setXY(e, kh.x, kh.y);
					else if (3 === this.itemSize)
						for (let e = 0, n = this.count; e < n; e++)
							Ih.fromBufferAttribute(this, e),
								Ih.applyMatrix3(t),
								this.setXYZ(e, Ih.x, Ih.y, Ih.z);
					return this;
				},
				applyMatrix4: function (t) {
					for (let e = 0, n = this.count; e < n; e++)
						(Ih.x = this.getX(e)),
							(Ih.y = this.getY(e)),
							(Ih.z = this.getZ(e)),
							Ih.applyMatrix4(t),
							this.setXYZ(e, Ih.x, Ih.y, Ih.z);
					return this;
				},
				applyNormalMatrix: function (t) {
					for (let e = 0, n = this.count; e < n; e++)
						(Ih.x = this.getX(e)),
							(Ih.y = this.getY(e)),
							(Ih.z = this.getZ(e)),
							Ih.applyNormalMatrix(t),
							this.setXYZ(e, Ih.x, Ih.y, Ih.z);
					return this;
				},
				transformDirection: function (t) {
					for (let e = 0, n = this.count; e < n; e++)
						(Ih.x = this.getX(e)),
							(Ih.y = this.getY(e)),
							(Ih.z = this.getZ(e)),
							Ih.transformDirection(t),
							this.setXYZ(e, Ih.x, Ih.y, Ih.z);
					return this;
				},
				set: function (t, e) {
					return void 0 === e && (e = 0), this.array.set(t, e), this;
				},
				getX: function (t) {
					return this.array[t * this.itemSize];
				},
				setX: function (t, e) {
					return (this.array[t * this.itemSize] = e), this;
				},
				getY: function (t) {
					return this.array[t * this.itemSize + 1];
				},
				setY: function (t, e) {
					return (this.array[t * this.itemSize + 1] = e), this;
				},
				getZ: function (t) {
					return this.array[t * this.itemSize + 2];
				},
				setZ: function (t, e) {
					return (this.array[t * this.itemSize + 2] = e), this;
				},
				getW: function (t) {
					return this.array[t * this.itemSize + 3];
				},
				setW: function (t, e) {
					return (this.array[t * this.itemSize + 3] = e), this;
				},
				setXY: function (t, e, n) {
					return (
						(t *= this.itemSize),
						(this.array[t + 0] = e),
						(this.array[t + 1] = n),
						this
					);
				},
				setXYZ: function (t, e, n, i) {
					return (
						(t *= this.itemSize),
						(this.array[t + 0] = e),
						(this.array[t + 1] = n),
						(this.array[t + 2] = i),
						this
					);
				},
				setXYZW: function (t, e, n, i, r) {
					return (
						(t *= this.itemSize),
						(this.array[t + 0] = e),
						(this.array[t + 1] = n),
						(this.array[t + 2] = i),
						(this.array[t + 3] = r),
						this
					);
				},
				onUpload: function (t) {
					return (this.onUploadCallback = t), this;
				},
				clone: function () {
					return new this.constructor(this.array, this.itemSize).copy(this);
				},
				toJSON: function () {
					return {
						itemSize: this.itemSize,
						type: this.array.constructor.name,
						array: Array.prototype.slice.call(this.array),
						normalized: this.normalized,
					};
				},
			}),
			(Bh.prototype = Object.create(Nh.prototype)),
			(Bh.prototype.constructor = Bh),
			(Fh.prototype = Object.create(Nh.prototype)),
			(Fh.prototype.constructor = Fh),
			(zh.prototype = Object.create(Nh.prototype)),
			(zh.prototype.constructor = zh),
			(Hh.prototype = Object.create(Nh.prototype)),
			(Hh.prototype.constructor = Hh),
			(Uh.prototype = Object.create(Nh.prototype)),
			(Uh.prototype.constructor = Uh),
			(Gh.prototype = Object.create(Nh.prototype)),
			(Gh.prototype.constructor = Gh),
			(Vh.prototype = Object.create(Nh.prototype)),
			(Vh.prototype.constructor = Vh),
			(jh.prototype = Object.create(Nh.prototype)),
			(jh.prototype.constructor = jh),
			(Wh.prototype = Object.create(Nh.prototype)),
			(Wh.prototype.constructor = Wh),
			Object.assign(qh.prototype, {
				computeGroups: function (t) {
					const e = [];
					let n,
						i,
						r = void 0;
					const o = t.faces;
					for (i = 0; i < o.length; i++) {
						const t = o[i];
						t.materialIndex !== r &&
							((r = t.materialIndex),
							void 0 !== n && ((n.count = 3 * i - n.start), e.push(n)),
							(n = { start: 3 * i, materialIndex: r }));
					}
					void 0 !== n && ((n.count = 3 * i - n.start), e.push(n)),
						(this.groups = e);
				},
				fromGeometry: function (t) {
					const e = t.faces,
						n = t.vertices,
						i = t.faceVertexUvs,
						r = i[0] && i[0].length > 0,
						o = i[1] && i[1].length > 0,
						s = t.morphTargets,
						a = s.length;
					let c;
					if (a > 0) {
						c = [];
						for (let t = 0; t < a; t++) c[t] = { name: s[t].name, data: [] };
						this.morphTargets.position = c;
					}
					const l = t.morphNormals,
						h = l.length;
					let u;
					if (h > 0) {
						u = [];
						for (let t = 0; t < h; t++) u[t] = { name: l[t].name, data: [] };
						this.morphTargets.normal = u;
					}
					const d = t.skinIndices,
						p = t.skinWeights,
						f = d.length === n.length,
						m = p.length === n.length;
					n.length > 0 &&
						0 === e.length &&
						console.error(
							"THREE.DirectGeometry: Faceless geometries are not supported."
						);
					for (let t = 0; t < e.length; t++) {
						const g = e[t];
						this.vertices.push(n[g.a], n[g.b], n[g.c]);
						const v = g.vertexNormals;
						if (3 === v.length) this.normals.push(v[0], v[1], v[2]);
						else {
							const t = g.normal;
							this.normals.push(t, t, t);
						}
						const y = g.vertexColors;
						if (3 === y.length) this.colors.push(y[0], y[1], y[2]);
						else {
							const t = g.color;
							this.colors.push(t, t, t);
						}
						if (!0 === r) {
							const e = i[0][t];
							void 0 !== e
								? this.uvs.push(e[0], e[1], e[2])
								: (console.warn(
										"THREE.DirectGeometry.fromGeometry(): Undefined vertexUv ",
										t
								  ),
								  this.uvs.push(new Kc(), new Kc(), new Kc()));
						}
						if (!0 === o) {
							const e = i[1][t];
							void 0 !== e
								? this.uvs2.push(e[0], e[1], e[2])
								: (console.warn(
										"THREE.DirectGeometry.fromGeometry(): Undefined vertexUv2 ",
										t
								  ),
								  this.uvs2.push(new Kc(), new Kc(), new Kc()));
						}
						for (let t = 0; t < a; t++) {
							const e = s[t].vertices;
							c[t].data.push(e[g.a], e[g.b], e[g.c]);
						}
						for (let e = 0; e < h; e++) {
							const n = l[e].vertexNormals[t];
							u[e].data.push(n.a, n.b, n.c);
						}
						f && this.skinIndices.push(d[g.a], d[g.b], d[g.c]),
							m && this.skinWeights.push(p[g.a], p[g.b], p[g.c]);
					}
					return (
						this.computeGroups(t),
						(this.verticesNeedUpdate = t.verticesNeedUpdate),
						(this.normalsNeedUpdate = t.normalsNeedUpdate),
						(this.colorsNeedUpdate = t.colorsNeedUpdate),
						(this.uvsNeedUpdate = t.uvsNeedUpdate),
						(this.groupsNeedUpdate = t.groupsNeedUpdate),
						null !== t.boundingSphere &&
							(this.boundingSphere = t.boundingSphere.clone()),
						null !== t.boundingBox &&
							(this.boundingBox = t.boundingBox.clone()),
						this
					);
				},
			});
		let Xh = 1;
		const Zh = new vl(),
			Jh = new kl(),
			Kh = new ll(),
			Qh = new Jl(),
			$h = new Jl(),
			tu = new ll();
		function eu() {
			Object.defineProperty(this, "id", { value: (Xh += 2) }),
				(this.uuid = Jc.generateUUID()),
				(this.name = ""),
				(this.type = "BufferGeometry"),
				(this.index = null),
				(this.attributes = {}),
				(this.morphAttributes = {}),
				(this.morphTargetsRelative = !1),
				(this.groups = []),
				(this.boundingBox = null),
				(this.boundingSphere = null),
				(this.drawRange = { start: 0, count: 1 / 0 }),
				(this.userData = {});
		}
		eu.prototype = Object.assign(Object.create(Xc.prototype), {
			constructor: eu,
			isBufferGeometry: !0,
			getIndex: function () {
				return this.index;
			},
			setIndex: function (t) {
				Array.isArray(t)
					? (this.index = new (Yh(t) > 65535 ? Vh : Uh)(t, 1))
					: (this.index = t);
			},
			getAttribute: function (t) {
				return this.attributes[t];
			},
			setAttribute: function (t, e) {
				return (this.attributes[t] = e), this;
			},
			deleteAttribute: function (t) {
				return delete this.attributes[t], this;
			},
			addGroup: function (t, e, n) {
				this.groups.push({
					start: t,
					count: e,
					materialIndex: void 0 !== n ? n : 0,
				});
			},
			clearGroups: function () {
				this.groups = [];
			},
			setDrawRange: function (t, e) {
				(this.drawRange.start = t), (this.drawRange.count = e);
			},
			applyMatrix4: function (t) {
				const e = this.attributes.position;
				void 0 !== e && (e.applyMatrix4(t), (e.needsUpdate = !0));
				const n = this.attributes.normal;
				if (void 0 !== n) {
					const e = new Qc().getNormalMatrix(t);
					n.applyNormalMatrix(e), (n.needsUpdate = !0);
				}
				const i = this.attributes.tangent;
				return (
					void 0 !== i && (i.transformDirection(t), (i.needsUpdate = !0)),
					null !== this.boundingBox && this.computeBoundingBox(),
					null !== this.boundingSphere && this.computeBoundingSphere(),
					this
				);
			},
			rotateX: function (t) {
				return Zh.makeRotationX(t), this.applyMatrix4(Zh), this;
			},
			rotateY: function (t) {
				return Zh.makeRotationY(t), this.applyMatrix4(Zh), this;
			},
			rotateZ: function (t) {
				return Zh.makeRotationZ(t), this.applyMatrix4(Zh), this;
			},
			translate: function (t, e, n) {
				return Zh.makeTranslation(t, e, n), this.applyMatrix4(Zh), this;
			},
			scale: function (t, e, n) {
				return Zh.makeScale(t, e, n), this.applyMatrix4(Zh), this;
			},
			lookAt: function (t) {
				return (
					Jh.lookAt(t), Jh.updateMatrix(), this.applyMatrix4(Jh.matrix), this
				);
			},
			center: function () {
				return (
					this.computeBoundingBox(),
					this.boundingBox.getCenter(Kh).negate(),
					this.translate(Kh.x, Kh.y, Kh.z),
					this
				);
			},
			setFromObject: function (t) {
				const e = t.geometry;
				if (t.isPoints || t.isLine) {
					const t = new jh(3 * e.vertices.length, 3),
						n = new jh(3 * e.colors.length, 3);
					if (
						(this.setAttribute("position", t.copyVector3sArray(e.vertices)),
						this.setAttribute("color", n.copyColorsArray(e.colors)),
						e.lineDistances && e.lineDistances.length === e.vertices.length)
					) {
						const t = new jh(e.lineDistances.length, 1);
						this.setAttribute("lineDistance", t.copyArray(e.lineDistances));
					}
					null !== e.boundingSphere &&
						(this.boundingSphere = e.boundingSphere.clone()),
						null !== e.boundingBox &&
							(this.boundingBox = e.boundingBox.clone());
				} else t.isMesh && e && e.isGeometry && this.fromGeometry(e);
				return this;
			},
			setFromPoints: function (t) {
				const e = [];
				for (let n = 0, i = t.length; n < i; n++) {
					const i = t[n];
					e.push(i.x, i.y, i.z || 0);
				}
				return this.setAttribute("position", new jh(e, 3)), this;
			},
			updateFromObject: function (t) {
				let e = t.geometry;
				if (t.isMesh) {
					let t = e.__directGeometry;
					if (
						(!0 === e.elementsNeedUpdate &&
							((t = void 0), (e.elementsNeedUpdate = !1)),
						void 0 === t)
					)
						return this.fromGeometry(e);
					(t.verticesNeedUpdate = e.verticesNeedUpdate),
						(t.normalsNeedUpdate = e.normalsNeedUpdate),
						(t.colorsNeedUpdate = e.colorsNeedUpdate),
						(t.uvsNeedUpdate = e.uvsNeedUpdate),
						(t.groupsNeedUpdate = e.groupsNeedUpdate),
						(e.verticesNeedUpdate = !1),
						(e.normalsNeedUpdate = !1),
						(e.colorsNeedUpdate = !1),
						(e.uvsNeedUpdate = !1),
						(e.groupsNeedUpdate = !1),
						(e = t);
				}
				if (!0 === e.verticesNeedUpdate) {
					const t = this.attributes.position;
					void 0 !== t &&
						(t.copyVector3sArray(e.vertices), (t.needsUpdate = !0)),
						(e.verticesNeedUpdate = !1);
				}
				if (!0 === e.normalsNeedUpdate) {
					const t = this.attributes.normal;
					void 0 !== t &&
						(t.copyVector3sArray(e.normals), (t.needsUpdate = !0)),
						(e.normalsNeedUpdate = !1);
				}
				if (!0 === e.colorsNeedUpdate) {
					const t = this.attributes.color;
					void 0 !== t && (t.copyColorsArray(e.colors), (t.needsUpdate = !0)),
						(e.colorsNeedUpdate = !1);
				}
				if (e.uvsNeedUpdate) {
					const t = this.attributes.uv;
					void 0 !== t && (t.copyVector2sArray(e.uvs), (t.needsUpdate = !0)),
						(e.uvsNeedUpdate = !1);
				}
				if (e.lineDistancesNeedUpdate) {
					const t = this.attributes.lineDistance;
					void 0 !== t && (t.copyArray(e.lineDistances), (t.needsUpdate = !0)),
						(e.lineDistancesNeedUpdate = !1);
				}
				return (
					e.groupsNeedUpdate &&
						(e.computeGroups(t.geometry),
						(this.groups = e.groups),
						(e.groupsNeedUpdate = !1)),
					this
				);
			},
			fromGeometry: function (t) {
				return (
					(t.__directGeometry = new qh().fromGeometry(t)),
					this.fromDirectGeometry(t.__directGeometry)
				);
			},
			fromDirectGeometry: function (t) {
				const e = new Float32Array(3 * t.vertices.length);
				if (
					(this.setAttribute(
						"position",
						new Nh(e, 3).copyVector3sArray(t.vertices)
					),
					t.normals.length > 0)
				) {
					const e = new Float32Array(3 * t.normals.length);
					this.setAttribute(
						"normal",
						new Nh(e, 3).copyVector3sArray(t.normals)
					);
				}
				if (t.colors.length > 0) {
					const e = new Float32Array(3 * t.colors.length);
					this.setAttribute("color", new Nh(e, 3).copyColorsArray(t.colors));
				}
				if (t.uvs.length > 0) {
					const e = new Float32Array(2 * t.uvs.length);
					this.setAttribute("uv", new Nh(e, 2).copyVector2sArray(t.uvs));
				}
				if (t.uvs2.length > 0) {
					const e = new Float32Array(2 * t.uvs2.length);
					this.setAttribute("uv2", new Nh(e, 2).copyVector2sArray(t.uvs2));
				}
				this.groups = t.groups;
				for (const e in t.morphTargets) {
					const n = [],
						i = t.morphTargets[e];
					for (let t = 0, e = i.length; t < e; t++) {
						const e = i[t],
							r = new jh(3 * e.data.length, 3);
						(r.name = e.name), n.push(r.copyVector3sArray(e.data));
					}
					this.morphAttributes[e] = n;
				}
				if (t.skinIndices.length > 0) {
					const e = new jh(4 * t.skinIndices.length, 4);
					this.setAttribute("skinIndex", e.copyVector4sArray(t.skinIndices));
				}
				if (t.skinWeights.length > 0) {
					const e = new jh(4 * t.skinWeights.length, 4);
					this.setAttribute("skinWeight", e.copyVector4sArray(t.skinWeights));
				}
				return (
					null !== t.boundingSphere &&
						(this.boundingSphere = t.boundingSphere.clone()),
					null !== t.boundingBox && (this.boundingBox = t.boundingBox.clone()),
					this
				);
			},
			computeBoundingBox: function () {
				null === this.boundingBox && (this.boundingBox = new Jl());
				const t = this.attributes.position,
					e = this.morphAttributes.position;
				if (void 0 !== t) {
					if ((this.boundingBox.setFromBufferAttribute(t), e))
						for (let t = 0, n = e.length; t < n; t++) {
							const n = e[t];
							Qh.setFromBufferAttribute(n),
								this.morphTargetsRelative
									? (tu.addVectors(this.boundingBox.min, Qh.min),
									  this.boundingBox.expandByPoint(tu),
									  tu.addVectors(this.boundingBox.max, Qh.max),
									  this.boundingBox.expandByPoint(tu))
									: (this.boundingBox.expandByPoint(Qh.min),
									  this.boundingBox.expandByPoint(Qh.max));
						}
				} else this.boundingBox.makeEmpty();
				(isNaN(this.boundingBox.min.x) ||
					isNaN(this.boundingBox.min.y) ||
					isNaN(this.boundingBox.min.z)) &&
					console.error(
						'THREE.BufferGeometry.computeBoundingBox: Computed min/max have NaN values. The "position" attribute is likely to have NaN values.',
						this
					);
			},
			computeBoundingSphere: function () {
				null === this.boundingSphere && (this.boundingSphere = new $l());
				const t = this.attributes.position,
					e = this.morphAttributes.position;
				if (t) {
					const n = this.boundingSphere.center;
					if ((Qh.setFromBufferAttribute(t), e))
						for (let t = 0, n = e.length; t < n; t++) {
							const n = e[t];
							$h.setFromBufferAttribute(n),
								this.morphTargetsRelative
									? (tu.addVectors(Qh.min, $h.min),
									  Qh.expandByPoint(tu),
									  tu.addVectors(Qh.max, $h.max),
									  Qh.expandByPoint(tu))
									: (Qh.expandByPoint($h.min), Qh.expandByPoint($h.max));
						}
					Qh.getCenter(n);
					let i = 0;
					for (let e = 0, r = t.count; e < r; e++)
						tu.fromBufferAttribute(t, e),
							(i = Math.max(i, n.distanceToSquared(tu)));
					if (e)
						for (let r = 0, o = e.length; r < o; r++) {
							const o = e[r],
								s = this.morphTargetsRelative;
							for (let e = 0, r = o.count; e < r; e++)
								tu.fromBufferAttribute(o, e),
									s && (Kh.fromBufferAttribute(t, e), tu.add(Kh)),
									(i = Math.max(i, n.distanceToSquared(tu)));
						}
					(this.boundingSphere.radius = Math.sqrt(i)),
						isNaN(this.boundingSphere.radius) &&
							console.error(
								'THREE.BufferGeometry.computeBoundingSphere(): Computed radius is NaN. The "position" attribute is likely to have NaN values.',
								this
							);
				}
			},
			computeFaceNormals: function () {},
			computeVertexNormals: function () {
				const t = this.index,
					e = this.getAttribute("position");
				if (void 0 !== e) {
					let n = this.getAttribute("normal");
					if (void 0 === n)
						(n = new Nh(new Float32Array(3 * e.count), 3)),
							this.setAttribute("normal", n);
					else for (let t = 0, e = n.count; t < e; t++) n.setXYZ(t, 0, 0, 0);
					const i = new ll(),
						r = new ll(),
						o = new ll(),
						s = new ll(),
						a = new ll(),
						c = new ll(),
						l = new ll(),
						h = new ll();
					if (t)
						for (let u = 0, d = t.count; u < d; u += 3) {
							const d = t.getX(u + 0),
								p = t.getX(u + 1),
								f = t.getX(u + 2);
							i.fromBufferAttribute(e, d),
								r.fromBufferAttribute(e, p),
								o.fromBufferAttribute(e, f),
								l.subVectors(o, r),
								h.subVectors(i, r),
								l.cross(h),
								s.fromBufferAttribute(n, d),
								a.fromBufferAttribute(n, p),
								c.fromBufferAttribute(n, f),
								s.add(l),
								a.add(l),
								c.add(l),
								n.setXYZ(d, s.x, s.y, s.z),
								n.setXYZ(p, a.x, a.y, a.z),
								n.setXYZ(f, c.x, c.y, c.z);
						}
					else
						for (let t = 0, s = e.count; t < s; t += 3)
							i.fromBufferAttribute(e, t + 0),
								r.fromBufferAttribute(e, t + 1),
								o.fromBufferAttribute(e, t + 2),
								l.subVectors(o, r),
								h.subVectors(i, r),
								l.cross(h),
								n.setXYZ(t + 0, l.x, l.y, l.z),
								n.setXYZ(t + 1, l.x, l.y, l.z),
								n.setXYZ(t + 2, l.x, l.y, l.z);
					this.normalizeNormals(), (n.needsUpdate = !0);
				}
			},
			merge: function (t, e) {
				if (!t || !t.isBufferGeometry)
					return void console.error(
						"THREE.BufferGeometry.merge(): geometry not an instance of THREE.BufferGeometry.",
						t
					);
				void 0 === e &&
					((e = 0),
					console.warn(
						"THREE.BufferGeometry.merge(): Overwriting original geometry, starting at offset=0. Use BufferGeometryUtils.mergeBufferGeometries() for lossless merge."
					));
				const n = this.attributes;
				for (const i in n) {
					if (void 0 === t.attributes[i]) continue;
					const r = n[i].array,
						o = t.attributes[i],
						s = o.array,
						a = o.itemSize * e,
						c = Math.min(s.length, r.length - a);
					for (let t = 0, e = a; t < c; t++, e++) r[e] = s[t];
				}
				return this;
			},
			normalizeNormals: function () {
				const t = this.attributes.normal;
				for (let e = 0, n = t.count; e < n; e++)
					tu.fromBufferAttribute(t, e),
						tu.normalize(),
						t.setXYZ(e, tu.x, tu.y, tu.z);
			},
			toNonIndexed: function () {
				function t(t, e) {
					const n = t.array,
						i = t.itemSize,
						r = t.normalized,
						o = new n.constructor(e.length * i);
					let s = 0,
						a = 0;
					for (let t = 0, r = e.length; t < r; t++) {
						s = e[t] * i;
						for (let t = 0; t < i; t++) o[a++] = n[s++];
					}
					return new Nh(o, i, r);
				}
				if (null === this.index)
					return (
						console.warn(
							"THREE.BufferGeometry.toNonIndexed(): Geometry is already non-indexed."
						),
						this
					);
				const e = new eu(),
					n = this.index.array,
					i = this.attributes;
				for (const r in i) {
					const o = t(i[r], n);
					e.setAttribute(r, o);
				}
				const r = this.morphAttributes;
				for (const i in r) {
					const o = [],
						s = r[i];
					for (let e = 0, i = s.length; e < i; e++) {
						const i = t(s[e], n);
						o.push(i);
					}
					e.morphAttributes[i] = o;
				}
				e.morphTargetsRelative = this.morphTargetsRelative;
				const o = this.groups;
				for (let t = 0, n = o.length; t < n; t++) {
					const n = o[t];
					e.addGroup(n.start, n.count, n.materialIndex);
				}
				return e;
			},
			toJSON: function () {
				const t = {
					metadata: {
						version: 4.5,
						type: "BufferGeometry",
						generator: "BufferGeometry.toJSON",
					},
				};
				if (
					((t.uuid = this.uuid),
					(t.type = this.type),
					"" !== this.name && (t.name = this.name),
					Object.keys(this.userData).length > 0 && (t.userData = this.userData),
					void 0 !== this.parameters)
				) {
					const e = this.parameters;
					for (const n in e) void 0 !== e[n] && (t[n] = e[n]);
					return t;
				}
				t.data = { attributes: {} };
				const e = this.index;
				null !== e &&
					(t.data.index = {
						type: e.array.constructor.name,
						array: Array.prototype.slice.call(e.array),
					});
				const n = this.attributes;
				for (const e in n) {
					const i = n[e],
						r = i.toJSON(t.data);
					"" !== i.name && (r.name = i.name), (t.data.attributes[e] = r);
				}
				const i = {};
				let r = !1;
				for (const e in this.morphAttributes) {
					const n = this.morphAttributes[e],
						o = [];
					for (let e = 0, i = n.length; e < i; e++) {
						const i = n[e],
							r = i.toJSON(t.data);
						"" !== i.name && (r.name = i.name), o.push(r);
					}
					o.length > 0 && ((i[e] = o), (r = !0));
				}
				r &&
					((t.data.morphAttributes = i),
					(t.data.morphTargetsRelative = this.morphTargetsRelative));
				const o = this.groups;
				o.length > 0 && (t.data.groups = JSON.parse(JSON.stringify(o)));
				const s = this.boundingSphere;
				return (
					null !== s &&
						(t.data.boundingSphere = {
							center: s.center.toArray(),
							radius: s.radius,
						}),
					t
				);
			},
			clone: function () {
				return new eu().copy(this);
			},
			copy: function (t) {
				(this.index = null),
					(this.attributes = {}),
					(this.morphAttributes = {}),
					(this.groups = []),
					(this.boundingBox = null),
					(this.boundingSphere = null);
				const e = {};
				this.name = t.name;
				const n = t.index;
				null !== n && this.setIndex(n.clone(e));
				const i = t.attributes;
				for (const t in i) {
					const n = i[t];
					this.setAttribute(t, n.clone(e));
				}
				const r = t.morphAttributes;
				for (const t in r) {
					const n = [],
						i = r[t];
					for (let t = 0, r = i.length; t < r; t++) n.push(i[t].clone(e));
					this.morphAttributes[t] = n;
				}
				this.morphTargetsRelative = t.morphTargetsRelative;
				const o = t.groups;
				for (let t = 0, e = o.length; t < e; t++) {
					const e = o[t];
					this.addGroup(e.start, e.count, e.materialIndex);
				}
				const s = t.boundingBox;
				null !== s && (this.boundingBox = s.clone());
				const a = t.boundingSphere;
				return (
					null !== a && (this.boundingSphere = a.clone()),
					(this.drawRange.start = t.drawRange.start),
					(this.drawRange.count = t.drawRange.count),
					(this.userData = t.userData),
					this
				);
			},
			dispose: function () {
				this.dispatchEvent({ type: "dispose" });
			},
		});
		const nu = new vl(),
			iu = new ah(),
			ru = new $l(),
			ou = new ll(),
			su = new ll(),
			au = new ll(),
			cu = new ll(),
			lu = new ll(),
			hu = new ll(),
			uu = new ll(),
			du = new ll(),
			pu = new ll(),
			fu = new Kc(),
			mu = new Kc(),
			gu = new Kc(),
			vu = new ll(),
			yu = new ll();
		function xu(t, e) {
			kl.call(this),
				(this.type = "Mesh"),
				(this.geometry = void 0 !== t ? t : new eu()),
				(this.material = void 0 !== e ? e : new Dh()),
				this.updateMorphTargets();
		}
		function bu(t, e, n, i, r, o, s, a) {
			let c;
			if (
				null ===
				(c =
					e.side === fs
						? i.intersectTriangle(s, o, r, !0, a)
						: i.intersectTriangle(r, o, s, e.side !== ms, a))
			)
				return null;
			yu.copy(a), yu.applyMatrix4(t.matrixWorld);
			const l = n.ray.origin.distanceTo(yu);
			return l < n.near || l > n.far
				? null
				: { distance: l, point: yu.clone(), object: t };
		}
		function wu(t, e, n, i, r, o, s, a, c, l, h, u) {
			ou.fromBufferAttribute(r, l),
				su.fromBufferAttribute(r, h),
				au.fromBufferAttribute(r, u);
			const d = t.morphTargetInfluences;
			if (e.morphTargets && o && d) {
				uu.set(0, 0, 0), du.set(0, 0, 0), pu.set(0, 0, 0);
				for (let t = 0, e = o.length; t < e; t++) {
					const e = d[t],
						n = o[t];
					0 !== e &&
						(cu.fromBufferAttribute(n, l),
						lu.fromBufferAttribute(n, h),
						hu.fromBufferAttribute(n, u),
						s
							? (uu.addScaledVector(cu, e),
							  du.addScaledVector(lu, e),
							  pu.addScaledVector(hu, e))
							: (uu.addScaledVector(cu.sub(ou), e),
							  du.addScaledVector(lu.sub(su), e),
							  pu.addScaledVector(hu.sub(au), e)));
				}
				ou.add(uu), su.add(du), au.add(pu);
			}
			t.isSkinnedMesh &&
				(t.boneTransform(l, ou),
				t.boneTransform(h, su),
				t.boneTransform(u, au));
			const p = bu(t, e, n, i, ou, su, au, vu);
			if (p) {
				a &&
					(fu.fromBufferAttribute(a, l),
					mu.fromBufferAttribute(a, h),
					gu.fromBufferAttribute(a, u),
					(p.uv = _h.getUV(vu, ou, su, au, fu, mu, gu, new Kc()))),
					c &&
						(fu.fromBufferAttribute(c, l),
						mu.fromBufferAttribute(c, h),
						gu.fromBufferAttribute(c, u),
						(p.uv2 = _h.getUV(vu, ou, su, au, fu, mu, gu, new Kc())));
				const t = new Rh(l, h, u);
				_h.getNormal(ou, su, au, t.normal), (p.face = t);
			}
			return p;
		}
		xu.prototype = Object.assign(Object.create(kl.prototype), {
			constructor: xu,
			isMesh: !0,
			copy: function (t) {
				return (
					kl.prototype.copy.call(this, t),
					void 0 !== t.morphTargetInfluences &&
						(this.morphTargetInfluences = t.morphTargetInfluences.slice()),
					void 0 !== t.morphTargetDictionary &&
						(this.morphTargetDictionary = Object.assign(
							{},
							t.morphTargetDictionary
						)),
					(this.material = t.material),
					(this.geometry = t.geometry),
					this
				);
			},
			updateMorphTargets: function () {
				const t = this.geometry;
				if (t.isBufferGeometry) {
					const e = t.morphAttributes,
						n = Object.keys(e);
					if (n.length > 0) {
						const t = e[n[0]];
						if (void 0 !== t) {
							(this.morphTargetInfluences = []),
								(this.morphTargetDictionary = {});
							for (let e = 0, n = t.length; e < n; e++) {
								const n = t[e].name || String(e);
								this.morphTargetInfluences.push(0),
									(this.morphTargetDictionary[n] = e);
							}
						}
					}
				} else {
					const e = t.morphTargets;
					void 0 !== e &&
						e.length > 0 &&
						console.error(
							"THREE.Mesh.updateMorphTargets() no longer supports THREE.Geometry. Use THREE.BufferGeometry instead."
						);
				}
			},
			raycast: function (t, e) {
				const n = this.geometry,
					i = this.material,
					r = this.matrixWorld;
				if (void 0 === i) return;
				if (
					(null === n.boundingSphere && n.computeBoundingSphere(),
					ru.copy(n.boundingSphere),
					ru.applyMatrix4(r),
					!1 === t.ray.intersectsSphere(ru))
				)
					return;
				if (
					(nu.getInverse(r),
					iu.copy(t.ray).applyMatrix4(nu),
					null !== n.boundingBox && !1 === iu.intersectsBox(n.boundingBox))
				)
					return;
				let o;
				if (n.isBufferGeometry) {
					const r = n.index,
						s = n.attributes.position,
						a = n.morphAttributes.position,
						c = n.morphTargetsRelative,
						l = n.attributes.uv,
						h = n.attributes.uv2,
						u = n.groups,
						d = n.drawRange;
					if (null !== r)
						if (Array.isArray(i))
							for (let n = 0, p = u.length; n < p; n++) {
								const p = u[n],
									f = i[p.materialIndex];
								for (
									let n = Math.max(p.start, d.start),
										i = Math.min(p.start + p.count, d.start + d.count);
									n < i;
									n += 3
								) {
									const i = r.getX(n),
										u = r.getX(n + 1),
										d = r.getX(n + 2);
									(o = wu(this, f, t, iu, s, a, c, l, h, i, u, d)) &&
										((o.faceIndex = Math.floor(n / 3)),
										(o.face.materialIndex = p.materialIndex),
										e.push(o));
								}
							}
						else {
							for (
								let n = Math.max(0, d.start),
									u = Math.min(r.count, d.start + d.count);
								n < u;
								n += 3
							) {
								const u = r.getX(n),
									d = r.getX(n + 1),
									p = r.getX(n + 2);
								(o = wu(this, i, t, iu, s, a, c, l, h, u, d, p)) &&
									((o.faceIndex = Math.floor(n / 3)), e.push(o));
							}
						}
					else if (void 0 !== s)
						if (Array.isArray(i))
							for (let n = 0, r = u.length; n < r; n++) {
								const r = u[n],
									p = i[r.materialIndex];
								for (
									let n = Math.max(r.start, d.start),
										i = Math.min(r.start + r.count, d.start + d.count);
									n < i;
									n += 3
								) {
									(o = wu(this, p, t, iu, s, a, c, l, h, n, n + 1, n + 2)) &&
										((o.faceIndex = Math.floor(n / 3)),
										(o.face.materialIndex = r.materialIndex),
										e.push(o));
								}
							}
						else {
							for (
								let n = Math.max(0, d.start),
									r = Math.min(s.count, d.start + d.count);
								n < r;
								n += 3
							) {
								(o = wu(this, i, t, iu, s, a, c, l, h, n, n + 1, n + 2)) &&
									((o.faceIndex = Math.floor(n / 3)), e.push(o));
							}
						}
				} else if (n.isGeometry) {
					const r = Array.isArray(i),
						s = n.vertices,
						a = n.faces;
					let c;
					const l = n.faceVertexUvs[0];
					l.length > 0 && (c = l);
					for (let n = 0, l = a.length; n < l; n++) {
						const l = a[n],
							h = r ? i[l.materialIndex] : i;
						if (void 0 === h) continue;
						const u = s[l.a],
							d = s[l.b],
							p = s[l.c];
						if ((o = bu(this, h, t, iu, u, d, p, vu))) {
							if (c && c[n]) {
								const t = c[n];
								fu.copy(t[0]),
									mu.copy(t[1]),
									gu.copy(t[2]),
									(o.uv = _h.getUV(vu, u, d, p, fu, mu, gu, new Kc()));
							}
							(o.face = l), (o.faceIndex = n), e.push(o);
						}
					}
				}
			},
		});
		let _u = 0;
		const Mu = new vl(),
			Su = new kl(),
			Tu = new ll();
		function Eu() {
			Object.defineProperty(this, "id", { value: (_u += 2) }),
				(this.uuid = Jc.generateUUID()),
				(this.name = ""),
				(this.type = "Geometry"),
				(this.vertices = []),
				(this.colors = []),
				(this.faces = []),
				(this.faceVertexUvs = [[]]),
				(this.morphTargets = []),
				(this.morphNormals = []),
				(this.skinWeights = []),
				(this.skinIndices = []),
				(this.lineDistances = []),
				(this.boundingBox = null),
				(this.boundingSphere = null),
				(this.elementsNeedUpdate = !1),
				(this.verticesNeedUpdate = !1),
				(this.uvsNeedUpdate = !1),
				(this.normalsNeedUpdate = !1),
				(this.colorsNeedUpdate = !1),
				(this.lineDistancesNeedUpdate = !1),
				(this.groupsNeedUpdate = !1);
		}
		Eu.prototype = Object.assign(Object.create(Xc.prototype), {
			constructor: Eu,
			isGeometry: !0,
			applyMatrix4: function (t) {
				const e = new Qc().getNormalMatrix(t);
				for (let e = 0, n = this.vertices.length; e < n; e++) {
					this.vertices[e].applyMatrix4(t);
				}
				for (let t = 0, n = this.faces.length; t < n; t++) {
					const n = this.faces[t];
					n.normal.applyMatrix3(e).normalize();
					for (let t = 0, i = n.vertexNormals.length; t < i; t++)
						n.vertexNormals[t].applyMatrix3(e).normalize();
				}
				return (
					null !== this.boundingBox && this.computeBoundingBox(),
					null !== this.boundingSphere && this.computeBoundingSphere(),
					(this.verticesNeedUpdate = !0),
					(this.normalsNeedUpdate = !0),
					this
				);
			},
			rotateX: function (t) {
				return Mu.makeRotationX(t), this.applyMatrix4(Mu), this;
			},
			rotateY: function (t) {
				return Mu.makeRotationY(t), this.applyMatrix4(Mu), this;
			},
			rotateZ: function (t) {
				return Mu.makeRotationZ(t), this.applyMatrix4(Mu), this;
			},
			translate: function (t, e, n) {
				return Mu.makeTranslation(t, e, n), this.applyMatrix4(Mu), this;
			},
			scale: function (t, e, n) {
				return Mu.makeScale(t, e, n), this.applyMatrix4(Mu), this;
			},
			lookAt: function (t) {
				return (
					Su.lookAt(t), Su.updateMatrix(), this.applyMatrix4(Su.matrix), this
				);
			},
			fromBufferGeometry: function (t) {
				const e = this,
					n = null !== t.index ? t.index : void 0,
					i = t.attributes;
				if (void 0 === i.position)
					return (
						console.error(
							"THREE.Geometry.fromBufferGeometry(): Position attribute required for conversion."
						),
						this
					);
				const r = i.position,
					o = i.normal,
					s = i.color,
					a = i.uv,
					c = i.uv2;
				void 0 !== c && (this.faceVertexUvs[1] = []);
				for (let t = 0; t < r.count; t++)
					e.vertices.push(new ll().fromBufferAttribute(r, t)),
						void 0 !== s && e.colors.push(new Eh().fromBufferAttribute(s, t));
				function l(t, n, i, r) {
					const l =
							void 0 === s
								? []
								: [
										e.colors[t].clone(),
										e.colors[n].clone(),
										e.colors[i].clone(),
								  ],
						h = new Rh(
							t,
							n,
							i,
							void 0 === o
								? []
								: [
										new ll().fromBufferAttribute(o, t),
										new ll().fromBufferAttribute(o, n),
										new ll().fromBufferAttribute(o, i),
								  ],
							l,
							r
						);
					e.faces.push(h),
						void 0 !== a &&
							e.faceVertexUvs[0].push([
								new Kc().fromBufferAttribute(a, t),
								new Kc().fromBufferAttribute(a, n),
								new Kc().fromBufferAttribute(a, i),
							]),
						void 0 !== c &&
							e.faceVertexUvs[1].push([
								new Kc().fromBufferAttribute(c, t),
								new Kc().fromBufferAttribute(c, n),
								new Kc().fromBufferAttribute(c, i),
							]);
				}
				const h = t.groups;
				if (h.length > 0)
					for (let t = 0; t < h.length; t++) {
						const e = h[t],
							i = e.start;
						for (let t = i, r = i + e.count; t < r; t += 3)
							void 0 !== n
								? l(n.getX(t), n.getX(t + 1), n.getX(t + 2), e.materialIndex)
								: l(t, t + 1, t + 2, e.materialIndex);
					}
				else if (void 0 !== n)
					for (let t = 0; t < n.count; t += 3)
						l(n.getX(t), n.getX(t + 1), n.getX(t + 2));
				else for (let t = 0; t < r.count; t += 3) l(t, t + 1, t + 2);
				return (
					this.computeFaceNormals(),
					null !== t.boundingBox && (this.boundingBox = t.boundingBox.clone()),
					null !== t.boundingSphere &&
						(this.boundingSphere = t.boundingSphere.clone()),
					this
				);
			},
			center: function () {
				return (
					this.computeBoundingBox(),
					this.boundingBox.getCenter(Tu).negate(),
					this.translate(Tu.x, Tu.y, Tu.z),
					this
				);
			},
			normalize: function () {
				this.computeBoundingSphere();
				const t = this.boundingSphere.center,
					e = this.boundingSphere.radius,
					n = 0 === e ? 1 : 1 / e,
					i = new vl();
				return (
					i.set(
						n,
						0,
						0,
						-n * t.x,
						0,
						n,
						0,
						-n * t.y,
						0,
						0,
						n,
						-n * t.z,
						0,
						0,
						0,
						1
					),
					this.applyMatrix4(i),
					this
				);
			},
			computeFaceNormals: function () {
				const t = new ll(),
					e = new ll();
				for (let n = 0, i = this.faces.length; n < i; n++) {
					const i = this.faces[n],
						r = this.vertices[i.a],
						o = this.vertices[i.b],
						s = this.vertices[i.c];
					t.subVectors(s, o),
						e.subVectors(r, o),
						t.cross(e),
						t.normalize(),
						i.normal.copy(t);
				}
			},
			computeVertexNormals: function (t) {
				void 0 === t && (t = !0);
				const e = new Array(this.vertices.length);
				for (let t = 0, n = this.vertices.length; t < n; t++) e[t] = new ll();
				if (t) {
					const t = new ll(),
						n = new ll();
					for (let i = 0, r = this.faces.length; i < r; i++) {
						const r = this.faces[i],
							o = this.vertices[r.a],
							s = this.vertices[r.b],
							a = this.vertices[r.c];
						t.subVectors(a, s),
							n.subVectors(o, s),
							t.cross(n),
							e[r.a].add(t),
							e[r.b].add(t),
							e[r.c].add(t);
					}
				} else {
					this.computeFaceNormals();
					for (let t = 0, n = this.faces.length; t < n; t++) {
						const n = this.faces[t];
						e[n.a].add(n.normal), e[n.b].add(n.normal), e[n.c].add(n.normal);
					}
				}
				for (let t = 0, n = this.vertices.length; t < n; t++) e[t].normalize();
				for (let t = 0, n = this.faces.length; t < n; t++) {
					const n = this.faces[t],
						i = n.vertexNormals;
					3 === i.length
						? (i[0].copy(e[n.a]), i[1].copy(e[n.b]), i[2].copy(e[n.c]))
						: ((i[0] = e[n.a].clone()),
						  (i[1] = e[n.b].clone()),
						  (i[2] = e[n.c].clone()));
				}
				this.faces.length > 0 && (this.normalsNeedUpdate = !0);
			},
			computeFlatVertexNormals: function () {
				this.computeFaceNormals();
				for (let t = 0, e = this.faces.length; t < e; t++) {
					const e = this.faces[t],
						n = e.vertexNormals;
					3 === n.length
						? (n[0].copy(e.normal), n[1].copy(e.normal), n[2].copy(e.normal))
						: ((n[0] = e.normal.clone()),
						  (n[1] = e.normal.clone()),
						  (n[2] = e.normal.clone()));
				}
				this.faces.length > 0 && (this.normalsNeedUpdate = !0);
			},
			computeMorphNormals: function () {
				for (let t = 0, e = this.faces.length; t < e; t++) {
					const e = this.faces[t];
					e.__originalFaceNormal
						? e.__originalFaceNormal.copy(e.normal)
						: (e.__originalFaceNormal = e.normal.clone()),
						e.__originalVertexNormals || (e.__originalVertexNormals = []);
					for (let t = 0, n = e.vertexNormals.length; t < n; t++)
						e.__originalVertexNormals[t]
							? e.__originalVertexNormals[t].copy(e.vertexNormals[t])
							: (e.__originalVertexNormals[t] = e.vertexNormals[t].clone());
				}
				const t = new Eu();
				t.faces = this.faces;
				for (let e = 0, n = this.morphTargets.length; e < n; e++) {
					if (!this.morphNormals[e]) {
						(this.morphNormals[e] = {}),
							(this.morphNormals[e].faceNormals = []),
							(this.morphNormals[e].vertexNormals = []);
						const t = this.morphNormals[e].faceNormals,
							n = this.morphNormals[e].vertexNormals;
						for (let e = 0, i = this.faces.length; e < i; e++) {
							const e = new ll(),
								i = { a: new ll(), b: new ll(), c: new ll() };
							t.push(e), n.push(i);
						}
					}
					const n = this.morphNormals[e];
					(t.vertices = this.morphTargets[e].vertices),
						t.computeFaceNormals(),
						t.computeVertexNormals();
					for (let t = 0, e = this.faces.length; t < e; t++) {
						const e = this.faces[t],
							i = n.faceNormals[t],
							r = n.vertexNormals[t];
						i.copy(e.normal),
							r.a.copy(e.vertexNormals[0]),
							r.b.copy(e.vertexNormals[1]),
							r.c.copy(e.vertexNormals[2]);
					}
				}
				for (let t = 0, e = this.faces.length; t < e; t++) {
					const e = this.faces[t];
					(e.normal = e.__originalFaceNormal),
						(e.vertexNormals = e.__originalVertexNormals);
				}
			},
			computeBoundingBox: function () {
				null === this.boundingBox && (this.boundingBox = new Jl()),
					this.boundingBox.setFromPoints(this.vertices);
			},
			computeBoundingSphere: function () {
				null === this.boundingSphere && (this.boundingSphere = new $l()),
					this.boundingSphere.setFromPoints(this.vertices);
			},
			merge: function (t, e, n) {
				if (!t || !t.isGeometry)
					return void console.error(
						"THREE.Geometry.merge(): geometry not an instance of THREE.Geometry.",
						t
					);
				let i,
					r = this.vertices.length,
					o = this.vertices,
					s = t.vertices,
					a = this.faces,
					c = t.faces,
					l = this.colors,
					h = t.colors;
				void 0 === n && (n = 0),
					void 0 !== e && (i = new Qc().getNormalMatrix(e));
				for (let t = 0, n = s.length; t < n; t++) {
					const n = s[t].clone();
					void 0 !== e && n.applyMatrix4(e), o.push(n);
				}
				for (let t = 0, e = h.length; t < e; t++) l.push(h[t].clone());
				for (let t = 0, e = c.length; t < e; t++) {
					let e,
						o,
						s,
						l = c[t],
						h = l.vertexNormals,
						u = l.vertexColors;
					(e = new Rh(l.a + r, l.b + r, l.c + r)).normal.copy(l.normal),
						void 0 !== i && e.normal.applyMatrix3(i).normalize();
					for (let t = 0, n = h.length; t < n; t++)
						(o = h[t].clone()),
							void 0 !== i && o.applyMatrix3(i).normalize(),
							e.vertexNormals.push(o);
					e.color.copy(l.color);
					for (let t = 0, n = u.length; t < n; t++)
						(s = u[t]), e.vertexColors.push(s.clone());
					(e.materialIndex = l.materialIndex + n), a.push(e);
				}
				for (let e = 0, n = t.faceVertexUvs.length; e < n; e++) {
					const n = t.faceVertexUvs[e];
					void 0 === this.faceVertexUvs[e] && (this.faceVertexUvs[e] = []);
					for (let t = 0, i = n.length; t < i; t++) {
						const i = n[t],
							r = [];
						for (let t = 0, e = i.length; t < e; t++) r.push(i[t].clone());
						this.faceVertexUvs[e].push(r);
					}
				}
			},
			mergeMesh: function (t) {
				t && t.isMesh
					? (t.matrixAutoUpdate && t.updateMatrix(),
					  this.merge(t.geometry, t.matrix))
					: console.error(
							"THREE.Geometry.mergeMesh(): mesh not an instance of THREE.Mesh.",
							t
					  );
			},
			mergeVertices: function () {
				const t = {},
					e = [],
					n = [],
					i = Math.pow(10, 4);
				for (let r = 0, o = this.vertices.length; r < o; r++) {
					const o = this.vertices[r],
						s =
							Math.round(o.x * i) +
							"_" +
							Math.round(o.y * i) +
							"_" +
							Math.round(o.z * i);
					void 0 === t[s]
						? ((t[s] = r), e.push(this.vertices[r]), (n[r] = e.length - 1))
						: (n[r] = n[t[s]]);
				}
				const r = [];
				for (let t = 0, e = this.faces.length; t < e; t++) {
					const e = this.faces[t];
					(e.a = n[e.a]), (e.b = n[e.b]), (e.c = n[e.c]);
					const i = [e.a, e.b, e.c];
					for (let e = 0; e < 3; e++)
						if (i[e] === i[(e + 1) % 3]) {
							r.push(t);
							break;
						}
				}
				for (let t = r.length - 1; t >= 0; t--) {
					const e = r[t];
					this.faces.splice(e, 1);
					for (let t = 0, n = this.faceVertexUvs.length; t < n; t++)
						this.faceVertexUvs[t].splice(e, 1);
				}
				const o = this.vertices.length - e.length;
				return (this.vertices = e), o;
			},
			setFromPoints: function (t) {
				this.vertices = [];
				for (let e = 0, n = t.length; e < n; e++) {
					const n = t[e];
					this.vertices.push(new ll(n.x, n.y, n.z || 0));
				}
				return this;
			},
			sortFacesByMaterialIndex: function () {
				const t = this.faces,
					e = t.length;
				for (let n = 0; n < e; n++) t[n]._id = n;
				t.sort(function (t, e) {
					return t.materialIndex - e.materialIndex;
				});
				const n = this.faceVertexUvs[0],
					i = this.faceVertexUvs[1];
				let r, o;
				n && n.length === e && (r = []), i && i.length === e && (o = []);
				for (let s = 0; s < e; s++) {
					const e = t[s]._id;
					r && r.push(n[e]), o && o.push(i[e]);
				}
				r && (this.faceVertexUvs[0] = r), o && (this.faceVertexUvs[1] = o);
			},
			toJSON: function () {
				const t = {
					metadata: {
						version: 4.5,
						type: "Geometry",
						generator: "Geometry.toJSON",
					},
				};
				if (
					((t.uuid = this.uuid),
					(t.type = this.type),
					"" !== this.name && (t.name = this.name),
					void 0 !== this.parameters)
				) {
					const e = this.parameters;
					for (const n in e) void 0 !== e[n] && (t[n] = e[n]);
					return t;
				}
				const e = [];
				for (let t = 0; t < this.vertices.length; t++) {
					const n = this.vertices[t];
					e.push(n.x, n.y, n.z);
				}
				const n = [],
					i = [],
					r = {},
					o = [],
					s = {},
					a = [],
					c = {};
				for (let t = 0; t < this.faces.length; t++) {
					const e = this.faces[t],
						i = !0,
						r = !1,
						o = void 0 !== this.faceVertexUvs[0][t],
						s = e.normal.length() > 0,
						a = e.vertexNormals.length > 0,
						c = 1 !== e.color.r || 1 !== e.color.g || 1 !== e.color.b,
						p = e.vertexColors.length > 0;
					let f = 0;
					if (
						((f = l(
							(f = l(
								(f = l(
									(f = l(
										(f = l(
											(f = l((f = l((f = l(f, 0, 0)), 1, i)), 2, r)),
											3,
											o
										)),
										4,
										s
									)),
									5,
									a
								)),
								6,
								c
							)),
							7,
							p
						)),
						n.push(f),
						n.push(e.a, e.b, e.c),
						n.push(e.materialIndex),
						o)
					) {
						const e = this.faceVertexUvs[0][t];
						n.push(d(e[0]), d(e[1]), d(e[2]));
					}
					if ((s && n.push(h(e.normal)), a)) {
						const t = e.vertexNormals;
						n.push(h(t[0]), h(t[1]), h(t[2]));
					}
					if ((c && n.push(u(e.color)), p)) {
						const t = e.vertexColors;
						n.push(u(t[0]), u(t[1]), u(t[2]));
					}
				}
				function l(t, e, n) {
					return n ? t | (1 << e) : t & ~(1 << e);
				}
				function h(t) {
					const e = t.x.toString() + t.y.toString() + t.z.toString();
					return void 0 !== r[e]
						? r[e]
						: ((r[e] = i.length / 3), i.push(t.x, t.y, t.z), r[e]);
				}
				function u(t) {
					const e = t.r.toString() + t.g.toString() + t.b.toString();
					return void 0 !== s[e]
						? s[e]
						: ((s[e] = o.length), o.push(t.getHex()), s[e]);
				}
				function d(t) {
					const e = t.x.toString() + t.y.toString();
					return void 0 !== c[e]
						? c[e]
						: ((c[e] = a.length / 2), a.push(t.x, t.y), c[e]);
				}
				return (
					(t.data = {}),
					(t.data.vertices = e),
					(t.data.normals = i),
					o.length > 0 && (t.data.colors = o),
					a.length > 0 && (t.data.uvs = [a]),
					(t.data.faces = n),
					t
				);
			},
			clone: function () {
				return new Eu().copy(this);
			},
			copy: function (t) {
				(this.vertices = []),
					(this.colors = []),
					(this.faces = []),
					(this.faceVertexUvs = [[]]),
					(this.morphTargets = []),
					(this.morphNormals = []),
					(this.skinWeights = []),
					(this.skinIndices = []),
					(this.lineDistances = []),
					(this.boundingBox = null),
					(this.boundingSphere = null),
					(this.name = t.name);
				const e = t.vertices;
				for (let t = 0, n = e.length; t < n; t++)
					this.vertices.push(e[t].clone());
				const n = t.colors;
				for (let t = 0, e = n.length; t < e; t++)
					this.colors.push(n[t].clone());
				const i = t.faces;
				for (let t = 0, e = i.length; t < e; t++) this.faces.push(i[t].clone());
				for (let e = 0, n = t.faceVertexUvs.length; e < n; e++) {
					const n = t.faceVertexUvs[e];
					void 0 === this.faceVertexUvs[e] && (this.faceVertexUvs[e] = []);
					for (let t = 0, i = n.length; t < i; t++) {
						const i = n[t],
							r = [];
						for (let t = 0, e = i.length; t < e; t++) {
							const e = i[t];
							r.push(e.clone());
						}
						this.faceVertexUvs[e].push(r);
					}
				}
				const r = t.morphTargets;
				for (let t = 0, e = r.length; t < e; t++) {
					const e = {};
					if (((e.name = r[t].name), void 0 !== r[t].vertices)) {
						e.vertices = [];
						for (let n = 0, i = r[t].vertices.length; n < i; n++)
							e.vertices.push(r[t].vertices[n].clone());
					}
					if (void 0 !== r[t].normals) {
						e.normals = [];
						for (let n = 0, i = r[t].normals.length; n < i; n++)
							e.normals.push(r[t].normals[n].clone());
					}
					this.morphTargets.push(e);
				}
				const o = t.morphNormals;
				for (let t = 0, e = o.length; t < e; t++) {
					const e = {};
					if (void 0 !== o[t].vertexNormals) {
						e.vertexNormals = [];
						for (let n = 0, i = o[t].vertexNormals.length; n < i; n++) {
							const i = o[t].vertexNormals[n],
								r = {};
							(r.a = i.a.clone()),
								(r.b = i.b.clone()),
								(r.c = i.c.clone()),
								e.vertexNormals.push(r);
						}
					}
					if (void 0 !== o[t].faceNormals) {
						e.faceNormals = [];
						for (let n = 0, i = o[t].faceNormals.length; n < i; n++)
							e.faceNormals.push(o[t].faceNormals[n].clone());
					}
					this.morphNormals.push(e);
				}
				const s = t.skinWeights;
				for (let t = 0, e = s.length; t < e; t++)
					this.skinWeights.push(s[t].clone());
				const a = t.skinIndices;
				for (let t = 0, e = a.length; t < e; t++)
					this.skinIndices.push(a[t].clone());
				const c = t.lineDistances;
				for (let t = 0, e = c.length; t < e; t++) this.lineDistances.push(c[t]);
				const l = t.boundingBox;
				null !== l && (this.boundingBox = l.clone());
				const h = t.boundingSphere;
				return (
					null !== h && (this.boundingSphere = h.clone()),
					(this.elementsNeedUpdate = t.elementsNeedUpdate),
					(this.verticesNeedUpdate = t.verticesNeedUpdate),
					(this.uvsNeedUpdate = t.uvsNeedUpdate),
					(this.normalsNeedUpdate = t.normalsNeedUpdate),
					(this.colorsNeedUpdate = t.colorsNeedUpdate),
					(this.lineDistancesNeedUpdate = t.lineDistancesNeedUpdate),
					(this.groupsNeedUpdate = t.groupsNeedUpdate),
					this
				);
			},
			dispose: function () {
				this.dispatchEvent({ type: "dispose" });
			},
		});
		class Au extends eu {
			constructor(t, e, n, i, r, o) {
				super(),
					(this.type = "BoxBufferGeometry"),
					(this.parameters = {
						width: t,
						height: e,
						depth: n,
						widthSegments: i,
						heightSegments: r,
						depthSegments: o,
					});
				const s = this;
				(t = t || 1),
					(e = e || 1),
					(n = n || 1),
					(i = Math.floor(i) || 1),
					(r = Math.floor(r) || 1);
				const a = [],
					c = [],
					l = [],
					h = [];
				let u = 0,
					d = 0;
				function p(t, e, n, i, r, o, p, f, m, g, v) {
					const y = o / m,
						x = p / g,
						b = o / 2,
						w = p / 2,
						_ = f / 2,
						M = m + 1,
						S = g + 1;
					let T = 0,
						E = 0;
					const A = new ll();
					for (let o = 0; o < S; o++) {
						const s = o * x - w;
						for (let a = 0; a < M; a++) {
							const u = a * y - b;
							(A[t] = u * i),
								(A[e] = s * r),
								(A[n] = _),
								c.push(A.x, A.y, A.z),
								(A[t] = 0),
								(A[e] = 0),
								(A[n] = f > 0 ? 1 : -1),
								l.push(A.x, A.y, A.z),
								h.push(a / m),
								h.push(1 - o / g),
								(T += 1);
						}
					}
					for (let t = 0; t < g; t++)
						for (let e = 0; e < m; e++) {
							const n = u + e + M * t,
								i = u + e + M * (t + 1),
								r = u + (e + 1) + M * (t + 1),
								o = u + (e + 1) + M * t;
							a.push(n, i, o), a.push(i, r, o), (E += 6);
						}
					s.addGroup(d, E, v), (d += E), (u += T);
				}
				p("z", "y", "x", -1, -1, n, e, t, (o = Math.floor(o) || 1), r, 0),
					p("z", "y", "x", 1, -1, n, e, -t, o, r, 1),
					p("x", "z", "y", 1, 1, t, n, e, i, o, 2),
					p("x", "z", "y", 1, -1, t, n, -e, i, o, 3),
					p("x", "y", "z", 1, -1, t, e, n, i, r, 4),
					p("x", "y", "z", -1, -1, t, e, -n, i, r, 5),
					this.setIndex(a),
					this.setAttribute("position", new jh(c, 3)),
					this.setAttribute("normal", new jh(l, 3)),
					this.setAttribute("uv", new jh(h, 2));
			}
		}
		function Lu(t) {
			const e = {};
			for (const n in t) {
				e[n] = {};
				for (const i in t[n]) {
					const r = t[n][i];
					r &&
					(r.isColor ||
						r.isMatrix3 ||
						r.isMatrix4 ||
						r.isVector2 ||
						r.isVector3 ||
						r.isVector4 ||
						r.isTexture)
						? (e[n][i] = r.clone())
						: Array.isArray(r)
						? (e[n][i] = r.slice())
						: (e[n][i] = r);
				}
			}
			return e;
		}
		function Pu(t) {
			const e = {};
			for (let n = 0; n < t.length; n++) {
				const i = Lu(t[n]);
				for (const t in i) e[t] = i[t];
			}
			return e;
		}
		const Ru = { clone: Lu, merge: Pu };
		var Cu =
				"void main() {\n\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n}",
			Ou = "void main() {\n\tgl_FragColor = vec4( 1.0, 0.0, 0.0, 1.0 );\n}";
		function Du(t) {
			Oh.call(this),
				(this.type = "ShaderMaterial"),
				(this.defines = {}),
				(this.uniforms = {}),
				(this.vertexShader = Cu),
				(this.fragmentShader = Ou),
				(this.linewidth = 1),
				(this.wireframe = !1),
				(this.wireframeLinewidth = 1),
				(this.fog = !1),
				(this.lights = !1),
				(this.clipping = !1),
				(this.skinning = !1),
				(this.morphTargets = !1),
				(this.morphNormals = !1),
				(this.extensions = {
					derivatives: !1,
					fragDepth: !1,
					drawBuffers: !1,
					shaderTextureLOD: !1,
				}),
				(this.defaultAttributeValues = {
					color: [1, 1, 1],
					uv: [0, 0],
					uv2: [0, 0],
				}),
				(this.index0AttributeName = void 0),
				(this.uniformsNeedUpdate = !1),
				void 0 !== t &&
					(void 0 !== t.attributes &&
						console.error(
							"THREE.ShaderMaterial: attributes should now be defined in THREE.BufferGeometry instead."
						),
					this.setValues(t));
		}
		function Iu() {
			kl.call(this),
				(this.type = "Camera"),
				(this.matrixWorldInverse = new vl()),
				(this.projectionMatrix = new vl()),
				(this.projectionMatrixInverse = new vl());
		}
		function ku(t, e, n, i) {
			Iu.call(this),
				(this.type = "PerspectiveCamera"),
				(this.fov = void 0 !== t ? t : 50),
				(this.zoom = 1),
				(this.near = void 0 !== n ? n : 0.1),
				(this.far = void 0 !== i ? i : 2e3),
				(this.focus = 10),
				(this.aspect = void 0 !== e ? e : 1),
				(this.view = null),
				(this.filmGauge = 35),
				(this.filmOffset = 0),
				this.updateProjectionMatrix();
		}
		(Du.prototype = Object.create(Oh.prototype)),
			(Du.prototype.constructor = Du),
			(Du.prototype.isShaderMaterial = !0),
			(Du.prototype.copy = function (t) {
				return (
					Oh.prototype.copy.call(this, t),
					(this.fragmentShader = t.fragmentShader),
					(this.vertexShader = t.vertexShader),
					(this.uniforms = Lu(t.uniforms)),
					(this.defines = Object.assign({}, t.defines)),
					(this.wireframe = t.wireframe),
					(this.wireframeLinewidth = t.wireframeLinewidth),
					(this.lights = t.lights),
					(this.clipping = t.clipping),
					(this.skinning = t.skinning),
					(this.morphTargets = t.morphTargets),
					(this.morphNormals = t.morphNormals),
					(this.extensions = Object.assign({}, t.extensions)),
					this
				);
			}),
			(Du.prototype.toJSON = function (t) {
				const e = Oh.prototype.toJSON.call(this, t);
				e.uniforms = {};
				for (const n in this.uniforms) {
					const i = this.uniforms[n].value;
					i && i.isTexture
						? (e.uniforms[n] = { type: "t", value: i.toJSON(t).uuid })
						: i && i.isColor
						? (e.uniforms[n] = { type: "c", value: i.getHex() })
						: i && i.isVector2
						? (e.uniforms[n] = { type: "v2", value: i.toArray() })
						: i && i.isVector3
						? (e.uniforms[n] = { type: "v3", value: i.toArray() })
						: i && i.isVector4
						? (e.uniforms[n] = { type: "v4", value: i.toArray() })
						: i && i.isMatrix3
						? (e.uniforms[n] = { type: "m3", value: i.toArray() })
						: i && i.isMatrix4
						? (e.uniforms[n] = { type: "m4", value: i.toArray() })
						: (e.uniforms[n] = { value: i });
				}
				Object.keys(this.defines).length > 0 && (e.defines = this.defines),
					(e.vertexShader = this.vertexShader),
					(e.fragmentShader = this.fragmentShader);
				const n = {};
				for (const t in this.extensions)
					!0 === this.extensions[t] && (n[t] = !0);
				return Object.keys(n).length > 0 && (e.extensions = n), e;
			}),
			(Iu.prototype = Object.assign(Object.create(kl.prototype), {
				constructor: Iu,
				isCamera: !0,
				copy: function (t, e) {
					return (
						kl.prototype.copy.call(this, t, e),
						this.matrixWorldInverse.copy(t.matrixWorldInverse),
						this.projectionMatrix.copy(t.projectionMatrix),
						this.projectionMatrixInverse.copy(t.projectionMatrixInverse),
						this
					);
				},
				getWorldDirection: function (t) {
					void 0 === t &&
						(console.warn(
							"THREE.Camera: .getWorldDirection() target is now required"
						),
						(t = new ll())),
						this.updateMatrixWorld(!0);
					const e = this.matrixWorld.elements;
					return t.set(-e[8], -e[9], -e[10]).normalize();
				},
				updateMatrixWorld: function (t) {
					kl.prototype.updateMatrixWorld.call(this, t),
						this.matrixWorldInverse.getInverse(this.matrixWorld);
				},
				updateWorldMatrix: function (t, e) {
					kl.prototype.updateWorldMatrix.call(this, t, e),
						this.matrixWorldInverse.getInverse(this.matrixWorld);
				},
				clone: function () {
					return new this.constructor().copy(this);
				},
			})),
			(ku.prototype = Object.assign(Object.create(Iu.prototype), {
				constructor: ku,
				isPerspectiveCamera: !0,
				copy: function (t, e) {
					return (
						Iu.prototype.copy.call(this, t, e),
						(this.fov = t.fov),
						(this.zoom = t.zoom),
						(this.near = t.near),
						(this.far = t.far),
						(this.focus = t.focus),
						(this.aspect = t.aspect),
						(this.view = null === t.view ? null : Object.assign({}, t.view)),
						(this.filmGauge = t.filmGauge),
						(this.filmOffset = t.filmOffset),
						this
					);
				},
				setFocalLength: function (t) {
					const e = (0.5 * this.getFilmHeight()) / t;
					(this.fov = 2 * Jc.RAD2DEG * Math.atan(e)),
						this.updateProjectionMatrix();
				},
				getFocalLength: function () {
					const t = Math.tan(0.5 * Jc.DEG2RAD * this.fov);
					return (0.5 * this.getFilmHeight()) / t;
				},
				getEffectiveFOV: function () {
					return (
						2 *
						Jc.RAD2DEG *
						Math.atan(Math.tan(0.5 * Jc.DEG2RAD * this.fov) / this.zoom)
					);
				},
				getFilmWidth: function () {
					return this.filmGauge * Math.min(this.aspect, 1);
				},
				getFilmHeight: function () {
					return this.filmGauge / Math.max(this.aspect, 1);
				},
				setViewOffset: function (t, e, n, i, r, o) {
					(this.aspect = t / e),
						null === this.view &&
							(this.view = {
								enabled: !0,
								fullWidth: 1,
								fullHeight: 1,
								offsetX: 0,
								offsetY: 0,
								width: 1,
								height: 1,
							}),
						(this.view.enabled = !0),
						(this.view.fullWidth = t),
						(this.view.fullHeight = e),
						(this.view.offsetX = n),
						(this.view.offsetY = i),
						(this.view.width = r),
						(this.view.height = o),
						this.updateProjectionMatrix();
				},
				clearViewOffset: function () {
					null !== this.view && (this.view.enabled = !1),
						this.updateProjectionMatrix();
				},
				updateProjectionMatrix: function () {
					let t = this.near,
						e = (t * Math.tan(0.5 * Jc.DEG2RAD * this.fov)) / this.zoom,
						n = 2 * e,
						i = this.aspect * n,
						r = -0.5 * i,
						o = this.view;
					if (null !== this.view && this.view.enabled) {
						const t = o.fullWidth,
							s = o.fullHeight;
						(r += (o.offsetX * i) / t),
							(e -= (o.offsetY * n) / s),
							(i *= o.width / t),
							(n *= o.height / s);
					}
					const s = this.filmOffset;
					0 !== s && (r += (t * s) / this.getFilmWidth()),
						this.projectionMatrix.makePerspective(
							r,
							r + i,
							e,
							e - n,
							t,
							this.far
						),
						this.projectionMatrixInverse.getInverse(this.projectionMatrix);
				},
				toJSON: function (t) {
					const e = kl.prototype.toJSON.call(this, t);
					return (
						(e.object.fov = this.fov),
						(e.object.zoom = this.zoom),
						(e.object.near = this.near),
						(e.object.far = this.far),
						(e.object.focus = this.focus),
						(e.object.aspect = this.aspect),
						null !== this.view &&
							(e.object.view = Object.assign({}, this.view)),
						(e.object.filmGauge = this.filmGauge),
						(e.object.filmOffset = this.filmOffset),
						e
					);
				},
			}));
		const Nu = 90,
			Bu = 1;
		function Fu(t, e, n) {
			if (
				(kl.call(this),
				(this.type = "CubeCamera"),
				!0 !== n.isWebGLCubeRenderTarget)
			)
				return void console.error(
					"THREE.CubeCamera: The constructor now expects an instance of WebGLCubeRenderTarget as third parameter."
				);
			this.renderTarget = n;
			const i = new ku(Nu, Bu, t, e);
			(i.layers = this.layers),
				i.up.set(0, -1, 0),
				i.lookAt(new ll(1, 0, 0)),
				this.add(i);
			const r = new ku(Nu, Bu, t, e);
			(r.layers = this.layers),
				r.up.set(0, -1, 0),
				r.lookAt(new ll(-1, 0, 0)),
				this.add(r);
			const o = new ku(Nu, Bu, t, e);
			(o.layers = this.layers),
				o.up.set(0, 0, 1),
				o.lookAt(new ll(0, 1, 0)),
				this.add(o);
			const s = new ku(Nu, Bu, t, e);
			(s.layers = this.layers),
				s.up.set(0, 0, -1),
				s.lookAt(new ll(0, -1, 0)),
				this.add(s);
			const a = new ku(Nu, Bu, t, e);
			(a.layers = this.layers),
				a.up.set(0, -1, 0),
				a.lookAt(new ll(0, 0, 1)),
				this.add(a);
			const c = new ku(Nu, Bu, t, e);
			(c.layers = this.layers),
				c.up.set(0, -1, 0),
				c.lookAt(new ll(0, 0, -1)),
				this.add(c),
				(this.update = function (t, e) {
					null === this.parent && this.updateMatrixWorld();
					const l = t.xr.enabled,
						h = t.getRenderTarget();
					t.xr.enabled = !1;
					const u = n.texture.generateMipmaps;
					(n.texture.generateMipmaps = !1),
						t.setRenderTarget(n, 0),
						t.render(e, i),
						t.setRenderTarget(n, 1),
						t.render(e, r),
						t.setRenderTarget(n, 2),
						t.render(e, o),
						t.setRenderTarget(n, 3),
						t.render(e, s),
						t.setRenderTarget(n, 4),
						t.render(e, a),
						(n.texture.generateMipmaps = u),
						t.setRenderTarget(n, 5),
						t.render(e, c),
						t.setRenderTarget(h),
						(t.xr.enabled = l);
				}),
				(this.clear = function (t, e, i, r) {
					const o = t.getRenderTarget();
					for (let o = 0; o < 6; o++) t.setRenderTarget(n, o), t.clear(e, i, r);
					t.setRenderTarget(o);
				});
		}
		function zu(t, e, n) {
			Number.isInteger(e) &&
				(console.warn(
					"THREE.WebGLCubeRenderTarget: constructor signature is now WebGLCubeRenderTarget( size, options )"
				),
				(e = n)),
				rl.call(this, t, t, e);
		}
		function Hu(t, e, n, i, r, o, s, a, c, l, h, u) {
			nl.call(this, null, o, s, a, c, l, i, r, h, u),
				(this.image = { data: t || null, width: e || 1, height: n || 1 }),
				(this.magFilter = void 0 !== c ? c : ha),
				(this.minFilter = void 0 !== l ? l : ha),
				(this.generateMipmaps = !1),
				(this.flipY = !1),
				(this.unpackAlignment = 1),
				(this.needsUpdate = !0);
		}
		(Fu.prototype = Object.create(kl.prototype)),
			(Fu.prototype.constructor = Fu),
			(zu.prototype = Object.create(rl.prototype)),
			(zu.prototype.constructor = zu),
			(zu.prototype.isWebGLCubeRenderTarget = !0),
			(zu.prototype.fromEquirectangularTexture = function (t, e) {
				(this.texture.type = e.type),
					(this.texture.format = e.format),
					(this.texture.encoding = e.encoding);
				const n = new Nl(),
					i = {
						uniforms: { tEquirect: { value: null } },
						vertexShader: [
							"varying vec3 vWorldDirection;",
							"vec3 transformDirection( in vec3 dir, in mat4 matrix ) {",
							"\treturn normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );",
							"}",
							"void main() {",
							"\tvWorldDirection = transformDirection( position, modelMatrix );",
							"\t#include <begin_vertex>",
							"\t#include <project_vertex>",
							"}",
						].join("\n"),
						fragmentShader: [
							"uniform sampler2D tEquirect;",
							"varying vec3 vWorldDirection;",
							"#include <common>",
							"void main() {",
							"\tvec3 direction = normalize( vWorldDirection );",
							"\tvec2 sampleUV = equirectUv( direction );",
							"\tgl_FragColor = texture2D( tEquirect, sampleUV );",
							"}",
						].join("\n"),
					},
					r = new Du({
						name: "CubemapFromEquirect",
						uniforms: Lu(i.uniforms),
						vertexShader: i.vertexShader,
						fragmentShader: i.fragmentShader,
						side: fs,
						blending: gs,
					});
				r.uniforms.tEquirect.value = e;
				const o = new xu(new Au(5, 5, 5), r);
				return (
					n.add(o),
					new Fu(1, 10, this).update(t, n),
					o.geometry.dispose(),
					o.material.dispose(),
					this
				);
			}),
			(Hu.prototype = Object.create(nl.prototype)),
			(Hu.prototype.constructor = Hu),
			(Hu.prototype.isDataTexture = !0);
		const Uu = new $l(),
			Gu = new ll();
		function Vu(t, e, n, i, r, o) {
			this.planes = [
				void 0 !== t ? t : new uh(),
				void 0 !== e ? e : new uh(),
				void 0 !== n ? n : new uh(),
				void 0 !== i ? i : new uh(),
				void 0 !== r ? r : new uh(),
				void 0 !== o ? o : new uh(),
			];
		}
		Object.assign(Vu.prototype, {
			set: function (t, e, n, i, r, o) {
				const s = this.planes;
				return (
					s[0].copy(t),
					s[1].copy(e),
					s[2].copy(n),
					s[3].copy(i),
					s[4].copy(r),
					s[5].copy(o),
					this
				);
			},
			clone: function () {
				return new this.constructor().copy(this);
			},
			copy: function (t) {
				const e = this.planes;
				for (let n = 0; n < 6; n++) e[n].copy(t.planes[n]);
				return this;
			},
			setFromProjectionMatrix: function (t) {
				const e = this.planes,
					n = t.elements,
					i = n[0],
					r = n[1],
					o = n[2],
					s = n[3],
					a = n[4],
					c = n[5],
					l = n[6],
					h = n[7],
					u = n[8],
					d = n[9],
					p = n[10],
					f = n[11],
					m = n[12],
					g = n[13],
					v = n[14],
					y = n[15];
				return (
					e[0].setComponents(s - i, h - a, f - u, y - m).normalize(),
					e[1].setComponents(s + i, h + a, f + u, y + m).normalize(),
					e[2].setComponents(s + r, h + c, f + d, y + g).normalize(),
					e[3].setComponents(s - r, h - c, f - d, y - g).normalize(),
					e[4].setComponents(s - o, h - l, f - p, y - v).normalize(),
					e[5].setComponents(s + o, h + l, f + p, y + v).normalize(),
					this
				);
			},
			intersectsObject: function (t) {
				const e = t.geometry;
				return (
					null === e.boundingSphere && e.computeBoundingSphere(),
					Uu.copy(e.boundingSphere).applyMatrix4(t.matrixWorld),
					this.intersectsSphere(Uu)
				);
			},
			intersectsSprite: function (t) {
				return (
					Uu.center.set(0, 0, 0),
					(Uu.radius = 0.7071067811865476),
					Uu.applyMatrix4(t.matrixWorld),
					this.intersectsSphere(Uu)
				);
			},
			intersectsSphere: function (t) {
				const e = this.planes,
					n = t.center,
					i = -t.radius;
				for (let t = 0; t < 6; t++) {
					if (e[t].distanceToPoint(n) < i) return !1;
				}
				return !0;
			},
			intersectsBox: function (t) {
				const e = this.planes;
				for (let n = 0; n < 6; n++) {
					const i = e[n];
					if (
						((Gu.x = i.normal.x > 0 ? t.max.x : t.min.x),
						(Gu.y = i.normal.y > 0 ? t.max.y : t.min.y),
						(Gu.z = i.normal.z > 0 ? t.max.z : t.min.z),
						i.distanceToPoint(Gu) < 0)
					)
						return !1;
				}
				return !0;
			},
			containsPoint: function (t) {
				const e = this.planes;
				for (let n = 0; n < 6; n++) if (e[n].distanceToPoint(t) < 0) return !1;
				return !0;
			},
		});
		const ju = {
			common: {
				diffuse: { value: new Eh(15658734) },
				opacity: { value: 1 },
				map: { value: null },
				uvTransform: { value: new Qc() },
				uv2Transform: { value: new Qc() },
				alphaMap: { value: null },
			},
			specularmap: { specularMap: { value: null } },
			envmap: {
				envMap: { value: null },
				flipEnvMap: { value: -1 },
				reflectivity: { value: 1 },
				refractionRatio: { value: 0.98 },
				maxMipLevel: { value: 0 },
			},
			aomap: { aoMap: { value: null }, aoMapIntensity: { value: 1 } },
			lightmap: { lightMap: { value: null }, lightMapIntensity: { value: 1 } },
			emissivemap: { emissiveMap: { value: null } },
			bumpmap: { bumpMap: { value: null }, bumpScale: { value: 1 } },
			normalmap: {
				normalMap: { value: null },
				normalScale: { value: new Kc(1, 1) },
			},
			displacementmap: {
				displacementMap: { value: null },
				displacementScale: { value: 1 },
				displacementBias: { value: 0 },
			},
			roughnessmap: { roughnessMap: { value: null } },
			metalnessmap: { metalnessMap: { value: null } },
			gradientmap: { gradientMap: { value: null } },
			fog: {
				fogDensity: { value: 25e-5 },
				fogNear: { value: 1 },
				fogFar: { value: 2e3 },
				fogColor: { value: new Eh(16777215) },
			},
			lights: {
				ambientLightColor: { value: [] },
				lightProbe: { value: [] },
				directionalLights: {
					value: [],
					properties: { direction: {}, color: {} },
				},
				directionalLightShadows: {
					value: [],
					properties: {
						shadowBias: {},
						shadowNormalBias: {},
						shadowRadius: {},
						shadowMapSize: {},
					},
				},
				directionalShadowMap: { value: [] },
				directionalShadowMatrix: { value: [] },
				spotLights: {
					value: [],
					properties: {
						color: {},
						position: {},
						direction: {},
						distance: {},
						coneCos: {},
						penumbraCos: {},
						decay: {},
					},
				},
				spotLightShadows: {
					value: [],
					properties: {
						shadowBias: {},
						shadowNormalBias: {},
						shadowRadius: {},
						shadowMapSize: {},
					},
				},
				spotShadowMap: { value: [] },
				spotShadowMatrix: { value: [] },
				pointLights: {
					value: [],
					properties: { color: {}, position: {}, decay: {}, distance: {} },
				},
				pointLightShadows: {
					value: [],
					properties: {
						shadowBias: {},
						shadowNormalBias: {},
						shadowRadius: {},
						shadowMapSize: {},
						shadowCameraNear: {},
						shadowCameraFar: {},
					},
				},
				pointShadowMap: { value: [] },
				pointShadowMatrix: { value: [] },
				hemisphereLights: {
					value: [],
					properties: { direction: {}, skyColor: {}, groundColor: {} },
				},
				rectAreaLights: {
					value: [],
					properties: { color: {}, position: {}, width: {}, height: {} },
				},
			},
			points: {
				diffuse: { value: new Eh(15658734) },
				opacity: { value: 1 },
				size: { value: 1 },
				scale: { value: 1 },
				map: { value: null },
				alphaMap: { value: null },
				uvTransform: { value: new Qc() },
			},
			sprite: {
				diffuse: { value: new Eh(15658734) },
				opacity: { value: 1 },
				center: { value: new Kc(0.5, 0.5) },
				rotation: { value: 0 },
				map: { value: null },
				alphaMap: { value: null },
				uvTransform: { value: new Qc() },
			},
		};
		function Wu() {
			let t = null,
				e = !1,
				n = null,
				i = null;
			function r(e, o) {
				n(e, o), (i = t.requestAnimationFrame(r));
			}
			return {
				start: function () {
					!0 !== e &&
						null !== n &&
						((i = t.requestAnimationFrame(r)), (e = !0));
				},
				stop: function () {
					t.cancelAnimationFrame(i), (e = !1);
				},
				setAnimationLoop: function (t) {
					n = t;
				},
				setContext: function (e) {
					t = e;
				},
			};
		}
		function qu(t, e) {
			const n = e.isWebGL2,
				i = new WeakMap();
			return {
				get: function (t) {
					return t.isInterleavedBufferAttribute && (t = t.data), i.get(t);
				},
				remove: function (e) {
					e.isInterleavedBufferAttribute && (e = e.data);
					const n = i.get(e);
					n && (t.deleteBuffer(n.buffer), i.delete(e));
				},
				update: function (e, r) {
					e.isInterleavedBufferAttribute && (e = e.data);
					const o = i.get(e);
					void 0 === o
						? i.set(
								e,
								(function (e, n) {
									const i = e.array,
										r = e.usage,
										o = t.createBuffer();
									t.bindBuffer(n, o),
										t.bufferData(n, i, r),
										e.onUploadCallback();
									let s = 5126;
									return (
										i instanceof Float32Array
											? (s = 5126)
											: i instanceof Float64Array
											? console.warn(
													"THREE.WebGLAttributes: Unsupported data buffer format: Float64Array."
											  )
											: i instanceof Uint16Array
											? (s = 5123)
											: i instanceof Int16Array
											? (s = 5122)
											: i instanceof Uint32Array
											? (s = 5125)
											: i instanceof Int32Array
											? (s = 5124)
											: i instanceof Int8Array
											? (s = 5120)
											: i instanceof Uint8Array && (s = 5121),
										{
											buffer: o,
											type: s,
											bytesPerElement: i.BYTES_PER_ELEMENT,
											version: e.version,
										}
									);
								})(e, r)
						  )
						: o.version < e.version &&
						  ((function (e, i, r) {
								const o = i.array,
									s = i.updateRange;
								t.bindBuffer(r, e),
									-1 === s.count
										? t.bufferSubData(r, 0, o)
										: (n
												? t.bufferSubData(
														r,
														s.offset * o.BYTES_PER_ELEMENT,
														o,
														s.offset,
														s.count
												  )
												: t.bufferSubData(
														r,
														s.offset * o.BYTES_PER_ELEMENT,
														o.subarray(s.offset, s.offset + s.count)
												  ),
										  (s.count = -1));
						  })(o.buffer, e, r),
						  (o.version = e.version));
				},
			};
		}
		function Yu(t, e, n, i) {
			Eu.call(this),
				(this.type = "PlaneGeometry"),
				(this.parameters = {
					width: t,
					height: e,
					widthSegments: n,
					heightSegments: i,
				}),
				this.fromBufferGeometry(new Xu(t, e, n, i)),
				this.mergeVertices();
		}
		function Xu(t, e, n, i) {
			eu.call(this),
				(this.type = "PlaneBufferGeometry"),
				(this.parameters = {
					width: t,
					height: e,
					widthSegments: n,
					heightSegments: i,
				});
			const r = (t = t || 1) / 2,
				o = (e = e || 1) / 2,
				s = Math.floor(n) || 1,
				a = Math.floor(i) || 1,
				c = s + 1,
				l = a + 1,
				h = t / s,
				u = e / a,
				d = [],
				p = [],
				f = [],
				m = [];
			for (let t = 0; t < l; t++) {
				const e = t * u - o;
				for (let n = 0; n < c; n++) {
					const i = n * h - r;
					p.push(i, -e, 0), f.push(0, 0, 1), m.push(n / s), m.push(1 - t / a);
				}
			}
			for (let t = 0; t < a; t++)
				for (let e = 0; e < s; e++) {
					const n = e + c * t,
						i = e + c * (t + 1),
						r = e + 1 + c * (t + 1),
						o = e + 1 + c * t;
					d.push(n, i, o), d.push(i, r, o);
				}
			this.setIndex(d),
				this.setAttribute("position", new jh(p, 3)),
				this.setAttribute("normal", new jh(f, 3)),
				this.setAttribute("uv", new jh(m, 2));
		}
		(Yu.prototype = Object.create(Eu.prototype)),
			(Yu.prototype.constructor = Yu),
			(Xu.prototype = Object.create(eu.prototype)),
			(Xu.prototype.constructor = Xu);
		const Zu = {
				alphamap_fragment:
					"#ifdef USE_ALPHAMAP\n\tdiffuseColor.a *= texture2D( alphaMap, vUv ).g;\n#endif",
				alphamap_pars_fragment:
					"#ifdef USE_ALPHAMAP\n\tuniform sampler2D alphaMap;\n#endif",
				alphatest_fragment:
					"#ifdef ALPHATEST\n\tif ( diffuseColor.a < ALPHATEST ) discard;\n#endif",
				aomap_fragment:
					"#ifdef USE_AOMAP\n\tfloat ambientOcclusion = ( texture2D( aoMap, vUv2 ).r - 1.0 ) * aoMapIntensity + 1.0;\n\treflectedLight.indirectDiffuse *= ambientOcclusion;\n\t#if defined( USE_ENVMAP ) && defined( STANDARD )\n\t\tfloat dotNV = saturate( dot( geometry.normal, geometry.viewDir ) );\n\t\treflectedLight.indirectSpecular *= computeSpecularOcclusion( dotNV, ambientOcclusion, material.specularRoughness );\n\t#endif\n#endif",
				aomap_pars_fragment:
					"#ifdef USE_AOMAP\n\tuniform sampler2D aoMap;\n\tuniform float aoMapIntensity;\n#endif",
				begin_vertex: "vec3 transformed = vec3( position );",
				beginnormal_vertex:
					"vec3 objectNormal = vec3( normal );\n#ifdef USE_TANGENT\n\tvec3 objectTangent = vec3( tangent.xyz );\n#endif",
				bsdfs:
					"vec2 integrateSpecularBRDF( const in float dotNV, const in float roughness ) {\n\tconst vec4 c0 = vec4( - 1, - 0.0275, - 0.572, 0.022 );\n\tconst vec4 c1 = vec4( 1, 0.0425, 1.04, - 0.04 );\n\tvec4 r = roughness * c0 + c1;\n\tfloat a004 = min( r.x * r.x, exp2( - 9.28 * dotNV ) ) * r.x + r.y;\n\treturn vec2( -1.04, 1.04 ) * a004 + r.zw;\n}\nfloat punctualLightIntensityToIrradianceFactor( const in float lightDistance, const in float cutoffDistance, const in float decayExponent ) {\n#if defined ( PHYSICALLY_CORRECT_LIGHTS )\n\tfloat distanceFalloff = 1.0 / max( pow( lightDistance, decayExponent ), 0.01 );\n\tif( cutoffDistance > 0.0 ) {\n\t\tdistanceFalloff *= pow2( saturate( 1.0 - pow4( lightDistance / cutoffDistance ) ) );\n\t}\n\treturn distanceFalloff;\n#else\n\tif( cutoffDistance > 0.0 && decayExponent > 0.0 ) {\n\t\treturn pow( saturate( -lightDistance / cutoffDistance + 1.0 ), decayExponent );\n\t}\n\treturn 1.0;\n#endif\n}\nvec3 BRDF_Diffuse_Lambert( const in vec3 diffuseColor ) {\n\treturn RECIPROCAL_PI * diffuseColor;\n}\nvec3 F_Schlick( const in vec3 specularColor, const in float dotLH ) {\n\tfloat fresnel = exp2( ( -5.55473 * dotLH - 6.98316 ) * dotLH );\n\treturn ( 1.0 - specularColor ) * fresnel + specularColor;\n}\nvec3 F_Schlick_RoughnessDependent( const in vec3 F0, const in float dotNV, const in float roughness ) {\n\tfloat fresnel = exp2( ( -5.55473 * dotNV - 6.98316 ) * dotNV );\n\tvec3 Fr = max( vec3( 1.0 - roughness ), F0 ) - F0;\n\treturn Fr * fresnel + F0;\n}\nfloat G_GGX_Smith( const in float alpha, const in float dotNL, const in float dotNV ) {\n\tfloat a2 = pow2( alpha );\n\tfloat gl = dotNL + sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNL ) );\n\tfloat gv = dotNV + sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNV ) );\n\treturn 1.0 / ( gl * gv );\n}\nfloat G_GGX_SmithCorrelated( const in float alpha, const in float dotNL, const in float dotNV ) {\n\tfloat a2 = pow2( alpha );\n\tfloat gv = dotNL * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNV ) );\n\tfloat gl = dotNV * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNL ) );\n\treturn 0.5 / max( gv + gl, EPSILON );\n}\nfloat D_GGX( const in float alpha, const in float dotNH ) {\n\tfloat a2 = pow2( alpha );\n\tfloat denom = pow2( dotNH ) * ( a2 - 1.0 ) + 1.0;\n\treturn RECIPROCAL_PI * a2 / pow2( denom );\n}\nvec3 BRDF_Specular_GGX( const in IncidentLight incidentLight, const in vec3 viewDir, const in vec3 normal, const in vec3 specularColor, const in float roughness ) {\n\tfloat alpha = pow2( roughness );\n\tvec3 halfDir = normalize( incidentLight.direction + viewDir );\n\tfloat dotNL = saturate( dot( normal, incidentLight.direction ) );\n\tfloat dotNV = saturate( dot( normal, viewDir ) );\n\tfloat dotNH = saturate( dot( normal, halfDir ) );\n\tfloat dotLH = saturate( dot( incidentLight.direction, halfDir ) );\n\tvec3 F = F_Schlick( specularColor, dotLH );\n\tfloat G = G_GGX_SmithCorrelated( alpha, dotNL, dotNV );\n\tfloat D = D_GGX( alpha, dotNH );\n\treturn F * ( G * D );\n}\nvec2 LTC_Uv( const in vec3 N, const in vec3 V, const in float roughness ) {\n\tconst float LUT_SIZE  = 64.0;\n\tconst float LUT_SCALE = ( LUT_SIZE - 1.0 ) / LUT_SIZE;\n\tconst float LUT_BIAS  = 0.5 / LUT_SIZE;\n\tfloat dotNV = saturate( dot( N, V ) );\n\tvec2 uv = vec2( roughness, sqrt( 1.0 - dotNV ) );\n\tuv = uv * LUT_SCALE + LUT_BIAS;\n\treturn uv;\n}\nfloat LTC_ClippedSphereFormFactor( const in vec3 f ) {\n\tfloat l = length( f );\n\treturn max( ( l * l + f.z ) / ( l + 1.0 ), 0.0 );\n}\nvec3 LTC_EdgeVectorFormFactor( const in vec3 v1, const in vec3 v2 ) {\n\tfloat x = dot( v1, v2 );\n\tfloat y = abs( x );\n\tfloat a = 0.8543985 + ( 0.4965155 + 0.0145206 * y ) * y;\n\tfloat b = 3.4175940 + ( 4.1616724 + y ) * y;\n\tfloat v = a / b;\n\tfloat theta_sintheta = ( x > 0.0 ) ? v : 0.5 * inversesqrt( max( 1.0 - x * x, 1e-7 ) ) - v;\n\treturn cross( v1, v2 ) * theta_sintheta;\n}\nvec3 LTC_Evaluate( const in vec3 N, const in vec3 V, const in vec3 P, const in mat3 mInv, const in vec3 rectCoords[ 4 ] ) {\n\tvec3 v1 = rectCoords[ 1 ] - rectCoords[ 0 ];\n\tvec3 v2 = rectCoords[ 3 ] - rectCoords[ 0 ];\n\tvec3 lightNormal = cross( v1, v2 );\n\tif( dot( lightNormal, P - rectCoords[ 0 ] ) < 0.0 ) return vec3( 0.0 );\n\tvec3 T1, T2;\n\tT1 = normalize( V - N * dot( V, N ) );\n\tT2 = - cross( N, T1 );\n\tmat3 mat = mInv * transposeMat3( mat3( T1, T2, N ) );\n\tvec3 coords[ 4 ];\n\tcoords[ 0 ] = mat * ( rectCoords[ 0 ] - P );\n\tcoords[ 1 ] = mat * ( rectCoords[ 1 ] - P );\n\tcoords[ 2 ] = mat * ( rectCoords[ 2 ] - P );\n\tcoords[ 3 ] = mat * ( rectCoords[ 3 ] - P );\n\tcoords[ 0 ] = normalize( coords[ 0 ] );\n\tcoords[ 1 ] = normalize( coords[ 1 ] );\n\tcoords[ 2 ] = normalize( coords[ 2 ] );\n\tcoords[ 3 ] = normalize( coords[ 3 ] );\n\tvec3 vectorFormFactor = vec3( 0.0 );\n\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 0 ], coords[ 1 ] );\n\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 1 ], coords[ 2 ] );\n\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 2 ], coords[ 3 ] );\n\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 3 ], coords[ 0 ] );\n\tfloat result = LTC_ClippedSphereFormFactor( vectorFormFactor );\n\treturn vec3( result );\n}\nvec3 BRDF_Specular_GGX_Environment( const in vec3 viewDir, const in vec3 normal, const in vec3 specularColor, const in float roughness ) {\n\tfloat dotNV = saturate( dot( normal, viewDir ) );\n\tvec2 brdf = integrateSpecularBRDF( dotNV, roughness );\n\treturn specularColor * brdf.x + brdf.y;\n}\nvoid BRDF_Specular_Multiscattering_Environment( const in GeometricContext geometry, const in vec3 specularColor, const in float roughness, inout vec3 singleScatter, inout vec3 multiScatter ) {\n\tfloat dotNV = saturate( dot( geometry.normal, geometry.viewDir ) );\n\tvec3 F = F_Schlick_RoughnessDependent( specularColor, dotNV, roughness );\n\tvec2 brdf = integrateSpecularBRDF( dotNV, roughness );\n\tvec3 FssEss = F * brdf.x + brdf.y;\n\tfloat Ess = brdf.x + brdf.y;\n\tfloat Ems = 1.0 - Ess;\n\tvec3 Favg = specularColor + ( 1.0 - specularColor ) * 0.047619;\tvec3 Fms = FssEss * Favg / ( 1.0 - Ems * Favg );\n\tsingleScatter += FssEss;\n\tmultiScatter += Fms * Ems;\n}\nfloat G_BlinnPhong_Implicit( ) {\n\treturn 0.25;\n}\nfloat D_BlinnPhong( const in float shininess, const in float dotNH ) {\n\treturn RECIPROCAL_PI * ( shininess * 0.5 + 1.0 ) * pow( dotNH, shininess );\n}\nvec3 BRDF_Specular_BlinnPhong( const in IncidentLight incidentLight, const in GeometricContext geometry, const in vec3 specularColor, const in float shininess ) {\n\tvec3 halfDir = normalize( incidentLight.direction + geometry.viewDir );\n\tfloat dotNH = saturate( dot( geometry.normal, halfDir ) );\n\tfloat dotLH = saturate( dot( incidentLight.direction, halfDir ) );\n\tvec3 F = F_Schlick( specularColor, dotLH );\n\tfloat G = G_BlinnPhong_Implicit( );\n\tfloat D = D_BlinnPhong( shininess, dotNH );\n\treturn F * ( G * D );\n}\nfloat GGXRoughnessToBlinnExponent( const in float ggxRoughness ) {\n\treturn ( 2.0 / pow2( ggxRoughness + 0.0001 ) - 2.0 );\n}\nfloat BlinnExponentToGGXRoughness( const in float blinnExponent ) {\n\treturn sqrt( 2.0 / ( blinnExponent + 2.0 ) );\n}\n#if defined( USE_SHEEN )\nfloat D_Charlie(float roughness, float NoH) {\n\tfloat invAlpha  = 1.0 / roughness;\n\tfloat cos2h = NoH * NoH;\n\tfloat sin2h = max(1.0 - cos2h, 0.0078125);\treturn (2.0 + invAlpha) * pow(sin2h, invAlpha * 0.5) / (2.0 * PI);\n}\nfloat V_Neubelt(float NoV, float NoL) {\n\treturn saturate(1.0 / (4.0 * (NoL + NoV - NoL * NoV)));\n}\nvec3 BRDF_Specular_Sheen( const in float roughness, const in vec3 L, const in GeometricContext geometry, vec3 specularColor ) {\n\tvec3 N = geometry.normal;\n\tvec3 V = geometry.viewDir;\n\tvec3 H = normalize( V + L );\n\tfloat dotNH = saturate( dot( N, H ) );\n\treturn specularColor * D_Charlie( roughness, dotNH ) * V_Neubelt( dot(N, V), dot(N, L) );\n}\n#endif",
				bumpmap_pars_fragment:
					"#ifdef USE_BUMPMAP\n\tuniform sampler2D bumpMap;\n\tuniform float bumpScale;\n\tvec2 dHdxy_fwd() {\n\t\tvec2 dSTdx = dFdx( vUv );\n\t\tvec2 dSTdy = dFdy( vUv );\n\t\tfloat Hll = bumpScale * texture2D( bumpMap, vUv ).x;\n\t\tfloat dBx = bumpScale * texture2D( bumpMap, vUv + dSTdx ).x - Hll;\n\t\tfloat dBy = bumpScale * texture2D( bumpMap, vUv + dSTdy ).x - Hll;\n\t\treturn vec2( dBx, dBy );\n\t}\n\tvec3 perturbNormalArb( vec3 surf_pos, vec3 surf_norm, vec2 dHdxy ) {\n\t\tvec3 vSigmaX = vec3( dFdx( surf_pos.x ), dFdx( surf_pos.y ), dFdx( surf_pos.z ) );\n\t\tvec3 vSigmaY = vec3( dFdy( surf_pos.x ), dFdy( surf_pos.y ), dFdy( surf_pos.z ) );\n\t\tvec3 vN = surf_norm;\n\t\tvec3 R1 = cross( vSigmaY, vN );\n\t\tvec3 R2 = cross( vN, vSigmaX );\n\t\tfloat fDet = dot( vSigmaX, R1 );\n\t\tfDet *= ( float( gl_FrontFacing ) * 2.0 - 1.0 );\n\t\tvec3 vGrad = sign( fDet ) * ( dHdxy.x * R1 + dHdxy.y * R2 );\n\t\treturn normalize( abs( fDet ) * surf_norm - vGrad );\n\t}\n#endif",
				clipping_planes_fragment:
					"#if NUM_CLIPPING_PLANES > 0\n\tvec4 plane;\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < UNION_CLIPPING_PLANES; i ++ ) {\n\t\tplane = clippingPlanes[ i ];\n\t\tif ( dot( vClipPosition, plane.xyz ) > plane.w ) discard;\n\t}\n\t#pragma unroll_loop_end\n\t#if UNION_CLIPPING_PLANES < NUM_CLIPPING_PLANES\n\t\tbool clipped = true;\n\t\t#pragma unroll_loop_start\n\t\tfor ( int i = UNION_CLIPPING_PLANES; i < NUM_CLIPPING_PLANES; i ++ ) {\n\t\t\tplane = clippingPlanes[ i ];\n\t\t\tclipped = ( dot( vClipPosition, plane.xyz ) > plane.w ) && clipped;\n\t\t}\n\t\t#pragma unroll_loop_end\n\t\tif ( clipped ) discard;\n\t#endif\n#endif",
				clipping_planes_pars_fragment:
					"#if NUM_CLIPPING_PLANES > 0\n\tvarying vec3 vClipPosition;\n\tuniform vec4 clippingPlanes[ NUM_CLIPPING_PLANES ];\n#endif",
				clipping_planes_pars_vertex:
					"#if NUM_CLIPPING_PLANES > 0\n\tvarying vec3 vClipPosition;\n#endif",
				clipping_planes_vertex:
					"#if NUM_CLIPPING_PLANES > 0\n\tvClipPosition = - mvPosition.xyz;\n#endif",
				color_fragment:
					"#ifdef USE_COLOR\n\tdiffuseColor.rgb *= vColor;\n#endif",
				color_pars_fragment: "#ifdef USE_COLOR\n\tvarying vec3 vColor;\n#endif",
				color_pars_vertex: "#ifdef USE_COLOR\n\tvarying vec3 vColor;\n#endif",
				color_vertex: "#ifdef USE_COLOR\n\tvColor.xyz = color.xyz;\n#endif",
				common:
					"#define PI 3.141592653589793\n#define PI2 6.283185307179586\n#define PI_HALF 1.5707963267948966\n#define RECIPROCAL_PI 0.3183098861837907\n#define RECIPROCAL_PI2 0.15915494309189535\n#define EPSILON 1e-6\n#ifndef saturate\n#define saturate(a) clamp( a, 0.0, 1.0 )\n#endif\n#define whiteComplement(a) ( 1.0 - saturate( a ) )\nfloat pow2( const in float x ) { return x*x; }\nfloat pow3( const in float x ) { return x*x*x; }\nfloat pow4( const in float x ) { float x2 = x*x; return x2*x2; }\nfloat average( const in vec3 color ) { return dot( color, vec3( 0.3333 ) ); }\nhighp float rand( const in vec2 uv ) {\n\tconst highp float a = 12.9898, b = 78.233, c = 43758.5453;\n\thighp float dt = dot( uv.xy, vec2( a,b ) ), sn = mod( dt, PI );\n\treturn fract(sin(sn) * c);\n}\n#ifdef HIGH_PRECISION\n\tfloat precisionSafeLength( vec3 v ) { return length( v ); }\n#else\n\tfloat max3( vec3 v ) { return max( max( v.x, v.y ), v.z ); }\n\tfloat precisionSafeLength( vec3 v ) {\n\t\tfloat maxComponent = max3( abs( v ) );\n\t\treturn length( v / maxComponent ) * maxComponent;\n\t}\n#endif\nstruct IncidentLight {\n\tvec3 color;\n\tvec3 direction;\n\tbool visible;\n};\nstruct ReflectedLight {\n\tvec3 directDiffuse;\n\tvec3 directSpecular;\n\tvec3 indirectDiffuse;\n\tvec3 indirectSpecular;\n};\nstruct GeometricContext {\n\tvec3 position;\n\tvec3 normal;\n\tvec3 viewDir;\n#ifdef CLEARCOAT\n\tvec3 clearcoatNormal;\n#endif\n};\nvec3 transformDirection( in vec3 dir, in mat4 matrix ) {\n\treturn normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );\n}\nvec3 inverseTransformDirection( in vec3 dir, in mat4 matrix ) {\n\treturn normalize( ( vec4( dir, 0.0 ) * matrix ).xyz );\n}\nvec3 projectOnPlane(in vec3 point, in vec3 pointOnPlane, in vec3 planeNormal ) {\n\tfloat distance = dot( planeNormal, point - pointOnPlane );\n\treturn - distance * planeNormal + point;\n}\nfloat sideOfPlane( in vec3 point, in vec3 pointOnPlane, in vec3 planeNormal ) {\n\treturn sign( dot( point - pointOnPlane, planeNormal ) );\n}\nvec3 linePlaneIntersect( in vec3 pointOnLine, in vec3 lineDirection, in vec3 pointOnPlane, in vec3 planeNormal ) {\n\treturn lineDirection * ( dot( planeNormal, pointOnPlane - pointOnLine ) / dot( planeNormal, lineDirection ) ) + pointOnLine;\n}\nmat3 transposeMat3( const in mat3 m ) {\n\tmat3 tmp;\n\ttmp[ 0 ] = vec3( m[ 0 ].x, m[ 1 ].x, m[ 2 ].x );\n\ttmp[ 1 ] = vec3( m[ 0 ].y, m[ 1 ].y, m[ 2 ].y );\n\ttmp[ 2 ] = vec3( m[ 0 ].z, m[ 1 ].z, m[ 2 ].z );\n\treturn tmp;\n}\nfloat linearToRelativeLuminance( const in vec3 color ) {\n\tvec3 weights = vec3( 0.2126, 0.7152, 0.0722 );\n\treturn dot( weights, color.rgb );\n}\nbool isPerspectiveMatrix( mat4 m ) {\n  return m[ 2 ][ 3 ] == - 1.0;\n}\nvec2 equirectUv( in vec3 dir ) {\n\tfloat u = atan( dir.z, dir.x ) * RECIPROCAL_PI2 + 0.5;\n\tfloat v = asin( clamp( dir.y, - 1.0, 1.0 ) ) * RECIPROCAL_PI + 0.5;\n\treturn vec2( u, v );\n}",
				cube_uv_reflection_fragment:
					"#ifdef ENVMAP_TYPE_CUBE_UV\n#define cubeUV_maxMipLevel 8.0\n#define cubeUV_minMipLevel 4.0\n#define cubeUV_maxTileSize 256.0\n#define cubeUV_minTileSize 16.0\nfloat getFace(vec3 direction) {\n    vec3 absDirection = abs(direction);\n    float face = -1.0;\n    if (absDirection.x > absDirection.z) {\n      if (absDirection.x > absDirection.y)\n        face = direction.x > 0.0 ? 0.0 : 3.0;\n      else\n        face = direction.y > 0.0 ? 1.0 : 4.0;\n    } else {\n      if (absDirection.z > absDirection.y)\n        face = direction.z > 0.0 ? 2.0 : 5.0;\n      else\n        face = direction.y > 0.0 ? 1.0 : 4.0;\n    }\n    return face;\n}\nvec2 getUV(vec3 direction, float face) {\n    vec2 uv;\n    if (face == 0.0) {\n      uv = vec2(direction.z, direction.y) / abs(direction.x);    } else if (face == 1.0) {\n      uv = vec2(-direction.x, -direction.z) / abs(direction.y);    } else if (face == 2.0) {\n      uv = vec2(-direction.x, direction.y) / abs(direction.z);    } else if (face == 3.0) {\n      uv = vec2(-direction.z, direction.y) / abs(direction.x);    } else if (face == 4.0) {\n      uv = vec2(-direction.x, direction.z) / abs(direction.y);    } else {\n      uv = vec2(direction.x, direction.y) / abs(direction.z);    }\n    return 0.5 * (uv + 1.0);\n}\nvec3 bilinearCubeUV(sampler2D envMap, vec3 direction, float mipInt) {\n  float face = getFace(direction);\n  float filterInt = max(cubeUV_minMipLevel - mipInt, 0.0);\n  mipInt = max(mipInt, cubeUV_minMipLevel);\n  float faceSize = exp2(mipInt);\n  float texelSize = 1.0 / (3.0 * cubeUV_maxTileSize);\n  vec2 uv = getUV(direction, face) * (faceSize - 1.0);\n  vec2 f = fract(uv);\n  uv += 0.5 - f;\n  if (face > 2.0) {\n    uv.y += faceSize;\n    face -= 3.0;\n  }\n  uv.x += face * faceSize;\n  if(mipInt < cubeUV_maxMipLevel){\n    uv.y += 2.0 * cubeUV_maxTileSize;\n  }\n  uv.y += filterInt * 2.0 * cubeUV_minTileSize;\n  uv.x += 3.0 * max(0.0, cubeUV_maxTileSize - 2.0 * faceSize);\n  uv *= texelSize;\n  vec3 tl = envMapTexelToLinear(texture2D(envMap, uv)).rgb;\n  uv.x += texelSize;\n  vec3 tr = envMapTexelToLinear(texture2D(envMap, uv)).rgb;\n  uv.y += texelSize;\n  vec3 br = envMapTexelToLinear(texture2D(envMap, uv)).rgb;\n  uv.x -= texelSize;\n  vec3 bl = envMapTexelToLinear(texture2D(envMap, uv)).rgb;\n  vec3 tm = mix(tl, tr, f.x);\n  vec3 bm = mix(bl, br, f.x);\n  return mix(tm, bm, f.y);\n}\n#define r0 1.0\n#define v0 0.339\n#define m0 -2.0\n#define r1 0.8\n#define v1 0.276\n#define m1 -1.0\n#define r4 0.4\n#define v4 0.046\n#define m4 2.0\n#define r5 0.305\n#define v5 0.016\n#define m5 3.0\n#define r6 0.21\n#define v6 0.0038\n#define m6 4.0\nfloat roughnessToMip(float roughness) {\n  float mip = 0.0;\n  if (roughness >= r1) {\n    mip = (r0 - roughness) * (m1 - m0) / (r0 - r1) + m0;\n  } else if (roughness >= r4) {\n    mip = (r1 - roughness) * (m4 - m1) / (r1 - r4) + m1;\n  } else if (roughness >= r5) {\n    mip = (r4 - roughness) * (m5 - m4) / (r4 - r5) + m4;\n  } else if (roughness >= r6) {\n    mip = (r5 - roughness) * (m6 - m5) / (r5 - r6) + m5;\n  } else {\n    mip = -2.0 * log2(1.16 * roughness);  }\n  return mip;\n}\nvec4 textureCubeUV(sampler2D envMap, vec3 sampleDir, float roughness) {\n  float mip = clamp(roughnessToMip(roughness), m0, cubeUV_maxMipLevel);\n  float mipF = fract(mip);\n  float mipInt = floor(mip);\n  vec3 color0 = bilinearCubeUV(envMap, sampleDir, mipInt);\n  if (mipF == 0.0) {\n    return vec4(color0, 1.0);\n  } else {\n    vec3 color1 = bilinearCubeUV(envMap, sampleDir, mipInt + 1.0);\n    return vec4(mix(color0, color1, mipF), 1.0);\n  }\n}\n#endif",
				defaultnormal_vertex:
					"vec3 transformedNormal = objectNormal;\n#ifdef USE_INSTANCING\n\tmat3 m = mat3( instanceMatrix );\n\ttransformedNormal /= vec3( dot( m[ 0 ], m[ 0 ] ), dot( m[ 1 ], m[ 1 ] ), dot( m[ 2 ], m[ 2 ] ) );\n\ttransformedNormal = m * transformedNormal;\n#endif\ntransformedNormal = normalMatrix * transformedNormal;\n#ifdef FLIP_SIDED\n\ttransformedNormal = - transformedNormal;\n#endif\n#ifdef USE_TANGENT\n\tvec3 transformedTangent = ( modelViewMatrix * vec4( objectTangent, 0.0 ) ).xyz;\n\t#ifdef FLIP_SIDED\n\t\ttransformedTangent = - transformedTangent;\n\t#endif\n#endif",
				displacementmap_pars_vertex:
					"#ifdef USE_DISPLACEMENTMAP\n\tuniform sampler2D displacementMap;\n\tuniform float displacementScale;\n\tuniform float displacementBias;\n#endif",
				displacementmap_vertex:
					"#ifdef USE_DISPLACEMENTMAP\n\ttransformed += normalize( objectNormal ) * ( texture2D( displacementMap, vUv ).x * displacementScale + displacementBias );\n#endif",
				emissivemap_fragment:
					"#ifdef USE_EMISSIVEMAP\n\tvec4 emissiveColor = texture2D( emissiveMap, vUv );\n\temissiveColor.rgb = emissiveMapTexelToLinear( emissiveColor ).rgb;\n\ttotalEmissiveRadiance *= emissiveColor.rgb;\n#endif",
				emissivemap_pars_fragment:
					"#ifdef USE_EMISSIVEMAP\n\tuniform sampler2D emissiveMap;\n#endif",
				encodings_fragment:
					"gl_FragColor = linearToOutputTexel( gl_FragColor );",
				encodings_pars_fragment:
					"\nvec4 LinearToLinear( in vec4 value ) {\n\treturn value;\n}\nvec4 GammaToLinear( in vec4 value, in float gammaFactor ) {\n\treturn vec4( pow( value.rgb, vec3( gammaFactor ) ), value.a );\n}\nvec4 LinearToGamma( in vec4 value, in float gammaFactor ) {\n\treturn vec4( pow( value.rgb, vec3( 1.0 / gammaFactor ) ), value.a );\n}\nvec4 sRGBToLinear( in vec4 value ) {\n\treturn vec4( mix( pow( value.rgb * 0.9478672986 + vec3( 0.0521327014 ), vec3( 2.4 ) ), value.rgb * 0.0773993808, vec3( lessThanEqual( value.rgb, vec3( 0.04045 ) ) ) ), value.a );\n}\nvec4 LinearTosRGB( in vec4 value ) {\n\treturn vec4( mix( pow( value.rgb, vec3( 0.41666 ) ) * 1.055 - vec3( 0.055 ), value.rgb * 12.92, vec3( lessThanEqual( value.rgb, vec3( 0.0031308 ) ) ) ), value.a );\n}\nvec4 RGBEToLinear( in vec4 value ) {\n\treturn vec4( value.rgb * exp2( value.a * 255.0 - 128.0 ), 1.0 );\n}\nvec4 LinearToRGBE( in vec4 value ) {\n\tfloat maxComponent = max( max( value.r, value.g ), value.b );\n\tfloat fExp = clamp( ceil( log2( maxComponent ) ), -128.0, 127.0 );\n\treturn vec4( value.rgb / exp2( fExp ), ( fExp + 128.0 ) / 255.0 );\n}\nvec4 RGBMToLinear( in vec4 value, in float maxRange ) {\n\treturn vec4( value.rgb * value.a * maxRange, 1.0 );\n}\nvec4 LinearToRGBM( in vec4 value, in float maxRange ) {\n\tfloat maxRGB = max( value.r, max( value.g, value.b ) );\n\tfloat M = clamp( maxRGB / maxRange, 0.0, 1.0 );\n\tM = ceil( M * 255.0 ) / 255.0;\n\treturn vec4( value.rgb / ( M * maxRange ), M );\n}\nvec4 RGBDToLinear( in vec4 value, in float maxRange ) {\n\treturn vec4( value.rgb * ( ( maxRange / 255.0 ) / value.a ), 1.0 );\n}\nvec4 LinearToRGBD( in vec4 value, in float maxRange ) {\n\tfloat maxRGB = max( value.r, max( value.g, value.b ) );\n\tfloat D = max( maxRange / maxRGB, 1.0 );\n\tD = clamp( floor( D ) / 255.0, 0.0, 1.0 );\n\treturn vec4( value.rgb * ( D * ( 255.0 / maxRange ) ), D );\n}\nconst mat3 cLogLuvM = mat3( 0.2209, 0.3390, 0.4184, 0.1138, 0.6780, 0.7319, 0.0102, 0.1130, 0.2969 );\nvec4 LinearToLogLuv( in vec4 value )  {\n\tvec3 Xp_Y_XYZp = cLogLuvM * value.rgb;\n\tXp_Y_XYZp = max( Xp_Y_XYZp, vec3( 1e-6, 1e-6, 1e-6 ) );\n\tvec4 vResult;\n\tvResult.xy = Xp_Y_XYZp.xy / Xp_Y_XYZp.z;\n\tfloat Le = 2.0 * log2(Xp_Y_XYZp.y) + 127.0;\n\tvResult.w = fract( Le );\n\tvResult.z = ( Le - ( floor( vResult.w * 255.0 ) ) / 255.0 ) / 255.0;\n\treturn vResult;\n}\nconst mat3 cLogLuvInverseM = mat3( 6.0014, -2.7008, -1.7996, -1.3320, 3.1029, -5.7721, 0.3008, -1.0882, 5.6268 );\nvec4 LogLuvToLinear( in vec4 value ) {\n\tfloat Le = value.z * 255.0 + value.w;\n\tvec3 Xp_Y_XYZp;\n\tXp_Y_XYZp.y = exp2( ( Le - 127.0 ) / 2.0 );\n\tXp_Y_XYZp.z = Xp_Y_XYZp.y / value.y;\n\tXp_Y_XYZp.x = value.x * Xp_Y_XYZp.z;\n\tvec3 vRGB = cLogLuvInverseM * Xp_Y_XYZp.rgb;\n\treturn vec4( max( vRGB, 0.0 ), 1.0 );\n}",
				envmap_fragment:
					"#ifdef USE_ENVMAP\n\t#ifdef ENV_WORLDPOS\n\t\tvec3 cameraToFrag;\n\t\t\n\t\tif ( isOrthographic ) {\n\t\t\tcameraToFrag = normalize( vec3( - viewMatrix[ 0 ][ 2 ], - viewMatrix[ 1 ][ 2 ], - viewMatrix[ 2 ][ 2 ] ) );\n\t\t}  else {\n\t\t\tcameraToFrag = normalize( vWorldPosition - cameraPosition );\n\t\t}\n\t\tvec3 worldNormal = inverseTransformDirection( normal, viewMatrix );\n\t\t#ifdef ENVMAP_MODE_REFLECTION\n\t\t\tvec3 reflectVec = reflect( cameraToFrag, worldNormal );\n\t\t#else\n\t\t\tvec3 reflectVec = refract( cameraToFrag, worldNormal, refractionRatio );\n\t\t#endif\n\t#else\n\t\tvec3 reflectVec = vReflect;\n\t#endif\n\t#ifdef ENVMAP_TYPE_CUBE\n\t\tvec4 envColor = textureCube( envMap, vec3( flipEnvMap * reflectVec.x, reflectVec.yz ) );\n\t#elif defined( ENVMAP_TYPE_CUBE_UV )\n\t\tvec4 envColor = textureCubeUV( envMap, reflectVec, 0.0 );\n\t#elif defined( ENVMAP_TYPE_EQUIREC )\n\t\treflectVec = normalize( reflectVec );\n\t\tvec2 sampleUV = equirectUv( reflectVec );\n\t\tvec4 envColor = texture2D( envMap, sampleUV );\n\t#else\n\t\tvec4 envColor = vec4( 0.0 );\n\t#endif\n\t#ifndef ENVMAP_TYPE_CUBE_UV\n\t\tenvColor = envMapTexelToLinear( envColor );\n\t#endif\n\t#ifdef ENVMAP_BLENDING_MULTIPLY\n\t\toutgoingLight = mix( outgoingLight, outgoingLight * envColor.xyz, specularStrength * reflectivity );\n\t#elif defined( ENVMAP_BLENDING_MIX )\n\t\toutgoingLight = mix( outgoingLight, envColor.xyz, specularStrength * reflectivity );\n\t#elif defined( ENVMAP_BLENDING_ADD )\n\t\toutgoingLight += envColor.xyz * specularStrength * reflectivity;\n\t#endif\n#endif",
				envmap_common_pars_fragment:
					"#ifdef USE_ENVMAP\n\tuniform float envMapIntensity;\n\tuniform float flipEnvMap;\n\tuniform int maxMipLevel;\n\t#ifdef ENVMAP_TYPE_CUBE\n\t\tuniform samplerCube envMap;\n\t#else\n\t\tuniform sampler2D envMap;\n\t#endif\n\t\n#endif",
				envmap_pars_fragment:
					"#ifdef USE_ENVMAP\n\tuniform float reflectivity;\n\t#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG )\n\t\t#define ENV_WORLDPOS\n\t#endif\n\t#ifdef ENV_WORLDPOS\n\t\tvarying vec3 vWorldPosition;\n\t\tuniform float refractionRatio;\n\t#else\n\t\tvarying vec3 vReflect;\n\t#endif\n#endif",
				envmap_pars_vertex:
					"#ifdef USE_ENVMAP\n\t#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) ||defined( PHONG )\n\t\t#define ENV_WORLDPOS\n\t#endif\n\t#ifdef ENV_WORLDPOS\n\t\t\n\t\tvarying vec3 vWorldPosition;\n\t#else\n\t\tvarying vec3 vReflect;\n\t\tuniform float refractionRatio;\n\t#endif\n#endif",
				envmap_physical_pars_fragment:
					"#if defined( USE_ENVMAP )\n\t#ifdef ENVMAP_MODE_REFRACTION\n\t\tuniform float refractionRatio;\n\t#endif\n\tvec3 getLightProbeIndirectIrradiance( const in GeometricContext geometry, const in int maxMIPLevel ) {\n\t\tvec3 worldNormal = inverseTransformDirection( geometry.normal, viewMatrix );\n\t\t#ifdef ENVMAP_TYPE_CUBE\n\t\t\tvec3 queryVec = vec3( flipEnvMap * worldNormal.x, worldNormal.yz );\n\t\t\t#ifdef TEXTURE_LOD_EXT\n\t\t\t\tvec4 envMapColor = textureCubeLodEXT( envMap, queryVec, float( maxMIPLevel ) );\n\t\t\t#else\n\t\t\t\tvec4 envMapColor = textureCube( envMap, queryVec, float( maxMIPLevel ) );\n\t\t\t#endif\n\t\t\tenvMapColor.rgb = envMapTexelToLinear( envMapColor ).rgb;\n\t\t#elif defined( ENVMAP_TYPE_CUBE_UV )\n\t\t\tvec4 envMapColor = textureCubeUV( envMap, worldNormal, 1.0 );\n\t\t#else\n\t\t\tvec4 envMapColor = vec4( 0.0 );\n\t\t#endif\n\t\treturn PI * envMapColor.rgb * envMapIntensity;\n\t}\n\tfloat getSpecularMIPLevel( const in float roughness, const in int maxMIPLevel ) {\n\t\tfloat maxMIPLevelScalar = float( maxMIPLevel );\n\t\tfloat sigma = PI * roughness * roughness / ( 1.0 + roughness );\n\t\tfloat desiredMIPLevel = maxMIPLevelScalar + log2( sigma );\n\t\treturn clamp( desiredMIPLevel, 0.0, maxMIPLevelScalar );\n\t}\n\tvec3 getLightProbeIndirectRadiance( const in vec3 viewDir, const in vec3 normal, const in float roughness, const in int maxMIPLevel ) {\n\t\t#ifdef ENVMAP_MODE_REFLECTION\n\t\t  vec3 reflectVec = reflect( -viewDir, normal );\n\t\t  reflectVec = normalize( mix( reflectVec, normal, roughness * roughness) );\n\t\t#else\n\t\t  vec3 reflectVec = refract( -viewDir, normal, refractionRatio );\n\t\t#endif\n\t\treflectVec = inverseTransformDirection( reflectVec, viewMatrix );\n\t\tfloat specularMIPLevel = getSpecularMIPLevel( roughness, maxMIPLevel );\n\t\t#ifdef ENVMAP_TYPE_CUBE\n\t\t\tvec3 queryReflectVec = vec3( flipEnvMap * reflectVec.x, reflectVec.yz );\n\t\t\t#ifdef TEXTURE_LOD_EXT\n\t\t\t\tvec4 envMapColor = textureCubeLodEXT( envMap, queryReflectVec, specularMIPLevel );\n\t\t\t#else\n\t\t\t\tvec4 envMapColor = textureCube( envMap, queryReflectVec, specularMIPLevel );\n\t\t\t#endif\n\t\t\tenvMapColor.rgb = envMapTexelToLinear( envMapColor ).rgb;\n\t\t#elif defined( ENVMAP_TYPE_CUBE_UV )\n\t\t\tvec4 envMapColor = textureCubeUV( envMap, reflectVec, roughness );\n\t\t#elif defined( ENVMAP_TYPE_EQUIREC )\n\t\t\tvec2 sampleUV = equirectUv( reflectVec );\n\t\t\t#ifdef TEXTURE_LOD_EXT\n\t\t\t\tvec4 envMapColor = texture2DLodEXT( envMap, sampleUV, specularMIPLevel );\n\t\t\t#else\n\t\t\t\tvec4 envMapColor = texture2D( envMap, sampleUV, specularMIPLevel );\n\t\t\t#endif\n\t\t\tenvMapColor.rgb = envMapTexelToLinear( envMapColor ).rgb;\n\t\t#endif\n\t\treturn envMapColor.rgb * envMapIntensity;\n\t}\n#endif",
				envmap_vertex:
					"#ifdef USE_ENVMAP\n\t#ifdef ENV_WORLDPOS\n\t\tvWorldPosition = worldPosition.xyz;\n\t#else\n\t\tvec3 cameraToVertex;\n\t\tif ( isOrthographic ) { \n\t\t\tcameraToVertex = normalize( vec3( - viewMatrix[ 0 ][ 2 ], - viewMatrix[ 1 ][ 2 ], - viewMatrix[ 2 ][ 2 ] ) );\n\t\t} else {\n\t\t\tcameraToVertex = normalize( worldPosition.xyz - cameraPosition );\n\t\t}\n\t\tvec3 worldNormal = inverseTransformDirection( transformedNormal, viewMatrix );\n\t\t#ifdef ENVMAP_MODE_REFLECTION\n\t\t\tvReflect = reflect( cameraToVertex, worldNormal );\n\t\t#else\n\t\t\tvReflect = refract( cameraToVertex, worldNormal, refractionRatio );\n\t\t#endif\n\t#endif\n#endif",
				fog_vertex: "#ifdef USE_FOG\n\tfogDepth = -mvPosition.z;\n#endif",
				fog_pars_vertex: "#ifdef USE_FOG\n\tvarying float fogDepth;\n#endif",
				fog_fragment:
					"#ifdef USE_FOG\n\t#ifdef FOG_EXP2\n\t\tfloat fogFactor = 1.0 - exp( - fogDensity * fogDensity * fogDepth * fogDepth );\n\t#else\n\t\tfloat fogFactor = smoothstep( fogNear, fogFar, fogDepth );\n\t#endif\n\tgl_FragColor.rgb = mix( gl_FragColor.rgb, fogColor, fogFactor );\n#endif",
				fog_pars_fragment:
					"#ifdef USE_FOG\n\tuniform vec3 fogColor;\n\tvarying float fogDepth;\n\t#ifdef FOG_EXP2\n\t\tuniform float fogDensity;\n\t#else\n\t\tuniform float fogNear;\n\t\tuniform float fogFar;\n\t#endif\n#endif",
				gradientmap_pars_fragment:
					"#ifdef USE_GRADIENTMAP\n\tuniform sampler2D gradientMap;\n#endif\nvec3 getGradientIrradiance( vec3 normal, vec3 lightDirection ) {\n\tfloat dotNL = dot( normal, lightDirection );\n\tvec2 coord = vec2( dotNL * 0.5 + 0.5, 0.0 );\n\t#ifdef USE_GRADIENTMAP\n\t\treturn texture2D( gradientMap, coord ).rgb;\n\t#else\n\t\treturn ( coord.x < 0.7 ) ? vec3( 0.7 ) : vec3( 1.0 );\n\t#endif\n}",
				lightmap_fragment:
					"#ifdef USE_LIGHTMAP\n\tvec4 lightMapTexel= texture2D( lightMap, vUv2 );\n\treflectedLight.indirectDiffuse += PI * lightMapTexelToLinear( lightMapTexel ).rgb * lightMapIntensity;\n#endif",
				lightmap_pars_fragment:
					"#ifdef USE_LIGHTMAP\n\tuniform sampler2D lightMap;\n\tuniform float lightMapIntensity;\n#endif",
				lights_lambert_vertex:
					"vec3 diffuse = vec3( 1.0 );\nGeometricContext geometry;\ngeometry.position = mvPosition.xyz;\ngeometry.normal = normalize( transformedNormal );\ngeometry.viewDir = ( isOrthographic ) ? vec3( 0, 0, 1 ) : normalize( -mvPosition.xyz );\nGeometricContext backGeometry;\nbackGeometry.position = geometry.position;\nbackGeometry.normal = -geometry.normal;\nbackGeometry.viewDir = geometry.viewDir;\nvLightFront = vec3( 0.0 );\nvIndirectFront = vec3( 0.0 );\n#ifdef DOUBLE_SIDED\n\tvLightBack = vec3( 0.0 );\n\tvIndirectBack = vec3( 0.0 );\n#endif\nIncidentLight directLight;\nfloat dotNL;\nvec3 directLightColor_Diffuse;\nvIndirectFront += getAmbientLightIrradiance( ambientLightColor );\nvIndirectFront += getLightProbeIrradiance( lightProbe, geometry );\n#ifdef DOUBLE_SIDED\n\tvIndirectBack += getAmbientLightIrradiance( ambientLightColor );\n\tvIndirectBack += getLightProbeIrradiance( lightProbe, backGeometry );\n#endif\n#if NUM_POINT_LIGHTS > 0\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {\n\t\tgetPointDirectLightIrradiance( pointLights[ i ], geometry, directLight );\n\t\tdotNL = dot( geometry.normal, directLight.direction );\n\t\tdirectLightColor_Diffuse = PI * directLight.color;\n\t\tvLightFront += saturate( dotNL ) * directLightColor_Diffuse;\n\t\t#ifdef DOUBLE_SIDED\n\t\t\tvLightBack += saturate( -dotNL ) * directLightColor_Diffuse;\n\t\t#endif\n\t}\n\t#pragma unroll_loop_end\n#endif\n#if NUM_SPOT_LIGHTS > 0\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {\n\t\tgetSpotDirectLightIrradiance( spotLights[ i ], geometry, directLight );\n\t\tdotNL = dot( geometry.normal, directLight.direction );\n\t\tdirectLightColor_Diffuse = PI * directLight.color;\n\t\tvLightFront += saturate( dotNL ) * directLightColor_Diffuse;\n\t\t#ifdef DOUBLE_SIDED\n\t\t\tvLightBack += saturate( -dotNL ) * directLightColor_Diffuse;\n\t\t#endif\n\t}\n\t#pragma unroll_loop_end\n#endif\n#if NUM_DIR_LIGHTS > 0\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\n\t\tgetDirectionalDirectLightIrradiance( directionalLights[ i ], geometry, directLight );\n\t\tdotNL = dot( geometry.normal, directLight.direction );\n\t\tdirectLightColor_Diffuse = PI * directLight.color;\n\t\tvLightFront += saturate( dotNL ) * directLightColor_Diffuse;\n\t\t#ifdef DOUBLE_SIDED\n\t\t\tvLightBack += saturate( -dotNL ) * directLightColor_Diffuse;\n\t\t#endif\n\t}\n\t#pragma unroll_loop_end\n#endif\n#if NUM_HEMI_LIGHTS > 0\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_HEMI_LIGHTS; i ++ ) {\n\t\tvIndirectFront += getHemisphereLightIrradiance( hemisphereLights[ i ], geometry );\n\t\t#ifdef DOUBLE_SIDED\n\t\t\tvIndirectBack += getHemisphereLightIrradiance( hemisphereLights[ i ], backGeometry );\n\t\t#endif\n\t}\n\t#pragma unroll_loop_end\n#endif",
				lights_pars_begin:
					"uniform bool receiveShadow;\nuniform vec3 ambientLightColor;\nuniform vec3 lightProbe[ 9 ];\nvec3 shGetIrradianceAt( in vec3 normal, in vec3 shCoefficients[ 9 ] ) {\n\tfloat x = normal.x, y = normal.y, z = normal.z;\n\tvec3 result = shCoefficients[ 0 ] * 0.886227;\n\tresult += shCoefficients[ 1 ] * 2.0 * 0.511664 * y;\n\tresult += shCoefficients[ 2 ] * 2.0 * 0.511664 * z;\n\tresult += shCoefficients[ 3 ] * 2.0 * 0.511664 * x;\n\tresult += shCoefficients[ 4 ] * 2.0 * 0.429043 * x * y;\n\tresult += shCoefficients[ 5 ] * 2.0 * 0.429043 * y * z;\n\tresult += shCoefficients[ 6 ] * ( 0.743125 * z * z - 0.247708 );\n\tresult += shCoefficients[ 7 ] * 2.0 * 0.429043 * x * z;\n\tresult += shCoefficients[ 8 ] * 0.429043 * ( x * x - y * y );\n\treturn result;\n}\nvec3 getLightProbeIrradiance( const in vec3 lightProbe[ 9 ], const in GeometricContext geometry ) {\n\tvec3 worldNormal = inverseTransformDirection( geometry.normal, viewMatrix );\n\tvec3 irradiance = shGetIrradianceAt( worldNormal, lightProbe );\n\treturn irradiance;\n}\nvec3 getAmbientLightIrradiance( const in vec3 ambientLightColor ) {\n\tvec3 irradiance = ambientLightColor;\n\t#ifndef PHYSICALLY_CORRECT_LIGHTS\n\t\tirradiance *= PI;\n\t#endif\n\treturn irradiance;\n}\n#if NUM_DIR_LIGHTS > 0\n\tstruct DirectionalLight {\n\t\tvec3 direction;\n\t\tvec3 color;\n\t};\n\tuniform DirectionalLight directionalLights[ NUM_DIR_LIGHTS ];\n\tvoid getDirectionalDirectLightIrradiance( const in DirectionalLight directionalLight, const in GeometricContext geometry, out IncidentLight directLight ) {\n\t\tdirectLight.color = directionalLight.color;\n\t\tdirectLight.direction = directionalLight.direction;\n\t\tdirectLight.visible = true;\n\t}\n#endif\n#if NUM_POINT_LIGHTS > 0\n\tstruct PointLight {\n\t\tvec3 position;\n\t\tvec3 color;\n\t\tfloat distance;\n\t\tfloat decay;\n\t};\n\tuniform PointLight pointLights[ NUM_POINT_LIGHTS ];\n\tvoid getPointDirectLightIrradiance( const in PointLight pointLight, const in GeometricContext geometry, out IncidentLight directLight ) {\n\t\tvec3 lVector = pointLight.position - geometry.position;\n\t\tdirectLight.direction = normalize( lVector );\n\t\tfloat lightDistance = length( lVector );\n\t\tdirectLight.color = pointLight.color;\n\t\tdirectLight.color *= punctualLightIntensityToIrradianceFactor( lightDistance, pointLight.distance, pointLight.decay );\n\t\tdirectLight.visible = ( directLight.color != vec3( 0.0 ) );\n\t}\n#endif\n#if NUM_SPOT_LIGHTS > 0\n\tstruct SpotLight {\n\t\tvec3 position;\n\t\tvec3 direction;\n\t\tvec3 color;\n\t\tfloat distance;\n\t\tfloat decay;\n\t\tfloat coneCos;\n\t\tfloat penumbraCos;\n\t};\n\tuniform SpotLight spotLights[ NUM_SPOT_LIGHTS ];\n\tvoid getSpotDirectLightIrradiance( const in SpotLight spotLight, const in GeometricContext geometry, out IncidentLight directLight  ) {\n\t\tvec3 lVector = spotLight.position - geometry.position;\n\t\tdirectLight.direction = normalize( lVector );\n\t\tfloat lightDistance = length( lVector );\n\t\tfloat angleCos = dot( directLight.direction, spotLight.direction );\n\t\tif ( angleCos > spotLight.coneCos ) {\n\t\t\tfloat spotEffect = smoothstep( spotLight.coneCos, spotLight.penumbraCos, angleCos );\n\t\t\tdirectLight.color = spotLight.color;\n\t\t\tdirectLight.color *= spotEffect * punctualLightIntensityToIrradianceFactor( lightDistance, spotLight.distance, spotLight.decay );\n\t\t\tdirectLight.visible = true;\n\t\t} else {\n\t\t\tdirectLight.color = vec3( 0.0 );\n\t\t\tdirectLight.visible = false;\n\t\t}\n\t}\n#endif\n#if NUM_RECT_AREA_LIGHTS > 0\n\tstruct RectAreaLight {\n\t\tvec3 color;\n\t\tvec3 position;\n\t\tvec3 halfWidth;\n\t\tvec3 halfHeight;\n\t};\n\tuniform sampler2D ltc_1;\tuniform sampler2D ltc_2;\n\tuniform RectAreaLight rectAreaLights[ NUM_RECT_AREA_LIGHTS ];\n#endif\n#if NUM_HEMI_LIGHTS > 0\n\tstruct HemisphereLight {\n\t\tvec3 direction;\n\t\tvec3 skyColor;\n\t\tvec3 groundColor;\n\t};\n\tuniform HemisphereLight hemisphereLights[ NUM_HEMI_LIGHTS ];\n\tvec3 getHemisphereLightIrradiance( const in HemisphereLight hemiLight, const in GeometricContext geometry ) {\n\t\tfloat dotNL = dot( geometry.normal, hemiLight.direction );\n\t\tfloat hemiDiffuseWeight = 0.5 * dotNL + 0.5;\n\t\tvec3 irradiance = mix( hemiLight.groundColor, hemiLight.skyColor, hemiDiffuseWeight );\n\t\t#ifndef PHYSICALLY_CORRECT_LIGHTS\n\t\t\tirradiance *= PI;\n\t\t#endif\n\t\treturn irradiance;\n\t}\n#endif",
				lights_toon_fragment:
					"ToonMaterial material;\nmaterial.diffuseColor = diffuseColor.rgb;",
				lights_toon_pars_fragment:
					"varying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\nstruct ToonMaterial {\n\tvec3\tdiffuseColor;\n};\nvoid RE_Direct_Toon( const in IncidentLight directLight, const in GeometricContext geometry, const in ToonMaterial material, inout ReflectedLight reflectedLight ) {\n\tvec3 irradiance = getGradientIrradiance( geometry.normal, directLight.direction ) * directLight.color;\n\t#ifndef PHYSICALLY_CORRECT_LIGHTS\n\t\tirradiance *= PI;\n\t#endif\n\treflectedLight.directDiffuse += irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\n}\nvoid RE_IndirectDiffuse_Toon( const in vec3 irradiance, const in GeometricContext geometry, const in ToonMaterial material, inout ReflectedLight reflectedLight ) {\n\treflectedLight.indirectDiffuse += irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\n}\n#define RE_Direct\t\t\t\tRE_Direct_Toon\n#define RE_IndirectDiffuse\t\tRE_IndirectDiffuse_Toon\n#define Material_LightProbeLOD( material )\t(0)",
				lights_phong_fragment:
					"BlinnPhongMaterial material;\nmaterial.diffuseColor = diffuseColor.rgb;\nmaterial.specularColor = specular;\nmaterial.specularShininess = shininess;\nmaterial.specularStrength = specularStrength;",
				lights_phong_pars_fragment:
					"varying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\nstruct BlinnPhongMaterial {\n\tvec3\tdiffuseColor;\n\tvec3\tspecularColor;\n\tfloat\tspecularShininess;\n\tfloat\tspecularStrength;\n};\nvoid RE_Direct_BlinnPhong( const in IncidentLight directLight, const in GeometricContext geometry, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {\n\tfloat dotNL = saturate( dot( geometry.normal, directLight.direction ) );\n\tvec3 irradiance = dotNL * directLight.color;\n\t#ifndef PHYSICALLY_CORRECT_LIGHTS\n\t\tirradiance *= PI;\n\t#endif\n\treflectedLight.directDiffuse += irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\n\treflectedLight.directSpecular += irradiance * BRDF_Specular_BlinnPhong( directLight, geometry, material.specularColor, material.specularShininess ) * material.specularStrength;\n}\nvoid RE_IndirectDiffuse_BlinnPhong( const in vec3 irradiance, const in GeometricContext geometry, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {\n\treflectedLight.indirectDiffuse += irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\n}\n#define RE_Direct\t\t\t\tRE_Direct_BlinnPhong\n#define RE_IndirectDiffuse\t\tRE_IndirectDiffuse_BlinnPhong\n#define Material_LightProbeLOD( material )\t(0)",
				lights_physical_fragment:
					"PhysicalMaterial material;\nmaterial.diffuseColor = diffuseColor.rgb * ( 1.0 - metalnessFactor );\nvec3 dxy = max( abs( dFdx( geometryNormal ) ), abs( dFdy( geometryNormal ) ) );\nfloat geometryRoughness = max( max( dxy.x, dxy.y ), dxy.z );\nmaterial.specularRoughness = max( roughnessFactor, 0.0525 );material.specularRoughness += geometryRoughness;\nmaterial.specularRoughness = min( material.specularRoughness, 1.0 );\n#ifdef REFLECTIVITY\n\tmaterial.specularColor = mix( vec3( MAXIMUM_SPECULAR_COEFFICIENT * pow2( reflectivity ) ), diffuseColor.rgb, metalnessFactor );\n#else\n\tmaterial.specularColor = mix( vec3( DEFAULT_SPECULAR_COEFFICIENT ), diffuseColor.rgb, metalnessFactor );\n#endif\n#ifdef CLEARCOAT\n\tmaterial.clearcoat = clearcoat;\n\tmaterial.clearcoatRoughness = clearcoatRoughness;\n\t#ifdef USE_CLEARCOATMAP\n\t\tmaterial.clearcoat *= texture2D( clearcoatMap, vUv ).x;\n\t#endif\n\t#ifdef USE_CLEARCOAT_ROUGHNESSMAP\n\t\tmaterial.clearcoatRoughness *= texture2D( clearcoatRoughnessMap, vUv ).y;\n\t#endif\n\tmaterial.clearcoat = saturate( material.clearcoat );\tmaterial.clearcoatRoughness = max( material.clearcoatRoughness, 0.0525 );\n\tmaterial.clearcoatRoughness += geometryRoughness;\n\tmaterial.clearcoatRoughness = min( material.clearcoatRoughness, 1.0 );\n#endif\n#ifdef USE_SHEEN\n\tmaterial.sheenColor = sheen;\n#endif",
				lights_physical_pars_fragment:
					"struct PhysicalMaterial {\n\tvec3\tdiffuseColor;\n\tfloat\tspecularRoughness;\n\tvec3\tspecularColor;\n#ifdef CLEARCOAT\n\tfloat clearcoat;\n\tfloat clearcoatRoughness;\n#endif\n#ifdef USE_SHEEN\n\tvec3 sheenColor;\n#endif\n};\n#define MAXIMUM_SPECULAR_COEFFICIENT 0.16\n#define DEFAULT_SPECULAR_COEFFICIENT 0.04\nfloat clearcoatDHRApprox( const in float roughness, const in float dotNL ) {\n\treturn DEFAULT_SPECULAR_COEFFICIENT + ( 1.0 - DEFAULT_SPECULAR_COEFFICIENT ) * ( pow( 1.0 - dotNL, 5.0 ) * pow( 1.0 - roughness, 2.0 ) );\n}\n#if NUM_RECT_AREA_LIGHTS > 0\n\tvoid RE_Direct_RectArea_Physical( const in RectAreaLight rectAreaLight, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\n\t\tvec3 normal = geometry.normal;\n\t\tvec3 viewDir = geometry.viewDir;\n\t\tvec3 position = geometry.position;\n\t\tvec3 lightPos = rectAreaLight.position;\n\t\tvec3 halfWidth = rectAreaLight.halfWidth;\n\t\tvec3 halfHeight = rectAreaLight.halfHeight;\n\t\tvec3 lightColor = rectAreaLight.color;\n\t\tfloat roughness = material.specularRoughness;\n\t\tvec3 rectCoords[ 4 ];\n\t\trectCoords[ 0 ] = lightPos + halfWidth - halfHeight;\t\trectCoords[ 1 ] = lightPos - halfWidth - halfHeight;\n\t\trectCoords[ 2 ] = lightPos - halfWidth + halfHeight;\n\t\trectCoords[ 3 ] = lightPos + halfWidth + halfHeight;\n\t\tvec2 uv = LTC_Uv( normal, viewDir, roughness );\n\t\tvec4 t1 = texture2D( ltc_1, uv );\n\t\tvec4 t2 = texture2D( ltc_2, uv );\n\t\tmat3 mInv = mat3(\n\t\t\tvec3( t1.x, 0, t1.y ),\n\t\t\tvec3(    0, 1,    0 ),\n\t\t\tvec3( t1.z, 0, t1.w )\n\t\t);\n\t\tvec3 fresnel = ( material.specularColor * t2.x + ( vec3( 1.0 ) - material.specularColor ) * t2.y );\n\t\treflectedLight.directSpecular += lightColor * fresnel * LTC_Evaluate( normal, viewDir, position, mInv, rectCoords );\n\t\treflectedLight.directDiffuse += lightColor * material.diffuseColor * LTC_Evaluate( normal, viewDir, position, mat3( 1.0 ), rectCoords );\n\t}\n#endif\nvoid RE_Direct_Physical( const in IncidentLight directLight, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\n\tfloat dotNL = saturate( dot( geometry.normal, directLight.direction ) );\n\tvec3 irradiance = dotNL * directLight.color;\n\t#ifndef PHYSICALLY_CORRECT_LIGHTS\n\t\tirradiance *= PI;\n\t#endif\n\t#ifdef CLEARCOAT\n\t\tfloat ccDotNL = saturate( dot( geometry.clearcoatNormal, directLight.direction ) );\n\t\tvec3 ccIrradiance = ccDotNL * directLight.color;\n\t\t#ifndef PHYSICALLY_CORRECT_LIGHTS\n\t\t\tccIrradiance *= PI;\n\t\t#endif\n\t\tfloat clearcoatDHR = material.clearcoat * clearcoatDHRApprox( material.clearcoatRoughness, ccDotNL );\n\t\treflectedLight.directSpecular += ccIrradiance * material.clearcoat * BRDF_Specular_GGX( directLight, geometry.viewDir, geometry.clearcoatNormal, vec3( DEFAULT_SPECULAR_COEFFICIENT ), material.clearcoatRoughness );\n\t#else\n\t\tfloat clearcoatDHR = 0.0;\n\t#endif\n\t#ifdef USE_SHEEN\n\t\treflectedLight.directSpecular += ( 1.0 - clearcoatDHR ) * irradiance * BRDF_Specular_Sheen(\n\t\t\tmaterial.specularRoughness,\n\t\t\tdirectLight.direction,\n\t\t\tgeometry,\n\t\t\tmaterial.sheenColor\n\t\t);\n\t#else\n\t\treflectedLight.directSpecular += ( 1.0 - clearcoatDHR ) * irradiance * BRDF_Specular_GGX( directLight, geometry.viewDir, geometry.normal, material.specularColor, material.specularRoughness);\n\t#endif\n\treflectedLight.directDiffuse += ( 1.0 - clearcoatDHR ) * irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\n}\nvoid RE_IndirectDiffuse_Physical( const in vec3 irradiance, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\n\treflectedLight.indirectDiffuse += irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\n}\nvoid RE_IndirectSpecular_Physical( const in vec3 radiance, const in vec3 irradiance, const in vec3 clearcoatRadiance, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight) {\n\t#ifdef CLEARCOAT\n\t\tfloat ccDotNV = saturate( dot( geometry.clearcoatNormal, geometry.viewDir ) );\n\t\treflectedLight.indirectSpecular += clearcoatRadiance * material.clearcoat * BRDF_Specular_GGX_Environment( geometry.viewDir, geometry.clearcoatNormal, vec3( DEFAULT_SPECULAR_COEFFICIENT ), material.clearcoatRoughness );\n\t\tfloat ccDotNL = ccDotNV;\n\t\tfloat clearcoatDHR = material.clearcoat * clearcoatDHRApprox( material.clearcoatRoughness, ccDotNL );\n\t#else\n\t\tfloat clearcoatDHR = 0.0;\n\t#endif\n\tfloat clearcoatInv = 1.0 - clearcoatDHR;\n\tvec3 singleScattering = vec3( 0.0 );\n\tvec3 multiScattering = vec3( 0.0 );\n\tvec3 cosineWeightedIrradiance = irradiance * RECIPROCAL_PI;\n\tBRDF_Specular_Multiscattering_Environment( geometry, material.specularColor, material.specularRoughness, singleScattering, multiScattering );\n\tvec3 diffuse = material.diffuseColor * ( 1.0 - ( singleScattering + multiScattering ) );\n\treflectedLight.indirectSpecular += clearcoatInv * radiance * singleScattering;\n\treflectedLight.indirectSpecular += multiScattering * cosineWeightedIrradiance;\n\treflectedLight.indirectDiffuse += diffuse * cosineWeightedIrradiance;\n}\n#define RE_Direct\t\t\t\tRE_Direct_Physical\n#define RE_Direct_RectArea\t\tRE_Direct_RectArea_Physical\n#define RE_IndirectDiffuse\t\tRE_IndirectDiffuse_Physical\n#define RE_IndirectSpecular\t\tRE_IndirectSpecular_Physical\nfloat computeSpecularOcclusion( const in float dotNV, const in float ambientOcclusion, const in float roughness ) {\n\treturn saturate( pow( dotNV + ambientOcclusion, exp2( - 16.0 * roughness - 1.0 ) ) - 1.0 + ambientOcclusion );\n}",
				lights_fragment_begin:
					"\nGeometricContext geometry;\ngeometry.position = - vViewPosition;\ngeometry.normal = normal;\ngeometry.viewDir = ( isOrthographic ) ? vec3( 0, 0, 1 ) : normalize( vViewPosition );\n#ifdef CLEARCOAT\n\tgeometry.clearcoatNormal = clearcoatNormal;\n#endif\nIncidentLight directLight;\n#if ( NUM_POINT_LIGHTS > 0 ) && defined( RE_Direct )\n\tPointLight pointLight;\n\t#if defined( USE_SHADOWMAP ) && NUM_POINT_LIGHT_SHADOWS > 0\n\tPointLightShadow pointLightShadow;\n\t#endif\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {\n\t\tpointLight = pointLights[ i ];\n\t\tgetPointDirectLightIrradiance( pointLight, geometry, directLight );\n\t\t#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_POINT_LIGHT_SHADOWS )\n\t\tpointLightShadow = pointLightShadows[ i ];\n\t\tdirectLight.color *= all( bvec2( directLight.visible, receiveShadow ) ) ? getPointShadow( pointShadowMap[ i ], pointLightShadow.shadowMapSize, pointLightShadow.shadowBias, pointLightShadow.shadowRadius, vPointShadowCoord[ i ], pointLightShadow.shadowCameraNear, pointLightShadow.shadowCameraFar ) : 1.0;\n\t\t#endif\n\t\tRE_Direct( directLight, geometry, material, reflectedLight );\n\t}\n\t#pragma unroll_loop_end\n#endif\n#if ( NUM_SPOT_LIGHTS > 0 ) && defined( RE_Direct )\n\tSpotLight spotLight;\n\t#if defined( USE_SHADOWMAP ) && NUM_SPOT_LIGHT_SHADOWS > 0\n\tSpotLightShadow spotLightShadow;\n\t#endif\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {\n\t\tspotLight = spotLights[ i ];\n\t\tgetSpotDirectLightIrradiance( spotLight, geometry, directLight );\n\t\t#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS )\n\t\tspotLightShadow = spotLightShadows[ i ];\n\t\tdirectLight.color *= all( bvec2( directLight.visible, receiveShadow ) ) ? getShadow( spotShadowMap[ i ], spotLightShadow.shadowMapSize, spotLightShadow.shadowBias, spotLightShadow.shadowRadius, vSpotShadowCoord[ i ] ) : 1.0;\n\t\t#endif\n\t\tRE_Direct( directLight, geometry, material, reflectedLight );\n\t}\n\t#pragma unroll_loop_end\n#endif\n#if ( NUM_DIR_LIGHTS > 0 ) && defined( RE_Direct )\n\tDirectionalLight directionalLight;\n\t#if defined( USE_SHADOWMAP ) && NUM_DIR_LIGHT_SHADOWS > 0\n\tDirectionalLightShadow directionalLightShadow;\n\t#endif\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\n\t\tdirectionalLight = directionalLights[ i ];\n\t\tgetDirectionalDirectLightIrradiance( directionalLight, geometry, directLight );\n\t\t#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_DIR_LIGHT_SHADOWS )\n\t\tdirectionalLightShadow = directionalLightShadows[ i ];\n\t\tdirectLight.color *= all( bvec2( directLight.visible, receiveShadow ) ) ? getShadow( directionalShadowMap[ i ], directionalLightShadow.shadowMapSize, directionalLightShadow.shadowBias, directionalLightShadow.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;\n\t\t#endif\n\t\tRE_Direct( directLight, geometry, material, reflectedLight );\n\t}\n\t#pragma unroll_loop_end\n#endif\n#if ( NUM_RECT_AREA_LIGHTS > 0 ) && defined( RE_Direct_RectArea )\n\tRectAreaLight rectAreaLight;\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_RECT_AREA_LIGHTS; i ++ ) {\n\t\trectAreaLight = rectAreaLights[ i ];\n\t\tRE_Direct_RectArea( rectAreaLight, geometry, material, reflectedLight );\n\t}\n\t#pragma unroll_loop_end\n#endif\n#if defined( RE_IndirectDiffuse )\n\tvec3 iblIrradiance = vec3( 0.0 );\n\tvec3 irradiance = getAmbientLightIrradiance( ambientLightColor );\n\tirradiance += getLightProbeIrradiance( lightProbe, geometry );\n\t#if ( NUM_HEMI_LIGHTS > 0 )\n\t\t#pragma unroll_loop_start\n\t\tfor ( int i = 0; i < NUM_HEMI_LIGHTS; i ++ ) {\n\t\t\tirradiance += getHemisphereLightIrradiance( hemisphereLights[ i ], geometry );\n\t\t}\n\t\t#pragma unroll_loop_end\n\t#endif\n#endif\n#if defined( RE_IndirectSpecular )\n\tvec3 radiance = vec3( 0.0 );\n\tvec3 clearcoatRadiance = vec3( 0.0 );\n#endif",
				lights_fragment_maps:
					"#if defined( RE_IndirectDiffuse )\n\t#ifdef USE_LIGHTMAP\n\t\tvec4 lightMapTexel= texture2D( lightMap, vUv2 );\n\t\tvec3 lightMapIrradiance = lightMapTexelToLinear( lightMapTexel ).rgb * lightMapIntensity;\n\t\t#ifndef PHYSICALLY_CORRECT_LIGHTS\n\t\t\tlightMapIrradiance *= PI;\n\t\t#endif\n\t\tirradiance += lightMapIrradiance;\n\t#endif\n\t#if defined( USE_ENVMAP ) && defined( STANDARD ) && defined( ENVMAP_TYPE_CUBE_UV )\n\t\tiblIrradiance += getLightProbeIndirectIrradiance( geometry, maxMipLevel );\n\t#endif\n#endif\n#if defined( USE_ENVMAP ) && defined( RE_IndirectSpecular )\n\tradiance += getLightProbeIndirectRadiance( geometry.viewDir, geometry.normal, material.specularRoughness, maxMipLevel );\n\t#ifdef CLEARCOAT\n\t\tclearcoatRadiance += getLightProbeIndirectRadiance( geometry.viewDir, geometry.clearcoatNormal, material.clearcoatRoughness, maxMipLevel );\n\t#endif\n#endif",
				lights_fragment_end:
					"#if defined( RE_IndirectDiffuse )\n\tRE_IndirectDiffuse( irradiance, geometry, material, reflectedLight );\n#endif\n#if defined( RE_IndirectSpecular )\n\tRE_IndirectSpecular( radiance, iblIrradiance, clearcoatRadiance, geometry, material, reflectedLight );\n#endif",
				logdepthbuf_fragment:
					"#if defined( USE_LOGDEPTHBUF ) && defined( USE_LOGDEPTHBUF_EXT )\n\tgl_FragDepthEXT = vIsPerspective == 0.0 ? gl_FragCoord.z : log2( vFragDepth ) * logDepthBufFC * 0.5;\n#endif",
				logdepthbuf_pars_fragment:
					"#if defined( USE_LOGDEPTHBUF ) && defined( USE_LOGDEPTHBUF_EXT )\n\tuniform float logDepthBufFC;\n\tvarying float vFragDepth;\n\tvarying float vIsPerspective;\n#endif",
				logdepthbuf_pars_vertex:
					"#ifdef USE_LOGDEPTHBUF\n\t#ifdef USE_LOGDEPTHBUF_EXT\n\t\tvarying float vFragDepth;\n\t\tvarying float vIsPerspective;\n\t#else\n\t\tuniform float logDepthBufFC;\n\t#endif\n#endif",
				logdepthbuf_vertex:
					"#ifdef USE_LOGDEPTHBUF\n\t#ifdef USE_LOGDEPTHBUF_EXT\n\t\tvFragDepth = 1.0 + gl_Position.w;\n\t\tvIsPerspective = float( isPerspectiveMatrix( projectionMatrix ) );\n\t#else\n\t\tif ( isPerspectiveMatrix( projectionMatrix ) ) {\n\t\t\tgl_Position.z = log2( max( EPSILON, gl_Position.w + 1.0 ) ) * logDepthBufFC - 1.0;\n\t\t\tgl_Position.z *= gl_Position.w;\n\t\t}\n\t#endif\n#endif",
				map_fragment:
					"#ifdef USE_MAP\n\tvec4 texelColor = texture2D( map, vUv );\n\ttexelColor = mapTexelToLinear( texelColor );\n\tdiffuseColor *= texelColor;\n#endif",
				map_pars_fragment: "#ifdef USE_MAP\n\tuniform sampler2D map;\n#endif",
				map_particle_fragment:
					"#if defined( USE_MAP ) || defined( USE_ALPHAMAP )\n\tvec2 uv = ( uvTransform * vec3( gl_PointCoord.x, 1.0 - gl_PointCoord.y, 1 ) ).xy;\n#endif\n#ifdef USE_MAP\n\tvec4 mapTexel = texture2D( map, uv );\n\tdiffuseColor *= mapTexelToLinear( mapTexel );\n#endif\n#ifdef USE_ALPHAMAP\n\tdiffuseColor.a *= texture2D( alphaMap, uv ).g;\n#endif",
				map_particle_pars_fragment:
					"#if defined( USE_MAP ) || defined( USE_ALPHAMAP )\n\tuniform mat3 uvTransform;\n#endif\n#ifdef USE_MAP\n\tuniform sampler2D map;\n#endif\n#ifdef USE_ALPHAMAP\n\tuniform sampler2D alphaMap;\n#endif",
				metalnessmap_fragment:
					"float metalnessFactor = metalness;\n#ifdef USE_METALNESSMAP\n\tvec4 texelMetalness = texture2D( metalnessMap, vUv );\n\tmetalnessFactor *= texelMetalness.b;\n#endif",
				metalnessmap_pars_fragment:
					"#ifdef USE_METALNESSMAP\n\tuniform sampler2D metalnessMap;\n#endif",
				morphnormal_vertex:
					"#ifdef USE_MORPHNORMALS\n\tobjectNormal *= morphTargetBaseInfluence;\n\tobjectNormal += morphNormal0 * morphTargetInfluences[ 0 ];\n\tobjectNormal += morphNormal1 * morphTargetInfluences[ 1 ];\n\tobjectNormal += morphNormal2 * morphTargetInfluences[ 2 ];\n\tobjectNormal += morphNormal3 * morphTargetInfluences[ 3 ];\n#endif",
				morphtarget_pars_vertex:
					"#ifdef USE_MORPHTARGETS\n\tuniform float morphTargetBaseInfluence;\n\t#ifndef USE_MORPHNORMALS\n\tuniform float morphTargetInfluences[ 8 ];\n\t#else\n\tuniform float morphTargetInfluences[ 4 ];\n\t#endif\n#endif",
				morphtarget_vertex:
					"#ifdef USE_MORPHTARGETS\n\ttransformed *= morphTargetBaseInfluence;\n\ttransformed += morphTarget0 * morphTargetInfluences[ 0 ];\n\ttransformed += morphTarget1 * morphTargetInfluences[ 1 ];\n\ttransformed += morphTarget2 * morphTargetInfluences[ 2 ];\n\ttransformed += morphTarget3 * morphTargetInfluences[ 3 ];\n\t#ifndef USE_MORPHNORMALS\n\ttransformed += morphTarget4 * morphTargetInfluences[ 4 ];\n\ttransformed += morphTarget5 * morphTargetInfluences[ 5 ];\n\ttransformed += morphTarget6 * morphTargetInfluences[ 6 ];\n\ttransformed += morphTarget7 * morphTargetInfluences[ 7 ];\n\t#endif\n#endif",
				normal_fragment_begin:
					"#ifdef FLAT_SHADED\n\tvec3 fdx = vec3( dFdx( vViewPosition.x ), dFdx( vViewPosition.y ), dFdx( vViewPosition.z ) );\n\tvec3 fdy = vec3( dFdy( vViewPosition.x ), dFdy( vViewPosition.y ), dFdy( vViewPosition.z ) );\n\tvec3 normal = normalize( cross( fdx, fdy ) );\n#else\n\tvec3 normal = normalize( vNormal );\n\t#ifdef DOUBLE_SIDED\n\t\tnormal = normal * ( float( gl_FrontFacing ) * 2.0 - 1.0 );\n\t#endif\n\t#ifdef USE_TANGENT\n\t\tvec3 tangent = normalize( vTangent );\n\t\tvec3 bitangent = normalize( vBitangent );\n\t\t#ifdef DOUBLE_SIDED\n\t\t\ttangent = tangent * ( float( gl_FrontFacing ) * 2.0 - 1.0 );\n\t\t\tbitangent = bitangent * ( float( gl_FrontFacing ) * 2.0 - 1.0 );\n\t\t#endif\n\t\t#if defined( TANGENTSPACE_NORMALMAP ) || defined( USE_CLEARCOAT_NORMALMAP )\n\t\t\tmat3 vTBN = mat3( tangent, bitangent, normal );\n\t\t#endif\n\t#endif\n#endif\nvec3 geometryNormal = normal;",
				normal_fragment_maps:
					"#ifdef OBJECTSPACE_NORMALMAP\n\tnormal = texture2D( normalMap, vUv ).xyz * 2.0 - 1.0;\n\t#ifdef FLIP_SIDED\n\t\tnormal = - normal;\n\t#endif\n\t#ifdef DOUBLE_SIDED\n\t\tnormal = normal * ( float( gl_FrontFacing ) * 2.0 - 1.0 );\n\t#endif\n\tnormal = normalize( normalMatrix * normal );\n#elif defined( TANGENTSPACE_NORMALMAP )\n\tvec3 mapN = texture2D( normalMap, vUv ).xyz * 2.0 - 1.0;\n\tmapN.xy *= normalScale;\n\t#ifdef USE_TANGENT\n\t\tnormal = normalize( vTBN * mapN );\n\t#else\n\t\tnormal = perturbNormal2Arb( -vViewPosition, normal, mapN );\n\t#endif\n#elif defined( USE_BUMPMAP )\n\tnormal = perturbNormalArb( -vViewPosition, normal, dHdxy_fwd() );\n#endif",
				normalmap_pars_fragment:
					"#ifdef USE_NORMALMAP\n\tuniform sampler2D normalMap;\n\tuniform vec2 normalScale;\n#endif\n#ifdef OBJECTSPACE_NORMALMAP\n\tuniform mat3 normalMatrix;\n#endif\n#if ! defined ( USE_TANGENT ) && ( defined ( TANGENTSPACE_NORMALMAP ) || defined ( USE_CLEARCOAT_NORMALMAP ) )\n\tvec3 perturbNormal2Arb( vec3 eye_pos, vec3 surf_norm, vec3 mapN ) {\n\t\tvec3 q0 = vec3( dFdx( eye_pos.x ), dFdx( eye_pos.y ), dFdx( eye_pos.z ) );\n\t\tvec3 q1 = vec3( dFdy( eye_pos.x ), dFdy( eye_pos.y ), dFdy( eye_pos.z ) );\n\t\tvec2 st0 = dFdx( vUv.st );\n\t\tvec2 st1 = dFdy( vUv.st );\n\t\tfloat scale = sign( st1.t * st0.s - st0.t * st1.s );\n\t\tvec3 S = normalize( ( q0 * st1.t - q1 * st0.t ) * scale );\n\t\tvec3 T = normalize( ( - q0 * st1.s + q1 * st0.s ) * scale );\n\t\tvec3 N = normalize( surf_norm );\n\t\tmat3 tsn = mat3( S, T, N );\n\t\tmapN.xy *= ( float( gl_FrontFacing ) * 2.0 - 1.0 );\n\t\treturn normalize( tsn * mapN );\n\t}\n#endif",
				clearcoat_normal_fragment_begin:
					"#ifdef CLEARCOAT\n\tvec3 clearcoatNormal = geometryNormal;\n#endif",
				clearcoat_normal_fragment_maps:
					"#ifdef USE_CLEARCOAT_NORMALMAP\n\tvec3 clearcoatMapN = texture2D( clearcoatNormalMap, vUv ).xyz * 2.0 - 1.0;\n\tclearcoatMapN.xy *= clearcoatNormalScale;\n\t#ifdef USE_TANGENT\n\t\tclearcoatNormal = normalize( vTBN * clearcoatMapN );\n\t#else\n\t\tclearcoatNormal = perturbNormal2Arb( - vViewPosition, clearcoatNormal, clearcoatMapN );\n\t#endif\n#endif",
				clearcoat_pars_fragment:
					"#ifdef USE_CLEARCOATMAP\n\tuniform sampler2D clearcoatMap;\n#endif\n#ifdef USE_CLEARCOAT_ROUGHNESSMAP\n\tuniform sampler2D clearcoatRoughnessMap;\n#endif\n#ifdef USE_CLEARCOAT_NORMALMAP\n\tuniform sampler2D clearcoatNormalMap;\n\tuniform vec2 clearcoatNormalScale;\n#endif",
				packing:
					"vec3 packNormalToRGB( const in vec3 normal ) {\n\treturn normalize( normal ) * 0.5 + 0.5;\n}\nvec3 unpackRGBToNormal( const in vec3 rgb ) {\n\treturn 2.0 * rgb.xyz - 1.0;\n}\nconst float PackUpscale = 256. / 255.;const float UnpackDownscale = 255. / 256.;\nconst vec3 PackFactors = vec3( 256. * 256. * 256., 256. * 256.,  256. );\nconst vec4 UnpackFactors = UnpackDownscale / vec4( PackFactors, 1. );\nconst float ShiftRight8 = 1. / 256.;\nvec4 packDepthToRGBA( const in float v ) {\n\tvec4 r = vec4( fract( v * PackFactors ), v );\n\tr.yzw -= r.xyz * ShiftRight8;\treturn r * PackUpscale;\n}\nfloat unpackRGBAToDepth( const in vec4 v ) {\n\treturn dot( v, UnpackFactors );\n}\nvec4 pack2HalfToRGBA( vec2 v ) {\n\tvec4 r = vec4( v.x, fract( v.x * 255.0 ), v.y, fract( v.y * 255.0 ));\n\treturn vec4( r.x - r.y / 255.0, r.y, r.z - r.w / 255.0, r.w);\n}\nvec2 unpackRGBATo2Half( vec4 v ) {\n\treturn vec2( v.x + ( v.y / 255.0 ), v.z + ( v.w / 255.0 ) );\n}\nfloat viewZToOrthographicDepth( const in float viewZ, const in float near, const in float far ) {\n\treturn ( viewZ + near ) / ( near - far );\n}\nfloat orthographicDepthToViewZ( const in float linearClipZ, const in float near, const in float far ) {\n\treturn linearClipZ * ( near - far ) - near;\n}\nfloat viewZToPerspectiveDepth( const in float viewZ, const in float near, const in float far ) {\n\treturn (( near + viewZ ) * far ) / (( far - near ) * viewZ );\n}\nfloat perspectiveDepthToViewZ( const in float invClipZ, const in float near, const in float far ) {\n\treturn ( near * far ) / ( ( far - near ) * invClipZ - far );\n}",
				premultiplied_alpha_fragment:
					"#ifdef PREMULTIPLIED_ALPHA\n\tgl_FragColor.rgb *= gl_FragColor.a;\n#endif",
				project_vertex:
					"vec4 mvPosition = vec4( transformed, 1.0 );\n#ifdef USE_INSTANCING\n\tmvPosition = instanceMatrix * mvPosition;\n#endif\nmvPosition = modelViewMatrix * mvPosition;\ngl_Position = projectionMatrix * mvPosition;",
				dithering_fragment:
					"#ifdef DITHERING\n\tgl_FragColor.rgb = dithering( gl_FragColor.rgb );\n#endif",
				dithering_pars_fragment:
					"#ifdef DITHERING\n\tvec3 dithering( vec3 color ) {\n\t\tfloat grid_position = rand( gl_FragCoord.xy );\n\t\tvec3 dither_shift_RGB = vec3( 0.25 / 255.0, -0.25 / 255.0, 0.25 / 255.0 );\n\t\tdither_shift_RGB = mix( 2.0 * dither_shift_RGB, -2.0 * dither_shift_RGB, grid_position );\n\t\treturn color + dither_shift_RGB;\n\t}\n#endif",
				roughnessmap_fragment:
					"float roughnessFactor = roughness;\n#ifdef USE_ROUGHNESSMAP\n\tvec4 texelRoughness = texture2D( roughnessMap, vUv );\n\troughnessFactor *= texelRoughness.g;\n#endif",
				roughnessmap_pars_fragment:
					"#ifdef USE_ROUGHNESSMAP\n\tuniform sampler2D roughnessMap;\n#endif",
				shadowmap_pars_fragment:
					"#ifdef USE_SHADOWMAP\n\t#if NUM_DIR_LIGHT_SHADOWS > 0\n\t\tuniform sampler2D directionalShadowMap[ NUM_DIR_LIGHT_SHADOWS ];\n\t\tvarying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHT_SHADOWS ];\n\t\tstruct DirectionalLightShadow {\n\t\t\tfloat shadowBias;\n\t\t\tfloat shadowNormalBias;\n\t\t\tfloat shadowRadius;\n\t\t\tvec2 shadowMapSize;\n\t\t};\n\t\tuniform DirectionalLightShadow directionalLightShadows[ NUM_DIR_LIGHT_SHADOWS ];\n\t#endif\n\t#if NUM_SPOT_LIGHT_SHADOWS > 0\n\t\tuniform sampler2D spotShadowMap[ NUM_SPOT_LIGHT_SHADOWS ];\n\t\tvarying vec4 vSpotShadowCoord[ NUM_SPOT_LIGHT_SHADOWS ];\n\t\tstruct SpotLightShadow {\n\t\t\tfloat shadowBias;\n\t\t\tfloat shadowNormalBias;\n\t\t\tfloat shadowRadius;\n\t\t\tvec2 shadowMapSize;\n\t\t};\n\t\tuniform SpotLightShadow spotLightShadows[ NUM_SPOT_LIGHT_SHADOWS ];\n\t#endif\n\t#if NUM_POINT_LIGHT_SHADOWS > 0\n\t\tuniform sampler2D pointShadowMap[ NUM_POINT_LIGHT_SHADOWS ];\n\t\tvarying vec4 vPointShadowCoord[ NUM_POINT_LIGHT_SHADOWS ];\n\t\tstruct PointLightShadow {\n\t\t\tfloat shadowBias;\n\t\t\tfloat shadowNormalBias;\n\t\t\tfloat shadowRadius;\n\t\t\tvec2 shadowMapSize;\n\t\t\tfloat shadowCameraNear;\n\t\t\tfloat shadowCameraFar;\n\t\t};\n\t\tuniform PointLightShadow pointLightShadows[ NUM_POINT_LIGHT_SHADOWS ];\n\t#endif\n\tfloat texture2DCompare( sampler2D depths, vec2 uv, float compare ) {\n\t\treturn step( compare, unpackRGBAToDepth( texture2D( depths, uv ) ) );\n\t}\n\tvec2 texture2DDistribution( sampler2D shadow, vec2 uv ) {\n\t\treturn unpackRGBATo2Half( texture2D( shadow, uv ) );\n\t}\n\tfloat VSMShadow (sampler2D shadow, vec2 uv, float compare ){\n\t\tfloat occlusion = 1.0;\n\t\tvec2 distribution = texture2DDistribution( shadow, uv );\n\t\tfloat hard_shadow = step( compare , distribution.x );\n\t\tif (hard_shadow != 1.0 ) {\n\t\t\tfloat distance = compare - distribution.x ;\n\t\t\tfloat variance = max( 0.00000, distribution.y * distribution.y );\n\t\t\tfloat softness_probability = variance / (variance + distance * distance );\t\t\tsoftness_probability = clamp( ( softness_probability - 0.3 ) / ( 0.95 - 0.3 ), 0.0, 1.0 );\t\t\tocclusion = clamp( max( hard_shadow, softness_probability ), 0.0, 1.0 );\n\t\t}\n\t\treturn occlusion;\n\t}\n\tfloat getShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord ) {\n\t\tfloat shadow = 1.0;\n\t\tshadowCoord.xyz /= shadowCoord.w;\n\t\tshadowCoord.z += shadowBias;\n\t\tbvec4 inFrustumVec = bvec4 ( shadowCoord.x >= 0.0, shadowCoord.x <= 1.0, shadowCoord.y >= 0.0, shadowCoord.y <= 1.0 );\n\t\tbool inFrustum = all( inFrustumVec );\n\t\tbvec2 frustumTestVec = bvec2( inFrustum, shadowCoord.z <= 1.0 );\n\t\tbool frustumTest = all( frustumTestVec );\n\t\tif ( frustumTest ) {\n\t\t#if defined( SHADOWMAP_TYPE_PCF )\n\t\t\tvec2 texelSize = vec2( 1.0 ) / shadowMapSize;\n\t\t\tfloat dx0 = - texelSize.x * shadowRadius;\n\t\t\tfloat dy0 = - texelSize.y * shadowRadius;\n\t\t\tfloat dx1 = + texelSize.x * shadowRadius;\n\t\t\tfloat dy1 = + texelSize.y * shadowRadius;\n\t\t\tfloat dx2 = dx0 / 2.0;\n\t\t\tfloat dy2 = dy0 / 2.0;\n\t\t\tfloat dx3 = dx1 / 2.0;\n\t\t\tfloat dy3 = dy1 / 2.0;\n\t\t\tshadow = (\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, dy2 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy2 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, dy2 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, dy3 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy3 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, dy3 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy1 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy1 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy1 ), shadowCoord.z )\n\t\t\t) * ( 1.0 / 17.0 );\n\t\t#elif defined( SHADOWMAP_TYPE_PCF_SOFT )\n\t\t\tvec2 texelSize = vec2( 1.0 ) / shadowMapSize;\n\t\t\tfloat dx = texelSize.x;\n\t\t\tfloat dy = texelSize.y;\n\t\t\tvec2 uv = shadowCoord.xy;\n\t\t\tvec2 f = fract( uv * shadowMapSize + 0.5 );\n\t\t\tuv -= f * texelSize;\n\t\t\tshadow = (\n\t\t\t\ttexture2DCompare( shadowMap, uv, shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, uv + vec2( dx, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, uv + vec2( 0.0, dy ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, uv + texelSize, shadowCoord.z ) +\n\t\t\t\tmix( texture2DCompare( shadowMap, uv + vec2( -dx, 0.0 ), shadowCoord.z ), \n\t\t\t\t\t texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, 0.0 ), shadowCoord.z ),\n\t\t\t\t\t f.x ) +\n\t\t\t\tmix( texture2DCompare( shadowMap, uv + vec2( -dx, dy ), shadowCoord.z ), \n\t\t\t\t\t texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, dy ), shadowCoord.z ),\n\t\t\t\t\t f.x ) +\n\t\t\t\tmix( texture2DCompare( shadowMap, uv + vec2( 0.0, -dy ), shadowCoord.z ), \n\t\t\t\t\t texture2DCompare( shadowMap, uv + vec2( 0.0, 2.0 * dy ), shadowCoord.z ),\n\t\t\t\t\t f.y ) +\n\t\t\t\tmix( texture2DCompare( shadowMap, uv + vec2( dx, -dy ), shadowCoord.z ), \n\t\t\t\t\t texture2DCompare( shadowMap, uv + vec2( dx, 2.0 * dy ), shadowCoord.z ),\n\t\t\t\t\t f.y ) +\n\t\t\t\tmix( mix( texture2DCompare( shadowMap, uv + vec2( -dx, -dy ), shadowCoord.z ), \n\t\t\t\t\t\t  texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, -dy ), shadowCoord.z ),\n\t\t\t\t\t\t  f.x ),\n\t\t\t\t\t mix( texture2DCompare( shadowMap, uv + vec2( -dx, 2.0 * dy ), shadowCoord.z ), \n\t\t\t\t\t\t  texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, 2.0 * dy ), shadowCoord.z ),\n\t\t\t\t\t\t  f.x ),\n\t\t\t\t\t f.y )\n\t\t\t) * ( 1.0 / 9.0 );\n\t\t#elif defined( SHADOWMAP_TYPE_VSM )\n\t\t\tshadow = VSMShadow( shadowMap, shadowCoord.xy, shadowCoord.z );\n\t\t#else\n\t\t\tshadow = texture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z );\n\t\t#endif\n\t\t}\n\t\treturn shadow;\n\t}\n\tvec2 cubeToUV( vec3 v, float texelSizeY ) {\n\t\tvec3 absV = abs( v );\n\t\tfloat scaleToCube = 1.0 / max( absV.x, max( absV.y, absV.z ) );\n\t\tabsV *= scaleToCube;\n\t\tv *= scaleToCube * ( 1.0 - 2.0 * texelSizeY );\n\t\tvec2 planar = v.xy;\n\t\tfloat almostATexel = 1.5 * texelSizeY;\n\t\tfloat almostOne = 1.0 - almostATexel;\n\t\tif ( absV.z >= almostOne ) {\n\t\t\tif ( v.z > 0.0 )\n\t\t\t\tplanar.x = 4.0 - v.x;\n\t\t} else if ( absV.x >= almostOne ) {\n\t\t\tfloat signX = sign( v.x );\n\t\t\tplanar.x = v.z * signX + 2.0 * signX;\n\t\t} else if ( absV.y >= almostOne ) {\n\t\t\tfloat signY = sign( v.y );\n\t\t\tplanar.x = v.x + 2.0 * signY + 2.0;\n\t\t\tplanar.y = v.z * signY - 2.0;\n\t\t}\n\t\treturn vec2( 0.125, 0.25 ) * planar + vec2( 0.375, 0.75 );\n\t}\n\tfloat getPointShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord, float shadowCameraNear, float shadowCameraFar ) {\n\t\tvec2 texelSize = vec2( 1.0 ) / ( shadowMapSize * vec2( 4.0, 2.0 ) );\n\t\tvec3 lightToPosition = shadowCoord.xyz;\n\t\tfloat dp = ( length( lightToPosition ) - shadowCameraNear ) / ( shadowCameraFar - shadowCameraNear );\t\tdp += shadowBias;\n\t\tvec3 bd3D = normalize( lightToPosition );\n\t\t#if defined( SHADOWMAP_TYPE_PCF ) || defined( SHADOWMAP_TYPE_PCF_SOFT ) || defined( SHADOWMAP_TYPE_VSM )\n\t\t\tvec2 offset = vec2( - 1, 1 ) * shadowRadius * texelSize.y;\n\t\t\treturn (\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyy, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyy, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyx, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyx, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxy, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxy, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxx, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxx, texelSize.y ), dp )\n\t\t\t) * ( 1.0 / 9.0 );\n\t\t#else\n\t\t\treturn texture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp );\n\t\t#endif\n\t}\n#endif",
				shadowmap_pars_vertex:
					"#ifdef USE_SHADOWMAP\n\t#if NUM_DIR_LIGHT_SHADOWS > 0\n\t\tuniform mat4 directionalShadowMatrix[ NUM_DIR_LIGHT_SHADOWS ];\n\t\tvarying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHT_SHADOWS ];\n\t\tstruct DirectionalLightShadow {\n\t\t\tfloat shadowBias;\n\t\t\tfloat shadowNormalBias;\n\t\t\tfloat shadowRadius;\n\t\t\tvec2 shadowMapSize;\n\t\t};\n\t\tuniform DirectionalLightShadow directionalLightShadows[ NUM_DIR_LIGHT_SHADOWS ];\n\t#endif\n\t#if NUM_SPOT_LIGHT_SHADOWS > 0\n\t\tuniform mat4 spotShadowMatrix[ NUM_SPOT_LIGHT_SHADOWS ];\n\t\tvarying vec4 vSpotShadowCoord[ NUM_SPOT_LIGHT_SHADOWS ];\n\t\tstruct SpotLightShadow {\n\t\t\tfloat shadowBias;\n\t\t\tfloat shadowNormalBias;\n\t\t\tfloat shadowRadius;\n\t\t\tvec2 shadowMapSize;\n\t\t};\n\t\tuniform SpotLightShadow spotLightShadows[ NUM_SPOT_LIGHT_SHADOWS ];\n\t#endif\n\t#if NUM_POINT_LIGHT_SHADOWS > 0\n\t\tuniform mat4 pointShadowMatrix[ NUM_POINT_LIGHT_SHADOWS ];\n\t\tvarying vec4 vPointShadowCoord[ NUM_POINT_LIGHT_SHADOWS ];\n\t\tstruct PointLightShadow {\n\t\t\tfloat shadowBias;\n\t\t\tfloat shadowNormalBias;\n\t\t\tfloat shadowRadius;\n\t\t\tvec2 shadowMapSize;\n\t\t\tfloat shadowCameraNear;\n\t\t\tfloat shadowCameraFar;\n\t\t};\n\t\tuniform PointLightShadow pointLightShadows[ NUM_POINT_LIGHT_SHADOWS ];\n\t#endif\n#endif",
				shadowmap_vertex:
					"#ifdef USE_SHADOWMAP\n\t#if NUM_DIR_LIGHT_SHADOWS > 0 || NUM_SPOT_LIGHT_SHADOWS > 0 || NUM_POINT_LIGHT_SHADOWS > 0\n\t\tvec3 shadowWorldNormal = inverseTransformDirection( transformedNormal, viewMatrix );\n\t\tvec4 shadowWorldPosition;\n\t#endif\n\t#if NUM_DIR_LIGHT_SHADOWS > 0\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_DIR_LIGHT_SHADOWS; i ++ ) {\n\t\tshadowWorldPosition = worldPosition + vec4( shadowWorldNormal * directionalLightShadows[ i ].shadowNormalBias, 0 );\n\t\tvDirectionalShadowCoord[ i ] = directionalShadowMatrix[ i ] * shadowWorldPosition;\n\t}\n\t#pragma unroll_loop_end\n\t#endif\n\t#if NUM_SPOT_LIGHT_SHADOWS > 0\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_SPOT_LIGHT_SHADOWS; i ++ ) {\n\t\tshadowWorldPosition = worldPosition + vec4( shadowWorldNormal * spotLightShadows[ i ].shadowNormalBias, 0 );\n\t\tvSpotShadowCoord[ i ] = spotShadowMatrix[ i ] * shadowWorldPosition;\n\t}\n\t#pragma unroll_loop_end\n\t#endif\n\t#if NUM_POINT_LIGHT_SHADOWS > 0\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_POINT_LIGHT_SHADOWS; i ++ ) {\n\t\tshadowWorldPosition = worldPosition + vec4( shadowWorldNormal * pointLightShadows[ i ].shadowNormalBias, 0 );\n\t\tvPointShadowCoord[ i ] = pointShadowMatrix[ i ] * shadowWorldPosition;\n\t}\n\t#pragma unroll_loop_end\n\t#endif\n#endif",
				shadowmask_pars_fragment:
					"float getShadowMask() {\n\tfloat shadow = 1.0;\n\t#ifdef USE_SHADOWMAP\n\t#if NUM_DIR_LIGHT_SHADOWS > 0\n\tDirectionalLightShadow directionalLight;\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_DIR_LIGHT_SHADOWS; i ++ ) {\n\t\tdirectionalLight = directionalLightShadows[ i ];\n\t\tshadow *= receiveShadow ? getShadow( directionalShadowMap[ i ], directionalLight.shadowMapSize, directionalLight.shadowBias, directionalLight.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;\n\t}\n\t#pragma unroll_loop_end\n\t#endif\n\t#if NUM_SPOT_LIGHT_SHADOWS > 0\n\tSpotLightShadow spotLight;\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_SPOT_LIGHT_SHADOWS; i ++ ) {\n\t\tspotLight = spotLightShadows[ i ];\n\t\tshadow *= receiveShadow ? getShadow( spotShadowMap[ i ], spotLight.shadowMapSize, spotLight.shadowBias, spotLight.shadowRadius, vSpotShadowCoord[ i ] ) : 1.0;\n\t}\n\t#pragma unroll_loop_end\n\t#endif\n\t#if NUM_POINT_LIGHT_SHADOWS > 0\n\tPointLightShadow pointLight;\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_POINT_LIGHT_SHADOWS; i ++ ) {\n\t\tpointLight = pointLightShadows[ i ];\n\t\tshadow *= receiveShadow ? getPointShadow( pointShadowMap[ i ], pointLight.shadowMapSize, pointLight.shadowBias, pointLight.shadowRadius, vPointShadowCoord[ i ], pointLight.shadowCameraNear, pointLight.shadowCameraFar ) : 1.0;\n\t}\n\t#pragma unroll_loop_end\n\t#endif\n\t#endif\n\treturn shadow;\n}",
				skinbase_vertex:
					"#ifdef USE_SKINNING\n\tmat4 boneMatX = getBoneMatrix( skinIndex.x );\n\tmat4 boneMatY = getBoneMatrix( skinIndex.y );\n\tmat4 boneMatZ = getBoneMatrix( skinIndex.z );\n\tmat4 boneMatW = getBoneMatrix( skinIndex.w );\n#endif",
				skinning_pars_vertex:
					"#ifdef USE_SKINNING\n\tuniform mat4 bindMatrix;\n\tuniform mat4 bindMatrixInverse;\n\t#ifdef BONE_TEXTURE\n\t\tuniform highp sampler2D boneTexture;\n\t\tuniform int boneTextureSize;\n\t\tmat4 getBoneMatrix( const in float i ) {\n\t\t\tfloat j = i * 4.0;\n\t\t\tfloat x = mod( j, float( boneTextureSize ) );\n\t\t\tfloat y = floor( j / float( boneTextureSize ) );\n\t\t\tfloat dx = 1.0 / float( boneTextureSize );\n\t\t\tfloat dy = 1.0 / float( boneTextureSize );\n\t\t\ty = dy * ( y + 0.5 );\n\t\t\tvec4 v1 = texture2D( boneTexture, vec2( dx * ( x + 0.5 ), y ) );\n\t\t\tvec4 v2 = texture2D( boneTexture, vec2( dx * ( x + 1.5 ), y ) );\n\t\t\tvec4 v3 = texture2D( boneTexture, vec2( dx * ( x + 2.5 ), y ) );\n\t\t\tvec4 v4 = texture2D( boneTexture, vec2( dx * ( x + 3.5 ), y ) );\n\t\t\tmat4 bone = mat4( v1, v2, v3, v4 );\n\t\t\treturn bone;\n\t\t}\n\t#else\n\t\tuniform mat4 boneMatrices[ MAX_BONES ];\n\t\tmat4 getBoneMatrix( const in float i ) {\n\t\t\tmat4 bone = boneMatrices[ int(i) ];\n\t\t\treturn bone;\n\t\t}\n\t#endif\n#endif",
				skinning_vertex:
					"#ifdef USE_SKINNING\n\tvec4 skinVertex = bindMatrix * vec4( transformed, 1.0 );\n\tvec4 skinned = vec4( 0.0 );\n\tskinned += boneMatX * skinVertex * skinWeight.x;\n\tskinned += boneMatY * skinVertex * skinWeight.y;\n\tskinned += boneMatZ * skinVertex * skinWeight.z;\n\tskinned += boneMatW * skinVertex * skinWeight.w;\n\ttransformed = ( bindMatrixInverse * skinned ).xyz;\n#endif",
				skinnormal_vertex:
					"#ifdef USE_SKINNING\n\tmat4 skinMatrix = mat4( 0.0 );\n\tskinMatrix += skinWeight.x * boneMatX;\n\tskinMatrix += skinWeight.y * boneMatY;\n\tskinMatrix += skinWeight.z * boneMatZ;\n\tskinMatrix += skinWeight.w * boneMatW;\n\tskinMatrix  = bindMatrixInverse * skinMatrix * bindMatrix;\n\tobjectNormal = vec4( skinMatrix * vec4( objectNormal, 0.0 ) ).xyz;\n\t#ifdef USE_TANGENT\n\t\tobjectTangent = vec4( skinMatrix * vec4( objectTangent, 0.0 ) ).xyz;\n\t#endif\n#endif",
				specularmap_fragment:
					"float specularStrength;\n#ifdef USE_SPECULARMAP\n\tvec4 texelSpecular = texture2D( specularMap, vUv );\n\tspecularStrength = texelSpecular.r;\n#else\n\tspecularStrength = 1.0;\n#endif",
				specularmap_pars_fragment:
					"#ifdef USE_SPECULARMAP\n\tuniform sampler2D specularMap;\n#endif",
				tonemapping_fragment:
					"#if defined( TONE_MAPPING )\n\tgl_FragColor.rgb = toneMapping( gl_FragColor.rgb );\n#endif",
				tonemapping_pars_fragment:
					"#ifndef saturate\n#define saturate(a) clamp( a, 0.0, 1.0 )\n#endif\nuniform float toneMappingExposure;\nvec3 LinearToneMapping( vec3 color ) {\n\treturn toneMappingExposure * color;\n}\nvec3 ReinhardToneMapping( vec3 color ) {\n\tcolor *= toneMappingExposure;\n\treturn saturate( color / ( vec3( 1.0 ) + color ) );\n}\nvec3 OptimizedCineonToneMapping( vec3 color ) {\n\tcolor *= toneMappingExposure;\n\tcolor = max( vec3( 0.0 ), color - 0.004 );\n\treturn pow( ( color * ( 6.2 * color + 0.5 ) ) / ( color * ( 6.2 * color + 1.7 ) + 0.06 ), vec3( 2.2 ) );\n}\nvec3 RRTAndODTFit( vec3 v ) {\n\tvec3 a = v * ( v + 0.0245786 ) - 0.000090537;\n\tvec3 b = v * ( 0.983729 * v + 0.4329510 ) + 0.238081;\n\treturn a / b;\n}\nvec3 ACESFilmicToneMapping( vec3 color ) {\n\tconst mat3 ACESInputMat = mat3(\n\t\tvec3( 0.59719, 0.07600, 0.02840 ),\t\tvec3( 0.35458, 0.90834, 0.13383 ),\n\t\tvec3( 0.04823, 0.01566, 0.83777 )\n\t);\n\tconst mat3 ACESOutputMat = mat3(\n\t\tvec3(  1.60475, -0.10208, -0.00327 ),\t\tvec3( -0.53108,  1.10813, -0.07276 ),\n\t\tvec3( -0.07367, -0.00605,  1.07602 )\n\t);\n\tcolor *= toneMappingExposure / 0.6;\n\tcolor = ACESInputMat * color;\n\tcolor = RRTAndODTFit( color );\n\tcolor = ACESOutputMat * color;\n\treturn saturate( color );\n}\nvec3 CustomToneMapping( vec3 color ) { return color; }",
				uv_pars_fragment:
					"#if ( defined( USE_UV ) && ! defined( UVS_VERTEX_ONLY ) )\n\tvarying vec2 vUv;\n#endif",
				uv_pars_vertex:
					"#ifdef USE_UV\n\t#ifdef UVS_VERTEX_ONLY\n\t\tvec2 vUv;\n\t#else\n\t\tvarying vec2 vUv;\n\t#endif\n\tuniform mat3 uvTransform;\n#endif",
				uv_vertex:
					"#ifdef USE_UV\n\tvUv = ( uvTransform * vec3( uv, 1 ) ).xy;\n#endif",
				uv2_pars_fragment:
					"#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )\n\tvarying vec2 vUv2;\n#endif",
				uv2_pars_vertex:
					"#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )\n\tattribute vec2 uv2;\n\tvarying vec2 vUv2;\n\tuniform mat3 uv2Transform;\n#endif",
				uv2_vertex:
					"#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )\n\tvUv2 = ( uv2Transform * vec3( uv2, 1 ) ).xy;\n#endif",
				worldpos_vertex:
					"#if defined( USE_ENVMAP ) || defined( DISTANCE ) || defined ( USE_SHADOWMAP )\n\tvec4 worldPosition = vec4( transformed, 1.0 );\n\t#ifdef USE_INSTANCING\n\t\tworldPosition = instanceMatrix * worldPosition;\n\t#endif\n\tworldPosition = modelMatrix * worldPosition;\n#endif",
				background_frag:
					"uniform sampler2D t2D;\nvarying vec2 vUv;\nvoid main() {\n\tvec4 texColor = texture2D( t2D, vUv );\n\tgl_FragColor = mapTexelToLinear( texColor );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n}",
				background_vert:
					"varying vec2 vUv;\nuniform mat3 uvTransform;\nvoid main() {\n\tvUv = ( uvTransform * vec3( uv, 1 ) ).xy;\n\tgl_Position = vec4( position.xy, 1.0, 1.0 );\n}",
				cube_frag:
					"#include <envmap_common_pars_fragment>\nuniform float opacity;\nvarying vec3 vWorldDirection;\n#include <cube_uv_reflection_fragment>\nvoid main() {\n\tvec3 vReflect = vWorldDirection;\n\t#include <envmap_fragment>\n\tgl_FragColor = envColor;\n\tgl_FragColor.a *= opacity;\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n}",
				cube_vert:
					"varying vec3 vWorldDirection;\n#include <common>\nvoid main() {\n\tvWorldDirection = transformDirection( position, modelMatrix );\n\t#include <begin_vertex>\n\t#include <project_vertex>\n\tgl_Position.z = gl_Position.w;\n}",
				depth_frag:
					"#if DEPTH_PACKING == 3200\n\tuniform float opacity;\n#endif\n#include <common>\n#include <packing>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvarying vec2 vHighPrecisionZW;\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( 1.0 );\n\t#if DEPTH_PACKING == 3200\n\t\tdiffuseColor.a = opacity;\n\t#endif\n\t#include <map_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <logdepthbuf_fragment>\n\tfloat fragCoordZ = 0.5 * vHighPrecisionZW[0] / vHighPrecisionZW[1] + 0.5;\n\t#if DEPTH_PACKING == 3200\n\t\tgl_FragColor = vec4( vec3( 1.0 - fragCoordZ ), opacity );\n\t#elif DEPTH_PACKING == 3201\n\t\tgl_FragColor = packDepthToRGBA( fragCoordZ );\n\t#endif\n}",
				depth_vert:
					"#include <common>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvarying vec2 vHighPrecisionZW;\nvoid main() {\n\t#include <uv_vertex>\n\t#include <skinbase_vertex>\n\t#ifdef USE_DISPLACEMENTMAP\n\t\t#include <beginnormal_vertex>\n\t\t#include <morphnormal_vertex>\n\t\t#include <skinnormal_vertex>\n\t#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\tvHighPrecisionZW = gl_Position.zw;\n}",
				distanceRGBA_frag:
					"#define DISTANCE\nuniform vec3 referencePosition;\nuniform float nearDistance;\nuniform float farDistance;\nvarying vec3 vWorldPosition;\n#include <common>\n#include <packing>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main () {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( 1.0 );\n\t#include <map_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\tfloat dist = length( vWorldPosition - referencePosition );\n\tdist = ( dist - nearDistance ) / ( farDistance - nearDistance );\n\tdist = saturate( dist );\n\tgl_FragColor = packDepthToRGBA( dist );\n}",
				distanceRGBA_vert:
					"#define DISTANCE\nvarying vec3 vWorldPosition;\n#include <common>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <skinbase_vertex>\n\t#ifdef USE_DISPLACEMENTMAP\n\t\t#include <beginnormal_vertex>\n\t\t#include <morphnormal_vertex>\n\t\t#include <skinnormal_vertex>\n\t#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <worldpos_vertex>\n\t#include <clipping_planes_vertex>\n\tvWorldPosition = worldPosition.xyz;\n}",
				equirect_frag:
					"uniform sampler2D tEquirect;\nvarying vec3 vWorldDirection;\n#include <common>\nvoid main() {\n\tvec3 direction = normalize( vWorldDirection );\n\tvec2 sampleUV = equirectUv( direction );\n\tvec4 texColor = texture2D( tEquirect, sampleUV );\n\tgl_FragColor = mapTexelToLinear( texColor );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n}",
				equirect_vert:
					"varying vec3 vWorldDirection;\n#include <common>\nvoid main() {\n\tvWorldDirection = transformDirection( position, modelMatrix );\n\t#include <begin_vertex>\n\t#include <project_vertex>\n}",
				linedashed_frag:
					"uniform vec3 diffuse;\nuniform float opacity;\nuniform float dashSize;\nuniform float totalSize;\nvarying float vLineDistance;\n#include <common>\n#include <color_pars_fragment>\n#include <fog_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tif ( mod( vLineDistance, totalSize ) > dashSize ) {\n\t\tdiscard;\n\t}\n\tvec3 outgoingLight = vec3( 0.0 );\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <logdepthbuf_fragment>\n\t#include <color_fragment>\n\toutgoingLight = diffuseColor.rgb;\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n}",
				linedashed_vert:
					"uniform float scale;\nattribute float lineDistance;\nvarying float vLineDistance;\n#include <common>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\tvLineDistance = scale * lineDistance;\n\t#include <color_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <fog_vertex>\n}",
				meshbasic_frag:
					"uniform vec3 diffuse;\nuniform float opacity;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\n#include <common>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <envmap_common_pars_fragment>\n#include <envmap_pars_fragment>\n#include <cube_uv_reflection_fragment>\n#include <fog_pars_fragment>\n#include <specularmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <specularmap_fragment>\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\t#ifdef USE_LIGHTMAP\n\t\n\t\tvec4 lightMapTexel= texture2D( lightMap, vUv2 );\n\t\treflectedLight.indirectDiffuse += lightMapTexelToLinear( lightMapTexel ).rgb * lightMapIntensity;\n\t#else\n\t\treflectedLight.indirectDiffuse += vec3( 1.0 );\n\t#endif\n\t#include <aomap_fragment>\n\treflectedLight.indirectDiffuse *= diffuseColor.rgb;\n\tvec3 outgoingLight = reflectedLight.indirectDiffuse;\n\t#include <envmap_fragment>\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}",
				meshbasic_vert:
					"#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <envmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <uv2_vertex>\n\t#include <color_vertex>\n\t#include <skinbase_vertex>\n\t#ifdef USE_ENVMAP\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <worldpos_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <envmap_vertex>\n\t#include <fog_vertex>\n}",
				meshlambert_frag:
					"uniform vec3 diffuse;\nuniform vec3 emissive;\nuniform float opacity;\nvarying vec3 vLightFront;\nvarying vec3 vIndirectFront;\n#ifdef DOUBLE_SIDED\n\tvarying vec3 vLightBack;\n\tvarying vec3 vIndirectBack;\n#endif\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <envmap_common_pars_fragment>\n#include <envmap_pars_fragment>\n#include <cube_uv_reflection_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <fog_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <shadowmask_pars_fragment>\n#include <specularmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\tvec3 totalEmissiveRadiance = emissive;\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <specularmap_fragment>\n\t#include <emissivemap_fragment>\n\t#ifdef DOUBLE_SIDED\n\t\treflectedLight.indirectDiffuse += ( gl_FrontFacing ) ? vIndirectFront : vIndirectBack;\n\t#else\n\t\treflectedLight.indirectDiffuse += vIndirectFront;\n\t#endif\n\t#include <lightmap_fragment>\n\treflectedLight.indirectDiffuse *= BRDF_Diffuse_Lambert( diffuseColor.rgb );\n\t#ifdef DOUBLE_SIDED\n\t\treflectedLight.directDiffuse = ( gl_FrontFacing ) ? vLightFront : vLightBack;\n\t#else\n\t\treflectedLight.directDiffuse = vLightFront;\n\t#endif\n\treflectedLight.directDiffuse *= BRDF_Diffuse_Lambert( diffuseColor.rgb ) * getShadowMask();\n\t#include <aomap_fragment>\n\tvec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + totalEmissiveRadiance;\n\t#include <envmap_fragment>\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}",
				meshlambert_vert:
					"#define LAMBERT\nvarying vec3 vLightFront;\nvarying vec3 vIndirectFront;\n#ifdef DOUBLE_SIDED\n\tvarying vec3 vLightBack;\n\tvarying vec3 vIndirectBack;\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <envmap_pars_vertex>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <uv2_vertex>\n\t#include <color_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <worldpos_vertex>\n\t#include <envmap_vertex>\n\t#include <lights_lambert_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n}",
				meshmatcap_frag:
					"#define MATCAP\nuniform vec3 diffuse;\nuniform float opacity;\nuniform sampler2D matcap;\nvarying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\n#include <common>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <fog_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\tvec3 viewDir = normalize( vViewPosition );\n\tvec3 x = normalize( vec3( viewDir.z, 0.0, - viewDir.x ) );\n\tvec3 y = cross( viewDir, x );\n\tvec2 uv = vec2( dot( x, normal ), dot( y, normal ) ) * 0.495 + 0.5;\n\t#ifdef USE_MATCAP\n\t\tvec4 matcapColor = texture2D( matcap, uv );\n\t\tmatcapColor = matcapTexelToLinear( matcapColor );\n\t#else\n\t\tvec4 matcapColor = vec4( 1.0 );\n\t#endif\n\tvec3 outgoingLight = diffuseColor.rgb * matcapColor.rgb;\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}",
				meshmatcap_vert:
					"#define MATCAP\nvarying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <color_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <color_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#ifndef FLAT_SHADED\n\t\tvNormal = normalize( transformedNormal );\n\t#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <fog_vertex>\n\tvViewPosition = - mvPosition.xyz;\n}",
				meshtoon_frag:
					"#define TOON\nuniform vec3 diffuse;\nuniform vec3 emissive;\nuniform float opacity;\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <gradientmap_pars_fragment>\n#include <fog_pars_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <lights_toon_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\tvec3 totalEmissiveRadiance = emissive;\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\t#include <emissivemap_fragment>\n\t#include <lights_toon_fragment>\n\t#include <lights_fragment_begin>\n\t#include <lights_fragment_maps>\n\t#include <lights_fragment_end>\n\t#include <aomap_fragment>\n\tvec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + totalEmissiveRadiance;\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}",
				meshtoon_vert:
					"#define TOON\nvarying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <uv2_vertex>\n\t#include <color_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n#ifndef FLAT_SHADED\n\tvNormal = normalize( transformedNormal );\n#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\tvViewPosition = - mvPosition.xyz;\n\t#include <worldpos_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n}",
				meshphong_frag:
					"#define PHONG\nuniform vec3 diffuse;\nuniform vec3 emissive;\nuniform vec3 specular;\nuniform float shininess;\nuniform float opacity;\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <envmap_common_pars_fragment>\n#include <envmap_pars_fragment>\n#include <cube_uv_reflection_fragment>\n#include <fog_pars_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <lights_phong_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <specularmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\tvec3 totalEmissiveRadiance = emissive;\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <specularmap_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\t#include <emissivemap_fragment>\n\t#include <lights_phong_fragment>\n\t#include <lights_fragment_begin>\n\t#include <lights_fragment_maps>\n\t#include <lights_fragment_end>\n\t#include <aomap_fragment>\n\tvec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + reflectedLight.directSpecular + reflectedLight.indirectSpecular + totalEmissiveRadiance;\n\t#include <envmap_fragment>\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}",
				meshphong_vert:
					"#define PHONG\nvarying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <envmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <uv2_vertex>\n\t#include <color_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n#ifndef FLAT_SHADED\n\tvNormal = normalize( transformedNormal );\n#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\tvViewPosition = - mvPosition.xyz;\n\t#include <worldpos_vertex>\n\t#include <envmap_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n}",
				meshphysical_frag:
					"#define STANDARD\n#ifdef PHYSICAL\n\t#define REFLECTIVITY\n\t#define CLEARCOAT\n\t#define TRANSPARENCY\n#endif\nuniform vec3 diffuse;\nuniform vec3 emissive;\nuniform float roughness;\nuniform float metalness;\nuniform float opacity;\n#ifdef TRANSPARENCY\n\tuniform float transparency;\n#endif\n#ifdef REFLECTIVITY\n\tuniform float reflectivity;\n#endif\n#ifdef CLEARCOAT\n\tuniform float clearcoat;\n\tuniform float clearcoatRoughness;\n#endif\n#ifdef USE_SHEEN\n\tuniform vec3 sheen;\n#endif\nvarying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n\t#ifdef USE_TANGENT\n\t\tvarying vec3 vTangent;\n\t\tvarying vec3 vBitangent;\n\t#endif\n#endif\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <bsdfs>\n#include <cube_uv_reflection_fragment>\n#include <envmap_common_pars_fragment>\n#include <envmap_physical_pars_fragment>\n#include <fog_pars_fragment>\n#include <lights_pars_begin>\n#include <lights_physical_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <clearcoat_pars_fragment>\n#include <roughnessmap_pars_fragment>\n#include <metalnessmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\tvec3 totalEmissiveRadiance = emissive;\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <roughnessmap_fragment>\n\t#include <metalnessmap_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\t#include <clearcoat_normal_fragment_begin>\n\t#include <clearcoat_normal_fragment_maps>\n\t#include <emissivemap_fragment>\n\t#include <lights_physical_fragment>\n\t#include <lights_fragment_begin>\n\t#include <lights_fragment_maps>\n\t#include <lights_fragment_end>\n\t#include <aomap_fragment>\n\tvec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + reflectedLight.directSpecular + reflectedLight.indirectSpecular + totalEmissiveRadiance;\n\t#ifdef TRANSPARENCY\n\t\tdiffuseColor.a *= saturate( 1. - transparency + linearToRelativeLuminance( reflectedLight.directSpecular + reflectedLight.indirectSpecular ) );\n\t#endif\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}",
				meshphysical_vert:
					"#define STANDARD\nvarying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n\t#ifdef USE_TANGENT\n\t\tvarying vec3 vTangent;\n\t\tvarying vec3 vBitangent;\n\t#endif\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <uv2_vertex>\n\t#include <color_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n#ifndef FLAT_SHADED\n\tvNormal = normalize( transformedNormal );\n\t#ifdef USE_TANGENT\n\t\tvTangent = normalize( transformedTangent );\n\t\tvBitangent = normalize( cross( vNormal, vTangent ) * tangent.w );\n\t#endif\n#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\tvViewPosition = - mvPosition.xyz;\n\t#include <worldpos_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n}",
				normal_frag:
					"#define NORMAL\nuniform float opacity;\n#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( TANGENTSPACE_NORMALMAP )\n\tvarying vec3 vViewPosition;\n#endif\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n\t#ifdef USE_TANGENT\n\t\tvarying vec3 vTangent;\n\t\tvarying vec3 vBitangent;\n\t#endif\n#endif\n#include <packing>\n#include <uv_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\t#include <logdepthbuf_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\tgl_FragColor = vec4( packNormalToRGB( normal ), opacity );\n}",
				normal_vert:
					"#define NORMAL\n#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( TANGENTSPACE_NORMALMAP )\n\tvarying vec3 vViewPosition;\n#endif\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n\t#ifdef USE_TANGENT\n\t\tvarying vec3 vTangent;\n\t\tvarying vec3 vBitangent;\n\t#endif\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n#ifndef FLAT_SHADED\n\tvNormal = normalize( transformedNormal );\n\t#ifdef USE_TANGENT\n\t\tvTangent = normalize( transformedTangent );\n\t\tvBitangent = normalize( cross( vNormal, vTangent ) * tangent.w );\n\t#endif\n#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( TANGENTSPACE_NORMALMAP )\n\tvViewPosition = - mvPosition.xyz;\n#endif\n}",
				points_frag:
					"uniform vec3 diffuse;\nuniform float opacity;\n#include <common>\n#include <color_pars_fragment>\n#include <map_particle_pars_fragment>\n#include <fog_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec3 outgoingLight = vec3( 0.0 );\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <logdepthbuf_fragment>\n\t#include <map_particle_fragment>\n\t#include <color_fragment>\n\t#include <alphatest_fragment>\n\toutgoingLight = diffuseColor.rgb;\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n}",
				points_vert:
					"uniform float size;\nuniform float scale;\n#include <common>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <color_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <project_vertex>\n\tgl_PointSize = size;\n\t#ifdef USE_SIZEATTENUATION\n\t\tbool isPerspective = isPerspectiveMatrix( projectionMatrix );\n\t\tif ( isPerspective ) gl_PointSize *= ( scale / - mvPosition.z );\n\t#endif\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <worldpos_vertex>\n\t#include <fog_vertex>\n}",
				shadow_frag:
					"uniform vec3 color;\nuniform float opacity;\n#include <common>\n#include <packing>\n#include <fog_pars_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <shadowmap_pars_fragment>\n#include <shadowmask_pars_fragment>\nvoid main() {\n\tgl_FragColor = vec4( color, opacity * ( 1.0 - getShadowMask() ) );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n}",
				shadow_vert:
					"#include <common>\n#include <fog_pars_vertex>\n#include <shadowmap_pars_vertex>\nvoid main() {\n\t#include <begin_vertex>\n\t#include <project_vertex>\n\t#include <worldpos_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n}",
				sprite_frag:
					"uniform vec3 diffuse;\nuniform float opacity;\n#include <common>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <fog_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec3 outgoingLight = vec3( 0.0 );\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\toutgoingLight = diffuseColor.rgb;\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n}",
				sprite_vert:
					"uniform float rotation;\nuniform vec2 center;\n#include <common>\n#include <uv_pars_vertex>\n#include <fog_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\tvec4 mvPosition = modelViewMatrix * vec4( 0.0, 0.0, 0.0, 1.0 );\n\tvec2 scale;\n\tscale.x = length( vec3( modelMatrix[ 0 ].x, modelMatrix[ 0 ].y, modelMatrix[ 0 ].z ) );\n\tscale.y = length( vec3( modelMatrix[ 1 ].x, modelMatrix[ 1 ].y, modelMatrix[ 1 ].z ) );\n\t#ifndef USE_SIZEATTENUATION\n\t\tbool isPerspective = isPerspectiveMatrix( projectionMatrix );\n\t\tif ( isPerspective ) scale *= - mvPosition.z;\n\t#endif\n\tvec2 alignedPosition = ( position.xy - ( center - vec2( 0.5 ) ) ) * scale;\n\tvec2 rotatedPosition;\n\trotatedPosition.x = cos( rotation ) * alignedPosition.x - sin( rotation ) * alignedPosition.y;\n\trotatedPosition.y = sin( rotation ) * alignedPosition.x + cos( rotation ) * alignedPosition.y;\n\tmvPosition.xy += rotatedPosition;\n\tgl_Position = projectionMatrix * mvPosition;\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <fog_vertex>\n}",
			},
			Ju = {
				basic: {
					uniforms: Pu([
						ju.common,
						ju.specularmap,
						ju.envmap,
						ju.aomap,
						ju.lightmap,
						ju.fog,
					]),
					vertexShader: Zu.meshbasic_vert,
					fragmentShader: Zu.meshbasic_frag,
				},
				lambert: {
					uniforms: Pu([
						ju.common,
						ju.specularmap,
						ju.envmap,
						ju.aomap,
						ju.lightmap,
						ju.emissivemap,
						ju.fog,
						ju.lights,
						{ emissive: { value: new Eh(0) } },
					]),
					vertexShader: Zu.meshlambert_vert,
					fragmentShader: Zu.meshlambert_frag,
				},
				phong: {
					uniforms: Pu([
						ju.common,
						ju.specularmap,
						ju.envmap,
						ju.aomap,
						ju.lightmap,
						ju.emissivemap,
						ju.bumpmap,
						ju.normalmap,
						ju.displacementmap,
						ju.fog,
						ju.lights,
						{
							emissive: { value: new Eh(0) },
							specular: { value: new Eh(1118481) },
							shininess: { value: 30 },
						},
					]),
					vertexShader: Zu.meshphong_vert,
					fragmentShader: Zu.meshphong_frag,
				},
				standard: {
					uniforms: Pu([
						ju.common,
						ju.envmap,
						ju.aomap,
						ju.lightmap,
						ju.emissivemap,
						ju.bumpmap,
						ju.normalmap,
						ju.displacementmap,
						ju.roughnessmap,
						ju.metalnessmap,
						ju.fog,
						ju.lights,
						{
							emissive: { value: new Eh(0) },
							roughness: { value: 1 },
							metalness: { value: 0 },
							envMapIntensity: { value: 1 },
						},
					]),
					vertexShader: Zu.meshphysical_vert,
					fragmentShader: Zu.meshphysical_frag,
				},
				toon: {
					uniforms: Pu([
						ju.common,
						ju.aomap,
						ju.lightmap,
						ju.emissivemap,
						ju.bumpmap,
						ju.normalmap,
						ju.displacementmap,
						ju.gradientmap,
						ju.fog,
						ju.lights,
						{ emissive: { value: new Eh(0) } },
					]),
					vertexShader: Zu.meshtoon_vert,
					fragmentShader: Zu.meshtoon_frag,
				},
				matcap: {
					uniforms: Pu([
						ju.common,
						ju.bumpmap,
						ju.normalmap,
						ju.displacementmap,
						ju.fog,
						{ matcap: { value: null } },
					]),
					vertexShader: Zu.meshmatcap_vert,
					fragmentShader: Zu.meshmatcap_frag,
				},
				points: {
					uniforms: Pu([ju.points, ju.fog]),
					vertexShader: Zu.points_vert,
					fragmentShader: Zu.points_frag,
				},
				dashed: {
					uniforms: Pu([
						ju.common,
						ju.fog,
						{
							scale: { value: 1 },
							dashSize: { value: 1 },
							totalSize: { value: 2 },
						},
					]),
					vertexShader: Zu.linedashed_vert,
					fragmentShader: Zu.linedashed_frag,
				},
				depth: {
					uniforms: Pu([ju.common, ju.displacementmap]),
					vertexShader: Zu.depth_vert,
					fragmentShader: Zu.depth_frag,
				},
				normal: {
					uniforms: Pu([
						ju.common,
						ju.bumpmap,
						ju.normalmap,
						ju.displacementmap,
						{ opacity: { value: 1 } },
					]),
					vertexShader: Zu.normal_vert,
					fragmentShader: Zu.normal_frag,
				},
				sprite: {
					uniforms: Pu([ju.sprite, ju.fog]),
					vertexShader: Zu.sprite_vert,
					fragmentShader: Zu.sprite_frag,
				},
				background: {
					uniforms: { uvTransform: { value: new Qc() }, t2D: { value: null } },
					vertexShader: Zu.background_vert,
					fragmentShader: Zu.background_frag,
				},
				cube: {
					uniforms: Pu([ju.envmap, { opacity: { value: 1 } }]),
					vertexShader: Zu.cube_vert,
					fragmentShader: Zu.cube_frag,
				},
				equirect: {
					uniforms: { tEquirect: { value: null } },
					vertexShader: Zu.equirect_vert,
					fragmentShader: Zu.equirect_frag,
				},
				distanceRGBA: {
					uniforms: Pu([
						ju.common,
						ju.displacementmap,
						{
							referencePosition: { value: new ll() },
							nearDistance: { value: 1 },
							farDistance: { value: 1e3 },
						},
					]),
					vertexShader: Zu.distanceRGBA_vert,
					fragmentShader: Zu.distanceRGBA_frag,
				},
				shadow: {
					uniforms: Pu([
						ju.lights,
						ju.fog,
						{ color: { value: new Eh(0) }, opacity: { value: 1 } },
					]),
					vertexShader: Zu.shadow_vert,
					fragmentShader: Zu.shadow_frag,
				},
			};
		function Ku(t, e, n, i) {
			const r = t.getParameter(34921),
				o = i.isWebGL2 ? null : e.get("OES_vertex_array_object"),
				s = i.isWebGL2 || null !== o,
				a = {},
				c = d(null);
			let l = c;
			function h(e) {
				return i.isWebGL2 ? t.bindVertexArray(e) : o.bindVertexArrayOES(e);
			}
			function u(e) {
				return i.isWebGL2 ? t.deleteVertexArray(e) : o.deleteVertexArrayOES(e);
			}
			function d(t) {
				const e = [],
					n = [],
					i = [];
				for (let t = 0; t < r; t++) (e[t] = 0), (n[t] = 0), (i[t] = 0);
				return {
					geometry: null,
					program: null,
					wireframe: !1,
					newAttributes: e,
					enabledAttributes: n,
					attributeDivisors: i,
					object: t,
					attributes: {},
				};
			}
			function p() {
				const t = l.newAttributes;
				for (let e = 0, n = t.length; e < n; e++) t[e] = 0;
			}
			function f(t) {
				m(t, 0);
			}
			function m(n, r) {
				const o = l.newAttributes,
					s = l.enabledAttributes,
					a = l.attributeDivisors;
				if (
					((o[n] = 1),
					0 === s[n] && (t.enableVertexAttribArray(n), (s[n] = 1)),
					a[n] !== r)
				) {
					(i.isWebGL2 ? t : e.get("ANGLE_instanced_arrays"))[
						i.isWebGL2 ? "vertexAttribDivisor" : "vertexAttribDivisorANGLE"
					](n, r),
						(a[n] = r);
				}
			}
			function g() {
				const e = l.newAttributes,
					n = l.enabledAttributes;
				for (let i = 0, r = n.length; i < r; i++)
					n[i] !== e[i] && (t.disableVertexAttribArray(i), (n[i] = 0));
			}
			function v(e, n, r, o, s, a) {
				!0 !== i.isWebGL2 || (5124 !== r && 5125 !== r)
					? t.vertexAttribPointer(e, n, r, o, s, a)
					: t.vertexAttribIPointer(e, n, r, o, s, a);
			}
			function y() {
				x(), l !== c && h((l = c).object);
			}
			function x() {
				(c.geometry = null), (c.program = null), (c.wireframe = !1);
			}
			return {
				setup: function (r, c, u, y, x) {
					let b = !1;
					if (s) {
						const e = (function (e, n, r) {
							const s = !0 === r.wireframe;
							let c = a[e.id];
							void 0 === c && ((c = {}), (a[e.id] = c));
							let l = c[n.id];
							void 0 === l && ((l = {}), (c[n.id] = l));
							let h = l[s];
							return (
								void 0 === h &&
									((h = d(
										i.isWebGL2
											? t.createVertexArray()
											: o.createVertexArrayOES()
									)),
									(l[s] = h)),
								h
							);
						})(y, u, c);
						l !== e && h((l = e).object),
							(b = (function (t) {
								const e = l.attributes,
									n = t.attributes;
								if (Object.keys(e).length !== Object.keys(n).length) return !0;
								for (const t in n) {
									const i = e[t],
										r = n[t];
									if (i.attribute !== r) return !0;
									if (i.data !== r.data) return !0;
								}
								return !1;
							})(y)) &&
								(function (t) {
									const e = {},
										n = t.attributes;
									for (const t in n) {
										const i = n[t],
											r = {};
										(r.attribute = i), i.data && (r.data = i.data), (e[t] = r);
									}
									l.attributes = e;
								})(y);
					} else {
						const t = !0 === c.wireframe;
						(l.geometry === y.id && l.program === u.id && l.wireframe === t) ||
							((l.geometry = y.id),
							(l.program = u.id),
							(l.wireframe = t),
							(b = !0));
					}
					!0 === r.isInstancedMesh && (b = !0),
						null !== x && n.update(x, 34963),
						b &&
							((function (r, o, s, a) {
								if (
									!1 === i.isWebGL2 &&
									(r.isInstancedMesh || a.isInstancedBufferGeometry) &&
									null === e.get("ANGLE_instanced_arrays")
								)
									return;
								p();
								const c = a.attributes,
									l = s.getAttributes(),
									h = o.defaultAttributeValues;
								for (const e in l) {
									const i = l[e];
									if (i >= 0) {
										const o = c[e];
										if (void 0 !== o) {
											const e = o.normalized,
												r = o.itemSize,
												s = n.get(o);
											if (void 0 === s) continue;
											const c = s.buffer,
												l = s.type,
												h = s.bytesPerElement;
											if (o.isInterleavedBufferAttribute) {
												const n = o.data,
													s = n.stride,
													u = o.offset;
												n && n.isInstancedInterleavedBuffer
													? (m(i, n.meshPerAttribute),
													  void 0 === a._maxInstanceCount &&
															(a._maxInstanceCount =
																n.meshPerAttribute * n.count))
													: f(i),
													t.bindBuffer(34962, c),
													v(i, r, l, e, s * h, u * h);
											} else
												o.isInstancedBufferAttribute
													? (m(i, o.meshPerAttribute),
													  void 0 === a._maxInstanceCount &&
															(a._maxInstanceCount =
																o.meshPerAttribute * o.count))
													: f(i),
													t.bindBuffer(34962, c),
													v(i, r, l, e, 0, 0);
										} else if ("instanceMatrix" === e) {
											const e = n.get(r.instanceMatrix);
											if (void 0 === e) continue;
											const o = e.buffer,
												s = e.type;
											m(i + 0, 1),
												m(i + 1, 1),
												m(i + 2, 1),
												m(i + 3, 1),
												t.bindBuffer(34962, o),
												t.vertexAttribPointer(i + 0, 4, s, !1, 64, 0),
												t.vertexAttribPointer(i + 1, 4, s, !1, 64, 16),
												t.vertexAttribPointer(i + 2, 4, s, !1, 64, 32),
												t.vertexAttribPointer(i + 3, 4, s, !1, 64, 48);
										} else if (void 0 !== h) {
											const n = h[e];
											if (void 0 !== n)
												switch (n.length) {
													case 2:
														t.vertexAttrib2fv(i, n);
														break;
													case 3:
														t.vertexAttrib3fv(i, n);
														break;
													case 4:
														t.vertexAttrib4fv(i, n);
														break;
													default:
														t.vertexAttrib1fv(i, n);
												}
										}
									}
								}
								g();
							})(r, c, u, y),
							null !== x && t.bindBuffer(34963, n.get(x).buffer));
				},
				reset: y,
				resetDefaultState: x,
				dispose: function () {
					y();
					for (const t in a) {
						const e = a[t];
						for (const t in e) {
							const n = e[t];
							for (const t in n) u(n[t].object), delete n[t];
							delete e[t];
						}
						delete a[t];
					}
				},
				releaseStatesOfGeometry: function (t) {
					if (void 0 === a[t.id]) return;
					const e = a[t.id];
					for (const t in e) {
						const n = e[t];
						for (const t in n) u(n[t].object), delete n[t];
						delete e[t];
					}
					delete a[t.id];
				},
				releaseStatesOfProgram: function (t) {
					for (const e in a) {
						const n = a[e];
						if (void 0 === n[t.id]) continue;
						const i = n[t.id];
						for (const t in i) u(i[t].object), delete i[t];
						delete n[t.id];
					}
				},
				initAttributes: p,
				enableAttribute: f,
				disableUnusedAttributes: g,
			};
		}
		function Qu(t, e) {
			return t[0] - e[0];
		}
		function $u(t, e) {
			return Math.abs(e[1]) - Math.abs(t[1]);
		}
		function td(t, e, n, i, r, o, s, a, c, l) {
			(t = void 0 !== t ? t : []),
				(e = void 0 !== e ? e : ea),
				(s = void 0 !== s ? s : Pa),
				nl.call(this, t, e, n, i, r, o, s, a, c, l),
				(this.flipY = !1);
		}
		function ed(t, e, n, i) {
			nl.call(this, null),
				(this.image = {
					data: t || null,
					width: e || 1,
					height: n || 1,
					depth: i || 1,
				}),
				(this.magFilter = ha),
				(this.minFilter = ha),
				(this.wrapR = ca),
				(this.generateMipmaps = !1),
				(this.flipY = !1),
				(this.needsUpdate = !0);
		}
		function nd(t, e, n, i) {
			nl.call(this, null),
				(this.image = {
					data: t || null,
					width: e || 1,
					height: n || 1,
					depth: i || 1,
				}),
				(this.magFilter = ha),
				(this.minFilter = ha),
				(this.wrapR = ca),
				(this.generateMipmaps = !1),
				(this.flipY = !1),
				(this.needsUpdate = !0);
		}
		(Ju.physical = {
			uniforms: Pu([
				Ju.standard.uniforms,
				{
					clearcoat: { value: 0 },
					clearcoatMap: { value: null },
					clearcoatRoughness: { value: 0 },
					clearcoatRoughnessMap: { value: null },
					clearcoatNormalScale: { value: new Kc(1, 1) },
					clearcoatNormalMap: { value: null },
					sheen: { value: new Eh(0) },
					transparency: { value: 0 },
				},
			]),
			vertexShader: Zu.meshphysical_vert,
			fragmentShader: Zu.meshphysical_frag,
		}),
			(td.prototype = Object.create(nl.prototype)),
			(td.prototype.constructor = td),
			(td.prototype.isCubeTexture = !0),
			Object.defineProperty(td.prototype, "images", {
				get: function () {
					return this.image;
				},
				set: function (t) {
					this.image = t;
				},
			}),
			(ed.prototype = Object.create(nl.prototype)),
			(ed.prototype.constructor = ed),
			(ed.prototype.isDataTexture2DArray = !0),
			(nd.prototype = Object.create(nl.prototype)),
			(nd.prototype.constructor = nd),
			(nd.prototype.isDataTexture3D = !0);
		const id = new nl(),
			rd = new ed(),
			od = new nd(),
			sd = new td(),
			ad = [],
			cd = [],
			ld = new Float32Array(16),
			hd = new Float32Array(9),
			ud = new Float32Array(4);
		function dd(t, e, n) {
			const i = t[0];
			if (i <= 0 || i > 0) return t;
			let r = e * n,
				o = ad[r];
			if ((void 0 === o && ((o = new Float32Array(r)), (ad[r] = o)), 0 !== e)) {
				i.toArray(o, 0);
				for (let i = 1, r = 0; i !== e; ++i) (r += n), t[i].toArray(o, r);
			}
			return o;
		}
		function pd(t, e) {
			if (t.length !== e.length) return !1;
			for (let n = 0, i = t.length; n < i; n++) if (t[n] !== e[n]) return !1;
			return !0;
		}
		function fd(t, e) {
			for (let n = 0, i = e.length; n < i; n++) t[n] = e[n];
		}
		function md(t, e) {
			let n = cd[e];
			void 0 === n && ((n = new Int32Array(e)), (cd[e] = n));
			for (let i = 0; i !== e; ++i) n[i] = t.allocateTextureUnit();
			return n;
		}
		function gd(t, e) {
			const n = this.cache;
			n[0] !== e && (t.uniform1f(this.addr, e), (n[0] = e));
		}
		function vd(t, e) {
			const n = this.cache;
			if (void 0 !== e.x)
				(n[0] === e.x && n[1] === e.y) ||
					(t.uniform2f(this.addr, e.x, e.y), (n[0] = e.x), (n[1] = e.y));
			else {
				if (pd(n, e)) return;
				t.uniform2fv(this.addr, e), fd(n, e);
			}
		}
		function yd(t, e) {
			const n = this.cache;
			if (void 0 !== e.x)
				(n[0] === e.x && n[1] === e.y && n[2] === e.z) ||
					(t.uniform3f(this.addr, e.x, e.y, e.z),
					(n[0] = e.x),
					(n[1] = e.y),
					(n[2] = e.z));
			else if (void 0 !== e.r)
				(n[0] === e.r && n[1] === e.g && n[2] === e.b) ||
					(t.uniform3f(this.addr, e.r, e.g, e.b),
					(n[0] = e.r),
					(n[1] = e.g),
					(n[2] = e.b));
			else {
				if (pd(n, e)) return;
				t.uniform3fv(this.addr, e), fd(n, e);
			}
		}
		function xd(t, e) {
			const n = this.cache;
			if (void 0 !== e.x)
				(n[0] === e.x && n[1] === e.y && n[2] === e.z && n[3] === e.w) ||
					(t.uniform4f(this.addr, e.x, e.y, e.z, e.w),
					(n[0] = e.x),
					(n[1] = e.y),
					(n[2] = e.z),
					(n[3] = e.w));
			else {
				if (pd(n, e)) return;
				t.uniform4fv(this.addr, e), fd(n, e);
			}
		}
		function bd(t, e) {
			const n = this.cache,
				i = e.elements;
			if (void 0 === i) {
				if (pd(n, e)) return;
				t.uniformMatrix2fv(this.addr, !1, e), fd(n, e);
			} else {
				if (pd(n, i)) return;
				ud.set(i), t.uniformMatrix2fv(this.addr, !1, ud), fd(n, i);
			}
		}
		function wd(t, e) {
			const n = this.cache,
				i = e.elements;
			if (void 0 === i) {
				if (pd(n, e)) return;
				t.uniformMatrix3fv(this.addr, !1, e), fd(n, e);
			} else {
				if (pd(n, i)) return;
				hd.set(i), t.uniformMatrix3fv(this.addr, !1, hd), fd(n, i);
			}
		}
		function _d(t, e) {
			const n = this.cache,
				i = e.elements;
			if (void 0 === i) {
				if (pd(n, e)) return;
				t.uniformMatrix4fv(this.addr, !1, e), fd(n, e);
			} else {
				if (pd(n, i)) return;
				ld.set(i), t.uniformMatrix4fv(this.addr, !1, ld), fd(n, i);
			}
		}
		function Md(t, e, n) {
			const i = this.cache,
				r = n.allocateTextureUnit();
			i[0] !== r && (t.uniform1i(this.addr, r), (i[0] = r)),
				n.safeSetTexture2D(e || id, r);
		}
		function Sd(t, e, n) {
			const i = this.cache,
				r = n.allocateTextureUnit();
			i[0] !== r && (t.uniform1i(this.addr, r), (i[0] = r)),
				n.setTexture2DArray(e || rd, r);
		}
		function Td(t, e, n) {
			const i = this.cache,
				r = n.allocateTextureUnit();
			i[0] !== r && (t.uniform1i(this.addr, r), (i[0] = r)),
				n.setTexture3D(e || od, r);
		}
		function Ed(t, e, n) {
			const i = this.cache,
				r = n.allocateTextureUnit();
			i[0] !== r && (t.uniform1i(this.addr, r), (i[0] = r)),
				n.safeSetTextureCube(e || sd, r);
		}
		function Ad(t, e) {
			const n = this.cache;
			n[0] !== e && (t.uniform1i(this.addr, e), (n[0] = e));
		}
		function Ld(t, e) {
			const n = this.cache;
			pd(n, e) || (t.uniform2iv(this.addr, e), fd(n, e));
		}
		function Pd(t, e) {
			const n = this.cache;
			pd(n, e) || (t.uniform3iv(this.addr, e), fd(n, e));
		}
		function Rd(t, e) {
			const n = this.cache;
			pd(n, e) || (t.uniform4iv(this.addr, e), fd(n, e));
		}
		function Cd(t, e) {
			const n = this.cache;
			n[0] !== e && (t.uniform1ui(this.addr, e), (n[0] = e));
		}
		function Od(t, e) {
			t.uniform1fv(this.addr, e);
		}
		function Dd(t, e) {
			t.uniform1iv(this.addr, e);
		}
		function Id(t, e) {
			t.uniform2iv(this.addr, e);
		}
		function kd(t, e) {
			t.uniform3iv(this.addr, e);
		}
		function Nd(t, e) {
			t.uniform4iv(this.addr, e);
		}
		function Bd(t, e) {
			const n = dd(e, this.size, 2);
			t.uniform2fv(this.addr, n);
		}
		function Fd(t, e) {
			const n = dd(e, this.size, 3);
			t.uniform3fv(this.addr, n);
		}
		function zd(t, e) {
			const n = dd(e, this.size, 4);
			t.uniform4fv(this.addr, n);
		}
		function Hd(t, e) {
			const n = dd(e, this.size, 4);
			t.uniformMatrix2fv(this.addr, !1, n);
		}
		function Ud(t, e) {
			const n = dd(e, this.size, 9);
			t.uniformMatrix3fv(this.addr, !1, n);
		}
		function Gd(t, e) {
			const n = dd(e, this.size, 16);
			t.uniformMatrix4fv(this.addr, !1, n);
		}
		function Vd(t, e, n) {
			const i = e.length,
				r = md(n, i);
			t.uniform1iv(this.addr, r);
			for (let t = 0; t !== i; ++t) n.safeSetTexture2D(e[t] || id, r[t]);
		}
		function jd(t, e, n) {
			const i = e.length,
				r = md(n, i);
			t.uniform1iv(this.addr, r);
			for (let t = 0; t !== i; ++t) n.safeSetTextureCube(e[t] || sd, r[t]);
		}
		function Wd(t, e, n) {
			(this.id = t),
				(this.addr = n),
				(this.cache = []),
				(this.setValue = (function (t) {
					switch (t) {
						case 5126:
							return gd;
						case 35664:
							return vd;
						case 35665:
							return yd;
						case 35666:
							return xd;
						case 35674:
							return bd;
						case 35675:
							return wd;
						case 35676:
							return _d;
						case 5124:
						case 35670:
							return Ad;
						case 35667:
						case 35671:
							return Ld;
						case 35668:
						case 35672:
							return Pd;
						case 35669:
						case 35673:
							return Rd;
						case 5125:
							return Cd;
						case 35678:
						case 36198:
						case 36298:
						case 36306:
						case 35682:
							return Md;
						case 35679:
						case 36299:
						case 36307:
							return Td;
						case 35680:
						case 36300:
						case 36308:
						case 36293:
							return Ed;
						case 36289:
						case 36303:
						case 36311:
						case 36292:
							return Sd;
					}
				})(e.type));
		}
		function qd(t, e, n) {
			(this.id = t),
				(this.addr = n),
				(this.cache = []),
				(this.size = e.size),
				(this.setValue = (function (t) {
					switch (t) {
						case 5126:
							return Od;
						case 35664:
							return Bd;
						case 35665:
							return Fd;
						case 35666:
							return zd;
						case 35674:
							return Hd;
						case 35675:
							return Ud;
						case 35676:
							return Gd;
						case 5124:
						case 35670:
							return Dd;
						case 35667:
						case 35671:
							return Id;
						case 35668:
						case 35672:
							return kd;
						case 35669:
						case 35673:
							return Nd;
						case 35678:
						case 36198:
						case 36298:
						case 36306:
						case 35682:
							return Vd;
						case 35680:
						case 36300:
						case 36308:
						case 36293:
							return jd;
					}
				})(e.type));
		}
		function Yd(t) {
			(this.id = t), (this.seq = []), (this.map = {});
		}
		(qd.prototype.updateCache = function (t) {
			let e = this.cache;
			t instanceof Float32Array &&
				e.length !== t.length &&
				(this.cache = new Float32Array(t.length)),
				fd(e, t);
		}),
			(Yd.prototype.setValue = function (t, e, n) {
				const i = this.seq;
				for (let r = 0, o = i.length; r !== o; ++r) {
					const o = i[r];
					o.setValue(t, e[o.id], n);
				}
			});
		const Xd = /([\w\d_]+)(\])?(\[|\.)?/g;
		function Zd(t, e) {
			t.seq.push(e), (t.map[e.id] = e);
		}
		function Jd(t, e, n) {
			const i = t.name,
				r = i.length;
			for (Xd.lastIndex = 0; ; ) {
				const o = Xd.exec(i),
					s = Xd.lastIndex;
				let a = o[1],
					c = "]" === o[2],
					l = o[3];
				if ((c && (a |= 0), void 0 === l || ("[" === l && s + 2 === r))) {
					Zd(n, void 0 === l ? new Wd(a, t, e) : new qd(a, t, e));
					break;
				}
				{
					let t = n.map[a];
					void 0 === t && Zd(n, (t = new Yd(a))), (n = t);
				}
			}
		}
		function Kd(t, e) {
			(this.seq = []), (this.map = {});
			const n = t.getProgramParameter(e, 35718);
			for (let i = 0; i < n; ++i) {
				const n = t.getActiveUniform(e, i);
				Jd(n, t.getUniformLocation(e, n.name), this);
			}
		}
		function Qd(t, e, n) {
			const i = t.createShader(e);
			return t.shaderSource(i, n), t.compileShader(i), i;
		}
		(Kd.prototype.setValue = function (t, e, n, i) {
			const r = this.map[e];
			void 0 !== r && r.setValue(t, n, i);
		}),
			(Kd.prototype.setOptional = function (t, e, n) {
				const i = e[n];
				void 0 !== i && this.setValue(t, n, i);
			}),
			(Kd.upload = function (t, e, n, i) {
				for (let r = 0, o = e.length; r !== o; ++r) {
					const o = e[r],
						s = n[o.id];
					!1 !== s.needsUpdate && o.setValue(t, s.value, i);
				}
			}),
			(Kd.seqWithValue = function (t, e) {
				const n = [];
				for (let i = 0, r = t.length; i !== r; ++i) {
					const r = t[i];
					r.id in e && n.push(r);
				}
				return n;
			});
		let $d = 0;
		function tp(t) {
			switch (t) {
				case Oc:
					return ["Linear", "( value )"];
				case Dc:
					return ["sRGB", "( value )"];
				case kc:
					return ["RGBE", "( value )"];
				case Bc:
					return ["RGBM", "( value, 7.0 )"];
				case Fc:
					return ["RGBM", "( value, 16.0 )"];
				case zc:
					return ["RGBD", "( value, 256.0 )"];
				case Ic:
					return ["Gamma", "( value, float( GAMMA_FACTOR ) )"];
				case Nc:
					return ["LogLuv", "( value )"];
				default:
					return (
						console.warn("THREE.WebGLProgram: Unsupported encoding:", t),
						["Linear", "( value )"]
					);
			}
		}
		function ep(t, e, n) {
			const i = t.getShaderParameter(e, 35713),
				r = t.getShaderInfoLog(e).trim();
			return i && "" === r
				? ""
				: "THREE.WebGLShader: gl.getShaderInfoLog() " +
						n +
						"\n" +
						r +
						(function (t) {
							const e = t.split("\n");
							for (let t = 0; t < e.length; t++) e[t] = t + 1 + ": " + e[t];
							return e.join("\n");
						})(t.getShaderSource(e));
		}
		function np(t, e) {
			const n = tp(e);
			return (
				"vec4 " +
				t +
				"( vec4 value ) { return " +
				n[0] +
				"ToLinear" +
				n[1] +
				"; }"
			);
		}
		function ip(t) {
			return "" !== t;
		}
		function rp(t, e) {
			return t
				.replace(/NUM_DIR_LIGHTS/g, e.numDirLights)
				.replace(/NUM_SPOT_LIGHTS/g, e.numSpotLights)
				.replace(/NUM_RECT_AREA_LIGHTS/g, e.numRectAreaLights)
				.replace(/NUM_POINT_LIGHTS/g, e.numPointLights)
				.replace(/NUM_HEMI_LIGHTS/g, e.numHemiLights)
				.replace(/NUM_DIR_LIGHT_SHADOWS/g, e.numDirLightShadows)
				.replace(/NUM_SPOT_LIGHT_SHADOWS/g, e.numSpotLightShadows)
				.replace(/NUM_POINT_LIGHT_SHADOWS/g, e.numPointLightShadows);
		}
		function op(t, e) {
			return t
				.replace(/NUM_CLIPPING_PLANES/g, e.numClippingPlanes)
				.replace(
					/UNION_CLIPPING_PLANES/g,
					e.numClippingPlanes - e.numClipIntersection
				);
		}
		const sp = /^[ \t]*#include +<([\w\d./]+)>/gm;
		function ap(t) {
			return t.replace(sp, cp);
		}
		function cp(t, e) {
			const n = Zu[e];
			if (void 0 === n) throw new Error("Can not resolve #include <" + e + ">");
			return ap(n);
		}
		const lp =
				/#pragma unroll_loop[\s]+?for \( int i \= (\d+)\; i < (\d+)\; i \+\+ \) \{([\s\S]+?)(?=\})\}/g,
			hp =
				/#pragma unroll_loop_start[\s]+?for \( int i \= (\d+)\; i < (\d+)\; i \+\+ \) \{([\s\S]+?)(?=\})\}[\s]+?#pragma unroll_loop_end/g;
		function up(t) {
			return t.replace(hp, pp).replace(lp, dp);
		}
		function dp(t, e, n, i) {
			return (
				console.warn(
					"WebGLProgram: #pragma unroll_loop shader syntax is deprecated. Please use #pragma unroll_loop_start syntax instead."
				),
				pp(t, e, n, i)
			);
		}
		function pp(t, e, n, i) {
			let r = "";
			for (let t = parseInt(e); t < parseInt(n); t++)
				r += i
					.replace(/\[ i \]/g, "[ " + t + " ]")
					.replace(/UNROLLED_LOOP_INDEX/g, t);
			return r;
		}
		function fp(t) {
			let e =
				"precision " +
				t.precision +
				" float;\nprecision " +
				t.precision +
				" int;";
			return (
				"highp" === t.precision
					? (e += "\n#define HIGH_PRECISION")
					: "mediump" === t.precision
					? (e += "\n#define MEDIUM_PRECISION")
					: "lowp" === t.precision && (e += "\n#define LOW_PRECISION"),
				e
			);
		}
		function mp(t, e, n, i) {
			const r = t.getContext(),
				o = n.defines;
			let s = n.vertexShader,
				a = n.fragmentShader;
			const c = (function (t) {
					let e = "SHADOWMAP_TYPE_BASIC";
					return (
						t.shadowMapType === hs
							? (e = "SHADOWMAP_TYPE_PCF")
							: t.shadowMapType === us
							? (e = "SHADOWMAP_TYPE_PCF_SOFT")
							: t.shadowMapType === ds && (e = "SHADOWMAP_TYPE_VSM"),
						e
					);
				})(n),
				l = (function (t) {
					let e = "ENVMAP_TYPE_CUBE";
					if (t.envMap)
						switch (t.envMapMode) {
							case ea:
							case na:
								e = "ENVMAP_TYPE_CUBE";
								break;
							case oa:
							case sa:
								e = "ENVMAP_TYPE_CUBE_UV";
								break;
							case ia:
							case ra:
								e = "ENVMAP_TYPE_EQUIREC";
						}
					return e;
				})(n),
				h = (function (t) {
					let e = "ENVMAP_MODE_REFLECTION";
					if (t.envMap)
						switch (t.envMapMode) {
							case na:
							case ra:
								e = "ENVMAP_MODE_REFRACTION";
						}
					return e;
				})(n),
				u = (function (t) {
					let e = "ENVMAP_BLENDING_NONE";
					if (t.envMap)
						switch (t.combine) {
							case qs:
								e = "ENVMAP_BLENDING_MULTIPLY";
								break;
							case Ys:
								e = "ENVMAP_BLENDING_MIX";
								break;
							case Xs:
								e = "ENVMAP_BLENDING_ADD";
						}
					return e;
				})(n),
				d = t.gammaFactor > 0 ? t.gammaFactor : 1,
				p = n.isWebGL2
					? ""
					: (function (t) {
							return [
								t.extensionDerivatives ||
								t.envMapCubeUV ||
								t.bumpMap ||
								t.tangentSpaceNormalMap ||
								t.clearcoatNormalMap ||
								t.flatShading ||
								"physical" === t.shaderID
									? "#extension GL_OES_standard_derivatives : enable"
									: "",
								(t.extensionFragDepth || t.logarithmicDepthBuffer) &&
								t.rendererExtensionFragDepth
									? "#extension GL_EXT_frag_depth : enable"
									: "",
								t.extensionDrawBuffers && t.rendererExtensionDrawBuffers
									? "#extension GL_EXT_draw_buffers : require"
									: "",
								(t.extensionShaderTextureLOD || t.envMap) &&
								t.rendererExtensionShaderTextureLod
									? "#extension GL_EXT_shader_texture_lod : enable"
									: "",
							]
								.filter(ip)
								.join("\n");
					  })(n),
				f = (function (t) {
					const e = [];
					for (const n in t) {
						const i = t[n];
						!1 !== i && e.push("#define " + n + " " + i);
					}
					return e.join("\n");
				})(o),
				m = r.createProgram();
			let g, v;
			if (
				(n.isRawShaderMaterial
					? ((g = [f].filter(ip).join("\n")).length > 0 && (g += "\n"),
					  (v = [p, f].filter(ip).join("\n")).length > 0 && (v += "\n"))
					: ((g = [
							fp(n),
							"#define SHADER_NAME " + n.shaderName,
							f,
							n.instancing ? "#define USE_INSTANCING" : "",
							n.supportsVertexTextures ? "#define VERTEX_TEXTURES" : "",
							"#define GAMMA_FACTOR " + d,
							"#define MAX_BONES " + n.maxBones,
							n.useFog && n.fog ? "#define USE_FOG" : "",
							n.useFog && n.fogExp2 ? "#define FOG_EXP2" : "",
							n.map ? "#define USE_MAP" : "",
							n.envMap ? "#define USE_ENVMAP" : "",
							n.envMap ? "#define " + h : "",
							n.lightMap ? "#define USE_LIGHTMAP" : "",
							n.aoMap ? "#define USE_AOMAP" : "",
							n.emissiveMap ? "#define USE_EMISSIVEMAP" : "",
							n.bumpMap ? "#define USE_BUMPMAP" : "",
							n.normalMap ? "#define USE_NORMALMAP" : "",
							n.normalMap && n.objectSpaceNormalMap
								? "#define OBJECTSPACE_NORMALMAP"
								: "",
							n.normalMap && n.tangentSpaceNormalMap
								? "#define TANGENTSPACE_NORMALMAP"
								: "",
							n.clearcoatMap ? "#define USE_CLEARCOATMAP" : "",
							n.clearcoatRoughnessMap
								? "#define USE_CLEARCOAT_ROUGHNESSMAP"
								: "",
							n.clearcoatNormalMap ? "#define USE_CLEARCOAT_NORMALMAP" : "",
							n.displacementMap && n.supportsVertexTextures
								? "#define USE_DISPLACEMENTMAP"
								: "",
							n.specularMap ? "#define USE_SPECULARMAP" : "",
							n.roughnessMap ? "#define USE_ROUGHNESSMAP" : "",
							n.metalnessMap ? "#define USE_METALNESSMAP" : "",
							n.alphaMap ? "#define USE_ALPHAMAP" : "",
							n.vertexTangents ? "#define USE_TANGENT" : "",
							n.vertexColors ? "#define USE_COLOR" : "",
							n.vertexUvs ? "#define USE_UV" : "",
							n.uvsVertexOnly ? "#define UVS_VERTEX_ONLY" : "",
							n.flatShading ? "#define FLAT_SHADED" : "",
							n.skinning ? "#define USE_SKINNING" : "",
							n.useVertexTexture ? "#define BONE_TEXTURE" : "",
							n.morphTargets ? "#define USE_MORPHTARGETS" : "",
							n.morphNormals && !1 === n.flatShading
								? "#define USE_MORPHNORMALS"
								: "",
							n.doubleSided ? "#define DOUBLE_SIDED" : "",
							n.flipSided ? "#define FLIP_SIDED" : "",
							n.shadowMapEnabled ? "#define USE_SHADOWMAP" : "",
							n.shadowMapEnabled ? "#define " + c : "",
							n.sizeAttenuation ? "#define USE_SIZEATTENUATION" : "",
							n.logarithmicDepthBuffer ? "#define USE_LOGDEPTHBUF" : "",
							n.logarithmicDepthBuffer && n.rendererExtensionFragDepth
								? "#define USE_LOGDEPTHBUF_EXT"
								: "",
							"uniform mat4 modelMatrix;",
							"uniform mat4 modelViewMatrix;",
							"uniform mat4 projectionMatrix;",
							"uniform mat4 viewMatrix;",
							"uniform mat3 normalMatrix;",
							"uniform vec3 cameraPosition;",
							"uniform bool isOrthographic;",
							"#ifdef USE_INSTANCING",
							" attribute mat4 instanceMatrix;",
							"#endif",
							"attribute vec3 position;",
							"attribute vec3 normal;",
							"attribute vec2 uv;",
							"#ifdef USE_TANGENT",
							"\tattribute vec4 tangent;",
							"#endif",
							"#ifdef USE_COLOR",
							"\tattribute vec3 color;",
							"#endif",
							"#ifdef USE_MORPHTARGETS",
							"\tattribute vec3 morphTarget0;",
							"\tattribute vec3 morphTarget1;",
							"\tattribute vec3 morphTarget2;",
							"\tattribute vec3 morphTarget3;",
							"\t#ifdef USE_MORPHNORMALS",
							"\t\tattribute vec3 morphNormal0;",
							"\t\tattribute vec3 morphNormal1;",
							"\t\tattribute vec3 morphNormal2;",
							"\t\tattribute vec3 morphNormal3;",
							"\t#else",
							"\t\tattribute vec3 morphTarget4;",
							"\t\tattribute vec3 morphTarget5;",
							"\t\tattribute vec3 morphTarget6;",
							"\t\tattribute vec3 morphTarget7;",
							"\t#endif",
							"#endif",
							"#ifdef USE_SKINNING",
							"\tattribute vec4 skinIndex;",
							"\tattribute vec4 skinWeight;",
							"#endif",
							"\n",
					  ]
							.filter(ip)
							.join("\n")),
					  (v = [
							p,
							fp(n),
							"#define SHADER_NAME " + n.shaderName,
							f,
							n.alphaTest
								? "#define ALPHATEST " +
								  n.alphaTest +
								  (n.alphaTest % 1 ? "" : ".0")
								: "",
							"#define GAMMA_FACTOR " + d,
							n.useFog && n.fog ? "#define USE_FOG" : "",
							n.useFog && n.fogExp2 ? "#define FOG_EXP2" : "",
							n.map ? "#define USE_MAP" : "",
							n.matcap ? "#define USE_MATCAP" : "",
							n.envMap ? "#define USE_ENVMAP" : "",
							n.envMap ? "#define " + l : "",
							n.envMap ? "#define " + h : "",
							n.envMap ? "#define " + u : "",
							n.lightMap ? "#define USE_LIGHTMAP" : "",
							n.aoMap ? "#define USE_AOMAP" : "",
							n.emissiveMap ? "#define USE_EMISSIVEMAP" : "",
							n.bumpMap ? "#define USE_BUMPMAP" : "",
							n.normalMap ? "#define USE_NORMALMAP" : "",
							n.normalMap && n.objectSpaceNormalMap
								? "#define OBJECTSPACE_NORMALMAP"
								: "",
							n.normalMap && n.tangentSpaceNormalMap
								? "#define TANGENTSPACE_NORMALMAP"
								: "",
							n.clearcoatMap ? "#define USE_CLEARCOATMAP" : "",
							n.clearcoatRoughnessMap
								? "#define USE_CLEARCOAT_ROUGHNESSMAP"
								: "",
							n.clearcoatNormalMap ? "#define USE_CLEARCOAT_NORMALMAP" : "",
							n.specularMap ? "#define USE_SPECULARMAP" : "",
							n.roughnessMap ? "#define USE_ROUGHNESSMAP" : "",
							n.metalnessMap ? "#define USE_METALNESSMAP" : "",
							n.alphaMap ? "#define USE_ALPHAMAP" : "",
							n.sheen ? "#define USE_SHEEN" : "",
							n.vertexTangents ? "#define USE_TANGENT" : "",
							n.vertexColors ? "#define USE_COLOR" : "",
							n.vertexUvs ? "#define USE_UV" : "",
							n.uvsVertexOnly ? "#define UVS_VERTEX_ONLY" : "",
							n.gradientMap ? "#define USE_GRADIENTMAP" : "",
							n.flatShading ? "#define FLAT_SHADED" : "",
							n.doubleSided ? "#define DOUBLE_SIDED" : "",
							n.flipSided ? "#define FLIP_SIDED" : "",
							n.shadowMapEnabled ? "#define USE_SHADOWMAP" : "",
							n.shadowMapEnabled ? "#define " + c : "",
							n.premultipliedAlpha ? "#define PREMULTIPLIED_ALPHA" : "",
							n.physicallyCorrectLights
								? "#define PHYSICALLY_CORRECT_LIGHTS"
								: "",
							n.logarithmicDepthBuffer ? "#define USE_LOGDEPTHBUF" : "",
							n.logarithmicDepthBuffer && n.rendererExtensionFragDepth
								? "#define USE_LOGDEPTHBUF_EXT"
								: "",
							(n.extensionShaderTextureLOD || n.envMap) &&
							n.rendererExtensionShaderTextureLod
								? "#define TEXTURE_LOD_EXT"
								: "",
							"uniform mat4 viewMatrix;",
							"uniform vec3 cameraPosition;",
							"uniform bool isOrthographic;",
							n.toneMapping !== Zs ? "#define TONE_MAPPING" : "",
							n.toneMapping !== Zs ? Zu.tonemapping_pars_fragment : "",
							n.toneMapping !== Zs
								? (function (t, e) {
										let n;
										switch (e) {
											case Js:
												n = "Linear";
												break;
											case Ks:
												n = "Reinhard";
												break;
											case Qs:
												n = "OptimizedCineon";
												break;
											case $s:
												n = "ACESFilmic";
												break;
											case ta:
												n = "Custom";
												break;
											default:
												console.warn(
													"THREE.WebGLProgram: Unsupported toneMapping:",
													e
												),
													(n = "Linear");
										}
										return (
											"vec3 " +
											t +
											"( vec3 color ) { return " +
											n +
											"ToneMapping( color ); }"
										);
								  })("toneMapping", n.toneMapping)
								: "",
							n.dithering ? "#define DITHERING" : "",
							Zu.encodings_pars_fragment,
							n.map ? np("mapTexelToLinear", n.mapEncoding) : "",
							n.matcap ? np("matcapTexelToLinear", n.matcapEncoding) : "",
							n.envMap ? np("envMapTexelToLinear", n.envMapEncoding) : "",
							n.emissiveMap
								? np("emissiveMapTexelToLinear", n.emissiveMapEncoding)
								: "",
							n.lightMap ? np("lightMapTexelToLinear", n.lightMapEncoding) : "",
							(function (t, e) {
								const n = tp(e);
								return (
									"vec4 " +
									t +
									"( vec4 value ) { return LinearTo" +
									n[0] +
									n[1] +
									"; }"
								);
							})("linearToOutputTexel", n.outputEncoding),
							n.depthPacking ? "#define DEPTH_PACKING " + n.depthPacking : "",
							"\n",
					  ]
							.filter(ip)
							.join("\n"))),
				(s = op((s = rp((s = ap(s)), n)), n)),
				(a = op((a = rp((a = ap(a)), n)), n)),
				(s = up(s)),
				(a = up(a)),
				n.isWebGL2 && !n.isRawShaderMaterial)
			) {
				let t = !1;
				const e = /^\s*#version\s+300\s+es\s*\n/;
				n.isShaderMaterial &&
					null !== s.match(e) &&
					null !== a.match(e) &&
					((t = !0), (s = s.replace(e, "")), (a = a.replace(e, ""))),
					(g =
						[
							"#version 300 es\n",
							"#define attribute in",
							"#define varying out",
							"#define texture2D texture",
						].join("\n") +
						"\n" +
						g),
					(v =
						[
							"#version 300 es\n",
							"#define varying in",
							t ? "" : "out highp vec4 pc_fragColor;",
							t ? "" : "#define gl_FragColor pc_fragColor",
							"#define gl_FragDepthEXT gl_FragDepth",
							"#define texture2D texture",
							"#define textureCube texture",
							"#define texture2DProj textureProj",
							"#define texture2DLodEXT textureLod",
							"#define texture2DProjLodEXT textureProjLod",
							"#define textureCubeLodEXT textureLod",
							"#define texture2DGradEXT textureGrad",
							"#define texture2DProjGradEXT textureProjGrad",
							"#define textureCubeGradEXT textureGrad",
						].join("\n") +
						"\n" +
						v);
			}
			const y = v + a,
				x = Qd(r, 35633, g + s),
				b = Qd(r, 35632, y);
			if (
				(r.attachShader(m, x),
				r.attachShader(m, b),
				void 0 !== n.index0AttributeName
					? r.bindAttribLocation(m, 0, n.index0AttributeName)
					: !0 === n.morphTargets && r.bindAttribLocation(m, 0, "position"),
				r.linkProgram(m),
				t.debug.checkShaderErrors)
			) {
				const t = r.getProgramInfoLog(m).trim(),
					e = r.getShaderInfoLog(x).trim(),
					n = r.getShaderInfoLog(b).trim();
				let i = !0,
					o = !0;
				if (!1 === r.getProgramParameter(m, 35714)) {
					i = !1;
					const e = ep(r, x, "vertex"),
						n = ep(r, b, "fragment");
					console.error(
						"THREE.WebGLProgram: shader error: ",
						r.getError(),
						"35715",
						r.getProgramParameter(m, 35715),
						"gl.getProgramInfoLog",
						t,
						e,
						n
					);
				} else
					"" !== t
						? console.warn("THREE.WebGLProgram: gl.getProgramInfoLog()", t)
						: ("" !== e && "" !== n) || (o = !1);
				o &&
					(this.diagnostics = {
						runnable: i,
						programLog: t,
						vertexShader: { log: e, prefix: g },
						fragmentShader: { log: n, prefix: v },
					});
			}
			let w, _;
			return (
				r.deleteShader(x),
				r.deleteShader(b),
				(this.getUniforms = function () {
					return void 0 === w && (w = new Kd(r, m)), w;
				}),
				(this.getAttributes = function () {
					return (
						void 0 === _ &&
							(_ = (function (t, e) {
								const n = {},
									i = t.getProgramParameter(e, 35721);
								for (let r = 0; r < i; r++) {
									const i = t.getActiveAttrib(e, r).name;
									n[i] = t.getAttribLocation(e, i);
								}
								return n;
							})(r, m)),
						_
					);
				}),
				(this.destroy = function () {
					i.releaseStatesOfProgram(this),
						r.deleteProgram(m),
						(this.program = void 0);
				}),
				(this.name = n.shaderName),
				(this.id = $d++),
				(this.cacheKey = e),
				(this.usedTimes = 1),
				(this.program = m),
				(this.vertexShader = x),
				(this.fragmentShader = b),
				this
			);
		}
		function gp(t, e, n, i) {
			const r = [],
				o = n.isWebGL2,
				s = n.logarithmicDepthBuffer,
				a = n.floatVertexTextures,
				c = n.maxVertexUniforms,
				l = n.vertexTextures;
			let h = n.precision;
			const u = {
					MeshDepthMaterial: "depth",
					MeshDistanceMaterial: "distanceRGBA",
					MeshNormalMaterial: "normal",
					MeshBasicMaterial: "basic",
					MeshLambertMaterial: "lambert",
					MeshPhongMaterial: "phong",
					MeshToonMaterial: "toon",
					MeshStandardMaterial: "physical",
					MeshPhysicalMaterial: "physical",
					MeshMatcapMaterial: "matcap",
					LineBasicMaterial: "basic",
					LineDashedMaterial: "dashed",
					PointsMaterial: "points",
					ShadowMaterial: "shadow",
					SpriteMaterial: "sprite",
				},
				d = [
					"precision",
					"isWebGL2",
					"supportsVertexTextures",
					"outputEncoding",
					"instancing",
					"map",
					"mapEncoding",
					"matcap",
					"matcapEncoding",
					"envMap",
					"envMapMode",
					"envMapEncoding",
					"envMapCubeUV",
					"lightMap",
					"lightMapEncoding",
					"aoMap",
					"emissiveMap",
					"emissiveMapEncoding",
					"bumpMap",
					"normalMap",
					"objectSpaceNormalMap",
					"tangentSpaceNormalMap",
					"clearcoatMap",
					"clearcoatRoughnessMap",
					"clearcoatNormalMap",
					"displacementMap",
					"specularMap",
					"roughnessMap",
					"metalnessMap",
					"gradientMap",
					"alphaMap",
					"combine",
					"vertexColors",
					"vertexTangents",
					"vertexUvs",
					"uvsVertexOnly",
					"fog",
					"useFog",
					"fogExp2",
					"flatShading",
					"sizeAttenuation",
					"logarithmicDepthBuffer",
					"skinning",
					"maxBones",
					"useVertexTexture",
					"morphTargets",
					"morphNormals",
					"maxMorphTargets",
					"maxMorphNormals",
					"premultipliedAlpha",
					"numDirLights",
					"numPointLights",
					"numSpotLights",
					"numHemiLights",
					"numRectAreaLights",
					"numDirLightShadows",
					"numPointLightShadows",
					"numSpotLightShadows",
					"shadowMapEnabled",
					"shadowMapType",
					"toneMapping",
					"physicallyCorrectLights",
					"alphaTest",
					"doubleSided",
					"flipSided",
					"numClippingPlanes",
					"numClipIntersection",
					"depthPacking",
					"dithering",
					"sheen",
				];
			function p(t) {
				let e;
				return (
					t
						? t.isTexture
							? (e = t.encoding)
							: t.isWebGLRenderTarget &&
							  (console.warn(
									"THREE.WebGLPrograms.getTextureEncodingFromMap: don't use render targets as textures. Use their .texture property instead."
							  ),
							  (e = t.texture.encoding))
						: (e = Oc),
					e
				);
			}
			return {
				getParameters: function (i, r, d, f, m, g, v) {
					const y = f.fog,
						x = i.isMeshStandardMaterial ? f.environment : null,
						b = i.envMap || x,
						w = u[i.type],
						_ = v.isSkinnedMesh
							? (function (t) {
									const e = t.skeleton.bones;
									if (a) return 1024;
									{
										const t = c,
											n = Math.floor((t - 20) / 4),
											i = Math.min(n, e.length);
										return i < e.length
											? (console.warn(
													"THREE.WebGLRenderer: Skeleton has " +
														e.length +
														" bones. This GPU supports " +
														i +
														"."
											  ),
											  0)
											: i;
									}
							  })(v)
							: 0;
					null !== i.precision &&
						(h = n.getMaxPrecision(i.precision)) !== i.precision &&
						console.warn(
							"THREE.WebGLProgram.getParameters:",
							i.precision,
							"not supported, using",
							h,
							"instead."
						);
					const M = (function (t, e) {
						let n;
						if (e) {
							const i = Ju[e];
							n = {
								name: t.name || t.type,
								uniforms: Ru.clone(i.uniforms),
								vertexShader: i.vertexShader,
								fragmentShader: i.fragmentShader,
							};
						} else
							n = {
								name: t.name || t.type,
								uniforms: t.uniforms,
								vertexShader: t.vertexShader,
								fragmentShader: t.fragmentShader,
							};
						return n;
					})(i, w);
					i.onBeforeCompile(M, t);
					const S = t.getRenderTarget();
					return {
						isWebGL2: o,
						shaderID: w,
						shaderName: M.name,
						uniforms: M.uniforms,
						vertexShader: M.vertexShader,
						fragmentShader: M.fragmentShader,
						defines: i.defines,
						isRawShaderMaterial: i.isRawShaderMaterial,
						isShaderMaterial: i.isShaderMaterial,
						precision: h,
						instancing: !0 === v.isInstancedMesh,
						supportsVertexTextures: l,
						outputEncoding: null !== S ? p(S.texture) : t.outputEncoding,
						map: !!i.map,
						mapEncoding: p(i.map),
						matcap: !!i.matcap,
						matcapEncoding: p(i.matcap),
						envMap: !!b,
						envMapMode: b && b.mapping,
						envMapEncoding: p(b),
						envMapCubeUV: !!b && (b.mapping === oa || b.mapping === sa),
						lightMap: !!i.lightMap,
						lightMapEncoding: p(i.lightMap),
						aoMap: !!i.aoMap,
						emissiveMap: !!i.emissiveMap,
						emissiveMapEncoding: p(i.emissiveMap),
						bumpMap: !!i.bumpMap,
						normalMap: !!i.normalMap,
						objectSpaceNormalMap: i.normalMapType === Vc,
						tangentSpaceNormalMap: i.normalMapType === Gc,
						clearcoatMap: !!i.clearcoatMap,
						clearcoatRoughnessMap: !!i.clearcoatRoughnessMap,
						clearcoatNormalMap: !!i.clearcoatNormalMap,
						displacementMap: !!i.displacementMap,
						roughnessMap: !!i.roughnessMap,
						metalnessMap: !!i.metalnessMap,
						specularMap: !!i.specularMap,
						alphaMap: !!i.alphaMap,
						gradientMap: !!i.gradientMap,
						sheen: !!i.sheen,
						combine: i.combine,
						vertexTangents: i.normalMap && i.vertexTangents,
						vertexColors: i.vertexColors,
						vertexUvs: !!(
							i.map ||
							i.bumpMap ||
							i.normalMap ||
							i.specularMap ||
							i.alphaMap ||
							i.emissiveMap ||
							i.roughnessMap ||
							i.metalnessMap ||
							i.clearcoatMap ||
							i.clearcoatRoughnessMap ||
							i.clearcoatNormalMap ||
							i.displacementMap
						),
						uvsVertexOnly: !(
							i.map ||
							i.bumpMap ||
							i.normalMap ||
							i.specularMap ||
							i.alphaMap ||
							i.emissiveMap ||
							i.roughnessMap ||
							i.metalnessMap ||
							i.clearcoatNormalMap ||
							!i.displacementMap
						),
						fog: !!y,
						useFog: i.fog,
						fogExp2: y && y.isFogExp2,
						flatShading: i.flatShading,
						sizeAttenuation: i.sizeAttenuation,
						logarithmicDepthBuffer: s,
						skinning: i.skinning && _ > 0,
						maxBones: _,
						useVertexTexture: a,
						morphTargets: i.morphTargets,
						morphNormals: i.morphNormals,
						maxMorphTargets: t.maxMorphTargets,
						maxMorphNormals: t.maxMorphNormals,
						numDirLights: r.directional.length,
						numPointLights: r.point.length,
						numSpotLights: r.spot.length,
						numRectAreaLights: r.rectArea.length,
						numHemiLights: r.hemi.length,
						numDirLightShadows: r.directionalShadowMap.length,
						numPointLightShadows: r.pointShadowMap.length,
						numSpotLightShadows: r.spotShadowMap.length,
						numClippingPlanes: m,
						numClipIntersection: g,
						dithering: i.dithering,
						shadowMapEnabled: t.shadowMap.enabled && d.length > 0,
						shadowMapType: t.shadowMap.type,
						toneMapping: i.toneMapped ? t.toneMapping : Zs,
						physicallyCorrectLights: t.physicallyCorrectLights,
						premultipliedAlpha: i.premultipliedAlpha,
						alphaTest: i.alphaTest,
						doubleSided: i.side === ms,
						flipSided: i.side === fs,
						depthPacking: void 0 !== i.depthPacking && i.depthPacking,
						index0AttributeName: i.index0AttributeName,
						extensionDerivatives: i.extensions && i.extensions.derivatives,
						extensionFragDepth: i.extensions && i.extensions.fragDepth,
						extensionDrawBuffers: i.extensions && i.extensions.drawBuffers,
						extensionShaderTextureLOD:
							i.extensions && i.extensions.shaderTextureLOD,
						rendererExtensionFragDepth: o || null !== e.get("EXT_frag_depth"),
						rendererExtensionDrawBuffers:
							o || null !== e.get("WEBGL_draw_buffers"),
						rendererExtensionShaderTextureLod:
							o || null !== e.get("EXT_shader_texture_lod"),
						customProgramCacheKey: i.customProgramCacheKey(),
					};
				},
				getProgramCacheKey: function (e) {
					const n = [];
					if (
						(e.shaderID
							? n.push(e.shaderID)
							: (n.push(e.fragmentShader), n.push(e.vertexShader)),
						void 0 !== e.defines)
					)
						for (const t in e.defines) n.push(t), n.push(e.defines[t]);
					if (void 0 === e.isRawShaderMaterial) {
						for (let t = 0; t < d.length; t++) n.push(e[d[t]]);
						n.push(t.outputEncoding), n.push(t.gammaFactor);
					}
					return n.push(e.customProgramCacheKey), n.join();
				},
				acquireProgram: function (e, n) {
					let o;
					for (let t = 0, e = r.length; t < e; t++) {
						const e = r[t];
						if (e.cacheKey === n) {
							++(o = e).usedTimes;
							break;
						}
					}
					return void 0 === o && ((o = new mp(t, n, e, i)), r.push(o)), o;
				},
				releaseProgram: function (t) {
					if (0 == --t.usedTimes) {
						const e = r.indexOf(t);
						(r[e] = r[r.length - 1]), r.pop(), t.destroy();
					}
				},
				programs: r,
			};
		}
		function vp(t, e) {
			return t.groupOrder !== e.groupOrder
				? t.groupOrder - e.groupOrder
				: t.renderOrder !== e.renderOrder
				? t.renderOrder - e.renderOrder
				: t.program !== e.program
				? t.program.id - e.program.id
				: t.material.id !== e.material.id
				? t.material.id - e.material.id
				: t.z !== e.z
				? t.z - e.z
				: t.id - e.id;
		}
		function yp(t, e) {
			return t.groupOrder !== e.groupOrder
				? t.groupOrder - e.groupOrder
				: t.renderOrder !== e.renderOrder
				? t.renderOrder - e.renderOrder
				: t.z !== e.z
				? e.z - t.z
				: t.id - e.id;
		}
		function xp() {
			const t = [];
			let e = 0;
			const n = [],
				i = [],
				r = { id: -1 };
			function o(n, i, o, s, a, c) {
				let l = t[e];
				return (
					void 0 === l
						? ((l = {
								id: n.id,
								object: n,
								geometry: i,
								material: o,
								program: o.program || r,
								groupOrder: s,
								renderOrder: n.renderOrder,
								z: a,
								group: c,
						  }),
						  (t[e] = l))
						: ((l.id = n.id),
						  (l.object = n),
						  (l.geometry = i),
						  (l.material = o),
						  (l.program = o.program || r),
						  (l.groupOrder = s),
						  (l.renderOrder = n.renderOrder),
						  (l.z = a),
						  (l.group = c)),
					e++,
					l
				);
			}
			return {
				opaque: n,
				transparent: i,
				init: function () {
					(e = 0), (n.length = 0), (i.length = 0);
				},
				push: function (t, e, r, s, a, c) {
					const l = o(t, e, r, s, a, c);
					(!0 === r.transparent ? i : n).push(l);
				},
				unshift: function (t, e, r, s, a, c) {
					const l = o(t, e, r, s, a, c);
					(!0 === r.transparent ? i : n).unshift(l);
				},
				finish: function () {
					for (let n = e, i = t.length; n < i; n++) {
						const e = t[n];
						if (null === e.id) break;
						(e.id = null),
							(e.object = null),
							(e.geometry = null),
							(e.material = null),
							(e.program = null),
							(e.group = null);
					}
				},
				sort: function (t, e) {
					n.length > 1 && n.sort(t || vp), i.length > 1 && i.sort(e || yp);
				},
			};
		}
		let bp = 0;
		function wp(t, e) {
			return (e.castShadow ? 1 : 0) - (t.castShadow ? 1 : 0);
		}
		function _p() {
			const t = new (function () {
					const t = {};
					return {
						get: function (e) {
							if (void 0 !== t[e.id]) return t[e.id];
							let n;
							switch (e.type) {
								case "DirectionalLight":
									n = { direction: new ll(), color: new Eh() };
									break;
								case "SpotLight":
									n = {
										position: new ll(),
										direction: new ll(),
										color: new Eh(),
										distance: 0,
										coneCos: 0,
										penumbraCos: 0,
										decay: 0,
									};
									break;
								case "PointLight":
									n = {
										position: new ll(),
										color: new Eh(),
										distance: 0,
										decay: 0,
									};
									break;
								case "HemisphereLight":
									n = {
										direction: new ll(),
										skyColor: new Eh(),
										groundColor: new Eh(),
									};
									break;
								case "RectAreaLight":
									n = {
										color: new Eh(),
										position: new ll(),
										halfWidth: new ll(),
										halfHeight: new ll(),
									};
							}
							return (t[e.id] = n), n;
						},
					};
				})(),
				e = (function () {
					const t = {};
					return {
						get: function (e) {
							if (void 0 !== t[e.id]) return t[e.id];
							let n;
							switch (e.type) {
								case "DirectionalLight":
								case "SpotLight":
									n = {
										shadowBias: 0,
										shadowNormalBias: 0,
										shadowRadius: 1,
										shadowMapSize: new Kc(),
									};
									break;
								case "PointLight":
									n = {
										shadowBias: 0,
										shadowNormalBias: 0,
										shadowRadius: 1,
										shadowMapSize: new Kc(),
										shadowCameraNear: 1,
										shadowCameraFar: 1e3,
									};
							}
							return (t[e.id] = n), n;
						},
					};
				})(),
				n = {
					version: 0,
					hash: {
						directionalLength: -1,
						pointLength: -1,
						spotLength: -1,
						rectAreaLength: -1,
						hemiLength: -1,
						numDirectionalShadows: -1,
						numPointShadows: -1,
						numSpotShadows: -1,
					},
					ambient: [0, 0, 0],
					probe: [],
					directional: [],
					directionalShadow: [],
					directionalShadowMap: [],
					directionalShadowMatrix: [],
					spot: [],
					spotShadow: [],
					spotShadowMap: [],
					spotShadowMatrix: [],
					rectArea: [],
					point: [],
					pointShadow: [],
					pointShadowMap: [],
					pointShadowMatrix: [],
					hemi: [],
				};
			for (let t = 0; t < 9; t++) n.probe.push(new ll());
			const i = new ll(),
				r = new vl(),
				o = new vl();
			return {
				setup: function (s, a, c) {
					let l = 0,
						h = 0,
						u = 0;
					for (let t = 0; t < 9; t++) n.probe[t].set(0, 0, 0);
					let d = 0,
						p = 0,
						f = 0,
						m = 0,
						g = 0,
						v = 0,
						y = 0,
						x = 0;
					const b = c.matrixWorldInverse;
					s.sort(wp);
					for (let a = 0, c = s.length; a < c; a++) {
						const c = s[a],
							w = c.color,
							_ = c.intensity,
							M = c.distance,
							S = c.shadow && c.shadow.map ? c.shadow.map.texture : null;
						if (c.isAmbientLight)
							(l += w.r * _), (h += w.g * _), (u += w.b * _);
						else if (c.isLightProbe)
							for (let t = 0; t < 9; t++)
								n.probe[t].addScaledVector(c.sh.coefficients[t], _);
						else if (c.isDirectionalLight) {
							const r = t.get(c);
							if (
								(r.color.copy(c.color).multiplyScalar(c.intensity),
								r.direction.setFromMatrixPosition(c.matrixWorld),
								i.setFromMatrixPosition(c.target.matrixWorld),
								r.direction.sub(i),
								r.direction.transformDirection(b),
								c.castShadow)
							) {
								const t = c.shadow,
									i = e.get(c);
								(i.shadowBias = t.bias),
									(i.shadowNormalBias = t.normalBias),
									(i.shadowRadius = t.radius),
									(i.shadowMapSize = t.mapSize),
									(n.directionalShadow[d] = i),
									(n.directionalShadowMap[d] = S),
									(n.directionalShadowMatrix[d] = c.shadow.matrix),
									v++;
							}
							(n.directional[d] = r), d++;
						} else if (c.isSpotLight) {
							const r = t.get(c);
							if (
								(r.position.setFromMatrixPosition(c.matrixWorld),
								r.position.applyMatrix4(b),
								r.color.copy(w).multiplyScalar(_),
								(r.distance = M),
								r.direction.setFromMatrixPosition(c.matrixWorld),
								i.setFromMatrixPosition(c.target.matrixWorld),
								r.direction.sub(i),
								r.direction.transformDirection(b),
								(r.coneCos = Math.cos(c.angle)),
								(r.penumbraCos = Math.cos(c.angle * (1 - c.penumbra))),
								(r.decay = c.decay),
								c.castShadow)
							) {
								const t = c.shadow,
									i = e.get(c);
								(i.shadowBias = t.bias),
									(i.shadowNormalBias = t.normalBias),
									(i.shadowRadius = t.radius),
									(i.shadowMapSize = t.mapSize),
									(n.spotShadow[f] = i),
									(n.spotShadowMap[f] = S),
									(n.spotShadowMatrix[f] = c.shadow.matrix),
									x++;
							}
							(n.spot[f] = r), f++;
						} else if (c.isRectAreaLight) {
							const e = t.get(c);
							e.color.copy(w).multiplyScalar(_),
								e.position.setFromMatrixPosition(c.matrixWorld),
								e.position.applyMatrix4(b),
								o.identity(),
								r.copy(c.matrixWorld),
								r.premultiply(b),
								o.extractRotation(r),
								e.halfWidth.set(0.5 * c.width, 0, 0),
								e.halfHeight.set(0, 0.5 * c.height, 0),
								e.halfWidth.applyMatrix4(o),
								e.halfHeight.applyMatrix4(o),
								(n.rectArea[m] = e),
								m++;
						} else if (c.isPointLight) {
							const i = t.get(c);
							if (
								(i.position.setFromMatrixPosition(c.matrixWorld),
								i.position.applyMatrix4(b),
								i.color.copy(c.color).multiplyScalar(c.intensity),
								(i.distance = c.distance),
								(i.decay = c.decay),
								c.castShadow)
							) {
								const t = c.shadow,
									i = e.get(c);
								(i.shadowBias = t.bias),
									(i.shadowNormalBias = t.normalBias),
									(i.shadowRadius = t.radius),
									(i.shadowMapSize = t.mapSize),
									(i.shadowCameraNear = t.camera.near),
									(i.shadowCameraFar = t.camera.far),
									(n.pointShadow[p] = i),
									(n.pointShadowMap[p] = S),
									(n.pointShadowMatrix[p] = c.shadow.matrix),
									y++;
							}
							(n.point[p] = i), p++;
						} else if (c.isHemisphereLight) {
							const e = t.get(c);
							e.direction.setFromMatrixPosition(c.matrixWorld),
								e.direction.transformDirection(b),
								e.direction.normalize(),
								e.skyColor.copy(c.color).multiplyScalar(_),
								e.groundColor.copy(c.groundColor).multiplyScalar(_),
								(n.hemi[g] = e),
								g++;
						}
					}
					(n.ambient[0] = l), (n.ambient[1] = h), (n.ambient[2] = u);
					const w = n.hash;
					(w.directionalLength === d &&
						w.pointLength === p &&
						w.spotLength === f &&
						w.rectAreaLength === m &&
						w.hemiLength === g &&
						w.numDirectionalShadows === v &&
						w.numPointShadows === y &&
						w.numSpotShadows === x) ||
						((n.directional.length = d),
						(n.spot.length = f),
						(n.rectArea.length = m),
						(n.point.length = p),
						(n.hemi.length = g),
						(n.directionalShadow.length = v),
						(n.directionalShadowMap.length = v),
						(n.pointShadow.length = y),
						(n.pointShadowMap.length = y),
						(n.spotShadow.length = x),
						(n.spotShadowMap.length = x),
						(n.directionalShadowMatrix.length = v),
						(n.pointShadowMatrix.length = y),
						(n.spotShadowMatrix.length = x),
						(w.directionalLength = d),
						(w.pointLength = p),
						(w.spotLength = f),
						(w.rectAreaLength = m),
						(w.hemiLength = g),
						(w.numDirectionalShadows = v),
						(w.numPointShadows = y),
						(w.numSpotShadows = x),
						(n.version = bp++));
				},
				state: n,
			};
		}
		function Mp() {
			const t = new _p(),
				e = [],
				n = [];
			return {
				init: function () {
					(e.length = 0), (n.length = 0);
				},
				state: { lightsArray: e, shadowsArray: n, lights: t },
				setupLights: function (i) {
					t.setup(e, n, i);
				},
				pushLight: function (t) {
					e.push(t);
				},
				pushShadow: function (t) {
					n.push(t);
				},
			};
		}
		function Sp(t) {
			Oh.call(this),
				(this.type = "MeshDepthMaterial"),
				(this.depthPacking = Hc),
				(this.skinning = !1),
				(this.morphTargets = !1),
				(this.map = null),
				(this.alphaMap = null),
				(this.displacementMap = null),
				(this.displacementScale = 1),
				(this.displacementBias = 0),
				(this.wireframe = !1),
				(this.wireframeLinewidth = 1),
				(this.fog = !1),
				this.setValues(t);
		}
		function Tp(t) {
			Oh.call(this),
				(this.type = "MeshDistanceMaterial"),
				(this.referencePosition = new ll()),
				(this.nearDistance = 1),
				(this.farDistance = 1e3),
				(this.skinning = !1),
				(this.morphTargets = !1),
				(this.map = null),
				(this.alphaMap = null),
				(this.displacementMap = null),
				(this.displacementScale = 1),
				(this.displacementBias = 0),
				(this.fog = !1),
				this.setValues(t);
		}
		(Sp.prototype = Object.create(Oh.prototype)),
			(Sp.prototype.constructor = Sp),
			(Sp.prototype.isMeshDepthMaterial = !0),
			(Sp.prototype.copy = function (t) {
				return (
					Oh.prototype.copy.call(this, t),
					(this.depthPacking = t.depthPacking),
					(this.skinning = t.skinning),
					(this.morphTargets = t.morphTargets),
					(this.map = t.map),
					(this.alphaMap = t.alphaMap),
					(this.displacementMap = t.displacementMap),
					(this.displacementScale = t.displacementScale),
					(this.displacementBias = t.displacementBias),
					(this.wireframe = t.wireframe),
					(this.wireframeLinewidth = t.wireframeLinewidth),
					this
				);
			}),
			(Tp.prototype = Object.create(Oh.prototype)),
			(Tp.prototype.constructor = Tp),
			(Tp.prototype.isMeshDistanceMaterial = !0),
			(Tp.prototype.copy = function (t) {
				return (
					Oh.prototype.copy.call(this, t),
					this.referencePosition.copy(t.referencePosition),
					(this.nearDistance = t.nearDistance),
					(this.farDistance = t.farDistance),
					(this.skinning = t.skinning),
					(this.morphTargets = t.morphTargets),
					(this.map = t.map),
					(this.alphaMap = t.alphaMap),
					(this.displacementMap = t.displacementMap),
					(this.displacementScale = t.displacementScale),
					(this.displacementBias = t.displacementBias),
					this
				);
			});
		var Ep =
				"uniform sampler2D shadow_pass;\nuniform vec2 resolution;\nuniform float radius;\n#include <packing>\nvoid main() {\n  float mean = 0.0;\n  float squared_mean = 0.0;\n\tfloat depth = unpackRGBAToDepth( texture2D( shadow_pass, ( gl_FragCoord.xy  ) / resolution ) );\n  for ( float i = -1.0; i < 1.0 ; i += SAMPLE_RATE) {\n    #ifdef HORIZONAL_PASS\n      vec2 distribution = unpackRGBATo2Half( texture2D( shadow_pass, ( gl_FragCoord.xy + vec2( i, 0.0 ) * radius ) / resolution ) );\n      mean += distribution.x;\n      squared_mean += distribution.y * distribution.y + distribution.x * distribution.x;\n    #else\n      float depth = unpackRGBAToDepth( texture2D( shadow_pass, ( gl_FragCoord.xy + vec2( 0.0,  i )  * radius ) / resolution ) );\n      mean += depth;\n      squared_mean += depth * depth;\n    #endif\n  }\n  mean = mean * HALF_SAMPLE_RATE;\n  squared_mean = squared_mean * HALF_SAMPLE_RATE;\n  float std_dev = sqrt( squared_mean - mean * mean );\n  gl_FragColor = pack2HalfToRGBA( vec2( mean, std_dev ) );\n}",
			Ap = "void main() {\n\tgl_Position = vec4( position, 1.0 );\n}";
		function Lp(t, e, n) {
			let i = new Vu();
			const r = new Kc(),
				o = new Kc(),
				s = new il(),
				a = [],
				c = [],
				l = {},
				h = { 0: fs, 1: ps, 2: ms },
				u = new Du({
					defines: { SAMPLE_RATE: 0.25, HALF_SAMPLE_RATE: 1 / 8 },
					uniforms: {
						shadow_pass: { value: null },
						resolution: { value: new Kc() },
						radius: { value: 4 },
					},
					vertexShader: Ap,
					fragmentShader: Ep,
				}),
				d = u.clone();
			d.defines.HORIZONAL_PASS = 1;
			const p = new eu();
			p.setAttribute(
				"position",
				new Nh(new Float32Array([-1, -1, 0.5, 3, -1, 0.5, -1, 3, 0.5]), 3)
			);
			const f = new xu(p, u),
				m = this;
			function g(n, i) {
				const r = e.update(f);
				(u.uniforms.shadow_pass.value = n.map.texture),
					(u.uniforms.resolution.value = n.mapSize),
					(u.uniforms.radius.value = n.radius),
					t.setRenderTarget(n.mapPass),
					t.clear(),
					t.renderBufferDirect(i, null, r, u, f, null),
					(d.uniforms.shadow_pass.value = n.mapPass.texture),
					(d.uniforms.resolution.value = n.mapSize),
					(d.uniforms.radius.value = n.radius),
					t.setRenderTarget(n.map),
					t.clear(),
					t.renderBufferDirect(i, null, r, d, f, null);
			}
			function v(t, e, n) {
				const i = (t << 0) | (e << 1) | (n << 2);
				let r = a[i];
				return (
					void 0 === r &&
						((r = new Sp({ depthPacking: Uc, morphTargets: t, skinning: e })),
						(a[i] = r)),
					r
				);
			}
			function y(t, e, n) {
				const i = (t << 0) | (e << 1) | (n << 2);
				let r = c[i];
				return (
					void 0 === r &&
						((r = new Tp({ morphTargets: t, skinning: e })), (c[i] = r)),
					r
				);
			}
			function x(e, n, i, r, o, s, a) {
				let c = null,
					u = v,
					d = e.customDepthMaterial;
				if (
					(!0 === r.isPointLight && ((u = y), (d = e.customDistanceMaterial)),
					void 0 === d)
				) {
					let t = !1;
					!0 === i.morphTargets &&
						(t =
							n.morphAttributes &&
							n.morphAttributes.position &&
							n.morphAttributes.position.length > 0);
					let r = !1;
					!0 === e.isSkinnedMesh &&
						(!0 === i.skinning
							? (r = !0)
							: console.warn(
									"THREE.WebGLShadowMap: THREE.SkinnedMesh with material.skinning set to false:",
									e
							  )),
						(c = u(t, r, !0 === e.isInstancedMesh));
				} else c = d;
				if (
					t.localClippingEnabled &&
					!0 === i.clipShadows &&
					0 !== i.clippingPlanes.length
				) {
					const t = c.uuid,
						e = i.uuid;
					let n = l[t];
					void 0 === n && ((n = {}), (l[t] = n));
					let r = n[e];
					void 0 === r && ((r = c.clone()), (n[e] = r)), (c = r);
				}
				return (
					(c.visible = i.visible),
					(c.wireframe = i.wireframe),
					(c.side =
						a === ds
							? null !== i.shadowSide
								? i.shadowSide
								: i.side
							: null !== i.shadowSide
							? i.shadowSide
							: h[i.side]),
					(c.clipShadows = i.clipShadows),
					(c.clippingPlanes = i.clippingPlanes),
					(c.clipIntersection = i.clipIntersection),
					(c.wireframeLinewidth = i.wireframeLinewidth),
					(c.linewidth = i.linewidth),
					!0 === r.isPointLight &&
						!0 === c.isMeshDistanceMaterial &&
						(c.referencePosition.setFromMatrixPosition(r.matrixWorld),
						(c.nearDistance = o),
						(c.farDistance = s)),
					c
				);
			}
			function b(n, r, o, s, a) {
				if (!1 === n.visible) return;
				if (
					n.layers.test(r.layers) &&
					(n.isMesh || n.isLine || n.isPoints) &&
					(n.castShadow || (n.receiveShadow && a === ds)) &&
					(!n.frustumCulled || i.intersectsObject(n))
				) {
					n.modelViewMatrix.multiplyMatrices(
						o.matrixWorldInverse,
						n.matrixWorld
					);
					const i = e.update(n),
						r = n.material;
					if (Array.isArray(r)) {
						const e = i.groups;
						for (let c = 0, l = e.length; c < l; c++) {
							const l = e[c],
								h = r[l.materialIndex];
							if (h && h.visible) {
								const e = x(n, i, h, s, o.near, o.far, a);
								t.renderBufferDirect(o, null, i, e, n, l);
							}
						}
					} else if (r.visible) {
						const e = x(n, i, r, s, o.near, o.far, a);
						t.renderBufferDirect(o, null, i, e, n, null);
					}
				}
				const c = n.children;
				for (let t = 0, e = c.length; t < e; t++) b(c[t], r, o, s, a);
			}
			(this.enabled = !1),
				(this.autoUpdate = !0),
				(this.needsUpdate = !1),
				(this.type = hs),
				(this.render = function (e, a, c) {
					if (!1 === m.enabled) return;
					if (!1 === m.autoUpdate && !1 === m.needsUpdate) return;
					if (0 === e.length) return;
					const l = t.getRenderTarget(),
						h = t.getActiveCubeFace(),
						u = t.getActiveMipmapLevel(),
						d = t.state;
					d.setBlending(gs),
						d.buffers.color.setClear(1, 1, 1, 1),
						d.buffers.depth.setTest(!0),
						d.setScissorTest(!1);
					for (let l = 0, h = e.length; l < h; l++) {
						const h = e[l],
							u = h.shadow;
						if (!1 === u.autoUpdate && !1 === u.needsUpdate) continue;
						if (void 0 === u) {
							console.warn("THREE.WebGLShadowMap:", h, "has no shadow.");
							continue;
						}
						r.copy(u.mapSize);
						const p = u.getFrameExtents();
						if (
							(r.multiply(p),
							o.copy(u.mapSize),
							(r.x > n || r.y > n) &&
								(r.x > n &&
									((o.x = Math.floor(n / p.x)),
									(r.x = o.x * p.x),
									(u.mapSize.x = o.x)),
								r.y > n &&
									((o.y = Math.floor(n / p.y)),
									(r.y = o.y * p.y),
									(u.mapSize.y = o.y))),
							null === u.map && !u.isPointLightShadow && this.type === ds)
						) {
							const t = { minFilter: pa, magFilter: pa, format: Ra };
							(u.map = new rl(r.x, r.y, t)),
								(u.map.texture.name = h.name + ".shadowMap"),
								(u.mapPass = new rl(r.x, r.y, t)),
								u.camera.updateProjectionMatrix();
						}
						if (null === u.map) {
							const t = { minFilter: ha, magFilter: ha, format: Ra };
							(u.map = new rl(r.x, r.y, t)),
								(u.map.texture.name = h.name + ".shadowMap"),
								u.camera.updateProjectionMatrix();
						}
						t.setRenderTarget(u.map), t.clear();
						const f = u.getViewportCount();
						for (let t = 0; t < f; t++) {
							const e = u.getViewport(t);
							s.set(o.x * e.x, o.y * e.y, o.x * e.z, o.y * e.w),
								d.viewport(s),
								u.updateMatrices(h, t),
								(i = u.getFrustum()),
								b(a, c, u.camera, h, this.type);
						}
						u.isPointLightShadow || this.type !== ds || g(u, c),
							(u.needsUpdate = !1);
					}
					(m.needsUpdate = !1), t.setRenderTarget(l, h, u);
				});
		}
		function Pp(t, e, n, i, r, o, s) {
			const a = r.isWebGL2,
				c = r.maxTextures,
				l = r.maxCubemapSize,
				h = r.maxTextureSize,
				u = r.maxSamples,
				d = new WeakMap();
			let p,
				f = !1;
			try {
				f =
					"undefined" != typeof OffscreenCanvas &&
					null !== new OffscreenCanvas(1, 1).getContext("2d");
			} catch (t) {}
			function m(t, e) {
				return f
					? new OffscreenCanvas(t, e)
					: document.createElementNS("http://www.w3.org/1999/xhtml", "canvas");
			}
			function g(t, e, n, i) {
				let r = 1;
				if (
					((t.width > i || t.height > i) &&
						(r = i / Math.max(t.width, t.height)),
					r < 1 || !0 === e)
				) {
					if (
						("undefined" != typeof HTMLImageElement &&
							t instanceof HTMLImageElement) ||
						("undefined" != typeof HTMLCanvasElement &&
							t instanceof HTMLCanvasElement) ||
						("undefined" != typeof ImageBitmap && t instanceof ImageBitmap)
					) {
						const i = e ? Jc.floorPowerOfTwo : Math.floor,
							o = i(r * t.width),
							s = i(r * t.height);
						void 0 === p && (p = m(o, s));
						const a = n ? m(o, s) : p;
						return (
							(a.width = o),
							(a.height = s),
							a.getContext("2d").drawImage(t, 0, 0, o, s),
							console.warn(
								"THREE.WebGLRenderer: Texture has been resized from (" +
									t.width +
									"x" +
									t.height +
									") to (" +
									o +
									"x" +
									s +
									")."
							),
							a
						);
					}
					return (
						"data" in t &&
							console.warn(
								"THREE.WebGLRenderer: Image in DataTexture is too big (" +
									t.width +
									"x" +
									t.height +
									")."
							),
						t
					);
				}
				return t;
			}
			function v(t) {
				return Jc.isPowerOfTwo(t.width) && Jc.isPowerOfTwo(t.height);
			}
			function y(t, e) {
				return (
					t.generateMipmaps && e && t.minFilter !== ha && t.minFilter !== pa
				);
			}
			function x(e, n, r, o) {
				t.generateMipmap(e),
					(i.get(n).__maxMipLevel = Math.log(Math.max(r, o)) * Math.LOG2E);
			}
			function b(n, i, r) {
				if (!1 === a) return i;
				if (null !== n) {
					if (void 0 !== t[n]) return t[n];
					console.warn(
						"THREE.WebGLRenderer: Attempt to use non-existing WebGL internal format '" +
							n +
							"'"
					);
				}
				let o = i;
				return (
					6403 === i &&
						(5126 === r && (o = 33326),
						5131 === r && (o = 33325),
						5121 === r && (o = 33321)),
					6407 === i &&
						(5126 === r && (o = 34837),
						5131 === r && (o = 34843),
						5121 === r && (o = 32849)),
					6408 === i &&
						(5126 === r && (o = 34836),
						5131 === r && (o = 34842),
						5121 === r && (o = 32856)),
					(33325 !== o && 33326 !== o && 34842 !== o && 34836 !== o) ||
						e.get("EXT_color_buffer_float"),
					o
				);
			}
			function w(t) {
				return t === ha || t === ua || t === da ? 9728 : 9729;
			}
			function _(e) {
				const n = e.target;
				n.removeEventListener("dispose", _),
					(function (e) {
						const n = i.get(e);
						if (void 0 === n.__webglInit) return;
						t.deleteTexture(n.__webglTexture), i.remove(e);
					})(n),
					n.isVideoTexture && d.delete(n),
					s.memory.textures--;
			}
			function M(e) {
				const n = e.target;
				n.removeEventListener("dispose", M),
					(function (e) {
						const n = i.get(e),
							r = i.get(e.texture);
						if (!e) return;
						void 0 !== r.__webglTexture && t.deleteTexture(r.__webglTexture);
						e.depthTexture && e.depthTexture.dispose();
						if (e.isWebGLCubeRenderTarget)
							for (let e = 0; e < 6; e++)
								t.deleteFramebuffer(n.__webglFramebuffer[e]),
									n.__webglDepthbuffer &&
										t.deleteRenderbuffer(n.__webglDepthbuffer[e]);
						else
							t.deleteFramebuffer(n.__webglFramebuffer),
								n.__webglDepthbuffer &&
									t.deleteRenderbuffer(n.__webglDepthbuffer),
								n.__webglMultisampledFramebuffer &&
									t.deleteFramebuffer(n.__webglMultisampledFramebuffer),
								n.__webglColorRenderbuffer &&
									t.deleteRenderbuffer(n.__webglColorRenderbuffer),
								n.__webglDepthRenderbuffer &&
									t.deleteRenderbuffer(n.__webglDepthRenderbuffer);
						i.remove(e.texture), i.remove(e);
					})(n),
					s.memory.textures--;
			}
			let S = 0;
			function T(t, e) {
				const r = i.get(t);
				if (
					(t.isVideoTexture &&
						(function (t) {
							const e = s.render.frame;
							d.get(t) !== e && (d.set(t, e), t.update());
						})(t),
					t.version > 0 && r.__version !== t.version)
				) {
					const n = t.image;
					if (void 0 === n)
						console.warn(
							"THREE.WebGLRenderer: Texture marked for update but image is undefined"
						);
					else {
						if (!1 !== n.complete) return void O(r, t, e);
						console.warn(
							"THREE.WebGLRenderer: Texture marked for update but image is incomplete"
						);
					}
				}
				n.activeTexture(33984 + e), n.bindTexture(3553, r.__webglTexture);
			}
			function E(e, r) {
				if (6 !== e.image.length) return;
				const s = i.get(e);
				if (e.version > 0 && s.__version !== e.version) {
					C(s, e),
						n.activeTexture(33984 + r),
						n.bindTexture(34067, s.__webglTexture),
						t.pixelStorei(37440, e.flipY);
					const i =
							e && (e.isCompressedTexture || e.image[0].isCompressedTexture),
						c = e.image[0] && e.image[0].isDataTexture,
						h = [];
					for (let t = 0; t < 6; t++)
						h[t] =
							i || c
								? c
									? e.image[t].image
									: e.image[t]
								: g(e.image[t], !1, !0, l);
					const u = h[0],
						d = v(u) || a,
						p = o.convert(e.format),
						f = o.convert(e.type),
						m = b(e.internalFormat, p, f);
					let w;
					if ((R(34067, e, d), i)) {
						for (let t = 0; t < 6; t++) {
							w = h[t].mipmaps;
							for (let i = 0; i < w.length; i++) {
								const r = w[i];
								e.format !== Ra && e.format !== Pa
									? null !== p
										? n.compressedTexImage2D(
												34069 + t,
												i,
												m,
												r.width,
												r.height,
												0,
												r.data
										  )
										: console.warn(
												"THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .setTextureCube()"
										  )
									: n.texImage2D(
											34069 + t,
											i,
											m,
											r.width,
											r.height,
											0,
											p,
											f,
											r.data
									  );
							}
						}
						s.__maxMipLevel = w.length - 1;
					} else {
						w = e.mipmaps;
						for (let t = 0; t < 6; t++)
							if (c) {
								n.texImage2D(
									34069 + t,
									0,
									m,
									h[t].width,
									h[t].height,
									0,
									p,
									f,
									h[t].data
								);
								for (let e = 0; e < w.length; e++) {
									const i = w[e].image[t].image;
									n.texImage2D(
										34069 + t,
										e + 1,
										m,
										i.width,
										i.height,
										0,
										p,
										f,
										i.data
									);
								}
							} else {
								n.texImage2D(34069 + t, 0, m, p, f, h[t]);
								for (let e = 0; e < w.length; e++) {
									const i = w[e];
									n.texImage2D(34069 + t, e + 1, m, p, f, i.image[t]);
								}
							}
						s.__maxMipLevel = w.length;
					}
					y(e, d) && x(34067, e, u.width, u.height),
						(s.__version = e.version),
						e.onUpdate && e.onUpdate(e);
				} else
					n.activeTexture(33984 + r), n.bindTexture(34067, s.__webglTexture);
			}
			function A(t, e) {
				n.activeTexture(33984 + e),
					n.bindTexture(34067, i.get(t).__webglTexture);
			}
			const L = { [aa]: 10497, [ca]: 33071, [la]: 33648 },
				P = {
					[ha]: 9728,
					[ua]: 9984,
					[da]: 9986,
					[pa]: 9729,
					[fa]: 9985,
					[ma]: 9987,
				};
			function R(n, o, s) {
				s
					? (t.texParameteri(n, 10242, L[o.wrapS]),
					  t.texParameteri(n, 10243, L[o.wrapT]),
					  (32879 !== n && 35866 !== n) ||
							t.texParameteri(n, 32882, L[o.wrapR]),
					  t.texParameteri(n, 10240, P[o.magFilter]),
					  t.texParameteri(n, 10241, P[o.minFilter]))
					: (t.texParameteri(n, 10242, 33071),
					  t.texParameteri(n, 10243, 33071),
					  (32879 !== n && 35866 !== n) || t.texParameteri(n, 32882, 33071),
					  (o.wrapS === ca && o.wrapT === ca) ||
							console.warn(
								"THREE.WebGLRenderer: Texture is not power of two. Texture.wrapS and Texture.wrapT should be set to THREE.ClampToEdgeWrapping."
							),
					  t.texParameteri(n, 10240, w(o.magFilter)),
					  t.texParameteri(n, 10241, w(o.minFilter)),
					  o.minFilter !== ha &&
							o.minFilter !== pa &&
							console.warn(
								"THREE.WebGLRenderer: Texture is not power of two. Texture.minFilter should be set to THREE.NearestFilter or THREE.LinearFilter."
							));
				const c = e.get("EXT_texture_filter_anisotropic");
				if (c) {
					if (o.type === _a && null === e.get("OES_texture_float_linear"))
						return;
					if (
						o.type === Ma &&
						null === (a || e.get("OES_texture_half_float_linear"))
					)
						return;
					(o.anisotropy > 1 || i.get(o).__currentAnisotropy) &&
						(t.texParameterf(
							n,
							c.TEXTURE_MAX_ANISOTROPY_EXT,
							Math.min(o.anisotropy, r.getMaxAnisotropy())
						),
						(i.get(o).__currentAnisotropy = o.anisotropy));
				}
			}
			function C(e, n) {
				void 0 === e.__webglInit &&
					((e.__webglInit = !0),
					n.addEventListener("dispose", _),
					(e.__webglTexture = t.createTexture()),
					s.memory.textures++);
			}
			function O(e, i, r) {
				let s = 3553;
				i.isDataTexture2DArray && (s = 35866),
					i.isDataTexture3D && (s = 32879),
					C(e, i),
					n.activeTexture(33984 + r),
					n.bindTexture(s, e.__webglTexture),
					t.pixelStorei(37440, i.flipY),
					t.pixelStorei(37441, i.premultiplyAlpha),
					t.pixelStorei(3317, i.unpackAlignment);
				const c =
						(function (t) {
							return (
								!a &&
								(t.wrapS !== ca ||
									t.wrapT !== ca ||
									(t.minFilter !== ha && t.minFilter !== pa))
							);
						})(i) && !1 === v(i.image),
					l = g(i.image, c, !1, h),
					u = v(l) || a,
					d = o.convert(i.format);
				let p,
					f = o.convert(i.type),
					m = b(i.internalFormat, d, f);
				R(s, i, u);
				const w = i.mipmaps;
				if (i.isDepthTexture)
					(m = 6402),
						a
							? (m =
									i.type === _a
										? 36012
										: i.type === wa
										? 33190
										: i.type === Aa
										? 35056
										: 33189)
							: i.type === _a &&
							  console.error(
									"WebGLRenderer: Floating point depth texture requires WebGL2."
							  ),
						i.format === Ia &&
							6402 === m &&
							i.type !== xa &&
							i.type !== wa &&
							(console.warn(
								"THREE.WebGLRenderer: Use UnsignedShortType or UnsignedIntType for DepthFormat DepthTexture."
							),
							(i.type = xa),
							(f = o.convert(i.type))),
						i.format === ka &&
							6402 === m &&
							((m = 34041),
							i.type !== Aa &&
								(console.warn(
									"THREE.WebGLRenderer: Use UnsignedInt248Type for DepthStencilFormat DepthTexture."
								),
								(i.type = Aa),
								(f = o.convert(i.type)))),
						n.texImage2D(3553, 0, m, l.width, l.height, 0, d, f, null);
				else if (i.isDataTexture)
					if (w.length > 0 && u) {
						for (let t = 0, e = w.length; t < e; t++)
							(p = w[t]),
								n.texImage2D(3553, t, m, p.width, p.height, 0, d, f, p.data);
						(i.generateMipmaps = !1), (e.__maxMipLevel = w.length - 1);
					} else
						n.texImage2D(3553, 0, m, l.width, l.height, 0, d, f, l.data),
							(e.__maxMipLevel = 0);
				else if (i.isCompressedTexture) {
					for (let t = 0, e = w.length; t < e; t++)
						(p = w[t]),
							i.format !== Ra && i.format !== Pa
								? null !== d
									? n.compressedTexImage2D(
											3553,
											t,
											m,
											p.width,
											p.height,
											0,
											p.data
									  )
									: console.warn(
											"THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .uploadTexture()"
									  )
								: n.texImage2D(3553, t, m, p.width, p.height, 0, d, f, p.data);
					e.__maxMipLevel = w.length - 1;
				} else if (i.isDataTexture2DArray)
					n.texImage3D(
						35866,
						0,
						m,
						l.width,
						l.height,
						l.depth,
						0,
						d,
						f,
						l.data
					),
						(e.__maxMipLevel = 0);
				else if (i.isDataTexture3D)
					n.texImage3D(
						32879,
						0,
						m,
						l.width,
						l.height,
						l.depth,
						0,
						d,
						f,
						l.data
					),
						(e.__maxMipLevel = 0);
				else if (w.length > 0 && u) {
					for (let t = 0, e = w.length; t < e; t++)
						(p = w[t]), n.texImage2D(3553, t, m, d, f, p);
					(i.generateMipmaps = !1), (e.__maxMipLevel = w.length - 1);
				} else n.texImage2D(3553, 0, m, d, f, l), (e.__maxMipLevel = 0);
				y(i, u) && x(s, i, l.width, l.height),
					(e.__version = i.version),
					i.onUpdate && i.onUpdate(i);
			}
			function D(e, r, s, a) {
				const c = o.convert(r.texture.format),
					l = o.convert(r.texture.type),
					h = b(r.texture.internalFormat, c, l);
				n.texImage2D(a, 0, h, r.width, r.height, 0, c, l, null),
					t.bindFramebuffer(36160, e),
					t.framebufferTexture2D(
						36160,
						s,
						a,
						i.get(r.texture).__webglTexture,
						0
					),
					t.bindFramebuffer(36160, null);
			}
			function I(e, n, i) {
				if ((t.bindRenderbuffer(36161, e), n.depthBuffer && !n.stencilBuffer)) {
					let r = 33189;
					if (i) {
						const e = n.depthTexture;
						e &&
							e.isDepthTexture &&
							(e.type === _a ? (r = 36012) : e.type === wa && (r = 33190));
						const i = N(n);
						t.renderbufferStorageMultisample(36161, i, r, n.width, n.height);
					} else t.renderbufferStorage(36161, r, n.width, n.height);
					t.framebufferRenderbuffer(36160, 36096, 36161, e);
				} else if (n.depthBuffer && n.stencilBuffer) {
					if (i) {
						const e = N(n);
						t.renderbufferStorageMultisample(
							36161,
							e,
							35056,
							n.width,
							n.height
						);
					} else t.renderbufferStorage(36161, 34041, n.width, n.height);
					t.framebufferRenderbuffer(36160, 33306, 36161, e);
				} else {
					const e = o.convert(n.texture.format),
						r = o.convert(n.texture.type),
						s = b(n.texture.internalFormat, e, r);
					if (i) {
						const e = N(n);
						t.renderbufferStorageMultisample(36161, e, s, n.width, n.height);
					} else t.renderbufferStorage(36161, s, n.width, n.height);
				}
				t.bindRenderbuffer(36161, null);
			}
			function k(e) {
				const n = i.get(e),
					r = !0 === e.isWebGLCubeRenderTarget;
				if (e.depthTexture) {
					if (r)
						throw new Error(
							"target.depthTexture not supported in Cube render targets"
						);
					!(function (e, n) {
						if (n && n.isWebGLCubeRenderTarget)
							throw new Error(
								"Depth Texture with cube render targets is not supported"
							);
						if (
							(t.bindFramebuffer(36160, e),
							!n.depthTexture || !n.depthTexture.isDepthTexture)
						)
							throw new Error(
								"renderTarget.depthTexture must be an instance of THREE.DepthTexture"
							);
						(i.get(n.depthTexture).__webglTexture &&
							n.depthTexture.image.width === n.width &&
							n.depthTexture.image.height === n.height) ||
							((n.depthTexture.image.width = n.width),
							(n.depthTexture.image.height = n.height),
							(n.depthTexture.needsUpdate = !0)),
							T(n.depthTexture, 0);
						const r = i.get(n.depthTexture).__webglTexture;
						if (n.depthTexture.format === Ia)
							t.framebufferTexture2D(36160, 36096, 3553, r, 0);
						else {
							if (n.depthTexture.format !== ka)
								throw new Error("Unknown depthTexture format");
							t.framebufferTexture2D(36160, 33306, 3553, r, 0);
						}
					})(n.__webglFramebuffer, e);
				} else if (r) {
					n.__webglDepthbuffer = [];
					for (let i = 0; i < 6; i++)
						t.bindFramebuffer(36160, n.__webglFramebuffer[i]),
							(n.__webglDepthbuffer[i] = t.createRenderbuffer()),
							I(n.__webglDepthbuffer[i], e, !1);
				} else
					t.bindFramebuffer(36160, n.__webglFramebuffer),
						(n.__webglDepthbuffer = t.createRenderbuffer()),
						I(n.__webglDepthbuffer, e, !1);
				t.bindFramebuffer(36160, null);
			}
			function N(t) {
				return a && t.isWebGLMultisampleRenderTarget
					? Math.min(u, t.samples)
					: 0;
			}
			let B = !1,
				F = !1;
			(this.allocateTextureUnit = function () {
				const t = S;
				return (
					t >= c &&
						console.warn(
							"THREE.WebGLTextures: Trying to use " +
								t +
								" texture units while this GPU supports only " +
								c
						),
					(S += 1),
					t
				);
			}),
				(this.resetTextureUnits = function () {
					S = 0;
				}),
				(this.setTexture2D = T),
				(this.setTexture2DArray = function (t, e) {
					const r = i.get(t);
					t.version > 0 && r.__version !== t.version
						? O(r, t, e)
						: (n.activeTexture(33984 + e),
						  n.bindTexture(35866, r.__webglTexture));
				}),
				(this.setTexture3D = function (t, e) {
					const r = i.get(t);
					t.version > 0 && r.__version !== t.version
						? O(r, t, e)
						: (n.activeTexture(33984 + e),
						  n.bindTexture(32879, r.__webglTexture));
				}),
				(this.setTextureCube = E),
				(this.setTextureCubeDynamic = A),
				(this.setupRenderTarget = function (e) {
					const r = i.get(e),
						c = i.get(e.texture);
					e.addEventListener("dispose", M),
						(c.__webglTexture = t.createTexture()),
						s.memory.textures++;
					const l = !0 === e.isWebGLCubeRenderTarget,
						h = !0 === e.isWebGLMultisampleRenderTarget,
						u = v(e) || a;
					if (
						(!a ||
							e.texture.format !== Pa ||
							(e.texture.type !== _a && e.texture.type !== Ma) ||
							((e.texture.format = Ra),
							console.warn(
								"THREE.WebGLRenderer: Rendering to textures with RGB format is not supported. Using RGBA format instead."
							)),
						l)
					) {
						r.__webglFramebuffer = [];
						for (let e = 0; e < 6; e++)
							r.__webglFramebuffer[e] = t.createFramebuffer();
					} else if (((r.__webglFramebuffer = t.createFramebuffer()), h))
						if (a) {
							(r.__webglMultisampledFramebuffer = t.createFramebuffer()),
								(r.__webglColorRenderbuffer = t.createRenderbuffer()),
								t.bindRenderbuffer(36161, r.__webglColorRenderbuffer);
							const n = o.convert(e.texture.format),
								i = o.convert(e.texture.type),
								s = b(e.texture.internalFormat, n, i),
								a = N(e);
							t.renderbufferStorageMultisample(36161, a, s, e.width, e.height),
								t.bindFramebuffer(36160, r.__webglMultisampledFramebuffer),
								t.framebufferRenderbuffer(
									36160,
									36064,
									36161,
									r.__webglColorRenderbuffer
								),
								t.bindRenderbuffer(36161, null),
								e.depthBuffer &&
									((r.__webglDepthRenderbuffer = t.createRenderbuffer()),
									I(r.__webglDepthRenderbuffer, e, !0)),
								t.bindFramebuffer(36160, null);
						} else
							console.warn(
								"THREE.WebGLRenderer: WebGLMultisampleRenderTarget can only be used with WebGL2."
							);
					if (l) {
						n.bindTexture(34067, c.__webglTexture), R(34067, e.texture, u);
						for (let t = 0; t < 6; t++)
							D(r.__webglFramebuffer[t], e, 36064, 34069 + t);
						y(e.texture, u) && x(34067, e.texture, e.width, e.height),
							n.bindTexture(34067, null);
					} else
						n.bindTexture(3553, c.__webglTexture),
							R(3553, e.texture, u),
							D(r.__webglFramebuffer, e, 36064, 3553),
							y(e.texture, u) && x(3553, e.texture, e.width, e.height),
							n.bindTexture(3553, null);
					e.depthBuffer && k(e);
				}),
				(this.updateRenderTargetMipmap = function (t) {
					const e = t.texture;
					if (y(e, v(t) || a)) {
						const r = t.isWebGLCubeRenderTarget ? 34067 : 3553,
							o = i.get(e).__webglTexture;
						n.bindTexture(r, o),
							x(r, e, t.width, t.height),
							n.bindTexture(r, null);
					}
				}),
				(this.updateMultisampleRenderTarget = function (e) {
					if (e.isWebGLMultisampleRenderTarget)
						if (a) {
							const n = i.get(e);
							t.bindFramebuffer(36008, n.__webglMultisampledFramebuffer),
								t.bindFramebuffer(36009, n.__webglFramebuffer);
							const r = e.width,
								o = e.height;
							let s = 16384;
							e.depthBuffer && (s |= 256),
								e.stencilBuffer && (s |= 1024),
								t.blitFramebuffer(0, 0, r, o, 0, 0, r, o, s, 9728),
								t.bindFramebuffer(36160, n.__webglMultisampledFramebuffer);
						} else
							console.warn(
								"THREE.WebGLRenderer: WebGLMultisampleRenderTarget can only be used with WebGL2."
							);
				}),
				(this.safeSetTexture2D = function (t, e) {
					t &&
						t.isWebGLRenderTarget &&
						(!1 === B &&
							(console.warn(
								"THREE.WebGLTextures.safeSetTexture2D: don't use render targets as textures. Use their .texture property instead."
							),
							(B = !0)),
						(t = t.texture)),
						T(t, e);
				}),
				(this.safeSetTextureCube = function (t, e) {
					t &&
						t.isWebGLCubeRenderTarget &&
						(!1 === F &&
							(console.warn(
								"THREE.WebGLTextures.safeSetTextureCube: don't use cube render targets as textures. Use their .texture property instead."
							),
							(F = !0)),
						(t = t.texture)),
						(t && t.isCubeTexture) ||
						(Array.isArray(t.image) && 6 === t.image.length)
							? E(t, e)
							: A(t, e);
				});
		}
		function Rp(t) {
			ku.call(this), (this.cameras = t || []);
		}
		function Cp() {
			kl.call(this), (this.type = "Group");
		}
		function Op() {
			(this._targetRay = null), (this._grip = null);
		}
		function Dp(t, e) {
			const n = this;
			let i = null,
				r = 1,
				o = null,
				s = "local-floor",
				a = null;
			const c = [],
				l = new Map(),
				h = new ku();
			h.layers.enable(1), (h.viewport = new il());
			const u = new ku();
			u.layers.enable(2), (u.viewport = new il());
			const d = [h, u],
				p = new Rp();
			p.layers.enable(1), p.layers.enable(2);
			let f = null,
				m = null;
			function g(t) {
				const e = l.get(t.inputSource);
				e && e.dispatchEvent({ type: t.type });
			}
			function v() {
				l.forEach(function (t, e) {
					t.disconnect(e);
				}),
					l.clear(),
					t.setFramebuffer(null),
					t.setRenderTarget(t.getRenderTarget()),
					S.stop(),
					(n.isPresenting = !1),
					n.dispatchEvent({ type: "sessionend" });
			}
			function y(t) {
				(o = t),
					S.setContext(i),
					S.start(),
					(n.isPresenting = !0),
					n.dispatchEvent({ type: "sessionstart" });
			}
			function x(t) {
				const e = i.inputSources;
				for (let t = 0; t < c.length; t++) l.set(e[t], c[t]);
				for (let e = 0; e < t.removed.length; e++) {
					const n = t.removed[e],
						i = l.get(n);
					i &&
						(i.dispatchEvent({ type: "disconnected", data: n }), l.delete(n));
				}
				for (let e = 0; e < t.added.length; e++) {
					const n = t.added[e],
						i = l.get(n);
					i && i.dispatchEvent({ type: "connected", data: n });
				}
			}
			(this.enabled = !1),
				(this.isPresenting = !1),
				(this.getController = function (t) {
					let e = c[t];
					return (
						void 0 === e && ((e = new Op()), (c[t] = e)), e.getTargetRaySpace()
					);
				}),
				(this.getControllerGrip = function (t) {
					let e = c[t];
					return void 0 === e && ((e = new Op()), (c[t] = e)), e.getGripSpace();
				}),
				(this.setFramebufferScaleFactor = function (t) {
					(r = t),
						!0 === n.isPresenting &&
							console.warn(
								"THREE.WebXRManager: Cannot change framebuffer scale while presenting."
							);
				}),
				(this.setReferenceSpaceType = function (t) {
					(s = t),
						!0 === n.isPresenting &&
							console.warn(
								"THREE.WebXRManager: Cannot change reference space type while presenting."
							);
				}),
				(this.getReferenceSpace = function () {
					return o;
				}),
				(this.getSession = function () {
					return i;
				}),
				(this.setSession = function (t) {
					if (null !== (i = t)) {
						i.addEventListener("select", g),
							i.addEventListener("selectstart", g),
							i.addEventListener("selectend", g),
							i.addEventListener("squeeze", g),
							i.addEventListener("squeezestart", g),
							i.addEventListener("squeezeend", g),
							i.addEventListener("end", v);
						const t = e.getContextAttributes();
						!0 !== t.xrCompatible && e.makeXRCompatible();
						const n = {
								antialias: t.antialias,
								alpha: t.alpha,
								depth: t.depth,
								stencil: t.stencil,
								framebufferScaleFactor: r,
							},
							o = new XRWebGLLayer(i, e, n);
						i.updateRenderState({ baseLayer: o }),
							i.requestReferenceSpace(s).then(y),
							i.addEventListener("inputsourceschange", x);
					}
				});
			const b = new ll(),
				w = new ll();
			function _(t, e) {
				null === e
					? t.matrixWorld.copy(t.matrix)
					: t.matrixWorld.multiplyMatrices(e.matrixWorld, t.matrix),
					t.matrixWorldInverse.getInverse(t.matrixWorld);
			}
			this.getCamera = function (t) {
				(p.near = u.near = h.near = t.near),
					(p.far = u.far = h.far = t.far),
					(f === p.near && m === p.far) ||
						(i.updateRenderState({ depthNear: p.near, depthFar: p.far }),
						(f = p.near),
						(m = p.far));
				const e = t.parent,
					n = p.cameras;
				_(p, e);
				for (let t = 0; t < n.length; t++) _(n[t], e);
				t.matrixWorld.copy(p.matrixWorld);
				const r = t.children;
				for (let t = 0, e = r.length; t < e; t++) r[t].updateMatrixWorld(!0);
				return (
					2 === n.length
						? (function (t, e, n) {
								b.setFromMatrixPosition(e.matrixWorld),
									w.setFromMatrixPosition(n.matrixWorld);
								const i = b.distanceTo(w),
									r = e.projectionMatrix.elements,
									o = n.projectionMatrix.elements,
									s = r[14] / (r[10] - 1),
									a = r[14] / (r[10] + 1),
									c = (r[9] + 1) / r[5],
									l = (r[9] - 1) / r[5],
									h = (r[8] - 1) / r[0],
									u = (o[8] + 1) / o[0],
									d = s * h,
									p = s * u,
									f = i / (-h + u),
									m = f * -h;
								e.matrixWorld.decompose(t.position, t.quaternion, t.scale),
									t.translateX(m),
									t.translateZ(f),
									t.matrixWorld.compose(t.position, t.quaternion, t.scale),
									t.matrixWorldInverse.getInverse(t.matrixWorld);
								const g = s + f,
									v = a + f,
									y = d - m,
									x = p + (i - m),
									_ = ((c * a) / v) * g,
									M = ((l * a) / v) * g;
								t.projectionMatrix.makePerspective(y, x, _, M, g, v);
						  })(p, h, u)
						: p.projectionMatrix.copy(h.projectionMatrix),
					p
				);
			};
			let M = null;
			const S = new Wu();
			S.setAnimationLoop(function (e, n) {
				if (null !== (a = n.getViewerPose(o))) {
					const e = a.views,
						n = i.renderState.baseLayer;
					t.setFramebuffer(n.framebuffer);
					let r = !1;
					e.length !== p.cameras.length && ((p.cameras.length = 0), (r = !0));
					for (let t = 0; t < e.length; t++) {
						const i = e[t],
							o = n.getViewport(i),
							s = d[t];
						s.matrix.fromArray(i.transform.matrix),
							s.projectionMatrix.fromArray(i.projectionMatrix),
							s.viewport.set(o.x, o.y, o.width, o.height),
							0 === t && p.matrix.copy(s.matrix),
							!0 === r && p.cameras.push(s);
					}
				}
				const r = i.inputSources;
				for (let t = 0; t < c.length; t++) {
					const e = c[t],
						i = r[t];
					e.update(i, n, o);
				}
				M && M(e, n);
			}),
				(this.setAnimationLoop = function (t) {
					M = t;
				}),
				(this.dispose = function () {});
		}
		function Ip(t) {
			function e(e, n, i) {
				(e.opacity.value = n.opacity),
					n.color && e.diffuse.value.copy(n.color),
					n.emissive &&
						e.emissive.value
							.copy(n.emissive)
							.multiplyScalar(n.emissiveIntensity),
					n.map && (e.map.value = n.map),
					n.alphaMap && (e.alphaMap.value = n.alphaMap),
					n.specularMap && (e.specularMap.value = n.specularMap);
				const r = n.envMap || i;
				let o, s;
				r &&
					((e.envMap.value = r),
					(e.flipEnvMap.value = r.isCubeTexture ? -1 : 1),
					(e.reflectivity.value = n.reflectivity),
					(e.refractionRatio.value = n.refractionRatio),
					(e.maxMipLevel.value = t.get(r).__maxMipLevel)),
					n.lightMap &&
						((e.lightMap.value = n.lightMap),
						(e.lightMapIntensity.value = n.lightMapIntensity)),
					n.aoMap &&
						((e.aoMap.value = n.aoMap),
						(e.aoMapIntensity.value = n.aoMapIntensity)),
					n.map
						? (o = n.map)
						: n.specularMap
						? (o = n.specularMap)
						: n.displacementMap
						? (o = n.displacementMap)
						: n.normalMap
						? (o = n.normalMap)
						: n.bumpMap
						? (o = n.bumpMap)
						: n.roughnessMap
						? (o = n.roughnessMap)
						: n.metalnessMap
						? (o = n.metalnessMap)
						: n.alphaMap
						? (o = n.alphaMap)
						: n.emissiveMap && (o = n.emissiveMap),
					void 0 !== o &&
						(o.isWebGLRenderTarget && (o = o.texture),
						!0 === o.matrixAutoUpdate && o.updateMatrix(),
						e.uvTransform.value.copy(o.matrix)),
					n.aoMap ? (s = n.aoMap) : n.lightMap && (s = n.lightMap),
					void 0 !== s &&
						(s.isWebGLRenderTarget && (s = s.texture),
						!0 === s.matrixAutoUpdate && s.updateMatrix(),
						e.uv2Transform.value.copy(s.matrix));
			}
			function n(t, e, n) {
				(t.roughness.value = e.roughness),
					(t.metalness.value = e.metalness),
					e.roughnessMap && (t.roughnessMap.value = e.roughnessMap),
					e.metalnessMap && (t.metalnessMap.value = e.metalnessMap),
					e.emissiveMap && (t.emissiveMap.value = e.emissiveMap),
					e.bumpMap &&
						((t.bumpMap.value = e.bumpMap),
						(t.bumpScale.value = e.bumpScale),
						e.side === fs && (t.bumpScale.value *= -1)),
					e.normalMap &&
						((t.normalMap.value = e.normalMap),
						t.normalScale.value.copy(e.normalScale),
						e.side === fs && t.normalScale.value.negate()),
					e.displacementMap &&
						((t.displacementMap.value = e.displacementMap),
						(t.displacementScale.value = e.displacementScale),
						(t.displacementBias.value = e.displacementBias)),
					(e.envMap || n) && (t.envMapIntensity.value = e.envMapIntensity);
			}
			return {
				refreshFogUniforms: function (t, e) {
					t.fogColor.value.copy(e.color),
						e.isFog
							? ((t.fogNear.value = e.near), (t.fogFar.value = e.far))
							: e.isFogExp2 && (t.fogDensity.value = e.density);
				},
				refreshMaterialUniforms: function (t, i, r, o, s) {
					i.isMeshBasicMaterial
						? e(t, i)
						: i.isMeshLambertMaterial
						? (e(t, i),
						  (function (t, e) {
								e.emissiveMap && (t.emissiveMap.value = e.emissiveMap);
						  })(t, i))
						: i.isMeshToonMaterial
						? (e(t, i),
						  (function (t, e) {
								e.gradientMap && (t.gradientMap.value = e.gradientMap),
									e.emissiveMap && (t.emissiveMap.value = e.emissiveMap),
									e.bumpMap &&
										((t.bumpMap.value = e.bumpMap),
										(t.bumpScale.value = e.bumpScale),
										e.side === fs && (t.bumpScale.value *= -1)),
									e.normalMap &&
										((t.normalMap.value = e.normalMap),
										t.normalScale.value.copy(e.normalScale),
										e.side === fs && t.normalScale.value.negate()),
									e.displacementMap &&
										((t.displacementMap.value = e.displacementMap),
										(t.displacementScale.value = e.displacementScale),
										(t.displacementBias.value = e.displacementBias));
						  })(t, i))
						: i.isMeshPhongMaterial
						? (e(t, i),
						  (function (t, e) {
								t.specular.value.copy(e.specular),
									(t.shininess.value = Math.max(e.shininess, 1e-4)),
									e.emissiveMap && (t.emissiveMap.value = e.emissiveMap),
									e.bumpMap &&
										((t.bumpMap.value = e.bumpMap),
										(t.bumpScale.value = e.bumpScale),
										e.side === fs && (t.bumpScale.value *= -1)),
									e.normalMap &&
										((t.normalMap.value = e.normalMap),
										t.normalScale.value.copy(e.normalScale),
										e.side === fs && t.normalScale.value.negate()),
									e.displacementMap &&
										((t.displacementMap.value = e.displacementMap),
										(t.displacementScale.value = e.displacementScale),
										(t.displacementBias.value = e.displacementBias));
						  })(t, i))
						: i.isMeshStandardMaterial
						? (e(t, i, r),
						  i.isMeshPhysicalMaterial
								? (function (t, e, i) {
										n(t, e, i),
											(t.reflectivity.value = e.reflectivity),
											(t.clearcoat.value = e.clearcoat),
											(t.clearcoatRoughness.value = e.clearcoatRoughness),
											e.sheen && t.sheen.value.copy(e.sheen),
											e.clearcoatMap && (t.clearcoatMap.value = e.clearcoatMap),
											e.clearcoatRoughnessMap &&
												(t.clearcoatRoughnessMap.value =
													e.clearcoatRoughnessMap),
											e.clearcoatNormalMap &&
												(t.clearcoatNormalScale.value.copy(
													e.clearcoatNormalScale
												),
												(t.clearcoatNormalMap.value = e.clearcoatNormalMap),
												e.side === fs && t.clearcoatNormalScale.value.negate()),
											(t.transparency.value = e.transparency);
								  })(t, i, r)
								: n(t, i, r))
						: i.isMeshMatcapMaterial
						? (e(t, i),
						  (function (t, e) {
								e.matcap && (t.matcap.value = e.matcap),
									e.bumpMap &&
										((t.bumpMap.value = e.bumpMap),
										(t.bumpScale.value = e.bumpScale),
										e.side === fs && (t.bumpScale.value *= -1)),
									e.normalMap &&
										((t.normalMap.value = e.normalMap),
										t.normalScale.value.copy(e.normalScale),
										e.side === fs && t.normalScale.value.negate()),
									e.displacementMap &&
										((t.displacementMap.value = e.displacementMap),
										(t.displacementScale.value = e.displacementScale),
										(t.displacementBias.value = e.displacementBias));
						  })(t, i))
						: i.isMeshDepthMaterial
						? (e(t, i),
						  (function (t, e) {
								e.displacementMap &&
									((t.displacementMap.value = e.displacementMap),
									(t.displacementScale.value = e.displacementScale),
									(t.displacementBias.value = e.displacementBias));
						  })(t, i))
						: i.isMeshDistanceMaterial
						? (e(t, i),
						  (function (t, e) {
								e.displacementMap &&
									((t.displacementMap.value = e.displacementMap),
									(t.displacementScale.value = e.displacementScale),
									(t.displacementBias.value = e.displacementBias)),
									t.referencePosition.value.copy(e.referencePosition),
									(t.nearDistance.value = e.nearDistance),
									(t.farDistance.value = e.farDistance);
						  })(t, i))
						: i.isMeshNormalMaterial
						? (e(t, i),
						  (function (t, e) {
								e.bumpMap &&
									((t.bumpMap.value = e.bumpMap),
									(t.bumpScale.value = e.bumpScale),
									e.side === fs && (t.bumpScale.value *= -1)),
									e.normalMap &&
										((t.normalMap.value = e.normalMap),
										t.normalScale.value.copy(e.normalScale),
										e.side === fs && t.normalScale.value.negate()),
									e.displacementMap &&
										((t.displacementMap.value = e.displacementMap),
										(t.displacementScale.value = e.displacementScale),
										(t.displacementBias.value = e.displacementBias));
						  })(t, i))
						: i.isLineBasicMaterial
						? ((function (t, e) {
								t.diffuse.value.copy(e.color), (t.opacity.value = e.opacity);
						  })(t, i),
						  i.isLineDashedMaterial &&
								(function (t, e) {
									(t.dashSize.value = e.dashSize),
										(t.totalSize.value = e.dashSize + e.gapSize),
										(t.scale.value = e.scale);
								})(t, i))
						: i.isPointsMaterial
						? (function (t, e, n, i) {
								let r;
								t.diffuse.value.copy(e.color),
									(t.opacity.value = e.opacity),
									(t.size.value = e.size * n),
									(t.scale.value = 0.5 * i),
									e.map && (t.map.value = e.map),
									e.alphaMap && (t.alphaMap.value = e.alphaMap),
									e.map ? (r = e.map) : e.alphaMap && (r = e.alphaMap),
									void 0 !== r &&
										(!0 === r.matrixAutoUpdate && r.updateMatrix(),
										t.uvTransform.value.copy(r.matrix));
						  })(t, i, o, s)
						: i.isSpriteMaterial
						? (function (t, e) {
								let n;
								t.diffuse.value.copy(e.color),
									(t.opacity.value = e.opacity),
									(t.rotation.value = e.rotation),
									e.map && (t.map.value = e.map),
									e.alphaMap && (t.alphaMap.value = e.alphaMap),
									e.map ? (n = e.map) : e.alphaMap && (n = e.alphaMap),
									void 0 !== n &&
										(!0 === n.matrixAutoUpdate && n.updateMatrix(),
										t.uvTransform.value.copy(n.matrix));
						  })(t, i)
						: i.isShadowMaterial
						? (t.color.value.copy(i.color), (t.opacity.value = i.opacity))
						: i.isShaderMaterial && (i.uniformsNeedUpdate = !1);
				},
			};
		}
		function kp(t) {
			const e =
					void 0 !== (t = t || {}).canvas
						? t.canvas
						: document.createElementNS(
								"http://www.w3.org/1999/xhtml",
								"canvas"
						  ),
				n = void 0 !== t.context ? t.context : null,
				i = void 0 !== t.alpha && t.alpha,
				r = void 0 === t.depth || t.depth,
				o = void 0 === t.stencil || t.stencil,
				s = void 0 !== t.antialias && t.antialias,
				a = void 0 === t.premultipliedAlpha || t.premultipliedAlpha,
				c = void 0 !== t.preserveDrawingBuffer && t.preserveDrawingBuffer,
				l = void 0 !== t.powerPreference ? t.powerPreference : "default",
				h =
					void 0 !== t.failIfMajorPerformanceCaveat &&
					t.failIfMajorPerformanceCaveat;
			let u = null,
				d = null;
			(this.domElement = e),
				(this.debug = { checkShaderErrors: !0 }),
				(this.autoClear = !0),
				(this.autoClearColor = !0),
				(this.autoClearDepth = !0),
				(this.autoClearStencil = !0),
				(this.sortObjects = !0),
				(this.clippingPlanes = []),
				(this.localClippingEnabled = !1),
				(this.gammaFactor = 2),
				(this.outputEncoding = Oc),
				(this.physicallyCorrectLights = !1),
				(this.toneMapping = Zs),
				(this.toneMappingExposure = 1),
				(this.maxMorphTargets = 8),
				(this.maxMorphNormals = 4);
			const p = this;
			let f = !1,
				m = null,
				g = 0,
				v = 0,
				y = null,
				x = null,
				b = -1,
				w = null,
				_ = null;
			const M = new il(),
				S = new il();
			let T = null,
				E = e.width,
				A = e.height,
				L = 1,
				P = null,
				R = null;
			const C = new il(0, 0, E, A),
				O = new il(0, 0, E, A);
			let D = !1;
			const I = new Vu(),
				k = new (function () {
					const t = this;
					let e = null,
						n = 0,
						i = !1,
						r = !1;
					const o = new uh(),
						s = new Qc(),
						a = { value: null, needsUpdate: !1 };
					function c() {
						a.value !== e && ((a.value = e), (a.needsUpdate = n > 0)),
							(t.numPlanes = n),
							(t.numIntersection = 0);
					}
					function l(e, n, i, r) {
						let c = null !== e ? e.length : 0,
							l = null;
						if (0 !== c) {
							if (((l = a.value), !0 !== r || null === l)) {
								const t = i + 4 * c,
									r = n.matrixWorldInverse;
								s.getNormalMatrix(r),
									(null === l || l.length < t) && (l = new Float32Array(t));
								for (let t = 0, n = i; t !== c; ++t, n += 4)
									o.copy(e[t]).applyMatrix4(r, s),
										o.normal.toArray(l, n),
										(l[n + 3] = o.constant);
							}
							(a.value = l), (a.needsUpdate = !0);
						}
						return (t.numPlanes = c), (t.numIntersection = 0), l;
					}
					(this.uniform = a),
						(this.numPlanes = 0),
						(this.numIntersection = 0),
						(this.init = function (t, r, o) {
							const s = 0 !== t.length || r || 0 !== n || i;
							return (i = r), (e = l(t, o, 0)), (n = t.length), s;
						}),
						(this.beginShadows = function () {
							(r = !0), l(null);
						}),
						(this.endShadows = function () {
							(r = !1), c();
						}),
						(this.setState = function (t, o, s, h, u, d) {
							if (!i || null === t || 0 === t.length || (r && !s))
								r ? l(null) : c();
							else {
								const i = r ? 0 : n,
									s = 4 * i;
								let c = u.clippingState || null;
								(a.value = c), (c = l(t, h, s, d));
								for (let t = 0; t !== s; ++t) c[t] = e[t];
								(u.clippingState = c),
									(this.numIntersection = o ? this.numPlanes : 0),
									(this.numPlanes += i);
							}
						});
				})();
			let N = !1,
				B = !1;
			const F = new vl(),
				z = new ll(),
				H = {
					background: null,
					fog: null,
					environment: null,
					overrideMaterial: null,
					isScene: !0,
				};
			function U() {
				return null === y ? L : 1;
			}
			let G,
				V,
				j,
				W,
				q,
				Y,
				X,
				Z,
				J,
				K,
				Q,
				$,
				tt,
				et,
				nt,
				it,
				rt,
				ot,
				st,
				at = n;
			function ct(t, n) {
				for (let i = 0; i < t.length; i++) {
					const r = t[i],
						o = e.getContext(r, n);
					if (null !== o) return o;
				}
				return null;
			}
			try {
				const t = {
					alpha: i,
					depth: r,
					stencil: o,
					antialias: s,
					premultipliedAlpha: a,
					preserveDrawingBuffer: c,
					powerPreference: l,
					failIfMajorPerformanceCaveat: h,
				};
				if (
					(e.addEventListener("webglcontextlost", dt, !1),
					e.addEventListener("webglcontextrestored", pt, !1),
					null === at)
				) {
					const e = ["webgl2", "webgl", "experimental-webgl"];
					if (
						(!0 === p.isWebGL1Renderer && e.shift(), null === (at = ct(e, t)))
					)
						throw ct(e)
							? new Error(
									"Error creating WebGL context with your selected attributes."
							  )
							: new Error("Error creating WebGL context.");
				}
				void 0 === at.getShaderPrecisionFormat &&
					(at.getShaderPrecisionFormat = function () {
						return { rangeMin: 1, rangeMax: 1, precision: 1 };
					});
			} catch (t) {
				throw (console.error("THREE.WebGLRenderer: " + t.message), t);
			}
			function lt() {
				(G = new (function (t) {
					const e = {};
					return {
						get: function (n) {
							if (void 0 !== e[n]) return e[n];
							let i;
							switch (n) {
								case "WEBGL_depth_texture":
									i =
										t.getExtension("WEBGL_depth_texture") ||
										t.getExtension("MOZ_WEBGL_depth_texture") ||
										t.getExtension("WEBKIT_WEBGL_depth_texture");
									break;
								case "EXT_texture_filter_anisotropic":
									i =
										t.getExtension("EXT_texture_filter_anisotropic") ||
										t.getExtension("MOZ_EXT_texture_filter_anisotropic") ||
										t.getExtension("WEBKIT_EXT_texture_filter_anisotropic");
									break;
								case "WEBGL_compressed_texture_s3tc":
									i =
										t.getExtension("WEBGL_compressed_texture_s3tc") ||
										t.getExtension("MOZ_WEBGL_compressed_texture_s3tc") ||
										t.getExtension("WEBKIT_WEBGL_compressed_texture_s3tc");
									break;
								case "WEBGL_compressed_texture_pvrtc":
									i =
										t.getExtension("WEBGL_compressed_texture_pvrtc") ||
										t.getExtension("WEBKIT_WEBGL_compressed_texture_pvrtc");
									break;
								default:
									i = t.getExtension(n);
							}
							return (
								null === i &&
									console.warn(
										"THREE.WebGLRenderer: " + n + " extension not supported."
									),
								(e[n] = i),
								i
							);
						},
					};
				})(at)),
					!1 ===
						(V = new (function (t, e, n) {
							let i;
							function r(e) {
								if ("highp" === e) {
									if (
										t.getShaderPrecisionFormat(35633, 36338).precision > 0 &&
										t.getShaderPrecisionFormat(35632, 36338).precision > 0
									)
										return "highp";
									e = "mediump";
								}
								return "mediump" === e &&
									t.getShaderPrecisionFormat(35633, 36337).precision > 0 &&
									t.getShaderPrecisionFormat(35632, 36337).precision > 0
									? "mediump"
									: "lowp";
							}
							const o =
								("undefined" != typeof WebGL2RenderingContext &&
									t instanceof WebGL2RenderingContext) ||
								("undefined" != typeof WebGL2ComputeRenderingContext &&
									t instanceof WebGL2ComputeRenderingContext);
							let s = void 0 !== n.precision ? n.precision : "highp";
							const a = r(s);
							a !== s &&
								(console.warn(
									"THREE.WebGLRenderer:",
									s,
									"not supported, using",
									a,
									"instead."
								),
								(s = a));
							const c = !0 === n.logarithmicDepthBuffer,
								l = t.getParameter(34930),
								h = t.getParameter(35660),
								u = t.getParameter(3379),
								d = t.getParameter(34076),
								p = t.getParameter(34921),
								f = t.getParameter(36347),
								m = t.getParameter(36348),
								g = t.getParameter(36349),
								v = h > 0,
								y = o || !!e.get("OES_texture_float");
							return {
								isWebGL2: o,
								getMaxAnisotropy: function () {
									if (void 0 !== i) return i;
									const n = e.get("EXT_texture_filter_anisotropic");
									return (i =
										null !== n
											? t.getParameter(n.MAX_TEXTURE_MAX_ANISOTROPY_EXT)
											: 0);
								},
								getMaxPrecision: r,
								precision: s,
								logarithmicDepthBuffer: c,
								maxTextures: l,
								maxVertexTextures: h,
								maxTextureSize: u,
								maxCubemapSize: d,
								maxAttributes: p,
								maxVertexUniforms: f,
								maxVaryings: m,
								maxFragmentUniforms: g,
								vertexTextures: v,
								floatFragmentTextures: y,
								floatVertexTextures: v && y,
								maxSamples: o ? t.getParameter(36183) : 0,
							};
						})(at, G, t)).isWebGL2 &&
						(G.get("WEBGL_depth_texture"),
						G.get("OES_texture_float"),
						G.get("OES_texture_half_float"),
						G.get("OES_texture_half_float_linear"),
						G.get("OES_standard_derivatives"),
						G.get("OES_element_index_uint"),
						G.get("OES_vertex_array_object"),
						G.get("ANGLE_instanced_arrays")),
					G.get("OES_texture_float_linear"),
					(ot = new (function (t, e, n) {
						const i = n.isWebGL2;
						return {
							convert: function (t) {
								let n;
								if (t === ga) return 5121;
								if (t === Sa) return 32819;
								if (t === Ta) return 32820;
								if (t === Ea) return 33635;
								if (t === va) return 5120;
								if (t === ya) return 5122;
								if (t === xa) return 5123;
								if (t === ba) return 5124;
								if (t === wa) return 5125;
								if (t === _a) return 5126;
								if (t === Ma)
									return i
										? 5131
										: null !== (n = e.get("OES_texture_half_float"))
										? n.HALF_FLOAT_OES
										: null;
								if (t === La) return 6406;
								if (t === Pa) return 6407;
								if (t === Ra) return 6408;
								if (t === Ca) return 6409;
								if (t === Oa) return 6410;
								if (t === Ia) return 6402;
								if (t === ka) return 34041;
								if (t === Na) return 6403;
								if (t === Ba) return 36244;
								if (t === Fa) return 33319;
								if (t === za) return 33320;
								if (t === Ha) return 36248;
								if (t === Ua) return 36249;
								if (t === Ga || t === Va || t === ja || t === Wa) {
									if (null === (n = e.get("WEBGL_compressed_texture_s3tc")))
										return null;
									if (t === Ga) return n.COMPRESSED_RGB_S3TC_DXT1_EXT;
									if (t === Va) return n.COMPRESSED_RGBA_S3TC_DXT1_EXT;
									if (t === ja) return n.COMPRESSED_RGBA_S3TC_DXT3_EXT;
									if (t === Wa) return n.COMPRESSED_RGBA_S3TC_DXT5_EXT;
								}
								if (t === qa || t === Ya || t === Xa || t === Za) {
									if (null === (n = e.get("WEBGL_compressed_texture_pvrtc")))
										return null;
									if (t === qa) return n.COMPRESSED_RGB_PVRTC_4BPPV1_IMG;
									if (t === Ya) return n.COMPRESSED_RGB_PVRTC_2BPPV1_IMG;
									if (t === Xa) return n.COMPRESSED_RGBA_PVRTC_4BPPV1_IMG;
									if (t === Za) return n.COMPRESSED_RGBA_PVRTC_2BPPV1_IMG;
								}
								if (t === Ja)
									return null !== (n = e.get("WEBGL_compressed_texture_etc1"))
										? n.COMPRESSED_RGB_ETC1_WEBGL
										: null;
								if (
									(t === Ka || t === Qa) &&
									null !== (n = e.get("WEBGL_compressed_texture_etc"))
								) {
									if (t === Ka) return n.COMPRESSED_RGB8_ETC2;
									if (t === Qa) return n.COMPRESSED_RGBA8_ETC2_EAC;
								}
								return t === $a ||
									t === tc ||
									t === ec ||
									t === nc ||
									t === ic ||
									t === rc ||
									t === oc ||
									t === sc ||
									t === ac ||
									t === cc ||
									t === lc ||
									t === hc ||
									t === uc ||
									t === dc ||
									t === fc ||
									t === mc ||
									t === gc ||
									t === vc ||
									t === yc ||
									t === xc ||
									t === bc ||
									t === wc ||
									t === _c ||
									t === Mc ||
									t === Sc ||
									t === Tc ||
									t === Ec ||
									t === Ac
									? null !== (n = e.get("WEBGL_compressed_texture_astc"))
										? t
										: null
									: t === pc
									? null !== (n = e.get("EXT_texture_compression_bptc"))
										? t
										: null
									: t === Aa
									? i
										? 34042
										: null !== (n = e.get("WEBGL_depth_texture"))
										? n.UNSIGNED_INT_24_8_WEBGL
										: null
									: void 0;
							},
						};
					})(at, G, V)),
					(j = new (function (t, e, n) {
						const i = n.isWebGL2,
							r = new (function () {
								let e = !1;
								const n = new il();
								let i = null;
								const r = new il(0, 0, 0, 0);
								return {
									setMask: function (n) {
										i === n || e || (t.colorMask(n, n, n, n), (i = n));
									},
									setLocked: function (t) {
										e = t;
									},
									setClear: function (e, i, o, s, a) {
										!0 === a && ((e *= s), (i *= s), (o *= s)),
											n.set(e, i, o, s),
											!1 === r.equals(n) &&
												(t.clearColor(e, i, o, s), r.copy(n));
									},
									reset: function () {
										(e = !1), (i = null), r.set(-1, 0, 0, 0);
									},
								};
							})(),
							o = new (function () {
								let e = !1,
									n = null,
									i = null,
									r = null;
								return {
									setTest: function (t) {
										t ? D(2929) : I(2929);
									},
									setMask: function (i) {
										n === i || e || (t.depthMask(i), (n = i));
									},
									setFunc: function (e) {
										if (i !== e) {
											if (e)
												switch (e) {
													case Fs:
														t.depthFunc(512);
														break;
													case zs:
														t.depthFunc(519);
														break;
													case Hs:
														t.depthFunc(513);
														break;
													case Us:
														t.depthFunc(515);
														break;
													case Gs:
														t.depthFunc(514);
														break;
													case Vs:
														t.depthFunc(518);
														break;
													case js:
														t.depthFunc(516);
														break;
													case Ws:
														t.depthFunc(517);
														break;
													default:
														t.depthFunc(515);
												}
											else t.depthFunc(515);
											i = e;
										}
									},
									setLocked: function (t) {
										e = t;
									},
									setClear: function (e) {
										r !== e && (t.clearDepth(e), (r = e));
									},
									reset: function () {
										(e = !1), (n = null), (i = null), (r = null);
									},
								};
							})(),
							s = new (function () {
								let e = !1,
									n = null,
									i = null,
									r = null,
									o = null,
									s = null,
									a = null,
									c = null,
									l = null;
								return {
									setTest: function (t) {
										e || (t ? D(2960) : I(2960));
									},
									setMask: function (i) {
										n === i || e || (t.stencilMask(i), (n = i));
									},
									setFunc: function (e, n, s) {
										(i === e && r === n && o === s) ||
											(t.stencilFunc(e, n, s), (i = e), (r = n), (o = s));
									},
									setOp: function (e, n, i) {
										(s === e && a === n && c === i) ||
											(t.stencilOp(e, n, i), (s = e), (a = n), (c = i));
									},
									setLocked: function (t) {
										e = t;
									},
									setClear: function (e) {
										l !== e && (t.clearStencil(e), (l = e));
									},
									reset: function () {
										(e = !1),
											(n = null),
											(i = null),
											(r = null),
											(o = null),
											(s = null),
											(a = null),
											(c = null),
											(l = null);
									},
								};
							})();
						let a = {},
							c = null,
							l = null,
							h = null,
							u = null,
							d = null,
							p = null,
							f = null,
							m = null,
							g = null,
							v = !1,
							y = null,
							x = null,
							b = null,
							w = null,
							_ = null;
						const M = t.getParameter(35661);
						let S = !1,
							T = 0;
						const E = t.getParameter(7938);
						-1 !== E.indexOf("WebGL")
							? ((T = parseFloat(/^WebGL\ ([0-9])/.exec(E)[1])), (S = T >= 1))
							: -1 !== E.indexOf("OpenGL ES") &&
							  ((T = parseFloat(/^OpenGL\ ES\ ([0-9])/.exec(E)[1])),
							  (S = T >= 2));
						let A = null,
							L = {};
						const P = new il(),
							R = new il();
						function C(e, n, i) {
							const r = new Uint8Array(4),
								o = t.createTexture();
							t.bindTexture(e, o),
								t.texParameteri(e, 10241, 9728),
								t.texParameteri(e, 10240, 9728);
							for (let e = 0; e < i; e++)
								t.texImage2D(n + e, 0, 6408, 1, 1, 0, 6408, 5121, r);
							return o;
						}
						const O = {};
						function D(e) {
							!0 !== a[e] && (t.enable(e), (a[e] = !0));
						}
						function I(e) {
							!1 !== a[e] && (t.disable(e), (a[e] = !1));
						}
						(O[3553] = C(3553, 3553, 1)),
							(O[34067] = C(34067, 34069, 6)),
							r.setClear(0, 0, 0, 1),
							o.setClear(1),
							s.setClear(0),
							D(2929),
							o.setFunc(Us),
							F(!1),
							z(cs),
							D(2884),
							B(gs);
						const k = { [_s]: 32774, [Ms]: 32778, [Ss]: 32779 };
						if (i) (k[Ts] = 32775), (k[Es] = 32776);
						else {
							const t = e.get("EXT_blend_minmax");
							null !== t && ((k[Ts] = t.MIN_EXT), (k[Es] = t.MAX_EXT));
						}
						const N = {
							[As]: 0,
							[Ls]: 1,
							[Ps]: 768,
							[Cs]: 770,
							[Bs]: 776,
							[ks]: 774,
							[Ds]: 772,
							[Rs]: 769,
							[Os]: 771,
							[Ns]: 775,
							[Is]: 773,
						};
						function B(e, n, i, r, o, s, a, c) {
							if (e !== gs) {
								if ((l || (D(3042), (l = !0)), e === ws))
									(o = o || n),
										(s = s || i),
										(a = a || r),
										(n === u && o === f) ||
											(t.blendEquationSeparate(k[n], k[o]), (u = n), (f = o)),
										(i === d && r === p && s === m && a === g) ||
											(t.blendFuncSeparate(N[i], N[r], N[s], N[a]),
											(d = i),
											(p = r),
											(m = s),
											(g = a)),
										(h = e),
										(v = null);
								else if (e !== h || c !== v) {
									if (
										((u === _s && f === _s) ||
											(t.blendEquation(32774), (u = _s), (f = _s)),
										c)
									)
										switch (e) {
											case vs:
												t.blendFuncSeparate(1, 771, 1, 771);
												break;
											case ys:
												t.blendFunc(1, 1);
												break;
											case xs:
												t.blendFuncSeparate(0, 0, 769, 771);
												break;
											case bs:
												t.blendFuncSeparate(0, 768, 0, 770);
												break;
											default:
												console.error(
													"THREE.WebGLState: Invalid blending: ",
													e
												);
										}
									else
										switch (e) {
											case vs:
												t.blendFuncSeparate(770, 771, 1, 771);
												break;
											case ys:
												t.blendFunc(770, 1);
												break;
											case xs:
												t.blendFunc(0, 769);
												break;
											case bs:
												t.blendFunc(0, 768);
												break;
											default:
												console.error(
													"THREE.WebGLState: Invalid blending: ",
													e
												);
										}
									(d = null),
										(p = null),
										(m = null),
										(g = null),
										(h = e),
										(v = c);
								}
							} else l && (I(3042), (l = !1));
						}
						function F(e) {
							y !== e && (e ? t.frontFace(2304) : t.frontFace(2305), (y = e));
						}
						function z(e) {
							e !== as
								? (D(2884),
								  e !== x &&
										(e === cs
											? t.cullFace(1029)
											: e === ls
											? t.cullFace(1028)
											: t.cullFace(1032)))
								: I(2884),
								(x = e);
						}
						function H(e, n, i) {
							e
								? (D(32823),
								  (w === n && _ === i) ||
										(t.polygonOffset(n, i), (w = n), (_ = i)))
								: I(32823);
						}
						function U(e) {
							void 0 === e && (e = 33984 + M - 1),
								A !== e && (t.activeTexture(e), (A = e));
						}
						return {
							buffers: { color: r, depth: o, stencil: s },
							enable: D,
							disable: I,
							useProgram: function (e) {
								return c !== e && (t.useProgram(e), (c = e), !0);
							},
							setBlending: B,
							setMaterial: function (t, e) {
								t.side === ms ? I(2884) : D(2884);
								let n = t.side === fs;
								e && (n = !n),
									F(n),
									t.blending === vs && !1 === t.transparent
										? B(gs)
										: B(
												t.blending,
												t.blendEquation,
												t.blendSrc,
												t.blendDst,
												t.blendEquationAlpha,
												t.blendSrcAlpha,
												t.blendDstAlpha,
												t.premultipliedAlpha
										  ),
									o.setFunc(t.depthFunc),
									o.setTest(t.depthTest),
									o.setMask(t.depthWrite),
									r.setMask(t.colorWrite);
								const i = t.stencilWrite;
								s.setTest(i),
									i &&
										(s.setMask(t.stencilWriteMask),
										s.setFunc(t.stencilFunc, t.stencilRef, t.stencilFuncMask),
										s.setOp(t.stencilFail, t.stencilZFail, t.stencilZPass)),
									H(
										t.polygonOffset,
										t.polygonOffsetFactor,
										t.polygonOffsetUnits
									);
							},
							setFlipSided: F,
							setCullFace: z,
							setLineWidth: function (e) {
								e !== b && (S && t.lineWidth(e), (b = e));
							},
							setPolygonOffset: H,
							setScissorTest: function (t) {
								t ? D(3089) : I(3089);
							},
							activeTexture: U,
							bindTexture: function (e, n) {
								null === A && U();
								let i = L[A];
								void 0 === i &&
									((i = { type: void 0, texture: void 0 }), (L[A] = i)),
									(i.type === e && i.texture === n) ||
										(t.bindTexture(e, n || O[e]),
										(i.type = e),
										(i.texture = n));
							},
							unbindTexture: function () {
								const e = L[A];
								void 0 !== e &&
									void 0 !== e.type &&
									(t.bindTexture(e.type, null),
									(e.type = void 0),
									(e.texture = void 0));
							},
							compressedTexImage2D: function () {
								try {
									t.compressedTexImage2D.apply(t, arguments);
								} catch (t) {
									console.error("THREE.WebGLState:", t);
								}
							},
							texImage2D: function () {
								try {
									t.texImage2D.apply(t, arguments);
								} catch (t) {
									console.error("THREE.WebGLState:", t);
								}
							},
							texImage3D: function () {
								try {
									t.texImage3D.apply(t, arguments);
								} catch (t) {
									console.error("THREE.WebGLState:", t);
								}
							},
							scissor: function (e) {
								!1 === P.equals(e) &&
									(t.scissor(e.x, e.y, e.z, e.w), P.copy(e));
							},
							viewport: function (e) {
								!1 === R.equals(e) &&
									(t.viewport(e.x, e.y, e.z, e.w), R.copy(e));
							},
							reset: function () {
								(a = {}),
									(A = null),
									(L = {}),
									(c = null),
									(h = null),
									(y = null),
									(x = null),
									r.reset(),
									o.reset(),
									s.reset();
							},
						};
					})(at, G, V)).scissor(S.copy(O).multiplyScalar(L).floor()),
					j.viewport(M.copy(C).multiplyScalar(L).floor()),
					(W = new (function (t) {
						const e = { frame: 0, calls: 0, triangles: 0, points: 0, lines: 0 };
						return {
							memory: { geometries: 0, textures: 0 },
							render: e,
							programs: null,
							autoReset: !0,
							reset: function () {
								e.frame++,
									(e.calls = 0),
									(e.triangles = 0),
									(e.points = 0),
									(e.lines = 0);
							},
							update: function (t, n, i) {
								switch (((i = i || 1), e.calls++, n)) {
									case 4:
										e.triangles += i * (t / 3);
										break;
									case 1:
										e.lines += i * (t / 2);
										break;
									case 3:
										e.lines += i * (t - 1);
										break;
									case 2:
										e.lines += i * t;
										break;
									case 0:
										e.points += i * t;
										break;
									default:
										console.error("THREE.WebGLInfo: Unknown draw mode:", n);
								}
							},
						};
					})(at)),
					(q = new (function () {
						let t = new WeakMap();
						return {
							get: function (e) {
								let n = t.get(e);
								return void 0 === n && ((n = {}), t.set(e, n)), n;
							},
							remove: function (e) {
								t.delete(e);
							},
							update: function (e, n, i) {
								t.get(e)[n] = i;
							},
							dispose: function () {
								t = new WeakMap();
							},
						};
					})()),
					(Y = new Pp(at, G, j, q, V, ot, W)),
					(X = new qu(at, V)),
					(st = new Ku(at, G, X, V)),
					(Z = new (function (t, e, n, i) {
						const r = new WeakMap(),
							o = new WeakMap();
						function s(t) {
							const a = t.target,
								c = r.get(a);
							null !== c.index && e.remove(c.index);
							for (const t in c.attributes) e.remove(c.attributes[t]);
							a.removeEventListener("dispose", s), r.delete(a);
							const l = o.get(c);
							l && (e.remove(l), o.delete(c)),
								i.releaseStatesOfGeometry(a),
								!0 === a.isInstancedBufferGeometry &&
									delete a._maxInstanceCount,
								n.memory.geometries--;
						}
						function a(t) {
							const n = [],
								i = t.index,
								r = t.attributes.position;
							let s = 0;
							if (null !== i) {
								const t = i.array;
								s = i.version;
								for (let e = 0, i = t.length; e < i; e += 3) {
									const i = t[e + 0],
										r = t[e + 1],
										o = t[e + 2];
									n.push(i, r, r, o, o, i);
								}
							} else {
								const t = r.array;
								s = r.version;
								for (let e = 0, i = t.length / 3 - 1; e < i; e += 3) {
									const t = e + 0,
										i = e + 1,
										r = e + 2;
									n.push(t, i, i, r, r, t);
								}
							}
							const a = new (Yh(n) > 65535 ? Vh : Uh)(n, 1);
							a.version = s;
							const c = o.get(t);
							c && e.remove(c), o.set(t, a);
						}
						return {
							get: function (t, e) {
								let i = r.get(e);
								return (
									i ||
									(e.addEventListener("dispose", s),
									e.isBufferGeometry
										? (i = e)
										: e.isGeometry &&
										  (void 0 === e._bufferGeometry &&
												(e._bufferGeometry = new eu().setFromObject(t)),
										  (i = e._bufferGeometry)),
									r.set(e, i),
									n.memory.geometries++,
									i)
								);
							},
							update: function (t) {
								const n = t.attributes;
								for (const t in n) e.update(n[t], 34962);
								const i = t.morphAttributes;
								for (const t in i) {
									const n = i[t];
									for (let t = 0, i = n.length; t < i; t++)
										e.update(n[t], 34962);
								}
							},
							getWireframeAttribute: function (t) {
								const e = o.get(t);
								if (e) {
									const n = t.index;
									null !== n && e.version < n.version && a(t);
								} else a(t);
								return o.get(t);
							},
						};
					})(at, X, W, st)),
					(J = new (function (t, e, n, i) {
						let r = new WeakMap();
						return {
							update: function (t) {
								const o = i.render.frame,
									s = t.geometry,
									a = e.get(t, s);
								return (
									r.get(a) !== o &&
										(s.isGeometry && a.updateFromObject(t),
										e.update(a),
										r.set(a, o)),
									t.isInstancedMesh && n.update(t.instanceMatrix, 34962),
									a
								);
							},
							dispose: function () {
								r = new WeakMap();
							},
						};
					})(at, Z, X, W)),
					(nt = new (function (t) {
						const e = {},
							n = new Float32Array(8),
							i = [];
						for (let t = 0; t < 8; t++) i[t] = [t, 0];
						return {
							update: function (r, o, s, a) {
								const c = r.morphTargetInfluences,
									l = void 0 === c ? 0 : c.length;
								let h = e[o.id];
								if (void 0 === h) {
									h = [];
									for (let t = 0; t < l; t++) h[t] = [t, 0];
									e[o.id] = h;
								}
								for (let t = 0; t < l; t++) {
									const e = h[t];
									(e[0] = t), (e[1] = c[t]);
								}
								h.sort($u);
								for (let t = 0; t < 8; t++)
									t < l && h[t][1]
										? ((i[t][0] = h[t][0]), (i[t][1] = h[t][1]))
										: ((i[t][0] = Number.MAX_SAFE_INTEGER), (i[t][1] = 0));
								i.sort(Qu);
								const u = s.morphTargets && o.morphAttributes.position,
									d = s.morphNormals && o.morphAttributes.normal;
								let p = 0;
								for (let t = 0; t < 8; t++) {
									const e = i[t],
										r = e[0],
										s = e[1];
									r !== Number.MAX_SAFE_INTEGER && s
										? (u &&
												o.getAttribute("morphTarget" + t) !== u[r] &&
												o.setAttribute("morphTarget" + t, u[r]),
										  d &&
												o.getAttribute("morphNormal" + t) !== d[r] &&
												o.setAttribute("morphNormal" + t, d[r]),
										  (n[t] = s),
										  (p += s))
										: (u &&
												void 0 !== o.getAttribute("morphTarget" + t) &&
												o.deleteAttribute("morphTarget" + t),
										  d &&
												void 0 !== o.getAttribute("morphNormal" + t) &&
												o.deleteAttribute("morphNormal" + t),
										  (n[t] = 0));
								}
								const f = o.morphTargetsRelative ? 1 : 1 - p;
								a.getUniforms().setValue(t, "morphTargetBaseInfluence", f),
									a.getUniforms().setValue(t, "morphTargetInfluences", n);
							},
						};
					})(at)),
					(K = new gp(p, G, V, st)),
					(Q = new Ip(q)),
					($ = new (function () {
						let t = new WeakMap();
						function e(n) {
							const i = n.target;
							i.removeEventListener("dispose", e), t.delete(i);
						}
						return {
							get: function (n, i) {
								const r = t.get(n);
								let o;
								return (
									void 0 === r
										? ((o = new xp()),
										  t.set(n, new WeakMap()),
										  t.get(n).set(i, o),
										  n.addEventListener("dispose", e))
										: void 0 === (o = r.get(i)) &&
										  ((o = new xp()), r.set(i, o)),
									o
								);
							},
							dispose: function () {
								t = new WeakMap();
							},
						};
					})()),
					(tt = new (function () {
						let t = new WeakMap();
						function e(n) {
							const i = n.target;
							i.removeEventListener("dispose", e), t.delete(i);
						}
						return {
							get: function (n, i) {
								let r;
								return (
									!1 === t.has(n)
										? ((r = new Mp()),
										  t.set(n, new WeakMap()),
										  t.get(n).set(i, r),
										  n.addEventListener("dispose", e))
										: !1 === t.get(n).has(i)
										? ((r = new Mp()), t.get(n).set(i, r))
										: (r = t.get(n).get(i)),
									r
								);
							},
							dispose: function () {
								t = new WeakMap();
							},
						};
					})()),
					(et = new (function (t, e, n, i) {
						const r = new Eh(0);
						let o,
							s,
							a = 0,
							c = null,
							l = 0,
							h = null;
						function u(t, n) {
							e.buffers.color.setClear(t.r, t.g, t.b, n, i);
						}
						return {
							getClearColor: function () {
								return r;
							},
							setClearColor: function (t, e) {
								r.set(t), u(r, (a = void 0 !== e ? e : 1));
							},
							getClearAlpha: function () {
								return a;
							},
							setClearAlpha: function (t) {
								u(r, (a = t));
							},
							render: function (e, i, d, p) {
								let f = !0 === i.isScene ? i.background : null;
								const m = t.xr,
									g = m.getSession && m.getSession();
								if (
									(g && "additive" === g.environmentBlendMode && (f = null),
									null === f ? u(r, a) : f && f.isColor && (u(f, 1), (p = !0)),
									(t.autoClear || p) &&
										t.clear(
											t.autoClearColor,
											t.autoClearDepth,
											t.autoClearStencil
										),
									f &&
										(f.isCubeTexture ||
											f.isWebGLCubeRenderTarget ||
											f.mapping === oa))
								) {
									void 0 === s &&
										((s = new xu(
											new Au(1, 1, 1),
											new Du({
												name: "BackgroundCubeMaterial",
												uniforms: Lu(Ju.cube.uniforms),
												vertexShader: Ju.cube.vertexShader,
												fragmentShader: Ju.cube.fragmentShader,
												side: fs,
												depthTest: !1,
												depthWrite: !1,
												fog: !1,
											})
										)).geometry.deleteAttribute("normal"),
										s.geometry.deleteAttribute("uv"),
										(s.onBeforeRender = function (t, e, n) {
											this.matrixWorld.copyPosition(n.matrixWorld);
										}),
										Object.defineProperty(s.material, "envMap", {
											get: function () {
												return this.uniforms.envMap.value;
											},
										}),
										n.update(s));
									const i = f.isWebGLCubeRenderTarget ? f.texture : f;
									(s.material.uniforms.envMap.value = i),
										(s.material.uniforms.flipEnvMap.value = i.isCubeTexture
											? -1
											: 1),
										(c === f && l === i.version && h === t.toneMapping) ||
											((s.material.needsUpdate = !0),
											(c = f),
											(l = i.version),
											(h = t.toneMapping)),
										e.unshift(s, s.geometry, s.material, 0, 0, null);
								} else
									f &&
										f.isTexture &&
										(void 0 === o &&
											((o = new xu(
												new Xu(2, 2),
												new Du({
													name: "BackgroundMaterial",
													uniforms: Lu(Ju.background.uniforms),
													vertexShader: Ju.background.vertexShader,
													fragmentShader: Ju.background.fragmentShader,
													side: ps,
													depthTest: !1,
													depthWrite: !1,
													fog: !1,
												})
											)).geometry.deleteAttribute("normal"),
											Object.defineProperty(o.material, "map", {
												get: function () {
													return this.uniforms.t2D.value;
												},
											}),
											n.update(o)),
										(o.material.uniforms.t2D.value = f),
										!0 === f.matrixAutoUpdate && f.updateMatrix(),
										o.material.uniforms.uvTransform.value.copy(f.matrix),
										(c === f && l === f.version && h === t.toneMapping) ||
											((o.material.needsUpdate = !0),
											(c = f),
											(l = f.version),
											(h = t.toneMapping)),
										e.unshift(o, o.geometry, o.material, 0, 0, null));
							},
						};
					})(p, j, J, a)),
					(it = new (function (t, e, n, i) {
						const r = i.isWebGL2;
						let o;
						(this.setMode = function (t) {
							o = t;
						}),
							(this.render = function (e, i) {
								t.drawArrays(o, e, i), n.update(i, o);
							}),
							(this.renderInstances = function (i, s, a, c) {
								if (0 === c) return;
								let l, h;
								if (r) (l = t), (h = "drawArraysInstanced");
								else if (
									((h = "drawArraysInstancedANGLE"),
									null === (l = e.get("ANGLE_instanced_arrays")))
								)
									return void console.error(
										"THREE.WebGLBufferRenderer: using THREE.InstancedBufferGeometry but hardware does not support extension ANGLE_instanced_arrays."
									);
								l[h](o, s, a, c), n.update(a, o, c);
							});
					})(at, G, W, V)),
					(rt = new (function (t, e, n, i) {
						const r = i.isWebGL2;
						let o, s, a;
						(this.setMode = function (t) {
							o = t;
						}),
							(this.setIndex = function (t) {
								(s = t.type), (a = t.bytesPerElement);
							}),
							(this.render = function (e, i) {
								t.drawElements(o, i, s, e * a), n.update(i, o);
							}),
							(this.renderInstances = function (i, c, l, h) {
								if (0 === h) return;
								let u, d;
								if (r) (u = t), (d = "drawElementsInstanced");
								else if (
									((d = "drawElementsInstancedANGLE"),
									null === (u = e.get("ANGLE_instanced_arrays")))
								)
									return void console.error(
										"THREE.WebGLIndexedBufferRenderer: using THREE.InstancedBufferGeometry but hardware does not support extension ANGLE_instanced_arrays."
									);
								u[d](o, l, s, c * a, h), n.update(l, o, h);
							});
					})(at, G, W, V)),
					(W.programs = K.programs),
					(p.capabilities = V),
					(p.extensions = G),
					(p.properties = q),
					(p.renderLists = $),
					(p.state = j),
					(p.info = W);
			}
			lt();
			const ht = new Dp(p, at);
			this.xr = ht;
			const ut = new Lp(p, J, V.maxTextureSize);
			function dt(t) {
				t.preventDefault(),
					console.log("THREE.WebGLRenderer: Context Lost."),
					(f = !0);
			}
			function pt() {
				console.log("THREE.WebGLRenderer: Context Restored."), (f = !1), lt();
			}
			function ft(t) {
				const e = t.target;
				e.removeEventListener("dispose", ft),
					(function (t) {
						mt(t), q.remove(t);
					})(e);
			}
			function mt(t) {
				const e = q.get(t).program;
				(t.program = void 0), void 0 !== e && K.releaseProgram(e);
			}
			(this.shadowMap = ut),
				(this.getContext = function () {
					return at;
				}),
				(this.getContextAttributes = function () {
					return at.getContextAttributes();
				}),
				(this.forceContextLoss = function () {
					const t = G.get("WEBGL_lose_context");
					t && t.loseContext();
				}),
				(this.forceContextRestore = function () {
					const t = G.get("WEBGL_lose_context");
					t && t.restoreContext();
				}),
				(this.getPixelRatio = function () {
					return L;
				}),
				(this.setPixelRatio = function (t) {
					void 0 !== t && ((L = t), this.setSize(E, A, !1));
				}),
				(this.getSize = function (t) {
					return (
						void 0 === t &&
							(console.warn(
								"WebGLRenderer: .getsize() now requires a Vector2 as an argument"
							),
							(t = new Kc())),
						t.set(E, A)
					);
				}),
				(this.setSize = function (t, n, i) {
					ht.isPresenting
						? console.warn(
								"THREE.WebGLRenderer: Can't change size while VR device is presenting."
						  )
						: ((E = t),
						  (A = n),
						  (e.width = Math.floor(t * L)),
						  (e.height = Math.floor(n * L)),
						  !1 !== i &&
								((e.style.width = t + "px"), (e.style.height = n + "px")),
						  this.setViewport(0, 0, t, n));
				}),
				(this.getDrawingBufferSize = function (t) {
					return (
						void 0 === t &&
							(console.warn(
								"WebGLRenderer: .getdrawingBufferSize() now requires a Vector2 as an argument"
							),
							(t = new Kc())),
						t.set(E * L, A * L).floor()
					);
				}),
				(this.setDrawingBufferSize = function (t, n, i) {
					(E = t),
						(A = n),
						(L = i),
						(e.width = Math.floor(t * i)),
						(e.height = Math.floor(n * i)),
						this.setViewport(0, 0, t, n);
				}),
				(this.getCurrentViewport = function (t) {
					return (
						void 0 === t &&
							(console.warn(
								"WebGLRenderer: .getCurrentViewport() now requires a Vector4 as an argument"
							),
							(t = new il())),
						t.copy(M)
					);
				}),
				(this.getViewport = function (t) {
					return t.copy(C);
				}),
				(this.setViewport = function (t, e, n, i) {
					t.isVector4 ? C.set(t.x, t.y, t.z, t.w) : C.set(t, e, n, i),
						j.viewport(M.copy(C).multiplyScalar(L).floor());
				}),
				(this.getScissor = function (t) {
					return t.copy(O);
				}),
				(this.setScissor = function (t, e, n, i) {
					t.isVector4 ? O.set(t.x, t.y, t.z, t.w) : O.set(t, e, n, i),
						j.scissor(S.copy(O).multiplyScalar(L).floor());
				}),
				(this.getScissorTest = function () {
					return D;
				}),
				(this.setScissorTest = function (t) {
					j.setScissorTest((D = t));
				}),
				(this.setOpaqueSort = function (t) {
					P = t;
				}),
				(this.setTransparentSort = function (t) {
					R = t;
				}),
				(this.getClearColor = function () {
					return et.getClearColor();
				}),
				(this.setClearColor = function () {
					et.setClearColor.apply(et, arguments);
				}),
				(this.getClearAlpha = function () {
					return et.getClearAlpha();
				}),
				(this.setClearAlpha = function () {
					et.setClearAlpha.apply(et, arguments);
				}),
				(this.clear = function (t, e, n) {
					let i = 0;
					(void 0 === t || t) && (i |= 16384),
						(void 0 === e || e) && (i |= 256),
						(void 0 === n || n) && (i |= 1024),
						at.clear(i);
				}),
				(this.clearColor = function () {
					this.clear(!0, !1, !1);
				}),
				(this.clearDepth = function () {
					this.clear(!1, !0, !1);
				}),
				(this.clearStencil = function () {
					this.clear(!1, !1, !0);
				}),
				(this.dispose = function () {
					e.removeEventListener("webglcontextlost", dt, !1),
						e.removeEventListener("webglcontextrestored", pt, !1),
						$.dispose(),
						tt.dispose(),
						q.dispose(),
						J.dispose(),
						st.dispose(),
						ht.dispose(),
						vt.stop();
				}),
				(this.renderBufferImmediate = function (t, e) {
					st.initAttributes();
					const n = q.get(t);
					t.hasPositions && !n.position && (n.position = at.createBuffer()),
						t.hasNormals && !n.normal && (n.normal = at.createBuffer()),
						t.hasUvs && !n.uv && (n.uv = at.createBuffer()),
						t.hasColors && !n.color && (n.color = at.createBuffer());
					const i = e.getAttributes();
					t.hasPositions &&
						(at.bindBuffer(34962, n.position),
						at.bufferData(34962, t.positionArray, 35048),
						st.enableAttribute(i.position),
						at.vertexAttribPointer(i.position, 3, 5126, !1, 0, 0)),
						t.hasNormals &&
							(at.bindBuffer(34962, n.normal),
							at.bufferData(34962, t.normalArray, 35048),
							st.enableAttribute(i.normal),
							at.vertexAttribPointer(i.normal, 3, 5126, !1, 0, 0)),
						t.hasUvs &&
							(at.bindBuffer(34962, n.uv),
							at.bufferData(34962, t.uvArray, 35048),
							st.enableAttribute(i.uv),
							at.vertexAttribPointer(i.uv, 2, 5126, !1, 0, 0)),
						t.hasColors &&
							(at.bindBuffer(34962, n.color),
							at.bufferData(34962, t.colorArray, 35048),
							st.enableAttribute(i.color),
							at.vertexAttribPointer(i.color, 3, 5126, !1, 0, 0)),
						st.disableUnusedAttributes(),
						at.drawArrays(4, 0, t.count),
						(t.count = 0);
				}),
				(this.renderBufferDirect = function (t, e, n, i, r, o) {
					null === e && (e = H);
					const s = r.isMesh && r.matrixWorld.determinant() < 0,
						a = wt(t, e, i, r);
					j.setMaterial(i, s);
					let c = n.index;
					const l = n.attributes.position;
					if (null === c) {
						if (void 0 === l || 0 === l.count) return;
					} else if (0 === c.count) return;
					let h,
						u = 1;
					!0 === i.wireframe && ((c = Z.getWireframeAttribute(n)), (u = 2)),
						(i.morphTargets || i.morphNormals) && nt.update(r, n, i, a),
						st.setup(r, i, a, n, c);
					let d = it;
					null !== c && ((h = X.get(c)), (d = rt).setIndex(h));
					const p = null !== c ? c.count : l.count,
						f = n.drawRange.start * u,
						m = n.drawRange.count * u,
						g = null !== o ? o.start * u : 0,
						v = null !== o ? o.count * u : 1 / 0,
						y = Math.max(f, g),
						x = Math.min(p, f + m, g + v) - 1,
						b = Math.max(0, x - y + 1);
					if (0 !== b) {
						if (r.isMesh)
							!0 === i.wireframe
								? (j.setLineWidth(i.wireframeLinewidth * U()), d.setMode(1))
								: d.setMode(4);
						else if (r.isLine) {
							let t = i.linewidth;
							void 0 === t && (t = 1),
								j.setLineWidth(t * U()),
								r.isLineSegments
									? d.setMode(1)
									: r.isLineLoop
									? d.setMode(2)
									: d.setMode(3);
						} else r.isPoints ? d.setMode(0) : r.isSprite && d.setMode(4);
						if (r.isInstancedMesh) d.renderInstances(n, y, b, r.count);
						else if (n.isInstancedBufferGeometry) {
							const t = Math.min(n.instanceCount, n._maxInstanceCount);
							d.renderInstances(n, y, b, t);
						} else d.render(y, b);
					}
				}),
				(this.compile = function (t, e) {
					(d = tt.get(t, e)).init(),
						t.traverse(function (t) {
							t.isLight && (d.pushLight(t), t.castShadow && d.pushShadow(t));
						}),
						d.setupLights(e);
					const n = new WeakMap();
					t.traverse(function (e) {
						let i = e.material;
						if (i)
							if (Array.isArray(i))
								for (let r = 0; r < i.length; r++) {
									let o = i[r];
									!1 === n.has(o) && (bt(o, t, e), n.set(o));
								}
							else !1 === n.has(i) && (bt(i, t, e), n.set(i));
					});
				});
			let gt = null;
			const vt = new Wu();
			function yt(t, e, n) {
				const i = !0 === e.isScene ? e.overrideMaterial : null;
				for (let r = 0, o = t.length; r < o; r++) {
					const o = t[r],
						s = o.object,
						a = o.geometry,
						c = null === i ? o.material : i,
						l = o.group;
					if (n.isArrayCamera) {
						_ = n;
						const t = n.cameras;
						for (let n = 0, i = t.length; n < i; n++) {
							const i = t[n];
							s.layers.test(i.layers) &&
								(j.viewport(M.copy(i.viewport)),
								d.setupLights(i),
								xt(s, e, i, a, c, l));
						}
					} else (_ = null), xt(s, e, n, a, c, l);
				}
			}
			function xt(t, e, n, i, r, o) {
				if (
					(t.onBeforeRender(p, e, n, i, r, o),
					(d = tt.get(e, _ || n)),
					t.modelViewMatrix.multiplyMatrices(
						n.matrixWorldInverse,
						t.matrixWorld
					),
					t.normalMatrix.getNormalMatrix(t.modelViewMatrix),
					t.isImmediateRenderObject)
				) {
					const i = wt(n, e, r, t);
					j.setMaterial(r),
						st.reset(),
						(function (t, e) {
							t.render(function (t) {
								p.renderBufferImmediate(t, e);
							});
						})(t, i);
				} else p.renderBufferDirect(n, e, i, r, t, o);
				t.onAfterRender(p, e, n, i, r, o), (d = tt.get(e, _ || n));
			}
			function bt(t, e, n) {
				!0 !== e.isScene && (e = H);
				const i = q.get(t),
					r = d.state.lights,
					o = d.state.shadowsArray,
					s = r.state.version,
					a = K.getParameters(
						t,
						r.state,
						o,
						e,
						k.numPlanes,
						k.numIntersection,
						n
					),
					c = K.getProgramCacheKey(a);
				let l = i.program,
					h = !0;
				if (void 0 === l) t.addEventListener("dispose", ft);
				else if (l.cacheKey !== c) mt(t);
				else if (i.lightsStateVersion !== s)
					(i.lightsStateVersion = s), (h = !1);
				else {
					if (void 0 !== a.shaderID) return;
					h = !1;
				}
				h &&
					((l = K.acquireProgram(a, c)),
					(i.program = l),
					(i.uniforms = a.uniforms),
					(i.outputEncoding = a.outputEncoding),
					(t.program = l));
				const u = l.getAttributes();
				if (t.morphTargets) {
					t.numSupportedMorphTargets = 0;
					for (let e = 0; e < p.maxMorphTargets; e++)
						u["morphTarget" + e] >= 0 && t.numSupportedMorphTargets++;
				}
				if (t.morphNormals) {
					t.numSupportedMorphNormals = 0;
					for (let e = 0; e < p.maxMorphNormals; e++)
						u["morphNormal" + e] >= 0 && t.numSupportedMorphNormals++;
				}
				const f = i.uniforms;
				((t.isShaderMaterial || t.isRawShaderMaterial) && !0 !== t.clipping) ||
					((i.numClippingPlanes = k.numPlanes),
					(i.numIntersection = k.numIntersection),
					(f.clippingPlanes = k.uniform)),
					(i.environment = t.isMeshStandardMaterial ? e.environment : null),
					(i.fog = e.fog),
					(i.needsLights = (function (t) {
						return (
							t.isMeshLambertMaterial ||
							t.isMeshToonMaterial ||
							t.isMeshPhongMaterial ||
							t.isMeshStandardMaterial ||
							t.isShadowMaterial ||
							(t.isShaderMaterial && !0 === t.lights)
						);
					})(t)),
					(i.lightsStateVersion = s),
					i.needsLights &&
						((f.ambientLightColor.value = r.state.ambient),
						(f.lightProbe.value = r.state.probe),
						(f.directionalLights.value = r.state.directional),
						(f.directionalLightShadows.value = r.state.directionalShadow),
						(f.spotLights.value = r.state.spot),
						(f.spotLightShadows.value = r.state.spotShadow),
						(f.rectAreaLights.value = r.state.rectArea),
						(f.pointLights.value = r.state.point),
						(f.pointLightShadows.value = r.state.pointShadow),
						(f.hemisphereLights.value = r.state.hemi),
						(f.directionalShadowMap.value = r.state.directionalShadowMap),
						(f.directionalShadowMatrix.value = r.state.directionalShadowMatrix),
						(f.spotShadowMap.value = r.state.spotShadowMap),
						(f.spotShadowMatrix.value = r.state.spotShadowMatrix),
						(f.pointShadowMap.value = r.state.pointShadowMap),
						(f.pointShadowMatrix.value = r.state.pointShadowMatrix));
				const m = i.program.getUniforms(),
					g = Kd.seqWithValue(m.seq, f);
				i.uniformsList = g;
			}
			function wt(t, e, n, i) {
				!0 !== e.isScene && (e = H), Y.resetTextureUnits();
				const r = e.fog,
					o = n.isMeshStandardMaterial ? e.environment : null,
					s = null === y ? p.outputEncoding : y.texture.encoding,
					a = q.get(n),
					c = d.state.lights;
				if (!0 === N && (!0 === B || t !== w)) {
					const e = t === w && n.id === b;
					k.setState(
						n.clippingPlanes,
						n.clipIntersection,
						n.clipShadows,
						t,
						a,
						e
					);
				}
				n.version === a.__version
					? void 0 === a.program
						? bt(n, e, i)
						: n.fog && a.fog !== r
						? bt(n, e, i)
						: a.environment !== o
						? bt(n, e, i)
						: a.needsLights && a.lightsStateVersion !== c.state.version
						? bt(n, e, i)
						: void 0 === a.numClippingPlanes ||
						  (a.numClippingPlanes === k.numPlanes &&
								a.numIntersection === k.numIntersection)
						? a.outputEncoding !== s && bt(n, e, i)
						: bt(n, e, i)
					: (bt(n, e, i), (a.__version = n.version));
				let l = !1,
					h = !1,
					u = !1;
				const f = a.program,
					m = f.getUniforms(),
					g = a.uniforms;
				if (
					(j.useProgram(f.program) && ((l = !0), (h = !0), (u = !0)),
					n.id !== b && ((b = n.id), (h = !0)),
					l || w !== t)
				) {
					if (
						(m.setValue(at, "projectionMatrix", t.projectionMatrix),
						V.logarithmicDepthBuffer &&
							m.setValue(
								at,
								"logDepthBufFC",
								2 / (Math.log(t.far + 1) / Math.LN2)
							),
						w !== t && ((w = t), (h = !0), (u = !0)),
						n.isShaderMaterial ||
							n.isMeshPhongMaterial ||
							n.isMeshToonMaterial ||
							n.isMeshStandardMaterial ||
							n.envMap)
					) {
						const e = m.map.cameraPosition;
						void 0 !== e &&
							e.setValue(at, z.setFromMatrixPosition(t.matrixWorld));
					}
					(n.isMeshPhongMaterial ||
						n.isMeshToonMaterial ||
						n.isMeshLambertMaterial ||
						n.isMeshBasicMaterial ||
						n.isMeshStandardMaterial ||
						n.isShaderMaterial) &&
						m.setValue(at, "isOrthographic", !0 === t.isOrthographicCamera),
						(n.isMeshPhongMaterial ||
							n.isMeshToonMaterial ||
							n.isMeshLambertMaterial ||
							n.isMeshBasicMaterial ||
							n.isMeshStandardMaterial ||
							n.isShaderMaterial ||
							n.isShadowMaterial ||
							n.skinning) &&
							m.setValue(at, "viewMatrix", t.matrixWorldInverse);
				}
				if (n.skinning) {
					m.setOptional(at, i, "bindMatrix"),
						m.setOptional(at, i, "bindMatrixInverse");
					const t = i.skeleton;
					if (t) {
						const e = t.bones;
						if (V.floatVertexTextures) {
							if (void 0 === t.boneTexture) {
								let n = Math.sqrt(4 * e.length);
								(n = Jc.ceilPowerOfTwo(n)), (n = Math.max(n, 4));
								const i = new Float32Array(n * n * 4);
								i.set(t.boneMatrices);
								const r = new Hu(i, n, n, Ra, _a);
								(t.boneMatrices = i),
									(t.boneTexture = r),
									(t.boneTextureSize = n);
							}
							m.setValue(at, "boneTexture", t.boneTexture, Y),
								m.setValue(at, "boneTextureSize", t.boneTextureSize);
						} else m.setOptional(at, t, "boneMatrices");
					}
				}
				var v, x;
				return (
					(h || a.receiveShadow !== i.receiveShadow) &&
						((a.receiveShadow = i.receiveShadow),
						m.setValue(at, "receiveShadow", i.receiveShadow)),
					h &&
						(m.setValue(at, "toneMappingExposure", p.toneMappingExposure),
						a.needsLights &&
							((x = u),
							((v = g).ambientLightColor.needsUpdate = x),
							(v.lightProbe.needsUpdate = x),
							(v.directionalLights.needsUpdate = x),
							(v.directionalLightShadows.needsUpdate = x),
							(v.pointLights.needsUpdate = x),
							(v.pointLightShadows.needsUpdate = x),
							(v.spotLights.needsUpdate = x),
							(v.spotLightShadows.needsUpdate = x),
							(v.rectAreaLights.needsUpdate = x),
							(v.hemisphereLights.needsUpdate = x)),
						r && n.fog && Q.refreshFogUniforms(g, r),
						Q.refreshMaterialUniforms(g, n, o, L, A),
						void 0 !== g.ltc_1 && (g.ltc_1.value = ju.LTC_1),
						void 0 !== g.ltc_2 && (g.ltc_2.value = ju.LTC_2),
						Kd.upload(at, a.uniformsList, g, Y)),
					n.isShaderMaterial &&
						!0 === n.uniformsNeedUpdate &&
						(Kd.upload(at, a.uniformsList, g, Y), (n.uniformsNeedUpdate = !1)),
					n.isSpriteMaterial && m.setValue(at, "center", i.center),
					m.setValue(at, "modelViewMatrix", i.modelViewMatrix),
					m.setValue(at, "normalMatrix", i.normalMatrix),
					m.setValue(at, "modelMatrix", i.matrixWorld),
					f
				);
			}
			vt.setAnimationLoop(function (t) {
				ht.isPresenting || (gt && gt(t));
			}),
				"undefined" != typeof window && vt.setContext(window),
				(this.setAnimationLoop = function (t) {
					(gt = t), ht.setAnimationLoop(t), null === t ? vt.stop() : vt.start();
				}),
				(this.render = function (t, e) {
					let n, i;
					if (
						(void 0 !== arguments[2] &&
							(console.warn(
								"THREE.WebGLRenderer.render(): the renderTarget argument has been removed. Use .setRenderTarget() instead."
							),
							(n = arguments[2])),
						void 0 !== arguments[3] &&
							(console.warn(
								"THREE.WebGLRenderer.render(): the forceClear argument has been removed. Use .clear() instead."
							),
							(i = arguments[3])),
						void 0 !== e && !0 !== e.isCamera)
					)
						return void console.error(
							"THREE.WebGLRenderer.render: camera is not an instance of THREE.Camera."
						);
					if (!0 === f) return;
					st.resetDefaultState(),
						(b = -1),
						(w = null),
						!0 === t.autoUpdate && t.updateMatrixWorld(),
						null === e.parent && e.updateMatrixWorld(),
						!0 === ht.enabled &&
							!0 === ht.isPresenting &&
							(e = ht.getCamera(e)),
						!0 === t.isScene && t.onBeforeRender(p, t, e, n || y),
						(d = tt.get(t, e)).init(),
						F.multiplyMatrices(e.projectionMatrix, e.matrixWorldInverse),
						I.setFromProjectionMatrix(F),
						(B = this.localClippingEnabled),
						(N = k.init(this.clippingPlanes, B, e)),
						(u = $.get(t, e)).init(),
						(function t(e, n, i, r) {
							if (!1 === e.visible) return;
							const o = e.layers.test(n.layers);
							if (o)
								if (e.isGroup) i = e.renderOrder;
								else if (e.isLOD) !0 === e.autoUpdate && e.update(n);
								else if (e.isLight)
									d.pushLight(e), e.castShadow && d.pushShadow(e);
								else if (e.isSprite) {
									if (!e.frustumCulled || I.intersectsSprite(e)) {
										r && z.setFromMatrixPosition(e.matrixWorld).applyMatrix4(F);
										const t = J.update(e),
											n = e.material;
										n.visible && u.push(e, t, n, i, z.z, null);
									}
								} else if (e.isImmediateRenderObject)
									r && z.setFromMatrixPosition(e.matrixWorld).applyMatrix4(F),
										u.push(e, null, e.material, i, z.z, null);
								else if (
									(e.isMesh || e.isLine || e.isPoints) &&
									(e.isSkinnedMesh &&
										e.skeleton.frame !== W.render.frame &&
										(e.skeleton.update(), (e.skeleton.frame = W.render.frame)),
									!e.frustumCulled || I.intersectsObject(e))
								) {
									r && z.setFromMatrixPosition(e.matrixWorld).applyMatrix4(F);
									const t = J.update(e),
										n = e.material;
									if (Array.isArray(n)) {
										const r = t.groups;
										for (let o = 0, s = r.length; o < s; o++) {
											const s = r[o],
												a = n[s.materialIndex];
											a && a.visible && u.push(e, t, a, i, z.z, s);
										}
									} else n.visible && u.push(e, t, n, i, z.z, null);
								}
							const s = e.children;
							for (let e = 0, o = s.length; e < o; e++) t(s[e], n, i, r);
						})(t, e, 0, p.sortObjects),
						u.finish(),
						!0 === p.sortObjects && u.sort(P, R),
						!0 === N && k.beginShadows();
					const r = d.state.shadowsArray;
					ut.render(r, t, e),
						d.setupLights(e),
						!0 === N && k.endShadows(),
						!0 === this.info.autoReset && this.info.reset(),
						void 0 !== n && this.setRenderTarget(n),
						et.render(u, t, e, i);
					const o = u.opaque,
						s = u.transparent;
					o.length > 0 && yt(o, t, e),
						s.length > 0 && yt(s, t, e),
						!0 === t.isScene && t.onAfterRender(p, t, e),
						null !== y &&
							(Y.updateRenderTargetMipmap(y),
							Y.updateMultisampleRenderTarget(y)),
						j.buffers.depth.setTest(!0),
						j.buffers.depth.setMask(!0),
						j.buffers.color.setMask(!0),
						j.setPolygonOffset(!1),
						(u = null),
						(d = null);
				}),
				(this.setFramebuffer = function (t) {
					m !== t && null === y && at.bindFramebuffer(36160, t), (m = t);
				}),
				(this.getActiveCubeFace = function () {
					return g;
				}),
				(this.getActiveMipmapLevel = function () {
					return v;
				}),
				(this.getRenderTarget = function () {
					return y;
				}),
				(this.setRenderTarget = function (t, e, n) {
					(y = t),
						(g = e),
						(v = n),
						t &&
							void 0 === q.get(t).__webglFramebuffer &&
							Y.setupRenderTarget(t);
					let i = m,
						r = !1;
					if (t) {
						const n = q.get(t).__webglFramebuffer;
						t.isWebGLCubeRenderTarget
							? ((i = n[e || 0]), (r = !0))
							: (i = t.isWebGLMultisampleRenderTarget
									? q.get(t).__webglMultisampledFramebuffer
									: n),
							M.copy(t.viewport),
							S.copy(t.scissor),
							(T = t.scissorTest);
					} else
						M.copy(C).multiplyScalar(L).floor(),
							S.copy(O).multiplyScalar(L).floor(),
							(T = D);
					if (
						(x !== i && (at.bindFramebuffer(36160, i), (x = i)),
						j.viewport(M),
						j.scissor(S),
						j.setScissorTest(T),
						r)
					) {
						const i = q.get(t.texture);
						at.framebufferTexture2D(
							36160,
							36064,
							34069 + (e || 0),
							i.__webglTexture,
							n || 0
						);
					}
				}),
				(this.readRenderTargetPixels = function (t, e, n, i, r, o, s) {
					if (!t || !t.isWebGLRenderTarget)
						return void console.error(
							"THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not THREE.WebGLRenderTarget."
						);
					let a = q.get(t).__webglFramebuffer;
					if ((t.isWebGLCubeRenderTarget && void 0 !== s && (a = a[s]), a)) {
						let s = !1;
						a !== x && (at.bindFramebuffer(36160, a), (s = !0));
						try {
							const a = t.texture,
								c = a.format,
								l = a.type;
							if (c !== Ra && ot.convert(c) !== at.getParameter(35739))
								return void console.error(
									"THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in RGBA or implementation defined format."
								);
							if (
								!(
									l === ga ||
									ot.convert(l) === at.getParameter(35738) ||
									(l === _a &&
										(V.isWebGL2 ||
											G.get("OES_texture_float") ||
											G.get("WEBGL_color_buffer_float"))) ||
									(l === Ma &&
										(V.isWebGL2
											? G.get("EXT_color_buffer_float")
											: G.get("EXT_color_buffer_half_float")))
								)
							)
								return void console.error(
									"THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in UnsignedByteType or implementation defined type."
								);
							36053 === at.checkFramebufferStatus(36160)
								? e >= 0 &&
								  e <= t.width - i &&
								  n >= 0 &&
								  n <= t.height - r &&
								  at.readPixels(e, n, i, r, ot.convert(c), ot.convert(l), o)
								: console.error(
										"THREE.WebGLRenderer.readRenderTargetPixels: readPixels from renderTarget failed. Framebuffer not complete."
								  );
						} finally {
							s && at.bindFramebuffer(36160, x);
						}
					}
				}),
				(this.copyFramebufferToTexture = function (t, e, n) {
					void 0 === n && (n = 0);
					const i = Math.pow(2, -n),
						r = Math.floor(e.image.width * i),
						o = Math.floor(e.image.height * i),
						s = ot.convert(e.format);
					Y.setTexture2D(e, 0),
						at.copyTexImage2D(3553, n, s, t.x, t.y, r, o, 0),
						j.unbindTexture();
				}),
				(this.copyTextureToTexture = function (t, e, n, i) {
					void 0 === i && (i = 0);
					const r = e.image.width,
						o = e.image.height,
						s = ot.convert(n.format),
						a = ot.convert(n.type);
					Y.setTexture2D(n, 0),
						at.pixelStorei(37440, n.flipY),
						at.pixelStorei(37441, n.premultiplyAlpha),
						at.pixelStorei(3317, n.unpackAlignment),
						e.isDataTexture
							? at.texSubImage2D(3553, i, t.x, t.y, r, o, s, a, e.image.data)
							: e.isCompressedTexture
							? at.compressedTexSubImage2D(
									3553,
									i,
									t.x,
									t.y,
									e.mipmaps[0].width,
									e.mipmaps[0].height,
									s,
									e.mipmaps[0].data
							  )
							: at.texSubImage2D(3553, i, t.x, t.y, s, a, e.image),
						0 === i && n.generateMipmaps && at.generateMipmap(3553),
						j.unbindTexture();
				}),
				(this.initTexture = function (t) {
					Y.setTexture2D(t, 0), j.unbindTexture();
				}),
				"undefined" != typeof __THREE_DEVTOOLS__ &&
					__THREE_DEVTOOLS__.dispatchEvent(
						new CustomEvent("observe", { detail: this })
					);
		}
		function Np(t) {
			kp.call(this, t);
		}
		function Bp(t, e) {
			(this.name = ""),
				(this.color = new Eh(t)),
				(this.density = void 0 !== e ? e : 25e-5);
		}
		function Fp(t, e, n) {
			(this.name = ""),
				(this.color = new Eh(t)),
				(this.near = void 0 !== e ? e : 1),
				(this.far = void 0 !== n ? n : 1e3);
		}
		function zp(t, e) {
			(this.array = t),
				(this.stride = e),
				(this.count = void 0 !== t ? t.length / e : 0),
				(this.usage = qc),
				(this.updateRange = { offset: 0, count: -1 }),
				(this.version = 0),
				(this.uuid = Jc.generateUUID());
		}
		(Rp.prototype = Object.assign(Object.create(ku.prototype), {
			constructor: Rp,
			isArrayCamera: !0,
		})),
			(Cp.prototype = Object.assign(Object.create(kl.prototype), {
				constructor: Cp,
				isGroup: !0,
			})),
			Object.assign(Op.prototype, {
				constructor: Op,
				getTargetRaySpace: function () {
					return (
						null === this._targetRay &&
							((this._targetRay = new Cp()),
							(this._targetRay.matrixAutoUpdate = !1),
							(this._targetRay.visible = !1)),
						this._targetRay
					);
				},
				getGripSpace: function () {
					return (
						null === this._grip &&
							((this._grip = new Cp()),
							(this._grip.matrixAutoUpdate = !1),
							(this._grip.visible = !1)),
						this._grip
					);
				},
				dispatchEvent: function (t) {
					return (
						null !== this._targetRay && this._targetRay.dispatchEvent(t),
						null !== this._grip && this._grip.dispatchEvent(t),
						this
					);
				},
				disconnect: function (t) {
					return (
						this.dispatchEvent({ type: "disconnected", data: t }),
						null !== this._targetRay && (this._targetRay.visible = !1),
						null !== this._grip && (this._grip.visible = !1),
						this
					);
				},
				update: function (t, e, n) {
					let i = null,
						r = null;
					const o = this._targetRay,
						s = this._grip;
					return (
						t &&
							(null !== o &&
								null !== (i = e.getPose(t.targetRaySpace, n)) &&
								(o.matrix.fromArray(i.transform.matrix),
								o.matrix.decompose(o.position, o.rotation, o.scale)),
							null !== s &&
								t.gripSpace &&
								null !== (r = e.getPose(t.gripSpace, n)) &&
								(s.matrix.fromArray(r.transform.matrix),
								s.matrix.decompose(s.position, s.rotation, s.scale))),
						null !== o && (o.visible = null !== i),
						null !== s && (s.visible = null !== r),
						this
					);
				},
			}),
			Object.assign(Dp.prototype, Xc.prototype),
			(Np.prototype = Object.assign(Object.create(kp.prototype), {
				constructor: Np,
				isWebGL1Renderer: !0,
			})),
			Object.assign(Bp.prototype, {
				isFogExp2: !0,
				clone: function () {
					return new Bp(this.color, this.density);
				},
				toJSON: function () {
					return {
						type: "FogExp2",
						color: this.color.getHex(),
						density: this.density,
					};
				},
			}),
			Object.assign(Fp.prototype, {
				isFog: !0,
				clone: function () {
					return new Fp(this.color, this.near, this.far);
				},
				toJSON: function () {
					return {
						type: "Fog",
						color: this.color.getHex(),
						near: this.near,
						far: this.far,
					};
				},
			}),
			Object.defineProperty(zp.prototype, "needsUpdate", {
				set: function (t) {
					!0 === t && this.version++;
				},
			}),
			Object.assign(zp.prototype, {
				isInterleavedBuffer: !0,
				onUploadCallback: function () {},
				setUsage: function (t) {
					return (this.usage = t), this;
				},
				copy: function (t) {
					return (
						(this.array = new t.array.constructor(t.array)),
						(this.count = t.count),
						(this.stride = t.stride),
						(this.usage = t.usage),
						this
					);
				},
				copyAt: function (t, e, n) {
					(t *= this.stride), (n *= e.stride);
					for (let i = 0, r = this.stride; i < r; i++)
						this.array[t + i] = e.array[n + i];
					return this;
				},
				set: function (t, e) {
					return void 0 === e && (e = 0), this.array.set(t, e), this;
				},
				clone: function (t) {
					void 0 === t.arrayBuffers && (t.arrayBuffers = {}),
						void 0 === this.array.buffer._uuid &&
							(this.array.buffer._uuid = Jc.generateUUID()),
						void 0 === t.arrayBuffers[this.array.buffer._uuid] &&
							(t.arrayBuffers[this.array.buffer._uuid] =
								this.array.slice(0).buffer);
					const e = new zp(
						new this.array.constructor(t.arrayBuffers[this.array.buffer._uuid]),
						this.stride
					);
					return e.setUsage(this.usage), e;
				},
				onUpload: function (t) {
					return (this.onUploadCallback = t), this;
				},
				toJSON: function (t) {
					return (
						void 0 === t.arrayBuffers && (t.arrayBuffers = {}),
						void 0 === this.array.buffer._uuid &&
							(this.array.buffer._uuid = Jc.generateUUID()),
						void 0 === t.arrayBuffers[this.array.buffer._uuid] &&
							(t.arrayBuffers[this.array.buffer._uuid] =
								Array.prototype.slice.call(new Uint32Array(this.array.buffer))),
						{
							uuid: this.uuid,
							buffer: this.array.buffer._uuid,
							type: this.array.constructor.name,
							stride: this.stride,
						}
					);
				},
			});
		const Hp = new ll();
		function Up(t, e, n, i) {
			(this.name = ""),
				(this.data = t),
				(this.itemSize = e),
				(this.offset = n),
				(this.normalized = !0 === i);
		}
		function Gp(t) {
			Oh.call(this),
				(this.type = "SpriteMaterial"),
				(this.color = new Eh(16777215)),
				(this.map = null),
				(this.alphaMap = null),
				(this.rotation = 0),
				(this.sizeAttenuation = !0),
				(this.transparent = !0),
				this.setValues(t);
		}
		let Vp;
		Object.defineProperties(Up.prototype, {
			count: {
				get: function () {
					return this.data.count;
				},
			},
			array: {
				get: function () {
					return this.data.array;
				},
			},
		}),
			Object.assign(Up.prototype, {
				isInterleavedBufferAttribute: !0,
				applyMatrix4: function (t) {
					for (let e = 0, n = this.data.count; e < n; e++)
						(Hp.x = this.getX(e)),
							(Hp.y = this.getY(e)),
							(Hp.z = this.getZ(e)),
							Hp.applyMatrix4(t),
							this.setXYZ(e, Hp.x, Hp.y, Hp.z);
					return this;
				},
				setX: function (t, e) {
					return (
						(this.data.array[t * this.data.stride + this.offset] = e), this
					);
				},
				setY: function (t, e) {
					return (
						(this.data.array[t * this.data.stride + this.offset + 1] = e), this
					);
				},
				setZ: function (t, e) {
					return (
						(this.data.array[t * this.data.stride + this.offset + 2] = e), this
					);
				},
				setW: function (t, e) {
					return (
						(this.data.array[t * this.data.stride + this.offset + 3] = e), this
					);
				},
				getX: function (t) {
					return this.data.array[t * this.data.stride + this.offset];
				},
				getY: function (t) {
					return this.data.array[t * this.data.stride + this.offset + 1];
				},
				getZ: function (t) {
					return this.data.array[t * this.data.stride + this.offset + 2];
				},
				getW: function (t) {
					return this.data.array[t * this.data.stride + this.offset + 3];
				},
				setXY: function (t, e, n) {
					return (
						(t = t * this.data.stride + this.offset),
						(this.data.array[t + 0] = e),
						(this.data.array[t + 1] = n),
						this
					);
				},
				setXYZ: function (t, e, n, i) {
					return (
						(t = t * this.data.stride + this.offset),
						(this.data.array[t + 0] = e),
						(this.data.array[t + 1] = n),
						(this.data.array[t + 2] = i),
						this
					);
				},
				setXYZW: function (t, e, n, i, r) {
					return (
						(t = t * this.data.stride + this.offset),
						(this.data.array[t + 0] = e),
						(this.data.array[t + 1] = n),
						(this.data.array[t + 2] = i),
						(this.data.array[t + 3] = r),
						this
					);
				},
				clone: function (t) {
					if (void 0 === t) {
						console.log(
							"THREE.InterleavedBufferAttribute.clone(): Cloning an interlaved buffer attribute will deinterleave buffer data."
						);
						const t = [];
						for (let e = 0; e < this.count; e++) {
							const n = e * this.data.stride + this.offset;
							for (let e = 0; e < this.itemSize; e++)
								t.push(this.data.array[n + e]);
						}
						return new Nh(
							new this.array.constructor(t),
							this.itemSize,
							this.normalized
						);
					}
					return (
						void 0 === t.interleavedBuffers && (t.interleavedBuffers = {}),
						void 0 === t.interleavedBuffers[this.data.uuid] &&
							(t.interleavedBuffers[this.data.uuid] = this.data.clone(t)),
						new Up(
							t.interleavedBuffers[this.data.uuid],
							this.itemSize,
							this.offset,
							this.normalized
						)
					);
				},
				toJSON: function (t) {
					if (void 0 === t) {
						console.log(
							"THREE.InterleavedBufferAttribute.toJSON(): Serializing an interlaved buffer attribute will deinterleave buffer data."
						);
						const t = [];
						for (let e = 0; e < this.count; e++) {
							const n = e * this.data.stride + this.offset;
							for (let e = 0; e < this.itemSize; e++)
								t.push(this.data.array[n + e]);
						}
						return {
							itemSize: this.itemSize,
							type: this.array.constructor.name,
							array: t,
							normalized: this.normalized,
						};
					}
					return (
						void 0 === t.interleavedBuffers && (t.interleavedBuffers = {}),
						void 0 === t.interleavedBuffers[this.data.uuid] &&
							(t.interleavedBuffers[this.data.uuid] = this.data.toJSON(t)),
						{
							isInterleavedBufferAttribute: !0,
							itemSize: this.itemSize,
							data: this.data.uuid,
							offset: this.offset,
							normalized: this.normalized,
						}
					);
				},
			}),
			(Gp.prototype = Object.create(Oh.prototype)),
			(Gp.prototype.constructor = Gp),
			(Gp.prototype.isSpriteMaterial = !0),
			(Gp.prototype.copy = function (t) {
				return (
					Oh.prototype.copy.call(this, t),
					this.color.copy(t.color),
					(this.map = t.map),
					(this.alphaMap = t.alphaMap),
					(this.rotation = t.rotation),
					(this.sizeAttenuation = t.sizeAttenuation),
					this
				);
			});
		const jp = new ll(),
			Wp = new ll(),
			qp = new ll(),
			Yp = new Kc(),
			Xp = new Kc(),
			Zp = new vl(),
			Jp = new ll(),
			Kp = new ll(),
			Qp = new ll(),
			$p = new Kc(),
			tf = new Kc(),
			ef = new Kc();
		function nf(t) {
			if ((kl.call(this), (this.type = "Sprite"), void 0 === Vp)) {
				Vp = new eu();
				const t = new zp(
					new Float32Array([
						-0.5, -0.5, 0, 0, 0, 0.5, -0.5, 0, 1, 0, 0.5, 0.5, 0, 1, 1, -0.5,
						0.5, 0, 0, 1,
					]),
					5
				);
				Vp.setIndex([0, 1, 2, 0, 2, 3]),
					Vp.setAttribute("position", new Up(t, 3, 0, !1)),
					Vp.setAttribute("uv", new Up(t, 2, 3, !1));
			}
			(this.geometry = Vp),
				(this.material = void 0 !== t ? t : new Gp()),
				(this.center = new Kc(0.5, 0.5));
		}
		function rf(t, e, n, i, r, o) {
			Yp.subVectors(t, n).addScalar(0.5).multiply(i),
				void 0 !== r
					? ((Xp.x = o * Yp.x - r * Yp.y), (Xp.y = r * Yp.x + o * Yp.y))
					: Xp.copy(Yp),
				t.copy(e),
				(t.x += Xp.x),
				(t.y += Xp.y),
				t.applyMatrix4(Zp);
		}
		nf.prototype = Object.assign(Object.create(kl.prototype), {
			constructor: nf,
			isSprite: !0,
			raycast: function (t, e) {
				null === t.camera &&
					console.error(
						'THREE.Sprite: "Raycaster.camera" needs to be set in order to raycast against sprites.'
					),
					Wp.setFromMatrixScale(this.matrixWorld),
					Zp.copy(t.camera.matrixWorld),
					this.modelViewMatrix.multiplyMatrices(
						t.camera.matrixWorldInverse,
						this.matrixWorld
					),
					qp.setFromMatrixPosition(this.modelViewMatrix),
					t.camera.isPerspectiveCamera &&
						!1 === this.material.sizeAttenuation &&
						Wp.multiplyScalar(-qp.z);
				const n = this.material.rotation;
				let i, r;
				0 !== n && ((r = Math.cos(n)), (i = Math.sin(n)));
				const o = this.center;
				rf(Jp.set(-0.5, -0.5, 0), qp, o, Wp, i, r),
					rf(Kp.set(0.5, -0.5, 0), qp, o, Wp, i, r),
					rf(Qp.set(0.5, 0.5, 0), qp, o, Wp, i, r),
					$p.set(0, 0),
					tf.set(1, 0),
					ef.set(1, 1);
				let s = t.ray.intersectTriangle(Jp, Kp, Qp, !1, jp);
				if (
					null === s &&
					(rf(Kp.set(-0.5, 0.5, 0), qp, o, Wp, i, r),
					tf.set(0, 1),
					null === (s = t.ray.intersectTriangle(Jp, Qp, Kp, !1, jp)))
				)
					return;
				const a = t.ray.origin.distanceTo(jp);
				a < t.near ||
					a > t.far ||
					e.push({
						distance: a,
						point: jp.clone(),
						uv: _h.getUV(jp, Jp, Kp, Qp, $p, tf, ef, new Kc()),
						face: null,
						object: this,
					});
			},
			copy: function (t) {
				return (
					kl.prototype.copy.call(this, t),
					void 0 !== t.center && this.center.copy(t.center),
					(this.material = t.material),
					this
				);
			},
		});
		const of = new ll(),
			sf = new ll();
		function af() {
			kl.call(this),
				(this._currentLevel = 0),
				(this.type = "LOD"),
				Object.defineProperties(this, {
					levels: { enumerable: !0, value: [] },
				}),
				(this.autoUpdate = !0);
		}
		function cf(t, e) {
			t &&
				t.isGeometry &&
				console.error(
					"THREE.SkinnedMesh no longer supports THREE.Geometry. Use THREE.BufferGeometry instead."
				),
				xu.call(this, t, e),
				(this.type = "SkinnedMesh"),
				(this.bindMode = "attached"),
				(this.bindMatrix = new vl()),
				(this.bindMatrixInverse = new vl());
		}
		(af.prototype = Object.assign(Object.create(kl.prototype), {
			constructor: af,
			isLOD: !0,
			copy: function (t) {
				kl.prototype.copy.call(this, t, !1);
				const e = t.levels;
				for (let t = 0, n = e.length; t < n; t++) {
					const n = e[t];
					this.addLevel(n.object.clone(), n.distance);
				}
				return (this.autoUpdate = t.autoUpdate), this;
			},
			addLevel: function (t, e) {
				void 0 === e && (e = 0), (e = Math.abs(e));
				const n = this.levels;
				let i;
				for (i = 0; i < n.length && !(e < n[i].distance); i++);
				return n.splice(i, 0, { distance: e, object: t }), this.add(t), this;
			},
			getCurrentLevel: function () {
				return this._currentLevel;
			},
			getObjectForDistance: function (t) {
				const e = this.levels;
				if (e.length > 0) {
					let n, i;
					for (n = 1, i = e.length; n < i && !(t < e[n].distance); n++);
					return e[n - 1].object;
				}
				return null;
			},
			raycast: function (t, e) {
				if (this.levels.length > 0) {
					of.setFromMatrixPosition(this.matrixWorld);
					const n = t.ray.origin.distanceTo(of);
					this.getObjectForDistance(n).raycast(t, e);
				}
			},
			update: function (t) {
				const e = this.levels;
				if (e.length > 1) {
					of.setFromMatrixPosition(t.matrixWorld),
						sf.setFromMatrixPosition(this.matrixWorld);
					const n = of.distanceTo(sf) / t.zoom;
					let i, r;
					for (
						e[0].object.visible = !0, i = 1, r = e.length;
						i < r && n >= e[i].distance;
						i++
					)
						(e[i - 1].object.visible = !1), (e[i].object.visible = !0);
					for (this._currentLevel = i - 1; i < r; i++) e[i].object.visible = !1;
				}
			},
			toJSON: function (t) {
				const e = kl.prototype.toJSON.call(this, t);
				!1 === this.autoUpdate && (e.object.autoUpdate = !1),
					(e.object.levels = []);
				const n = this.levels;
				for (let t = 0, i = n.length; t < i; t++) {
					const i = n[t];
					e.object.levels.push({ object: i.object.uuid, distance: i.distance });
				}
				return e;
			},
		})),
			(cf.prototype = Object.assign(Object.create(xu.prototype), {
				constructor: cf,
				isSkinnedMesh: !0,
				copy: function (t) {
					return (
						xu.prototype.copy.call(this, t),
						(this.bindMode = t.bindMode),
						this.bindMatrix.copy(t.bindMatrix),
						this.bindMatrixInverse.copy(t.bindMatrixInverse),
						(this.skeleton = t.skeleton),
						this
					);
				},
				bind: function (t, e) {
					(this.skeleton = t),
						void 0 === e &&
							(this.updateMatrixWorld(!0),
							this.skeleton.calculateInverses(),
							(e = this.matrixWorld)),
						this.bindMatrix.copy(e),
						this.bindMatrixInverse.getInverse(e);
				},
				pose: function () {
					this.skeleton.pose();
				},
				normalizeSkinWeights: function () {
					const t = new il(),
						e = this.geometry.attributes.skinWeight;
					for (let n = 0, i = e.count; n < i; n++) {
						(t.x = e.getX(n)),
							(t.y = e.getY(n)),
							(t.z = e.getZ(n)),
							(t.w = e.getW(n));
						const i = 1 / t.manhattanLength();
						i !== 1 / 0 ? t.multiplyScalar(i) : t.set(1, 0, 0, 0),
							e.setXYZW(n, t.x, t.y, t.z, t.w);
					}
				},
				updateMatrixWorld: function (t) {
					xu.prototype.updateMatrixWorld.call(this, t),
						"attached" === this.bindMode
							? this.bindMatrixInverse.getInverse(this.matrixWorld)
							: "detached" === this.bindMode
							? this.bindMatrixInverse.getInverse(this.bindMatrix)
							: console.warn(
									"THREE.SkinnedMesh: Unrecognized bindMode: " + this.bindMode
							  );
				},
				boneTransform: (function () {
					const t = new ll(),
						e = new il(),
						n = new il(),
						i = new ll(),
						r = new vl();
					return function (o, s) {
						const a = this.skeleton,
							c = this.geometry;
						e.fromBufferAttribute(c.attributes.skinIndex, o),
							n.fromBufferAttribute(c.attributes.skinWeight, o),
							t
								.fromBufferAttribute(c.attributes.position, o)
								.applyMatrix4(this.bindMatrix),
							s.set(0, 0, 0);
						for (let o = 0; o < 4; o++) {
							const c = n.getComponent(o);
							if (0 !== c) {
								const n = e.getComponent(o);
								r.multiplyMatrices(a.bones[n].matrixWorld, a.boneInverses[n]),
									s.addScaledVector(i.copy(t).applyMatrix4(r), c);
							}
						}
						return s.applyMatrix4(this.bindMatrixInverse);
					};
				})(),
			}));
		const lf = new vl(),
			hf = new vl();
		function uf(t, e) {
			if (
				((t = t || []),
				(this.bones = t.slice(0)),
				(this.boneMatrices = new Float32Array(16 * this.bones.length)),
				(this.frame = -1),
				void 0 === e)
			)
				this.calculateInverses();
			else if (this.bones.length === e.length) this.boneInverses = e.slice(0);
			else {
				console.warn("THREE.Skeleton boneInverses is the wrong length."),
					(this.boneInverses = []);
				for (let t = 0, e = this.bones.length; t < e; t++)
					this.boneInverses.push(new vl());
			}
		}
		function df() {
			kl.call(this), (this.type = "Bone");
		}
		Object.assign(uf.prototype, {
			calculateInverses: function () {
				this.boneInverses = [];
				for (let t = 0, e = this.bones.length; t < e; t++) {
					const e = new vl();
					this.bones[t] && e.getInverse(this.bones[t].matrixWorld),
						this.boneInverses.push(e);
				}
			},
			pose: function () {
				for (let t = 0, e = this.bones.length; t < e; t++) {
					const e = this.bones[t];
					e && e.matrixWorld.getInverse(this.boneInverses[t]);
				}
				for (let t = 0, e = this.bones.length; t < e; t++) {
					const e = this.bones[t];
					e &&
						(e.parent && e.parent.isBone
							? (e.matrix.getInverse(e.parent.matrixWorld),
							  e.matrix.multiply(e.matrixWorld))
							: e.matrix.copy(e.matrixWorld),
						e.matrix.decompose(e.position, e.quaternion, e.scale));
				}
			},
			update: function () {
				const t = this.bones,
					e = this.boneInverses,
					n = this.boneMatrices,
					i = this.boneTexture;
				for (let i = 0, r = t.length; i < r; i++) {
					const r = t[i] ? t[i].matrixWorld : hf;
					lf.multiplyMatrices(r, e[i]), lf.toArray(n, 16 * i);
				}
				void 0 !== i && (i.needsUpdate = !0);
			},
			clone: function () {
				return new uf(this.bones, this.boneInverses);
			},
			getBoneByName: function (t) {
				for (let e = 0, n = this.bones.length; e < n; e++) {
					const n = this.bones[e];
					if (n.name === t) return n;
				}
			},
			dispose: function () {
				this.boneTexture &&
					(this.boneTexture.dispose(), (this.boneTexture = void 0));
			},
		}),
			(df.prototype = Object.assign(Object.create(kl.prototype), {
				constructor: df,
				isBone: !0,
			}));
		const pf = new vl(),
			ff = new vl(),
			mf = [],
			gf = new xu();
		function vf(t, e, n) {
			xu.call(this, t, e),
				(this.instanceMatrix = new Nh(new Float32Array(16 * n), 16)),
				(this.count = n),
				(this.frustumCulled = !1);
		}
		function yf(t) {
			Oh.call(this),
				(this.type = "LineBasicMaterial"),
				(this.color = new Eh(16777215)),
				(this.linewidth = 1),
				(this.linecap = "round"),
				(this.linejoin = "round"),
				(this.morphTargets = !1),
				this.setValues(t);
		}
		(vf.prototype = Object.assign(Object.create(xu.prototype), {
			constructor: vf,
			isInstancedMesh: !0,
			copy: function (t) {
				return (
					xu.prototype.copy.call(this, t),
					this.instanceMatrix.copy(t.instanceMatrix),
					(this.count = t.count),
					this
				);
			},
			getMatrixAt: function (t, e) {
				e.fromArray(this.instanceMatrix.array, 16 * t);
			},
			raycast: function (t, e) {
				const n = this.matrixWorld,
					i = this.count;
				if (
					((gf.geometry = this.geometry),
					(gf.material = this.material),
					void 0 !== gf.material)
				)
					for (let r = 0; r < i; r++) {
						this.getMatrixAt(r, pf),
							ff.multiplyMatrices(n, pf),
							(gf.matrixWorld = ff),
							gf.raycast(t, mf);
						for (let t = 0, n = mf.length; t < n; t++) {
							const n = mf[t];
							(n.instanceId = r), (n.object = this), e.push(n);
						}
						mf.length = 0;
					}
			},
			setMatrixAt: function (t, e) {
				e.toArray(this.instanceMatrix.array, 16 * t);
			},
			updateMorphTargets: function () {},
		})),
			(yf.prototype = Object.create(Oh.prototype)),
			(yf.prototype.constructor = yf),
			(yf.prototype.isLineBasicMaterial = !0),
			(yf.prototype.copy = function (t) {
				return (
					Oh.prototype.copy.call(this, t),
					this.color.copy(t.color),
					(this.linewidth = t.linewidth),
					(this.linecap = t.linecap),
					(this.linejoin = t.linejoin),
					(this.morphTargets = t.morphTargets),
					this
				);
			});
		const xf = new ll(),
			bf = new ll(),
			wf = new vl(),
			_f = new ah(),
			Mf = new $l();
		function Sf(t, e, n) {
			1 === n &&
				console.error(
					"THREE.Line: parameter THREE.LinePieces no longer supported. Use THREE.LineSegments instead."
				),
				kl.call(this),
				(this.type = "Line"),
				(this.geometry = void 0 !== t ? t : new eu()),
				(this.material = void 0 !== e ? e : new yf()),
				this.updateMorphTargets();
		}
		Sf.prototype = Object.assign(Object.create(kl.prototype), {
			constructor: Sf,
			isLine: !0,
			copy: function (t) {
				return (
					kl.prototype.copy.call(this, t),
					(this.material = t.material),
					(this.geometry = t.geometry),
					this
				);
			},
			computeLineDistances: function () {
				const t = this.geometry;
				if (t.isBufferGeometry)
					if (null === t.index) {
						const e = t.attributes.position,
							n = [0];
						for (let t = 1, i = e.count; t < i; t++)
							xf.fromBufferAttribute(e, t - 1),
								bf.fromBufferAttribute(e, t),
								(n[t] = n[t - 1]),
								(n[t] += xf.distanceTo(bf));
						t.setAttribute("lineDistance", new jh(n, 1));
					} else
						console.warn(
							"THREE.Line.computeLineDistances(): Computation only possible with non-indexed BufferGeometry."
						);
				else if (t.isGeometry) {
					const e = t.vertices,
						n = t.lineDistances;
					n[0] = 0;
					for (let t = 1, i = e.length; t < i; t++)
						(n[t] = n[t - 1]), (n[t] += e[t - 1].distanceTo(e[t]));
				}
				return this;
			},
			raycast: function (t, e) {
				const n = this.geometry,
					i = this.matrixWorld,
					r = t.params.Line.threshold;
				if (
					(null === n.boundingSphere && n.computeBoundingSphere(),
					Mf.copy(n.boundingSphere),
					Mf.applyMatrix4(i),
					(Mf.radius += r),
					!1 === t.ray.intersectsSphere(Mf))
				)
					return;
				wf.getInverse(i), _f.copy(t.ray).applyMatrix4(wf);
				const o = r / ((this.scale.x + this.scale.y + this.scale.z) / 3),
					s = o * o,
					a = new ll(),
					c = new ll(),
					l = new ll(),
					h = new ll(),
					u = this && this.isLineSegments ? 2 : 1;
				if (n.isBufferGeometry) {
					const i = n.index,
						r = n.attributes.position.array;
					if (null !== i) {
						const n = i.array;
						for (let i = 0, o = n.length - 1; i < o; i += u) {
							const o = n[i],
								u = n[i + 1];
							if (
								(a.fromArray(r, 3 * o),
								c.fromArray(r, 3 * u),
								_f.distanceSqToSegment(a, c, h, l) > s)
							)
								continue;
							h.applyMatrix4(this.matrixWorld);
							const d = t.ray.origin.distanceTo(h);
							d < t.near ||
								d > t.far ||
								e.push({
									distance: d,
									point: l.clone().applyMatrix4(this.matrixWorld),
									index: i,
									face: null,
									faceIndex: null,
									object: this,
								});
						}
					} else
						for (let n = 0, i = r.length / 3 - 1; n < i; n += u) {
							if (
								(a.fromArray(r, 3 * n),
								c.fromArray(r, 3 * n + 3),
								_f.distanceSqToSegment(a, c, h, l) > s)
							)
								continue;
							h.applyMatrix4(this.matrixWorld);
							const i = t.ray.origin.distanceTo(h);
							i < t.near ||
								i > t.far ||
								e.push({
									distance: i,
									point: l.clone().applyMatrix4(this.matrixWorld),
									index: n,
									face: null,
									faceIndex: null,
									object: this,
								});
						}
				} else if (n.isGeometry) {
					const i = n.vertices,
						r = i.length;
					for (let n = 0; n < r - 1; n += u) {
						if (_f.distanceSqToSegment(i[n], i[n + 1], h, l) > s) continue;
						h.applyMatrix4(this.matrixWorld);
						const r = t.ray.origin.distanceTo(h);
						r < t.near ||
							r > t.far ||
							e.push({
								distance: r,
								point: l.clone().applyMatrix4(this.matrixWorld),
								index: n,
								face: null,
								faceIndex: null,
								object: this,
							});
					}
				}
			},
			updateMorphTargets: function () {
				const t = this.geometry;
				if (t.isBufferGeometry) {
					const e = t.morphAttributes,
						n = Object.keys(e);
					if (n.length > 0) {
						const t = e[n[0]];
						if (void 0 !== t) {
							(this.morphTargetInfluences = []),
								(this.morphTargetDictionary = {});
							for (let e = 0, n = t.length; e < n; e++) {
								const n = t[e].name || String(e);
								this.morphTargetInfluences.push(0),
									(this.morphTargetDictionary[n] = e);
							}
						}
					}
				} else {
					const e = t.morphTargets;
					void 0 !== e &&
						e.length > 0 &&
						console.error(
							"THREE.Line.updateMorphTargets() does not support THREE.Geometry. Use THREE.BufferGeometry instead."
						);
				}
			},
		});
		const Tf = new ll(),
			Ef = new ll();
		function Af(t, e) {
			Sf.call(this, t, e), (this.type = "LineSegments");
		}
		function Lf(t, e) {
			Sf.call(this, t, e), (this.type = "LineLoop");
		}
		function Pf(t) {
			Oh.call(this),
				(this.type = "PointsMaterial"),
				(this.color = new Eh(16777215)),
				(this.map = null),
				(this.alphaMap = null),
				(this.size = 1),
				(this.sizeAttenuation = !0),
				(this.morphTargets = !1),
				this.setValues(t);
		}
		(Af.prototype = Object.assign(Object.create(Sf.prototype), {
			constructor: Af,
			isLineSegments: !0,
			computeLineDistances: function () {
				const t = this.geometry;
				if (t.isBufferGeometry)
					if (null === t.index) {
						const e = t.attributes.position,
							n = [];
						for (let t = 0, i = e.count; t < i; t += 2)
							Tf.fromBufferAttribute(e, t),
								Ef.fromBufferAttribute(e, t + 1),
								(n[t] = 0 === t ? 0 : n[t - 1]),
								(n[t + 1] = n[t] + Tf.distanceTo(Ef));
						t.setAttribute("lineDistance", new jh(n, 1));
					} else
						console.warn(
							"THREE.LineSegments.computeLineDistances(): Computation only possible with non-indexed BufferGeometry."
						);
				else if (t.isGeometry) {
					const e = t.vertices,
						n = t.lineDistances;
					for (let t = 0, i = e.length; t < i; t += 2)
						Tf.copy(e[t]),
							Ef.copy(e[t + 1]),
							(n[t] = 0 === t ? 0 : n[t - 1]),
							(n[t + 1] = n[t] + Tf.distanceTo(Ef));
				}
				return this;
			},
		})),
			(Lf.prototype = Object.assign(Object.create(Sf.prototype), {
				constructor: Lf,
				isLineLoop: !0,
			})),
			(Pf.prototype = Object.create(Oh.prototype)),
			(Pf.prototype.constructor = Pf),
			(Pf.prototype.isPointsMaterial = !0),
			(Pf.prototype.copy = function (t) {
				return (
					Oh.prototype.copy.call(this, t),
					this.color.copy(t.color),
					(this.map = t.map),
					(this.alphaMap = t.alphaMap),
					(this.size = t.size),
					(this.sizeAttenuation = t.sizeAttenuation),
					(this.morphTargets = t.morphTargets),
					this
				);
			});
		const Rf = new vl(),
			Cf = new ah(),
			Of = new $l(),
			Df = new ll();
		function If(t, e) {
			kl.call(this),
				(this.type = "Points"),
				(this.geometry = void 0 !== t ? t : new eu()),
				(this.material = void 0 !== e ? e : new Pf()),
				this.updateMorphTargets();
		}
		function kf(t, e, n, i, r, o, s) {
			const a = Cf.distanceSqToPoint(t);
			if (a < n) {
				const n = new ll();
				Cf.closestPointToPoint(t, n), n.applyMatrix4(i);
				const c = r.ray.origin.distanceTo(n);
				if (c < r.near || c > r.far) return;
				o.push({
					distance: c,
					distanceToRay: Math.sqrt(a),
					point: n,
					index: e,
					face: null,
					object: s,
				});
			}
		}
		function Nf(t, e, n, i, r, o, s, a, c) {
			nl.call(this, t, e, n, i, r, o, s, a, c),
				(this.format = void 0 !== s ? s : Pa),
				(this.minFilter = void 0 !== o ? o : pa),
				(this.magFilter = void 0 !== r ? r : pa),
				(this.generateMipmaps = !1);
		}
		function Bf(t, e, n, i, r, o, s, a, c, l, h, u) {
			nl.call(this, null, o, s, a, c, l, i, r, h, u),
				(this.image = { width: e, height: n }),
				(this.mipmaps = t),
				(this.flipY = !1),
				(this.generateMipmaps = !1);
		}
		function Ff(t, e, n, i, r, o, s, a, c) {
			nl.call(this, t, e, n, i, r, o, s, a, c), (this.needsUpdate = !0);
		}
		function zf(t, e, n, i, r, o, s, a, c, l) {
			if ((l = void 0 !== l ? l : Ia) !== Ia && l !== ka)
				throw new Error(
					"DepthTexture format must be either THREE.DepthFormat or THREE.DepthStencilFormat"
				);
			void 0 === n && l === Ia && (n = xa),
				void 0 === n && l === ka && (n = Aa),
				nl.call(this, null, i, r, o, s, a, l, n, c),
				(this.image = { width: t, height: e }),
				(this.magFilter = void 0 !== s ? s : ha),
				(this.minFilter = void 0 !== a ? a : ha),
				(this.flipY = !1),
				(this.generateMipmaps = !1);
		}
		function Hf(t) {
			eu.call(this), (this.type = "WireframeGeometry");
			const e = [],
				n = [0, 0],
				i = {},
				r = ["a", "b", "c"];
			if (t && t.isGeometry) {
				const o = t.faces;
				for (let t = 0, e = o.length; t < e; t++) {
					const e = o[t];
					for (let t = 0; t < 3; t++) {
						const o = e[r[t]],
							s = e[r[(t + 1) % 3]];
						(n[0] = Math.min(o, s)), (n[1] = Math.max(o, s));
						const a = n[0] + "," + n[1];
						void 0 === i[a] && (i[a] = { index1: n[0], index2: n[1] });
					}
				}
				for (const n in i) {
					const r = i[n];
					let o = t.vertices[r.index1];
					e.push(o.x, o.y, o.z),
						(o = t.vertices[r.index2]),
						e.push(o.x, o.y, o.z);
				}
			} else if (t && t.isBufferGeometry) {
				let r = new ll();
				if (null !== t.index) {
					const o = t.attributes.position,
						s = t.index;
					let a = t.groups;
					0 === a.length &&
						(a = [{ start: 0, count: s.count, materialIndex: 0 }]);
					for (let t = 0, e = a.length; t < e; ++t) {
						const e = a[t],
							r = e.start;
						for (let t = r, o = r + e.count; t < o; t += 3)
							for (let e = 0; e < 3; e++) {
								const r = s.getX(t + e),
									o = s.getX(t + ((e + 1) % 3));
								(n[0] = Math.min(r, o)), (n[1] = Math.max(r, o));
								const a = n[0] + "," + n[1];
								void 0 === i[a] && (i[a] = { index1: n[0], index2: n[1] });
							}
					}
					for (const t in i) {
						const n = i[t];
						r.fromBufferAttribute(o, n.index1),
							e.push(r.x, r.y, r.z),
							r.fromBufferAttribute(o, n.index2),
							e.push(r.x, r.y, r.z);
					}
				} else {
					const n = t.attributes.position;
					for (let t = 0, i = n.count / 3; t < i; t++)
						for (let i = 0; i < 3; i++) {
							const o = 3 * t + i;
							r.fromBufferAttribute(n, o), e.push(r.x, r.y, r.z);
							const s = 3 * t + ((i + 1) % 3);
							r.fromBufferAttribute(n, s), e.push(r.x, r.y, r.z);
						}
				}
			}
			this.setAttribute("position", new jh(e, 3));
		}
		function Uf(t, e, n) {
			Eu.call(this),
				(this.type = "ParametricGeometry"),
				(this.parameters = { func: t, slices: e, stacks: n }),
				this.fromBufferGeometry(new Gf(t, e, n)),
				this.mergeVertices();
		}
		function Gf(t, e, n) {
			eu.call(this),
				(this.type = "ParametricBufferGeometry"),
				(this.parameters = { func: t, slices: e, stacks: n });
			const i = [],
				r = [],
				o = [],
				s = [],
				a = new ll(),
				c = new ll(),
				l = new ll(),
				h = new ll(),
				u = new ll();
			t.length < 3 &&
				console.error(
					"THREE.ParametricGeometry: Function must now modify a Vector3 as third parameter."
				);
			const d = e + 1;
			for (let i = 0; i <= n; i++) {
				const d = i / n;
				for (let n = 0; n <= e; n++) {
					const i = n / e;
					t(i, d, c),
						r.push(c.x, c.y, c.z),
						i - 1e-5 >= 0
							? (t(i - 1e-5, d, l), h.subVectors(c, l))
							: (t(i + 1e-5, d, l), h.subVectors(l, c)),
						d - 1e-5 >= 0
							? (t(i, d - 1e-5, l), u.subVectors(c, l))
							: (t(i, d + 1e-5, l), u.subVectors(l, c)),
						a.crossVectors(h, u).normalize(),
						o.push(a.x, a.y, a.z),
						s.push(i, d);
				}
			}
			for (let t = 0; t < n; t++)
				for (let n = 0; n < e; n++) {
					const e = t * d + n,
						r = t * d + n + 1,
						o = (t + 1) * d + n + 1,
						s = (t + 1) * d + n;
					i.push(e, r, s), i.push(r, o, s);
				}
			this.setIndex(i),
				this.setAttribute("position", new jh(r, 3)),
				this.setAttribute("normal", new jh(o, 3)),
				this.setAttribute("uv", new jh(s, 2));
		}
		function Vf(t, e, n, i) {
			Eu.call(this),
				(this.type = "PolyhedronGeometry"),
				(this.parameters = { vertices: t, indices: e, radius: n, detail: i }),
				this.fromBufferGeometry(new jf(t, e, n, i)),
				this.mergeVertices();
		}
		function jf(t, e, n, i) {
			eu.call(this),
				(this.type = "PolyhedronBufferGeometry"),
				(this.parameters = { vertices: t, indices: e, radius: n, detail: i }),
				(n = n || 1);
			const r = [],
				o = [];
			function s(t, e, n, i) {
				const r = Math.pow(2, i),
					o = [];
				for (let i = 0; i <= r; i++) {
					o[i] = [];
					const s = t.clone().lerp(n, i / r),
						a = e.clone().lerp(n, i / r),
						c = r - i;
					for (let t = 0; t <= c; t++)
						o[i][t] = 0 === t && i === r ? s : s.clone().lerp(a, t / c);
				}
				for (let t = 0; t < r; t++)
					for (let e = 0; e < 2 * (r - t) - 1; e++) {
						const n = Math.floor(e / 2);
						e % 2 == 0
							? (a(o[t][n + 1]), a(o[t + 1][n]), a(o[t][n]))
							: (a(o[t][n + 1]), a(o[t + 1][n + 1]), a(o[t + 1][n]));
					}
			}
			function a(t) {
				r.push(t.x, t.y, t.z);
			}
			function c(e, n) {
				const i = 3 * e;
				(n.x = t[i + 0]), (n.y = t[i + 1]), (n.z = t[i + 2]);
			}
			function l(t, e, n, i) {
				i < 0 && 1 === t.x && (o[e] = t.x - 1),
					0 === n.x && 0 === n.z && (o[e] = i / 2 / Math.PI + 0.5);
			}
			function h(t) {
				return Math.atan2(t.z, -t.x);
			}
			!(function (t) {
				const n = new ll(),
					i = new ll(),
					r = new ll();
				for (let o = 0; o < e.length; o += 3)
					c(e[o + 0], n), c(e[o + 1], i), c(e[o + 2], r), s(n, i, r, t);
			})((i = i || 0)),
				(function (t) {
					const e = new ll();
					for (let n = 0; n < r.length; n += 3)
						(e.x = r[n + 0]),
							(e.y = r[n + 1]),
							(e.z = r[n + 2]),
							e.normalize().multiplyScalar(t),
							(r[n + 0] = e.x),
							(r[n + 1] = e.y),
							(r[n + 2] = e.z);
				})(n),
				(function () {
					const t = new ll();
					for (let n = 0; n < r.length; n += 3) {
						(t.x = r[n + 0]), (t.y = r[n + 1]), (t.z = r[n + 2]);
						const i = h(t) / 2 / Math.PI + 0.5,
							s =
								((e = t),
								Math.atan2(-e.y, Math.sqrt(e.x * e.x + e.z * e.z)) / Math.PI +
									0.5);
						o.push(i, 1 - s);
					}
					var e;
					(function () {
						const t = new ll(),
							e = new ll(),
							n = new ll(),
							i = new ll(),
							s = new Kc(),
							a = new Kc(),
							c = new Kc();
						for (let u = 0, d = 0; u < r.length; u += 9, d += 6) {
							t.set(r[u + 0], r[u + 1], r[u + 2]),
								e.set(r[u + 3], r[u + 4], r[u + 5]),
								n.set(r[u + 6], r[u + 7], r[u + 8]),
								s.set(o[d + 0], o[d + 1]),
								a.set(o[d + 2], o[d + 3]),
								c.set(o[d + 4], o[d + 5]),
								i.copy(t).add(e).add(n).divideScalar(3);
							const p = h(i);
							l(s, d + 0, t, p), l(a, d + 2, e, p), l(c, d + 4, n, p);
						}
					})(),
						(function () {
							for (let t = 0; t < o.length; t += 6) {
								const e = o[t + 0],
									n = o[t + 2],
									i = o[t + 4],
									r = Math.max(e, n, i),
									s = Math.min(e, n, i);
								r > 0.9 &&
									s < 0.1 &&
									(e < 0.2 && (o[t + 0] += 1),
									n < 0.2 && (o[t + 2] += 1),
									i < 0.2 && (o[t + 4] += 1));
							}
						})();
				})(),
				this.setAttribute("position", new jh(r, 3)),
				this.setAttribute("normal", new jh(r.slice(), 3)),
				this.setAttribute("uv", new jh(o, 2)),
				0 === i ? this.computeVertexNormals() : this.normalizeNormals();
		}
		function Wf(t, e) {
			Eu.call(this),
				(this.type = "TetrahedronGeometry"),
				(this.parameters = { radius: t, detail: e }),
				this.fromBufferGeometry(new qf(t, e)),
				this.mergeVertices();
		}
		function qf(t, e) {
			jf.call(
				this,
				[1, 1, 1, -1, -1, 1, -1, 1, -1, 1, -1, -1],
				[2, 1, 0, 0, 3, 2, 1, 3, 0, 2, 3, 1],
				t,
				e
			),
				(this.type = "TetrahedronBufferGeometry"),
				(this.parameters = { radius: t, detail: e });
		}
		function Yf(t, e) {
			Eu.call(this),
				(this.type = "OctahedronGeometry"),
				(this.parameters = { radius: t, detail: e }),
				this.fromBufferGeometry(new Xf(t, e)),
				this.mergeVertices();
		}
		function Xf(t, e) {
			jf.call(
				this,
				[1, 0, 0, -1, 0, 0, 0, 1, 0, 0, -1, 0, 0, 0, 1, 0, 0, -1],
				[
					0, 2, 4, 0, 4, 3, 0, 3, 5, 0, 5, 2, 1, 2, 5, 1, 5, 3, 1, 3, 4, 1, 4,
					2,
				],
				t,
				e
			),
				(this.type = "OctahedronBufferGeometry"),
				(this.parameters = { radius: t, detail: e });
		}
		function Zf(t, e) {
			Eu.call(this),
				(this.type = "IcosahedronGeometry"),
				(this.parameters = { radius: t, detail: e }),
				this.fromBufferGeometry(new Jf(t, e)),
				this.mergeVertices();
		}
		function Jf(t, e) {
			const n = (1 + Math.sqrt(5)) / 2,
				i = [
					-1,
					n,
					0,
					1,
					n,
					0,
					-1,
					-n,
					0,
					1,
					-n,
					0,
					0,
					-1,
					n,
					0,
					1,
					n,
					0,
					-1,
					-n,
					0,
					1,
					-n,
					n,
					0,
					-1,
					n,
					0,
					1,
					-n,
					0,
					-1,
					-n,
					0,
					1,
				];
			jf.call(
				this,
				i,
				[
					0, 11, 5, 0, 5, 1, 0, 1, 7, 0, 7, 10, 0, 10, 11, 1, 5, 9, 5, 11, 4,
					11, 10, 2, 10, 7, 6, 7, 1, 8, 3, 9, 4, 3, 4, 2, 3, 2, 6, 3, 6, 8, 3,
					8, 9, 4, 9, 5, 2, 4, 11, 6, 2, 10, 8, 6, 7, 9, 8, 1,
				],
				t,
				e
			),
				(this.type = "IcosahedronBufferGeometry"),
				(this.parameters = { radius: t, detail: e });
		}
		function Kf(t, e) {
			Eu.call(this),
				(this.type = "DodecahedronGeometry"),
				(this.parameters = { radius: t, detail: e }),
				this.fromBufferGeometry(new Qf(t, e)),
				this.mergeVertices();
		}
		function Qf(t, e) {
			const n = (1 + Math.sqrt(5)) / 2,
				i = 1 / n,
				r = [
					-1,
					-1,
					-1,
					-1,
					-1,
					1,
					-1,
					1,
					-1,
					-1,
					1,
					1,
					1,
					-1,
					-1,
					1,
					-1,
					1,
					1,
					1,
					-1,
					1,
					1,
					1,
					0,
					-i,
					-n,
					0,
					-i,
					n,
					0,
					i,
					-n,
					0,
					i,
					n,
					-i,
					-n,
					0,
					-i,
					n,
					0,
					i,
					-n,
					0,
					i,
					n,
					0,
					-n,
					0,
					-i,
					n,
					0,
					-i,
					-n,
					0,
					i,
					n,
					0,
					i,
				];
			jf.call(
				this,
				r,
				[
					3, 11, 7, 3, 7, 15, 3, 15, 13, 7, 19, 17, 7, 17, 6, 7, 6, 15, 17, 4,
					8, 17, 8, 10, 17, 10, 6, 8, 0, 16, 8, 16, 2, 8, 2, 10, 0, 12, 1, 0, 1,
					18, 0, 18, 16, 6, 10, 2, 6, 2, 13, 6, 13, 15, 2, 16, 18, 2, 18, 3, 2,
					3, 13, 18, 1, 9, 18, 9, 11, 18, 11, 3, 4, 14, 12, 4, 12, 0, 4, 0, 8,
					11, 9, 5, 11, 5, 19, 11, 19, 7, 19, 5, 14, 19, 14, 4, 19, 4, 17, 1,
					12, 14, 1, 14, 5, 1, 5, 9,
				],
				t,
				e
			),
				(this.type = "DodecahedronBufferGeometry"),
				(this.parameters = { radius: t, detail: e });
		}
		function $f(t, e, n, i, r, o) {
			Eu.call(this),
				(this.type = "TubeGeometry"),
				(this.parameters = {
					path: t,
					tubularSegments: e,
					radius: n,
					radialSegments: i,
					closed: r,
				}),
				void 0 !== o &&
					console.warn("THREE.TubeGeometry: taper has been removed.");
			const s = new tm(t, e, n, i, r);
			(this.tangents = s.tangents),
				(this.normals = s.normals),
				(this.binormals = s.binormals),
				this.fromBufferGeometry(s),
				this.mergeVertices();
		}
		function tm(t, e, n, i, r) {
			eu.call(this),
				(this.type = "TubeBufferGeometry"),
				(this.parameters = {
					path: t,
					tubularSegments: e,
					radius: n,
					radialSegments: i,
					closed: r,
				}),
				(e = e || 64),
				(n = n || 1),
				(i = i || 8),
				(r = r || !1);
			const o = t.computeFrenetFrames(e, r);
			(this.tangents = o.tangents),
				(this.normals = o.normals),
				(this.binormals = o.binormals);
			const s = new ll(),
				a = new ll(),
				c = new Kc();
			let l = new ll();
			const h = [],
				u = [],
				d = [],
				p = [];
			function f(r) {
				l = t.getPointAt(r / e, l);
				const c = o.normals[r],
					d = o.binormals[r];
				for (let t = 0; t <= i; t++) {
					const e = (t / i) * Math.PI * 2,
						r = Math.sin(e),
						o = -Math.cos(e);
					(a.x = o * c.x + r * d.x),
						(a.y = o * c.y + r * d.y),
						(a.z = o * c.z + r * d.z),
						a.normalize(),
						u.push(a.x, a.y, a.z),
						(s.x = l.x + n * a.x),
						(s.y = l.y + n * a.y),
						(s.z = l.z + n * a.z),
						h.push(s.x, s.y, s.z);
				}
			}
			!(function () {
				for (let t = 0; t < e; t++) f(t);
				f(!1 === r ? e : 0),
					(function () {
						for (let t = 0; t <= e; t++)
							for (let n = 0; n <= i; n++)
								(c.x = t / e), (c.y = n / i), d.push(c.x, c.y);
					})(),
					(function () {
						for (let t = 1; t <= e; t++)
							for (let e = 1; e <= i; e++) {
								const n = (i + 1) * (t - 1) + (e - 1),
									r = (i + 1) * t + (e - 1),
									o = (i + 1) * t + e,
									s = (i + 1) * (t - 1) + e;
								p.push(n, r, s), p.push(r, o, s);
							}
					})();
			})(),
				this.setIndex(p),
				this.setAttribute("position", new jh(h, 3)),
				this.setAttribute("normal", new jh(u, 3)),
				this.setAttribute("uv", new jh(d, 2));
		}
		function em(t, e, n, i, r, o, s) {
			Eu.call(this),
				(this.type = "TorusKnotGeometry"),
				(this.parameters = {
					radius: t,
					tube: e,
					tubularSegments: n,
					radialSegments: i,
					p: r,
					q: o,
				}),
				void 0 !== s &&
					console.warn(
						"THREE.TorusKnotGeometry: heightScale has been deprecated. Use .scale( x, y, z ) instead."
					),
				this.fromBufferGeometry(new nm(t, e, n, i, r, o)),
				this.mergeVertices();
		}
		function nm(t, e, n, i, r, o) {
			eu.call(this),
				(this.type = "TorusKnotBufferGeometry"),
				(this.parameters = {
					radius: t,
					tube: e,
					tubularSegments: n,
					radialSegments: i,
					p: r,
					q: o,
				}),
				(t = t || 1),
				(e = e || 0.4),
				(n = Math.floor(n) || 64),
				(i = Math.floor(i) || 8),
				(r = r || 2),
				(o = o || 3);
			const s = [],
				a = [],
				c = [],
				l = [],
				h = new ll(),
				u = new ll(),
				d = new ll(),
				p = new ll(),
				f = new ll(),
				m = new ll(),
				g = new ll();
			for (let s = 0; s <= n; ++s) {
				const y = (s / n) * r * Math.PI * 2;
				v(y, r, o, t, d),
					v(y + 0.01, r, o, t, p),
					m.subVectors(p, d),
					g.addVectors(p, d),
					f.crossVectors(m, g),
					g.crossVectors(f, m),
					f.normalize(),
					g.normalize();
				for (let t = 0; t <= i; ++t) {
					const r = (t / i) * Math.PI * 2,
						o = -e * Math.cos(r),
						p = e * Math.sin(r);
					(h.x = d.x + (o * g.x + p * f.x)),
						(h.y = d.y + (o * g.y + p * f.y)),
						(h.z = d.z + (o * g.z + p * f.z)),
						a.push(h.x, h.y, h.z),
						u.subVectors(h, d).normalize(),
						c.push(u.x, u.y, u.z),
						l.push(s / n),
						l.push(t / i);
				}
			}
			for (let t = 1; t <= n; t++)
				for (let e = 1; e <= i; e++) {
					const n = (i + 1) * (t - 1) + (e - 1),
						r = (i + 1) * t + (e - 1),
						o = (i + 1) * t + e,
						a = (i + 1) * (t - 1) + e;
					s.push(n, r, a), s.push(r, o, a);
				}
			function v(t, e, n, i, r) {
				const o = Math.cos(t),
					s = Math.sin(t),
					a = (n / e) * t,
					c = Math.cos(a);
				(r.x = i * (2 + c) * 0.5 * o),
					(r.y = i * (2 + c) * s * 0.5),
					(r.z = i * Math.sin(a) * 0.5);
			}
			this.setIndex(s),
				this.setAttribute("position", new jh(a, 3)),
				this.setAttribute("normal", new jh(c, 3)),
				this.setAttribute("uv", new jh(l, 2));
		}
		function im(t, e, n, i, r) {
			Eu.call(this),
				(this.type = "TorusGeometry"),
				(this.parameters = {
					radius: t,
					tube: e,
					radialSegments: n,
					tubularSegments: i,
					arc: r,
				}),
				this.fromBufferGeometry(new rm(t, e, n, i, r)),
				this.mergeVertices();
		}
		function rm(t, e, n, i, r) {
			eu.call(this),
				(this.type = "TorusBufferGeometry"),
				(this.parameters = {
					radius: t,
					tube: e,
					radialSegments: n,
					tubularSegments: i,
					arc: r,
				}),
				(t = t || 1),
				(e = e || 0.4),
				(n = Math.floor(n) || 8),
				(i = Math.floor(i) || 6),
				(r = r || 2 * Math.PI);
			const o = [],
				s = [],
				a = [],
				c = [],
				l = new ll(),
				h = new ll(),
				u = new ll();
			for (let o = 0; o <= n; o++)
				for (let d = 0; d <= i; d++) {
					const p = (d / i) * r,
						f = (o / n) * Math.PI * 2;
					(h.x = (t + e * Math.cos(f)) * Math.cos(p)),
						(h.y = (t + e * Math.cos(f)) * Math.sin(p)),
						(h.z = e * Math.sin(f)),
						s.push(h.x, h.y, h.z),
						(l.x = t * Math.cos(p)),
						(l.y = t * Math.sin(p)),
						u.subVectors(h, l).normalize(),
						a.push(u.x, u.y, u.z),
						c.push(d / i),
						c.push(o / n);
				}
			for (let t = 1; t <= n; t++)
				for (let e = 1; e <= i; e++) {
					const n = (i + 1) * t + e - 1,
						r = (i + 1) * (t - 1) + e - 1,
						s = (i + 1) * (t - 1) + e,
						a = (i + 1) * t + e;
					o.push(n, r, a), o.push(r, s, a);
				}
			this.setIndex(o),
				this.setAttribute("position", new jh(s, 3)),
				this.setAttribute("normal", new jh(a, 3)),
				this.setAttribute("uv", new jh(c, 2));
		}
		(If.prototype = Object.assign(Object.create(kl.prototype), {
			constructor: If,
			isPoints: !0,
			copy: function (t) {
				return (
					kl.prototype.copy.call(this, t),
					(this.material = t.material),
					(this.geometry = t.geometry),
					this
				);
			},
			raycast: function (t, e) {
				const n = this.geometry,
					i = this.matrixWorld,
					r = t.params.Points.threshold;
				if (
					(null === n.boundingSphere && n.computeBoundingSphere(),
					Of.copy(n.boundingSphere),
					Of.applyMatrix4(i),
					(Of.radius += r),
					!1 === t.ray.intersectsSphere(Of))
				)
					return;
				Rf.getInverse(i), Cf.copy(t.ray).applyMatrix4(Rf);
				const o = r / ((this.scale.x + this.scale.y + this.scale.z) / 3),
					s = o * o;
				if (n.isBufferGeometry) {
					const r = n.index,
						o = n.attributes.position.array;
					if (null !== r) {
						const n = r.array;
						for (let r = 0, a = n.length; r < a; r++) {
							const a = n[r];
							Df.fromArray(o, 3 * a), kf(Df, a, s, i, t, e, this);
						}
					} else
						for (let n = 0, r = o.length / 3; n < r; n++)
							Df.fromArray(o, 3 * n), kf(Df, n, s, i, t, e, this);
				} else {
					const r = n.vertices;
					for (let n = 0, o = r.length; n < o; n++)
						kf(r[n], n, s, i, t, e, this);
				}
			},
			updateMorphTargets: function () {
				const t = this.geometry;
				if (t.isBufferGeometry) {
					const e = t.morphAttributes,
						n = Object.keys(e);
					if (n.length > 0) {
						const t = e[n[0]];
						if (void 0 !== t) {
							(this.morphTargetInfluences = []),
								(this.morphTargetDictionary = {});
							for (let e = 0, n = t.length; e < n; e++) {
								const n = t[e].name || String(e);
								this.morphTargetInfluences.push(0),
									(this.morphTargetDictionary[n] = e);
							}
						}
					}
				} else {
					const e = t.morphTargets;
					void 0 !== e &&
						e.length > 0 &&
						console.error(
							"THREE.Points.updateMorphTargets() does not support THREE.Geometry. Use THREE.BufferGeometry instead."
						);
				}
			},
		})),
			(Nf.prototype = Object.assign(Object.create(nl.prototype), {
				constructor: Nf,
				isVideoTexture: !0,
				update: function () {
					const t = this.image;
					t.readyState >= t.HAVE_CURRENT_DATA && (this.needsUpdate = !0);
				},
			})),
			(Bf.prototype = Object.create(nl.prototype)),
			(Bf.prototype.constructor = Bf),
			(Bf.prototype.isCompressedTexture = !0),
			(Ff.prototype = Object.create(nl.prototype)),
			(Ff.prototype.constructor = Ff),
			(Ff.prototype.isCanvasTexture = !0),
			(zf.prototype = Object.create(nl.prototype)),
			(zf.prototype.constructor = zf),
			(zf.prototype.isDepthTexture = !0),
			(Hf.prototype = Object.create(eu.prototype)),
			(Hf.prototype.constructor = Hf),
			(Uf.prototype = Object.create(Eu.prototype)),
			(Uf.prototype.constructor = Uf),
			(Gf.prototype = Object.create(eu.prototype)),
			(Gf.prototype.constructor = Gf),
			(Vf.prototype = Object.create(Eu.prototype)),
			(Vf.prototype.constructor = Vf),
			(jf.prototype = Object.create(eu.prototype)),
			(jf.prototype.constructor = jf),
			(Wf.prototype = Object.create(Eu.prototype)),
			(Wf.prototype.constructor = Wf),
			(qf.prototype = Object.create(jf.prototype)),
			(qf.prototype.constructor = qf),
			(Yf.prototype = Object.create(Eu.prototype)),
			(Yf.prototype.constructor = Yf),
			(Xf.prototype = Object.create(jf.prototype)),
			(Xf.prototype.constructor = Xf),
			(Zf.prototype = Object.create(Eu.prototype)),
			(Zf.prototype.constructor = Zf),
			(Jf.prototype = Object.create(jf.prototype)),
			(Jf.prototype.constructor = Jf),
			(Kf.prototype = Object.create(Eu.prototype)),
			(Kf.prototype.constructor = Kf),
			(Qf.prototype = Object.create(jf.prototype)),
			(Qf.prototype.constructor = Qf),
			($f.prototype = Object.create(Eu.prototype)),
			($f.prototype.constructor = $f),
			(tm.prototype = Object.create(eu.prototype)),
			(tm.prototype.constructor = tm),
			(tm.prototype.toJSON = function () {
				const t = eu.prototype.toJSON.call(this);
				return (t.path = this.parameters.path.toJSON()), t;
			}),
			(em.prototype = Object.create(Eu.prototype)),
			(em.prototype.constructor = em),
			(nm.prototype = Object.create(eu.prototype)),
			(nm.prototype.constructor = nm),
			(im.prototype = Object.create(Eu.prototype)),
			(im.prototype.constructor = im),
			(rm.prototype = Object.create(eu.prototype)),
			(rm.prototype.constructor = rm);
		const om = function (t, e, n) {
			n = n || 2;
			let i,
				r,
				o,
				s,
				a,
				c,
				l,
				h = e && e.length,
				u = h ? e[0] * n : t.length,
				d = sm(t, 0, u, n, !0),
				p = [];
			if (!d || d.next === d.prev) return p;
			if (
				(h &&
					(d = (function (t, e, n, i) {
						let r,
							o,
							s,
							a,
							c,
							l = [];
						for (r = 0, o = e.length; r < o; r++)
							(s = e[r] * i),
								(a = r < o - 1 ? e[r + 1] * i : t.length),
								(c = sm(t, s, a, i, !1)) === c.next && (c.steiner = !0),
								l.push(vm(c));
						for (l.sort(pm), r = 0; r < l.length; r++)
							fm(l[r], n), (n = am(n, n.next));
						return n;
					})(t, e, d, n)),
				t.length > 80 * n)
			) {
				(i = o = t[0]), (r = s = t[1]);
				for (let e = n; e < u; e += n)
					(a = t[e]),
						(c = t[e + 1]),
						a < i && (i = a),
						c < r && (r = c),
						a > o && (o = a),
						c > s && (s = c);
				l = 0 !== (l = Math.max(o - i, s - r)) ? 1 / l : 0;
			}
			return cm(d, p, n, i, r, l), p;
		};
		function sm(t, e, n, i, r) {
			let o, s;
			if (
				r ===
				(function (t, e, n, i) {
					let r = 0;
					for (let o = e, s = n - i; o < n; o += i)
						(r += (t[s] - t[o]) * (t[o + 1] + t[s + 1])), (s = o);
					return r;
				})(t, e, n, i) >
					0
			)
				for (o = e; o < n; o += i) s = Am(o, t[o], t[o + 1], s);
			else for (o = n - i; o >= e; o -= i) s = Am(o, t[o], t[o + 1], s);
			return s && wm(s, s.next) && (Lm(s), (s = s.next)), s;
		}
		function am(t, e) {
			if (!t) return t;
			e || (e = t);
			let n,
				i = t;
			do {
				if (
					((n = !1),
					i.steiner || (!wm(i, i.next) && 0 !== bm(i.prev, i, i.next)))
				)
					i = i.next;
				else {
					if ((Lm(i), (i = e = i.prev) === i.next)) break;
					n = !0;
				}
			} while (n || i !== e);
			return e;
		}
		function cm(t, e, n, i, r, o, s) {
			if (!t) return;
			!s &&
				o &&
				(function (t, e, n, i) {
					let r = t;
					do {
						null === r.z && (r.z = gm(r.x, r.y, e, n, i)),
							(r.prevZ = r.prev),
							(r.nextZ = r.next),
							(r = r.next);
					} while (r !== t);
					(r.prevZ.nextZ = null),
						(r.prevZ = null),
						(function (t) {
							let e,
								n,
								i,
								r,
								o,
								s,
								a,
								c,
								l = 1;
							do {
								for (n = t, t = null, o = null, s = 0; n; ) {
									for (
										s++, i = n, a = 0, e = 0;
										e < l && (a++, (i = i.nextZ));
										e++
									);
									for (c = l; a > 0 || (c > 0 && i); )
										0 !== a && (0 === c || !i || n.z <= i.z)
											? ((r = n), (n = n.nextZ), a--)
											: ((r = i), (i = i.nextZ), c--),
											o ? (o.nextZ = r) : (t = r),
											(r.prevZ = o),
											(o = r);
									n = i;
								}
								(o.nextZ = null), (l *= 2);
							} while (s > 1);
						})(r);
				})(t, i, r, o);
			let a,
				c,
				l = t;
			for (; t.prev !== t.next; )
				if (((a = t.prev), (c = t.next), o ? hm(t, i, r, o) : lm(t)))
					e.push(a.i / n),
						e.push(t.i / n),
						e.push(c.i / n),
						Lm(t),
						(t = c.next),
						(l = c.next);
				else if ((t = c) === l) {
					s
						? 1 === s
							? cm((t = um(am(t), e, n)), e, n, i, r, o, 2)
							: 2 === s && dm(t, e, n, i, r, o)
						: cm(am(t), e, n, i, r, o, 1);
					break;
				}
		}
		function lm(t) {
			let e = t.prev,
				n = t,
				i = t.next;
			if (bm(e, n, i) >= 0) return !1;
			let r = t.next.next;
			for (; r !== t.prev; ) {
				if (
					ym(e.x, e.y, n.x, n.y, i.x, i.y, r.x, r.y) &&
					bm(r.prev, r, r.next) >= 0
				)
					return !1;
				r = r.next;
			}
			return !0;
		}
		function hm(t, e, n, i) {
			let r = t.prev,
				o = t,
				s = t.next;
			if (bm(r, o, s) >= 0) return !1;
			let a = r.x < o.x ? (r.x < s.x ? r.x : s.x) : o.x < s.x ? o.x : s.x,
				c = r.y < o.y ? (r.y < s.y ? r.y : s.y) : o.y < s.y ? o.y : s.y,
				l = r.x > o.x ? (r.x > s.x ? r.x : s.x) : o.x > s.x ? o.x : s.x,
				h = r.y > o.y ? (r.y > s.y ? r.y : s.y) : o.y > s.y ? o.y : s.y,
				u = gm(a, c, e, n, i),
				d = gm(l, h, e, n, i),
				p = t.prevZ,
				f = t.nextZ;
			for (; p && p.z >= u && f && f.z <= d; ) {
				if (
					p !== t.prev &&
					p !== t.next &&
					ym(r.x, r.y, o.x, o.y, s.x, s.y, p.x, p.y) &&
					bm(p.prev, p, p.next) >= 0
				)
					return !1;
				if (
					((p = p.prevZ),
					f !== t.prev &&
						f !== t.next &&
						ym(r.x, r.y, o.x, o.y, s.x, s.y, f.x, f.y) &&
						bm(f.prev, f, f.next) >= 0)
				)
					return !1;
				f = f.nextZ;
			}
			for (; p && p.z >= u; ) {
				if (
					p !== t.prev &&
					p !== t.next &&
					ym(r.x, r.y, o.x, o.y, s.x, s.y, p.x, p.y) &&
					bm(p.prev, p, p.next) >= 0
				)
					return !1;
				p = p.prevZ;
			}
			for (; f && f.z <= d; ) {
				if (
					f !== t.prev &&
					f !== t.next &&
					ym(r.x, r.y, o.x, o.y, s.x, s.y, f.x, f.y) &&
					bm(f.prev, f, f.next) >= 0
				)
					return !1;
				f = f.nextZ;
			}
			return !0;
		}
		function um(t, e, n) {
			let i = t;
			do {
				let r = i.prev,
					o = i.next.next;
				!wm(r, o) &&
					_m(r, i, i.next, o) &&
					Tm(r, o) &&
					Tm(o, r) &&
					(e.push(r.i / n),
					e.push(i.i / n),
					e.push(o.i / n),
					Lm(i),
					Lm(i.next),
					(i = t = o)),
					(i = i.next);
			} while (i !== t);
			return am(i);
		}
		function dm(t, e, n, i, r, o) {
			let s = t;
			do {
				let t = s.next.next;
				for (; t !== s.prev; ) {
					if (s.i !== t.i && xm(s, t)) {
						let a = Em(s, t);
						return (
							(s = am(s, s.next)),
							(a = am(a, a.next)),
							cm(s, e, n, i, r, o),
							void cm(a, e, n, i, r, o)
						);
					}
					t = t.next;
				}
				s = s.next;
			} while (s !== t);
		}
		function pm(t, e) {
			return t.x - e.x;
		}
		function fm(t, e) {
			if (
				(e = (function (t, e) {
					let n,
						i = e,
						r = t.x,
						o = t.y,
						s = -1 / 0;
					do {
						if (o <= i.y && o >= i.next.y && i.next.y !== i.y) {
							let t = i.x + ((o - i.y) * (i.next.x - i.x)) / (i.next.y - i.y);
							if (t <= r && t > s) {
								if (((s = t), t === r)) {
									if (o === i.y) return i;
									if (o === i.next.y) return i.next;
								}
								n = i.x < i.next.x ? i : i.next;
							}
						}
						i = i.next;
					} while (i !== e);
					if (!n) return null;
					if (r === s) return n;
					let a,
						c = n,
						l = n.x,
						h = n.y,
						u = 1 / 0;
					i = n;
					do {
						r >= i.x &&
							i.x >= l &&
							r !== i.x &&
							ym(o < h ? r : s, o, l, h, o < h ? s : r, o, i.x, i.y) &&
							((a = Math.abs(o - i.y) / (r - i.x)),
							Tm(i, t) &&
								(a < u ||
									(a === u && (i.x > n.x || (i.x === n.x && mm(n, i))))) &&
								((n = i), (u = a))),
							(i = i.next);
					} while (i !== c);
					return n;
				})(t, e))
			) {
				const n = Em(e, t);
				am(e, e.next), am(n, n.next);
			}
		}
		function mm(t, e) {
			return bm(t.prev, t, e.prev) < 0 && bm(e.next, t, t.next) < 0;
		}
		function gm(t, e, n, i, r) {
			return (
				(t =
					1431655765 &
					((t =
						858993459 &
						((t =
							252645135 &
							((t = 16711935 & ((t = 32767 * (t - n) * r) | (t << 8))) |
								(t << 4))) |
							(t << 2))) |
						(t << 1))) |
				((e =
					1431655765 &
					((e =
						858993459 &
						((e =
							252645135 &
							((e = 16711935 & ((e = 32767 * (e - i) * r) | (e << 8))) |
								(e << 4))) |
							(e << 2))) |
						(e << 1))) <<
					1)
			);
		}
		function vm(t) {
			let e = t,
				n = t;
			do {
				(e.x < n.x || (e.x === n.x && e.y < n.y)) && (n = e), (e = e.next);
			} while (e !== t);
			return n;
		}
		function ym(t, e, n, i, r, o, s, a) {
			return (
				(r - s) * (e - a) - (t - s) * (o - a) >= 0 &&
				(t - s) * (i - a) - (n - s) * (e - a) >= 0 &&
				(n - s) * (o - a) - (r - s) * (i - a) >= 0
			);
		}
		function xm(t, e) {
			return (
				t.next.i !== e.i &&
				t.prev.i !== e.i &&
				!(function (t, e) {
					let n = t;
					do {
						if (
							n.i !== t.i &&
							n.next.i !== t.i &&
							n.i !== e.i &&
							n.next.i !== e.i &&
							_m(n, n.next, t, e)
						)
							return !0;
						n = n.next;
					} while (n !== t);
					return !1;
				})(t, e) &&
				((Tm(t, e) &&
					Tm(e, t) &&
					(function (t, e) {
						let n = t,
							i = !1,
							r = (t.x + e.x) / 2,
							o = (t.y + e.y) / 2;
						do {
							n.y > o != n.next.y > o &&
								n.next.y !== n.y &&
								r < ((n.next.x - n.x) * (o - n.y)) / (n.next.y - n.y) + n.x &&
								(i = !i),
								(n = n.next);
						} while (n !== t);
						return i;
					})(t, e) &&
					(bm(t.prev, t, e.prev) || bm(t, e.prev, e))) ||
					(wm(t, e) && bm(t.prev, t, t.next) > 0 && bm(e.prev, e, e.next) > 0))
			);
		}
		function bm(t, e, n) {
			return (e.y - t.y) * (n.x - e.x) - (e.x - t.x) * (n.y - e.y);
		}
		function wm(t, e) {
			return t.x === e.x && t.y === e.y;
		}
		function _m(t, e, n, i) {
			const r = Sm(bm(t, e, n)),
				o = Sm(bm(t, e, i)),
				s = Sm(bm(n, i, t)),
				a = Sm(bm(n, i, e));
			return (
				(r !== o && s !== a) ||
				!(0 !== r || !Mm(t, n, e)) ||
				!(0 !== o || !Mm(t, i, e)) ||
				!(0 !== s || !Mm(n, t, i)) ||
				!(0 !== a || !Mm(n, e, i))
			);
		}
		function Mm(t, e, n) {
			return (
				e.x <= Math.max(t.x, n.x) &&
				e.x >= Math.min(t.x, n.x) &&
				e.y <= Math.max(t.y, n.y) &&
				e.y >= Math.min(t.y, n.y)
			);
		}
		function Sm(t) {
			return t > 0 ? 1 : t < 0 ? -1 : 0;
		}
		function Tm(t, e) {
			return bm(t.prev, t, t.next) < 0
				? bm(t, e, t.next) >= 0 && bm(t, t.prev, e) >= 0
				: bm(t, e, t.prev) < 0 || bm(t, t.next, e) < 0;
		}
		function Em(t, e) {
			let n = new Pm(t.i, t.x, t.y),
				i = new Pm(e.i, e.x, e.y),
				r = t.next,
				o = e.prev;
			return (
				(t.next = e),
				(e.prev = t),
				(n.next = r),
				(r.prev = n),
				(i.next = n),
				(n.prev = i),
				(o.next = i),
				(i.prev = o),
				i
			);
		}
		function Am(t, e, n, i) {
			const r = new Pm(t, e, n);
			return (
				i
					? ((r.next = i.next), (r.prev = i), (i.next.prev = r), (i.next = r))
					: ((r.prev = r), (r.next = r)),
				r
			);
		}
		function Lm(t) {
			(t.next.prev = t.prev),
				(t.prev.next = t.next),
				t.prevZ && (t.prevZ.nextZ = t.nextZ),
				t.nextZ && (t.nextZ.prevZ = t.prevZ);
		}
		function Pm(t, e, n) {
			(this.i = t),
				(this.x = e),
				(this.y = n),
				(this.prev = null),
				(this.next = null),
				(this.z = null),
				(this.prevZ = null),
				(this.nextZ = null),
				(this.steiner = !1);
		}
		const Rm = {
			area: function (t) {
				const e = t.length;
				let n = 0;
				for (let i = e - 1, r = 0; r < e; i = r++)
					n += t[i].x * t[r].y - t[r].x * t[i].y;
				return 0.5 * n;
			},
			isClockWise: function (t) {
				return Rm.area(t) < 0;
			},
			triangulateShape: function (t, e) {
				const n = [],
					i = [],
					r = [];
				Cm(t), Om(n, t);
				let o = t.length;
				e.forEach(Cm);
				for (let t = 0; t < e.length; t++)
					i.push(o), (o += e[t].length), Om(n, e[t]);
				const s = om(n, i);
				for (let t = 0; t < s.length; t += 3) r.push(s.slice(t, t + 3));
				return r;
			},
		};
		function Cm(t) {
			const e = t.length;
			e > 2 && t[e - 1].equals(t[0]) && t.pop();
		}
		function Om(t, e) {
			for (let n = 0; n < e.length; n++) t.push(e[n].x), t.push(e[n].y);
		}
		function Dm(t, e) {
			Eu.call(this),
				(this.type = "ExtrudeGeometry"),
				(this.parameters = { shapes: t, options: e }),
				this.fromBufferGeometry(new Im(t, e)),
				this.mergeVertices();
		}
		function Im(t, e) {
			eu.call(this),
				(this.type = "ExtrudeBufferGeometry"),
				(this.parameters = { shapes: t, options: e });
			const n = this,
				i = [],
				r = [];
			for (let e = 0, n = (t = Array.isArray(t) ? t : [t]).length; e < n; e++) {
				o(t[e]);
			}
			function o(t) {
				const o = [],
					s = void 0 !== e.curveSegments ? e.curveSegments : 12,
					a = void 0 !== e.steps ? e.steps : 1;
				let c = void 0 !== e.depth ? e.depth : 100,
					l = void 0 === e.bevelEnabled || e.bevelEnabled,
					h = void 0 !== e.bevelThickness ? e.bevelThickness : 6,
					u = void 0 !== e.bevelSize ? e.bevelSize : h - 2,
					d = void 0 !== e.bevelOffset ? e.bevelOffset : 0,
					p = void 0 !== e.bevelSegments ? e.bevelSegments : 3;
				const f = e.extrudePath,
					m = void 0 !== e.UVGenerator ? e.UVGenerator : km;
				void 0 !== e.amount &&
					(console.warn(
						"THREE.ExtrudeBufferGeometry: amount has been renamed to depth."
					),
					(c = e.amount));
				let g,
					v,
					y,
					x,
					b,
					w = !1;
				f &&
					((g = f.getSpacedPoints(a)),
					(w = !0),
					(l = !1),
					(v = f.computeFrenetFrames(a, !1)),
					(y = new ll()),
					(x = new ll()),
					(b = new ll())),
					l || ((p = 0), (h = 0), (u = 0), (d = 0));
				const _ = t.extractPoints(s);
				let M = _.shape;
				const S = _.holes;
				if (!Rm.isClockWise(M)) {
					M = M.reverse();
					for (let t = 0, e = S.length; t < e; t++) {
						const e = S[t];
						Rm.isClockWise(e) && (S[t] = e.reverse());
					}
				}
				const T = Rm.triangulateShape(M, S),
					E = M;
				for (let t = 0, e = S.length; t < e; t++) {
					const e = S[t];
					M = M.concat(e);
				}
				function A(t, e, n) {
					return (
						e || console.error("THREE.ExtrudeGeometry: vec does not exist"),
						e.clone().multiplyScalar(n).add(t)
					);
				}
				const L = M.length,
					P = T.length;
				function R(t, e, n) {
					let i, r, o;
					const s = t.x - e.x,
						a = t.y - e.y,
						c = n.x - t.x,
						l = n.y - t.y,
						h = s * s + a * a,
						u = s * l - a * c;
					if (Math.abs(u) > Number.EPSILON) {
						const u = Math.sqrt(h),
							d = Math.sqrt(c * c + l * l),
							p = e.x - a / u,
							f = e.y + s / u,
							m =
								((n.x - l / d - p) * l - (n.y + c / d - f) * c) /
								(s * l - a * c),
							g = (i = p + s * m - t.x) * i + (r = f + a * m - t.y) * r;
						if (g <= 2) return new Kc(i, r);
						o = Math.sqrt(g / 2);
					} else {
						let t = !1;
						s > Number.EPSILON
							? c > Number.EPSILON && (t = !0)
							: s < -Number.EPSILON
							? c < -Number.EPSILON && (t = !0)
							: Math.sign(a) === Math.sign(l) && (t = !0),
							t
								? ((i = -a), (r = s), (o = Math.sqrt(h)))
								: ((i = s), (r = a), (o = Math.sqrt(h / 2)));
					}
					return new Kc(i / o, r / o);
				}
				const C = [];
				for (
					let t = 0, e = E.length, n = e - 1, i = t + 1;
					t < e;
					t++, n++, i++
				)
					n === e && (n = 0), i === e && (i = 0), (C[t] = R(E[t], E[n], E[i]));
				const O = [];
				let D,
					I = C.concat();
				for (let t = 0, e = S.length; t < e; t++) {
					const e = S[t];
					D = [];
					for (
						let t = 0, n = e.length, i = n - 1, r = t + 1;
						t < n;
						t++, i++, r++
					)
						i === n && (i = 0),
							r === n && (r = 0),
							(D[t] = R(e[t], e[i], e[r]));
					O.push(D), (I = I.concat(D));
				}
				for (let t = 0; t < p; t++) {
					const e = t / p,
						n = h * Math.cos((e * Math.PI) / 2),
						i = u * Math.sin((e * Math.PI) / 2) + d;
					for (let t = 0, e = E.length; t < e; t++) {
						const e = A(E[t], C[t], i);
						B(e.x, e.y, -n);
					}
					for (let t = 0, e = S.length; t < e; t++) {
						const e = S[t];
						D = O[t];
						for (let t = 0, r = e.length; t < r; t++) {
							const r = A(e[t], D[t], i);
							B(r.x, r.y, -n);
						}
					}
				}
				const k = u + d;
				for (let t = 0; t < L; t++) {
					const e = l ? A(M[t], I[t], k) : M[t];
					w
						? (x.copy(v.normals[0]).multiplyScalar(e.x),
						  y.copy(v.binormals[0]).multiplyScalar(e.y),
						  b.copy(g[0]).add(x).add(y),
						  B(b.x, b.y, b.z))
						: B(e.x, e.y, 0);
				}
				for (let t = 1; t <= a; t++)
					for (let e = 0; e < L; e++) {
						const n = l ? A(M[e], I[e], k) : M[e];
						w
							? (x.copy(v.normals[t]).multiplyScalar(n.x),
							  y.copy(v.binormals[t]).multiplyScalar(n.y),
							  b.copy(g[t]).add(x).add(y),
							  B(b.x, b.y, b.z))
							: B(n.x, n.y, (c / a) * t);
					}
				for (let t = p - 1; t >= 0; t--) {
					const e = t / p,
						n = h * Math.cos((e * Math.PI) / 2),
						i = u * Math.sin((e * Math.PI) / 2) + d;
					for (let t = 0, e = E.length; t < e; t++) {
						const e = A(E[t], C[t], i);
						B(e.x, e.y, c + n);
					}
					for (let t = 0, e = S.length; t < e; t++) {
						const e = S[t];
						D = O[t];
						for (let t = 0, r = e.length; t < r; t++) {
							const r = A(e[t], D[t], i);
							w ? B(r.x, r.y + g[a - 1].y, g[a - 1].x + n) : B(r.x, r.y, c + n);
						}
					}
				}
				function N(t, e) {
					let n = t.length;
					for (; --n >= 0; ) {
						const i = n;
						let r = n - 1;
						r < 0 && (r = t.length - 1);
						for (let t = 0, n = a + 2 * p; t < n; t++) {
							const n = L * t,
								o = L * (t + 1);
							z(e + i + n, e + r + n, e + r + o, e + i + o);
						}
					}
				}
				function B(t, e, n) {
					o.push(t), o.push(e), o.push(n);
				}
				function F(t, e, r) {
					H(t), H(e), H(r);
					const o = i.length / 3,
						s = m.generateTopUV(n, i, o - 3, o - 2, o - 1);
					U(s[0]), U(s[1]), U(s[2]);
				}
				function z(t, e, r, o) {
					H(t), H(e), H(o), H(e), H(r), H(o);
					const s = i.length / 3,
						a = m.generateSideWallUV(n, i, s - 6, s - 3, s - 2, s - 1);
					U(a[0]), U(a[1]), U(a[3]), U(a[1]), U(a[2]), U(a[3]);
				}
				function H(t) {
					i.push(o[3 * t + 0]), i.push(o[3 * t + 1]), i.push(o[3 * t + 2]);
				}
				function U(t) {
					r.push(t.x), r.push(t.y);
				}
				!(function () {
					const t = i.length / 3;
					if (l) {
						let t = 0,
							e = L * t;
						for (let t = 0; t < P; t++) {
							const n = T[t];
							F(n[2] + e, n[1] + e, n[0] + e);
						}
						e = L * (t = a + 2 * p);
						for (let t = 0; t < P; t++) {
							const n = T[t];
							F(n[0] + e, n[1] + e, n[2] + e);
						}
					} else {
						for (let t = 0; t < P; t++) {
							const e = T[t];
							F(e[2], e[1], e[0]);
						}
						for (let t = 0; t < P; t++) {
							const e = T[t];
							F(e[0] + L * a, e[1] + L * a, e[2] + L * a);
						}
					}
					n.addGroup(t, i.length / 3 - t, 0);
				})(),
					(function () {
						const t = i.length / 3;
						let e = 0;
						N(E, e), (e += E.length);
						for (let t = 0, n = S.length; t < n; t++) {
							const n = S[t];
							N(n, e), (e += n.length);
						}
						n.addGroup(t, i.length / 3 - t, 1);
					})();
			}
			this.setAttribute("position", new jh(i, 3)),
				this.setAttribute("uv", new jh(r, 2)),
				this.computeVertexNormals();
		}
		(Dm.prototype = Object.create(Eu.prototype)),
			(Dm.prototype.constructor = Dm),
			(Dm.prototype.toJSON = function () {
				const t = Eu.prototype.toJSON.call(this);
				return Nm(this.parameters.shapes, this.parameters.options, t);
			}),
			(Im.prototype = Object.create(eu.prototype)),
			(Im.prototype.constructor = Im),
			(Im.prototype.toJSON = function () {
				const t = eu.prototype.toJSON.call(this);
				return Nm(this.parameters.shapes, this.parameters.options, t);
			});
		const km = {
			generateTopUV: function (t, e, n, i, r) {
				const o = e[3 * n],
					s = e[3 * n + 1],
					a = e[3 * i],
					c = e[3 * i + 1],
					l = e[3 * r],
					h = e[3 * r + 1];
				return [new Kc(o, s), new Kc(a, c), new Kc(l, h)];
			},
			generateSideWallUV: function (t, e, n, i, r, o) {
				const s = e[3 * n],
					a = e[3 * n + 1],
					c = e[3 * n + 2],
					l = e[3 * i],
					h = e[3 * i + 1],
					u = e[3 * i + 2],
					d = e[3 * r],
					p = e[3 * r + 1],
					f = e[3 * r + 2],
					m = e[3 * o],
					g = e[3 * o + 1],
					v = e[3 * o + 2];
				return Math.abs(a - h) < 0.01
					? [
							new Kc(s, 1 - c),
							new Kc(l, 1 - u),
							new Kc(d, 1 - f),
							new Kc(m, 1 - v),
					  ]
					: [
							new Kc(a, 1 - c),
							new Kc(h, 1 - u),
							new Kc(p, 1 - f),
							new Kc(g, 1 - v),
					  ];
			},
		};
		function Nm(t, e, n) {
			if (((n.shapes = []), Array.isArray(t)))
				for (let e = 0, i = t.length; e < i; e++) {
					const i = t[e];
					n.shapes.push(i.uuid);
				}
			else n.shapes.push(t.uuid);
			return (
				void 0 !== e.extrudePath &&
					(n.options.extrudePath = e.extrudePath.toJSON()),
				n
			);
		}
		function Bm(t, e) {
			Eu.call(this),
				(this.type = "TextGeometry"),
				(this.parameters = { text: t, parameters: e }),
				this.fromBufferGeometry(new Fm(t, e)),
				this.mergeVertices();
		}
		function Fm(t, e) {
			const n = (e = e || {}).font;
			if (!n || !n.isFont)
				return (
					console.error(
						"THREE.TextGeometry: font parameter is not an instance of THREE.Font."
					),
					new Eu()
				);
			const i = n.generateShapes(t, e.size);
			(e.depth = void 0 !== e.height ? e.height : 50),
				void 0 === e.bevelThickness && (e.bevelThickness = 10),
				void 0 === e.bevelSize && (e.bevelSize = 8),
				void 0 === e.bevelEnabled && (e.bevelEnabled = !1),
				Im.call(this, i, e),
				(this.type = "TextBufferGeometry");
		}
		function zm(t, e, n, i, r, o, s) {
			Eu.call(this),
				(this.type = "SphereGeometry"),
				(this.parameters = {
					radius: t,
					widthSegments: e,
					heightSegments: n,
					phiStart: i,
					phiLength: r,
					thetaStart: o,
					thetaLength: s,
				}),
				this.fromBufferGeometry(new Hm(t, e, n, i, r, o, s)),
				this.mergeVertices();
		}
		function Hm(t, e, n, i, r, o, s) {
			eu.call(this),
				(this.type = "SphereBufferGeometry"),
				(this.parameters = {
					radius: t,
					widthSegments: e,
					heightSegments: n,
					phiStart: i,
					phiLength: r,
					thetaStart: o,
					thetaLength: s,
				}),
				(t = t || 1),
				(e = Math.max(3, Math.floor(e) || 8)),
				(n = Math.max(2, Math.floor(n) || 6)),
				(i = void 0 !== i ? i : 0),
				(r = void 0 !== r ? r : 2 * Math.PI),
				(o = void 0 !== o ? o : 0),
				(s = void 0 !== s ? s : Math.PI);
			const a = Math.min(o + s, Math.PI);
			let c = 0;
			const l = [],
				h = new ll(),
				u = new ll(),
				d = [],
				p = [],
				f = [],
				m = [];
			for (let d = 0; d <= n; d++) {
				const g = [],
					v = d / n;
				let y = 0;
				0 == d && 0 == o
					? (y = 0.5 / e)
					: d == n && a == Math.PI && (y = -0.5 / e);
				for (let n = 0; n <= e; n++) {
					const a = n / e;
					(h.x = -t * Math.cos(i + a * r) * Math.sin(o + v * s)),
						(h.y = t * Math.cos(o + v * s)),
						(h.z = t * Math.sin(i + a * r) * Math.sin(o + v * s)),
						p.push(h.x, h.y, h.z),
						u.copy(h).normalize(),
						f.push(u.x, u.y, u.z),
						m.push(a + y, 1 - v),
						g.push(c++);
				}
				l.push(g);
			}
			for (let t = 0; t < n; t++)
				for (let i = 0; i < e; i++) {
					const e = l[t][i + 1],
						r = l[t][i],
						s = l[t + 1][i],
						c = l[t + 1][i + 1];
					(0 !== t || o > 0) && d.push(e, r, c),
						(t !== n - 1 || a < Math.PI) && d.push(r, s, c);
				}
			this.setIndex(d),
				this.setAttribute("position", new jh(p, 3)),
				this.setAttribute("normal", new jh(f, 3)),
				this.setAttribute("uv", new jh(m, 2));
		}
		function Um(t, e, n, i, r, o) {
			Eu.call(this),
				(this.type = "RingGeometry"),
				(this.parameters = {
					innerRadius: t,
					outerRadius: e,
					thetaSegments: n,
					phiSegments: i,
					thetaStart: r,
					thetaLength: o,
				}),
				this.fromBufferGeometry(new Gm(t, e, n, i, r, o)),
				this.mergeVertices();
		}
		function Gm(t, e, n, i, r, o) {
			eu.call(this),
				(this.type = "RingBufferGeometry"),
				(this.parameters = {
					innerRadius: t,
					outerRadius: e,
					thetaSegments: n,
					phiSegments: i,
					thetaStart: r,
					thetaLength: o,
				}),
				(t = t || 0.5),
				(e = e || 1),
				(r = void 0 !== r ? r : 0),
				(o = void 0 !== o ? o : 2 * Math.PI),
				(n = void 0 !== n ? Math.max(3, n) : 8);
			const s = [],
				a = [],
				c = [],
				l = [];
			let h = t;
			const u = (e - t) / (i = void 0 !== i ? Math.max(1, i) : 1),
				d = new ll(),
				p = new Kc();
			for (let t = 0; t <= i; t++) {
				for (let t = 0; t <= n; t++) {
					const i = r + (t / n) * o;
					(d.x = h * Math.cos(i)),
						(d.y = h * Math.sin(i)),
						a.push(d.x, d.y, d.z),
						c.push(0, 0, 1),
						(p.x = (d.x / e + 1) / 2),
						(p.y = (d.y / e + 1) / 2),
						l.push(p.x, p.y);
				}
				h += u;
			}
			for (let t = 0; t < i; t++) {
				const e = t * (n + 1);
				for (let t = 0; t < n; t++) {
					const i = t + e,
						r = i,
						o = i + n + 1,
						a = i + n + 2,
						c = i + 1;
					s.push(r, o, c), s.push(o, a, c);
				}
			}
			this.setIndex(s),
				this.setAttribute("position", new jh(a, 3)),
				this.setAttribute("normal", new jh(c, 3)),
				this.setAttribute("uv", new jh(l, 2));
		}
		function Vm(t, e, n, i) {
			Eu.call(this),
				(this.type = "LatheGeometry"),
				(this.parameters = {
					points: t,
					segments: e,
					phiStart: n,
					phiLength: i,
				}),
				this.fromBufferGeometry(new jm(t, e, n, i)),
				this.mergeVertices();
		}
		function jm(t, e, n, i) {
			eu.call(this),
				(this.type = "LatheBufferGeometry"),
				(this.parameters = {
					points: t,
					segments: e,
					phiStart: n,
					phiLength: i,
				}),
				(e = Math.floor(e) || 12),
				(n = n || 0),
				(i = i || 2 * Math.PI),
				(i = Jc.clamp(i, 0, 2 * Math.PI));
			const r = [],
				o = [],
				s = [],
				a = 1 / e,
				c = new ll(),
				l = new Kc();
			for (let r = 0; r <= e; r++) {
				const h = n + r * a * i,
					u = Math.sin(h),
					d = Math.cos(h);
				for (let n = 0; n <= t.length - 1; n++)
					(c.x = t[n].x * u),
						(c.y = t[n].y),
						(c.z = t[n].x * d),
						o.push(c.x, c.y, c.z),
						(l.x = r / e),
						(l.y = n / (t.length - 1)),
						s.push(l.x, l.y);
			}
			for (let n = 0; n < e; n++)
				for (let e = 0; e < t.length - 1; e++) {
					const i = e + n * t.length,
						o = i,
						s = i + t.length,
						a = i + t.length + 1,
						c = i + 1;
					r.push(o, s, c), r.push(s, a, c);
				}
			if (
				(this.setIndex(r),
				this.setAttribute("position", new jh(o, 3)),
				this.setAttribute("uv", new jh(s, 2)),
				this.computeVertexNormals(),
				i === 2 * Math.PI)
			) {
				const n = this.attributes.normal.array,
					i = new ll(),
					r = new ll(),
					o = new ll(),
					s = e * t.length * 3;
				for (let e = 0, a = 0; e < t.length; e++, a += 3)
					(i.x = n[a + 0]),
						(i.y = n[a + 1]),
						(i.z = n[a + 2]),
						(r.x = n[s + a + 0]),
						(r.y = n[s + a + 1]),
						(r.z = n[s + a + 2]),
						o.addVectors(i, r).normalize(),
						(n[a + 0] = n[s + a + 0] = o.x),
						(n[a + 1] = n[s + a + 1] = o.y),
						(n[a + 2] = n[s + a + 2] = o.z);
			}
		}
		function Wm(t, e) {
			Eu.call(this),
				(this.type = "ShapeGeometry"),
				"object" == typeof e &&
					(console.warn(
						"THREE.ShapeGeometry: Options parameter has been removed."
					),
					(e = e.curveSegments)),
				(this.parameters = { shapes: t, curveSegments: e }),
				this.fromBufferGeometry(new qm(t, e)),
				this.mergeVertices();
		}
		function qm(t, e) {
			eu.call(this),
				(this.type = "ShapeBufferGeometry"),
				(this.parameters = { shapes: t, curveSegments: e }),
				(e = e || 12);
			const n = [],
				i = [],
				r = [],
				o = [];
			let s = 0,
				a = 0;
			if (!1 === Array.isArray(t)) c(t);
			else
				for (let e = 0; e < t.length; e++)
					c(t[e]), this.addGroup(s, a, e), (s += a), (a = 0);
			function c(t) {
				const s = i.length / 3,
					c = t.extractPoints(e);
				let l = c.shape;
				const h = c.holes;
				!1 === Rm.isClockWise(l) && (l = l.reverse());
				for (let t = 0, e = h.length; t < e; t++) {
					const e = h[t];
					!0 === Rm.isClockWise(e) && (h[t] = e.reverse());
				}
				const u = Rm.triangulateShape(l, h);
				for (let t = 0, e = h.length; t < e; t++) {
					const e = h[t];
					l = l.concat(e);
				}
				for (let t = 0, e = l.length; t < e; t++) {
					const e = l[t];
					i.push(e.x, e.y, 0), r.push(0, 0, 1), o.push(e.x, e.y);
				}
				for (let t = 0, e = u.length; t < e; t++) {
					const e = u[t],
						i = e[0] + s,
						r = e[1] + s,
						o = e[2] + s;
					n.push(i, r, o), (a += 3);
				}
			}
			this.setIndex(n),
				this.setAttribute("position", new jh(i, 3)),
				this.setAttribute("normal", new jh(r, 3)),
				this.setAttribute("uv", new jh(o, 2));
		}
		function Ym(t, e) {
			if (((e.shapes = []), Array.isArray(t)))
				for (let n = 0, i = t.length; n < i; n++) {
					const i = t[n];
					e.shapes.push(i.uuid);
				}
			else e.shapes.push(t.uuid);
			return e;
		}
		function Xm(t, e) {
			eu.call(this),
				(this.type = "EdgesGeometry"),
				(this.parameters = { thresholdAngle: e }),
				(e = void 0 !== e ? e : 1);
			const n = [],
				i = Math.cos(Jc.DEG2RAD * e),
				r = [0, 0],
				o = {};
			let s, a, c;
			const l = ["a", "b", "c"];
			let h;
			t.isBufferGeometry
				? (h = new Eu()).fromBufferGeometry(t)
				: (h = t.clone()),
				h.mergeVertices(),
				h.computeFaceNormals();
			const u = h.vertices,
				d = h.faces;
			for (let t = 0, e = d.length; t < e; t++) {
				const e = d[t];
				for (let n = 0; n < 3; n++)
					(s = e[l[n]]),
						(a = e[l[(n + 1) % 3]]),
						(r[0] = Math.min(s, a)),
						(r[1] = Math.max(s, a)),
						void 0 === o[(c = r[0] + "," + r[1])]
							? (o[c] = { index1: r[0], index2: r[1], face1: t, face2: void 0 })
							: (o[c].face2 = t);
			}
			for (c in o) {
				const t = o[c];
				if (
					void 0 === t.face2 ||
					d[t.face1].normal.dot(d[t.face2].normal) <= i
				) {
					let e = u[t.index1];
					n.push(e.x, e.y, e.z), (e = u[t.index2]), n.push(e.x, e.y, e.z);
				}
			}
			this.setAttribute("position", new jh(n, 3));
		}
		function Zm(t, e, n, i, r, o, s, a) {
			Eu.call(this),
				(this.type = "CylinderGeometry"),
				(this.parameters = {
					radiusTop: t,
					radiusBottom: e,
					height: n,
					radialSegments: i,
					heightSegments: r,
					openEnded: o,
					thetaStart: s,
					thetaLength: a,
				}),
				this.fromBufferGeometry(new Jm(t, e, n, i, r, o, s, a)),
				this.mergeVertices();
		}
		function Jm(t, e, n, i, r, o, s, a) {
			eu.call(this),
				(this.type = "CylinderBufferGeometry"),
				(this.parameters = {
					radiusTop: t,
					radiusBottom: e,
					height: n,
					radialSegments: i,
					heightSegments: r,
					openEnded: o,
					thetaStart: s,
					thetaLength: a,
				});
			const c = this;
			(t = void 0 !== t ? t : 1),
				(e = void 0 !== e ? e : 1),
				(n = n || 1),
				(i = Math.floor(i) || 8),
				(r = Math.floor(r) || 1),
				(o = void 0 !== o && o),
				(s = void 0 !== s ? s : 0),
				(a = void 0 !== a ? a : 2 * Math.PI);
			const l = [],
				h = [],
				u = [],
				d = [];
			let p = 0;
			const f = [],
				m = n / 2;
			let g = 0;
			function v(n) {
				let r, o;
				const f = new Kc(),
					v = new ll();
				let y = 0;
				const x = !0 === n ? t : e,
					b = !0 === n ? 1 : -1;
				r = p;
				for (let t = 1; t <= i; t++)
					h.push(0, m * b, 0), u.push(0, b, 0), d.push(0.5, 0.5), p++;
				o = p;
				for (let t = 0; t <= i; t++) {
					const e = (t / i) * a + s,
						n = Math.cos(e),
						r = Math.sin(e);
					(v.x = x * r),
						(v.y = m * b),
						(v.z = x * n),
						h.push(v.x, v.y, v.z),
						u.push(0, b, 0),
						(f.x = 0.5 * n + 0.5),
						(f.y = 0.5 * r * b + 0.5),
						d.push(f.x, f.y),
						p++;
				}
				for (let t = 0; t < i; t++) {
					const e = r + t,
						i = o + t;
					!0 === n ? l.push(i, i + 1, e) : l.push(i + 1, i, e), (y += 3);
				}
				c.addGroup(g, y, !0 === n ? 1 : 2), (g += y);
			}
			!(function () {
				const o = new ll(),
					v = new ll();
				let y = 0;
				const x = (e - t) / n;
				for (let c = 0; c <= r; c++) {
					const l = [],
						g = c / r,
						y = g * (e - t) + t;
					for (let t = 0; t <= i; t++) {
						const e = t / i,
							r = e * a + s,
							c = Math.sin(r),
							f = Math.cos(r);
						(v.x = y * c),
							(v.y = -g * n + m),
							(v.z = y * f),
							h.push(v.x, v.y, v.z),
							o.set(c, x, f).normalize(),
							u.push(o.x, o.y, o.z),
							d.push(e, 1 - g),
							l.push(p++);
					}
					f.push(l);
				}
				for (let t = 0; t < i; t++)
					for (let e = 0; e < r; e++) {
						const n = f[e][t],
							i = f[e + 1][t],
							r = f[e + 1][t + 1],
							o = f[e][t + 1];
						l.push(n, i, o), l.push(i, r, o), (y += 6);
					}
				c.addGroup(g, y, 0), (g += y);
			})(),
				!1 === o && (t > 0 && v(!0), e > 0 && v(!1)),
				this.setIndex(l),
				this.setAttribute("position", new jh(h, 3)),
				this.setAttribute("normal", new jh(u, 3)),
				this.setAttribute("uv", new jh(d, 2));
		}
		function Km(t, e, n, i, r, o, s) {
			Zm.call(this, 0, t, e, n, i, r, o, s),
				(this.type = "ConeGeometry"),
				(this.parameters = {
					radius: t,
					height: e,
					radialSegments: n,
					heightSegments: i,
					openEnded: r,
					thetaStart: o,
					thetaLength: s,
				});
		}
		function Qm(t, e, n, i, r, o, s) {
			Jm.call(this, 0, t, e, n, i, r, o, s),
				(this.type = "ConeBufferGeometry"),
				(this.parameters = {
					radius: t,
					height: e,
					radialSegments: n,
					heightSegments: i,
					openEnded: r,
					thetaStart: o,
					thetaLength: s,
				});
		}
		function $m(t, e, n, i) {
			Eu.call(this),
				(this.type = "CircleGeometry"),
				(this.parameters = {
					radius: t,
					segments: e,
					thetaStart: n,
					thetaLength: i,
				}),
				this.fromBufferGeometry(new tg(t, e, n, i)),
				this.mergeVertices();
		}
		function tg(t, e, n, i) {
			eu.call(this),
				(this.type = "CircleBufferGeometry"),
				(this.parameters = {
					radius: t,
					segments: e,
					thetaStart: n,
					thetaLength: i,
				}),
				(t = t || 1),
				(e = void 0 !== e ? Math.max(3, e) : 8),
				(n = void 0 !== n ? n : 0),
				(i = void 0 !== i ? i : 2 * Math.PI);
			const r = [],
				o = [],
				s = [],
				a = [],
				c = new ll(),
				l = new Kc();
			o.push(0, 0, 0), s.push(0, 0, 1), a.push(0.5, 0.5);
			for (let r = 0, h = 3; r <= e; r++, h += 3) {
				const u = n + (r / e) * i;
				(c.x = t * Math.cos(u)),
					(c.y = t * Math.sin(u)),
					o.push(c.x, c.y, c.z),
					s.push(0, 0, 1),
					(l.x = (o[h] / t + 1) / 2),
					(l.y = (o[h + 1] / t + 1) / 2),
					a.push(l.x, l.y);
			}
			for (let t = 1; t <= e; t++) r.push(t, t + 1, 0);
			this.setIndex(r),
				this.setAttribute("position", new jh(o, 3)),
				this.setAttribute("normal", new jh(s, 3)),
				this.setAttribute("uv", new jh(a, 2));
		}
		(Bm.prototype = Object.create(Eu.prototype)),
			(Bm.prototype.constructor = Bm),
			(Fm.prototype = Object.create(Im.prototype)),
			(Fm.prototype.constructor = Fm),
			(zm.prototype = Object.create(Eu.prototype)),
			(zm.prototype.constructor = zm),
			(Hm.prototype = Object.create(eu.prototype)),
			(Hm.prototype.constructor = Hm),
			(Um.prototype = Object.create(Eu.prototype)),
			(Um.prototype.constructor = Um),
			(Gm.prototype = Object.create(eu.prototype)),
			(Gm.prototype.constructor = Gm),
			(Vm.prototype = Object.create(Eu.prototype)),
			(Vm.prototype.constructor = Vm),
			(jm.prototype = Object.create(eu.prototype)),
			(jm.prototype.constructor = jm),
			(Wm.prototype = Object.create(Eu.prototype)),
			(Wm.prototype.constructor = Wm),
			(Wm.prototype.toJSON = function () {
				const t = Eu.prototype.toJSON.call(this);
				return Ym(this.parameters.shapes, t);
			}),
			(qm.prototype = Object.create(eu.prototype)),
			(qm.prototype.constructor = qm),
			(qm.prototype.toJSON = function () {
				const t = eu.prototype.toJSON.call(this);
				return Ym(this.parameters.shapes, t);
			}),
			(Xm.prototype = Object.create(eu.prototype)),
			(Xm.prototype.constructor = Xm),
			(Zm.prototype = Object.create(Eu.prototype)),
			(Zm.prototype.constructor = Zm),
			(Jm.prototype = Object.create(eu.prototype)),
			(Jm.prototype.constructor = Jm),
			(Km.prototype = Object.create(Zm.prototype)),
			(Km.prototype.constructor = Km),
			(Qm.prototype = Object.create(Jm.prototype)),
			(Qm.prototype.constructor = Qm),
			($m.prototype = Object.create(Eu.prototype)),
			($m.prototype.constructor = $m),
			(tg.prototype = Object.create(eu.prototype)),
			(tg.prototype.constructor = tg);
		var eg = Object.freeze({
			__proto__: null,
			WireframeGeometry: Hf,
			ParametricGeometry: Uf,
			ParametricBufferGeometry: Gf,
			TetrahedronGeometry: Wf,
			TetrahedronBufferGeometry: qf,
			OctahedronGeometry: Yf,
			OctahedronBufferGeometry: Xf,
			IcosahedronGeometry: Zf,
			IcosahedronBufferGeometry: Jf,
			DodecahedronGeometry: Kf,
			DodecahedronBufferGeometry: Qf,
			PolyhedronGeometry: Vf,
			PolyhedronBufferGeometry: jf,
			TubeGeometry: $f,
			TubeBufferGeometry: tm,
			TorusKnotGeometry: em,
			TorusKnotBufferGeometry: nm,
			TorusGeometry: im,
			TorusBufferGeometry: rm,
			TextGeometry: Bm,
			TextBufferGeometry: Fm,
			SphereGeometry: zm,
			SphereBufferGeometry: Hm,
			RingGeometry: Um,
			RingBufferGeometry: Gm,
			PlaneGeometry: Yu,
			PlaneBufferGeometry: Xu,
			LatheGeometry: Vm,
			LatheBufferGeometry: jm,
			ShapeGeometry: Wm,
			ShapeBufferGeometry: qm,
			ExtrudeGeometry: Dm,
			ExtrudeBufferGeometry: Im,
			EdgesGeometry: Xm,
			ConeGeometry: Km,
			ConeBufferGeometry: Qm,
			CylinderGeometry: Zm,
			CylinderBufferGeometry: Jm,
			CircleGeometry: $m,
			CircleBufferGeometry: tg,
			BoxGeometry: class extends Eu {
				constructor(t, e, n, i, r, o) {
					super(),
						(this.type = "BoxGeometry"),
						(this.parameters = {
							width: t,
							height: e,
							depth: n,
							widthSegments: i,
							heightSegments: r,
							depthSegments: o,
						}),
						this.fromBufferGeometry(new Au(t, e, n, i, r, o)),
						this.mergeVertices();
				}
			},
			BoxBufferGeometry: Au,
		});
		function ng(t) {
			Oh.call(this),
				(this.type = "ShadowMaterial"),
				(this.color = new Eh(0)),
				(this.transparent = !0),
				this.setValues(t);
		}
		function ig(t) {
			Du.call(this, t), (this.type = "RawShaderMaterial");
		}
		function rg(t) {
			Oh.call(this),
				(this.defines = { STANDARD: "" }),
				(this.type = "MeshStandardMaterial"),
				(this.color = new Eh(16777215)),
				(this.roughness = 1),
				(this.metalness = 0),
				(this.map = null),
				(this.lightMap = null),
				(this.lightMapIntensity = 1),
				(this.aoMap = null),
				(this.aoMapIntensity = 1),
				(this.emissive = new Eh(0)),
				(this.emissiveIntensity = 1),
				(this.emissiveMap = null),
				(this.bumpMap = null),
				(this.bumpScale = 1),
				(this.normalMap = null),
				(this.normalMapType = Gc),
				(this.normalScale = new Kc(1, 1)),
				(this.displacementMap = null),
				(this.displacementScale = 1),
				(this.displacementBias = 0),
				(this.roughnessMap = null),
				(this.metalnessMap = null),
				(this.alphaMap = null),
				(this.envMap = null),
				(this.envMapIntensity = 1),
				(this.refractionRatio = 0.98),
				(this.wireframe = !1),
				(this.wireframeLinewidth = 1),
				(this.wireframeLinecap = "round"),
				(this.wireframeLinejoin = "round"),
				(this.skinning = !1),
				(this.morphTargets = !1),
				(this.morphNormals = !1),
				(this.vertexTangents = !1),
				this.setValues(t);
		}
		function og(t) {
			rg.call(this),
				(this.defines = { STANDARD: "", PHYSICAL: "" }),
				(this.type = "MeshPhysicalMaterial"),
				(this.clearcoat = 0),
				(this.clearcoatMap = null),
				(this.clearcoatRoughness = 0),
				(this.clearcoatRoughnessMap = null),
				(this.clearcoatNormalScale = new Kc(1, 1)),
				(this.clearcoatNormalMap = null),
				(this.reflectivity = 0.5),
				(this.sheen = null),
				(this.transparency = 0),
				this.setValues(t);
		}
		function sg(t) {
			Oh.call(this),
				(this.type = "MeshPhongMaterial"),
				(this.color = new Eh(16777215)),
				(this.specular = new Eh(1118481)),
				(this.shininess = 30),
				(this.map = null),
				(this.lightMap = null),
				(this.lightMapIntensity = 1),
				(this.aoMap = null),
				(this.aoMapIntensity = 1),
				(this.emissive = new Eh(0)),
				(this.emissiveIntensity = 1),
				(this.emissiveMap = null),
				(this.bumpMap = null),
				(this.bumpScale = 1),
				(this.normalMap = null),
				(this.normalMapType = Gc),
				(this.normalScale = new Kc(1, 1)),
				(this.displacementMap = null),
				(this.displacementScale = 1),
				(this.displacementBias = 0),
				(this.specularMap = null),
				(this.alphaMap = null),
				(this.envMap = null),
				(this.combine = qs),
				(this.reflectivity = 1),
				(this.refractionRatio = 0.98),
				(this.wireframe = !1),
				(this.wireframeLinewidth = 1),
				(this.wireframeLinecap = "round"),
				(this.wireframeLinejoin = "round"),
				(this.skinning = !1),
				(this.morphTargets = !1),
				(this.morphNormals = !1),
				this.setValues(t);
		}
		function ag(t) {
			Oh.call(this),
				(this.defines = { TOON: "" }),
				(this.type = "MeshToonMaterial"),
				(this.color = new Eh(16777215)),
				(this.map = null),
				(this.gradientMap = null),
				(this.lightMap = null),
				(this.lightMapIntensity = 1),
				(this.aoMap = null),
				(this.aoMapIntensity = 1),
				(this.emissive = new Eh(0)),
				(this.emissiveIntensity = 1),
				(this.emissiveMap = null),
				(this.bumpMap = null),
				(this.bumpScale = 1),
				(this.normalMap = null),
				(this.normalMapType = Gc),
				(this.normalScale = new Kc(1, 1)),
				(this.displacementMap = null),
				(this.displacementScale = 1),
				(this.displacementBias = 0),
				(this.alphaMap = null),
				(this.wireframe = !1),
				(this.wireframeLinewidth = 1),
				(this.wireframeLinecap = "round"),
				(this.wireframeLinejoin = "round"),
				(this.skinning = !1),
				(this.morphTargets = !1),
				(this.morphNormals = !1),
				this.setValues(t);
		}
		function cg(t) {
			Oh.call(this),
				(this.type = "MeshNormalMaterial"),
				(this.bumpMap = null),
				(this.bumpScale = 1),
				(this.normalMap = null),
				(this.normalMapType = Gc),
				(this.normalScale = new Kc(1, 1)),
				(this.displacementMap = null),
				(this.displacementScale = 1),
				(this.displacementBias = 0),
				(this.wireframe = !1),
				(this.wireframeLinewidth = 1),
				(this.fog = !1),
				(this.skinning = !1),
				(this.morphTargets = !1),
				(this.morphNormals = !1),
				this.setValues(t);
		}
		function lg(t) {
			Oh.call(this),
				(this.type = "MeshLambertMaterial"),
				(this.color = new Eh(16777215)),
				(this.map = null),
				(this.lightMap = null),
				(this.lightMapIntensity = 1),
				(this.aoMap = null),
				(this.aoMapIntensity = 1),
				(this.emissive = new Eh(0)),
				(this.emissiveIntensity = 1),
				(this.emissiveMap = null),
				(this.specularMap = null),
				(this.alphaMap = null),
				(this.envMap = null),
				(this.combine = qs),
				(this.reflectivity = 1),
				(this.refractionRatio = 0.98),
				(this.wireframe = !1),
				(this.wireframeLinewidth = 1),
				(this.wireframeLinecap = "round"),
				(this.wireframeLinejoin = "round"),
				(this.skinning = !1),
				(this.morphTargets = !1),
				(this.morphNormals = !1),
				this.setValues(t);
		}
		function hg(t) {
			Oh.call(this),
				(this.defines = { MATCAP: "" }),
				(this.type = "MeshMatcapMaterial"),
				(this.color = new Eh(16777215)),
				(this.matcap = null),
				(this.map = null),
				(this.bumpMap = null),
				(this.bumpScale = 1),
				(this.normalMap = null),
				(this.normalMapType = Gc),
				(this.normalScale = new Kc(1, 1)),
				(this.displacementMap = null),
				(this.displacementScale = 1),
				(this.displacementBias = 0),
				(this.alphaMap = null),
				(this.skinning = !1),
				(this.morphTargets = !1),
				(this.morphNormals = !1),
				this.setValues(t);
		}
		function ug(t) {
			yf.call(this),
				(this.type = "LineDashedMaterial"),
				(this.scale = 1),
				(this.dashSize = 3),
				(this.gapSize = 1),
				this.setValues(t);
		}
		(ng.prototype = Object.create(Oh.prototype)),
			(ng.prototype.constructor = ng),
			(ng.prototype.isShadowMaterial = !0),
			(ng.prototype.copy = function (t) {
				return Oh.prototype.copy.call(this, t), this.color.copy(t.color), this;
			}),
			(ig.prototype = Object.create(Du.prototype)),
			(ig.prototype.constructor = ig),
			(ig.prototype.isRawShaderMaterial = !0),
			(rg.prototype = Object.create(Oh.prototype)),
			(rg.prototype.constructor = rg),
			(rg.prototype.isMeshStandardMaterial = !0),
			(rg.prototype.copy = function (t) {
				return (
					Oh.prototype.copy.call(this, t),
					(this.defines = { STANDARD: "" }),
					this.color.copy(t.color),
					(this.roughness = t.roughness),
					(this.metalness = t.metalness),
					(this.map = t.map),
					(this.lightMap = t.lightMap),
					(this.lightMapIntensity = t.lightMapIntensity),
					(this.aoMap = t.aoMap),
					(this.aoMapIntensity = t.aoMapIntensity),
					this.emissive.copy(t.emissive),
					(this.emissiveMap = t.emissiveMap),
					(this.emissiveIntensity = t.emissiveIntensity),
					(this.bumpMap = t.bumpMap),
					(this.bumpScale = t.bumpScale),
					(this.normalMap = t.normalMap),
					(this.normalMapType = t.normalMapType),
					this.normalScale.copy(t.normalScale),
					(this.displacementMap = t.displacementMap),
					(this.displacementScale = t.displacementScale),
					(this.displacementBias = t.displacementBias),
					(this.roughnessMap = t.roughnessMap),
					(this.metalnessMap = t.metalnessMap),
					(this.alphaMap = t.alphaMap),
					(this.envMap = t.envMap),
					(this.envMapIntensity = t.envMapIntensity),
					(this.refractionRatio = t.refractionRatio),
					(this.wireframe = t.wireframe),
					(this.wireframeLinewidth = t.wireframeLinewidth),
					(this.wireframeLinecap = t.wireframeLinecap),
					(this.wireframeLinejoin = t.wireframeLinejoin),
					(this.skinning = t.skinning),
					(this.morphTargets = t.morphTargets),
					(this.morphNormals = t.morphNormals),
					(this.vertexTangents = t.vertexTangents),
					this
				);
			}),
			(og.prototype = Object.create(rg.prototype)),
			(og.prototype.constructor = og),
			(og.prototype.isMeshPhysicalMaterial = !0),
			(og.prototype.copy = function (t) {
				return (
					rg.prototype.copy.call(this, t),
					(this.defines = { STANDARD: "", PHYSICAL: "" }),
					(this.clearcoat = t.clearcoat),
					(this.clearcoatMap = t.clearcoatMap),
					(this.clearcoatRoughness = t.clearcoatRoughness),
					(this.clearcoatRoughnessMap = t.clearcoatRoughnessMap),
					(this.clearcoatNormalMap = t.clearcoatNormalMap),
					this.clearcoatNormalScale.copy(t.clearcoatNormalScale),
					(this.reflectivity = t.reflectivity),
					t.sheen
						? (this.sheen = (this.sheen || new Eh()).copy(t.sheen))
						: (this.sheen = null),
					(this.transparency = t.transparency),
					this
				);
			}),
			(sg.prototype = Object.create(Oh.prototype)),
			(sg.prototype.constructor = sg),
			(sg.prototype.isMeshPhongMaterial = !0),
			(sg.prototype.copy = function (t) {
				return (
					Oh.prototype.copy.call(this, t),
					this.color.copy(t.color),
					this.specular.copy(t.specular),
					(this.shininess = t.shininess),
					(this.map = t.map),
					(this.lightMap = t.lightMap),
					(this.lightMapIntensity = t.lightMapIntensity),
					(this.aoMap = t.aoMap),
					(this.aoMapIntensity = t.aoMapIntensity),
					this.emissive.copy(t.emissive),
					(this.emissiveMap = t.emissiveMap),
					(this.emissiveIntensity = t.emissiveIntensity),
					(this.bumpMap = t.bumpMap),
					(this.bumpScale = t.bumpScale),
					(this.normalMap = t.normalMap),
					(this.normalMapType = t.normalMapType),
					this.normalScale.copy(t.normalScale),
					(this.displacementMap = t.displacementMap),
					(this.displacementScale = t.displacementScale),
					(this.displacementBias = t.displacementBias),
					(this.specularMap = t.specularMap),
					(this.alphaMap = t.alphaMap),
					(this.envMap = t.envMap),
					(this.combine = t.combine),
					(this.reflectivity = t.reflectivity),
					(this.refractionRatio = t.refractionRatio),
					(this.wireframe = t.wireframe),
					(this.wireframeLinewidth = t.wireframeLinewidth),
					(this.wireframeLinecap = t.wireframeLinecap),
					(this.wireframeLinejoin = t.wireframeLinejoin),
					(this.skinning = t.skinning),
					(this.morphTargets = t.morphTargets),
					(this.morphNormals = t.morphNormals),
					this
				);
			}),
			(ag.prototype = Object.create(Oh.prototype)),
			(ag.prototype.constructor = ag),
			(ag.prototype.isMeshToonMaterial = !0),
			(ag.prototype.copy = function (t) {
				return (
					Oh.prototype.copy.call(this, t),
					this.color.copy(t.color),
					(this.map = t.map),
					(this.gradientMap = t.gradientMap),
					(this.lightMap = t.lightMap),
					(this.lightMapIntensity = t.lightMapIntensity),
					(this.aoMap = t.aoMap),
					(this.aoMapIntensity = t.aoMapIntensity),
					this.emissive.copy(t.emissive),
					(this.emissiveMap = t.emissiveMap),
					(this.emissiveIntensity = t.emissiveIntensity),
					(this.bumpMap = t.bumpMap),
					(this.bumpScale = t.bumpScale),
					(this.normalMap = t.normalMap),
					(this.normalMapType = t.normalMapType),
					this.normalScale.copy(t.normalScale),
					(this.displacementMap = t.displacementMap),
					(this.displacementScale = t.displacementScale),
					(this.displacementBias = t.displacementBias),
					(this.alphaMap = t.alphaMap),
					(this.wireframe = t.wireframe),
					(this.wireframeLinewidth = t.wireframeLinewidth),
					(this.wireframeLinecap = t.wireframeLinecap),
					(this.wireframeLinejoin = t.wireframeLinejoin),
					(this.skinning = t.skinning),
					(this.morphTargets = t.morphTargets),
					(this.morphNormals = t.morphNormals),
					this
				);
			}),
			(cg.prototype = Object.create(Oh.prototype)),
			(cg.prototype.constructor = cg),
			(cg.prototype.isMeshNormalMaterial = !0),
			(cg.prototype.copy = function (t) {
				return (
					Oh.prototype.copy.call(this, t),
					(this.bumpMap = t.bumpMap),
					(this.bumpScale = t.bumpScale),
					(this.normalMap = t.normalMap),
					(this.normalMapType = t.normalMapType),
					this.normalScale.copy(t.normalScale),
					(this.displacementMap = t.displacementMap),
					(this.displacementScale = t.displacementScale),
					(this.displacementBias = t.displacementBias),
					(this.wireframe = t.wireframe),
					(this.wireframeLinewidth = t.wireframeLinewidth),
					(this.skinning = t.skinning),
					(this.morphTargets = t.morphTargets),
					(this.morphNormals = t.morphNormals),
					this
				);
			}),
			(lg.prototype = Object.create(Oh.prototype)),
			(lg.prototype.constructor = lg),
			(lg.prototype.isMeshLambertMaterial = !0),
			(lg.prototype.copy = function (t) {
				return (
					Oh.prototype.copy.call(this, t),
					this.color.copy(t.color),
					(this.map = t.map),
					(this.lightMap = t.lightMap),
					(this.lightMapIntensity = t.lightMapIntensity),
					(this.aoMap = t.aoMap),
					(this.aoMapIntensity = t.aoMapIntensity),
					this.emissive.copy(t.emissive),
					(this.emissiveMap = t.emissiveMap),
					(this.emissiveIntensity = t.emissiveIntensity),
					(this.specularMap = t.specularMap),
					(this.alphaMap = t.alphaMap),
					(this.envMap = t.envMap),
					(this.combine = t.combine),
					(this.reflectivity = t.reflectivity),
					(this.refractionRatio = t.refractionRatio),
					(this.wireframe = t.wireframe),
					(this.wireframeLinewidth = t.wireframeLinewidth),
					(this.wireframeLinecap = t.wireframeLinecap),
					(this.wireframeLinejoin = t.wireframeLinejoin),
					(this.skinning = t.skinning),
					(this.morphTargets = t.morphTargets),
					(this.morphNormals = t.morphNormals),
					this
				);
			}),
			(hg.prototype = Object.create(Oh.prototype)),
			(hg.prototype.constructor = hg),
			(hg.prototype.isMeshMatcapMaterial = !0),
			(hg.prototype.copy = function (t) {
				return (
					Oh.prototype.copy.call(this, t),
					(this.defines = { MATCAP: "" }),
					this.color.copy(t.color),
					(this.matcap = t.matcap),
					(this.map = t.map),
					(this.bumpMap = t.bumpMap),
					(this.bumpScale = t.bumpScale),
					(this.normalMap = t.normalMap),
					(this.normalMapType = t.normalMapType),
					this.normalScale.copy(t.normalScale),
					(this.displacementMap = t.displacementMap),
					(this.displacementScale = t.displacementScale),
					(this.displacementBias = t.displacementBias),
					(this.alphaMap = t.alphaMap),
					(this.skinning = t.skinning),
					(this.morphTargets = t.morphTargets),
					(this.morphNormals = t.morphNormals),
					this
				);
			}),
			(ug.prototype = Object.create(yf.prototype)),
			(ug.prototype.constructor = ug),
			(ug.prototype.isLineDashedMaterial = !0),
			(ug.prototype.copy = function (t) {
				return (
					yf.prototype.copy.call(this, t),
					(this.scale = t.scale),
					(this.dashSize = t.dashSize),
					(this.gapSize = t.gapSize),
					this
				);
			});
		var dg = Object.freeze({
			__proto__: null,
			ShadowMaterial: ng,
			SpriteMaterial: Gp,
			RawShaderMaterial: ig,
			ShaderMaterial: Du,
			PointsMaterial: Pf,
			MeshPhysicalMaterial: og,
			MeshStandardMaterial: rg,
			MeshPhongMaterial: sg,
			MeshToonMaterial: ag,
			MeshNormalMaterial: cg,
			MeshLambertMaterial: lg,
			MeshDepthMaterial: Sp,
			MeshDistanceMaterial: Tp,
			MeshBasicMaterial: Dh,
			MeshMatcapMaterial: hg,
			LineDashedMaterial: ug,
			LineBasicMaterial: yf,
			Material: Oh,
		});
		const pg = {
			arraySlice: function (t, e, n) {
				return pg.isTypedArray(t)
					? new t.constructor(t.subarray(e, void 0 !== n ? n : t.length))
					: t.slice(e, n);
			},
			convertArray: function (t, e, n) {
				return !t || (!n && t.constructor === e)
					? t
					: "number" == typeof e.BYTES_PER_ELEMENT
					? new e(t)
					: Array.prototype.slice.call(t);
			},
			isTypedArray: function (t) {
				return ArrayBuffer.isView(t) && !(t instanceof DataView);
			},
			getKeyframeOrder: function (t) {
				const e = t.length,
					n = new Array(e);
				for (let t = 0; t !== e; ++t) n[t] = t;
				return (
					n.sort(function (e, n) {
						return t[e] - t[n];
					}),
					n
				);
			},
			sortedArray: function (t, e, n) {
				const i = t.length,
					r = new t.constructor(i);
				for (let o = 0, s = 0; s !== i; ++o) {
					const i = n[o] * e;
					for (let n = 0; n !== e; ++n) r[s++] = t[i + n];
				}
				return r;
			},
			flattenJSON: function (t, e, n, i) {
				let r = 1,
					o = t[0];
				for (; void 0 !== o && void 0 === o[i]; ) o = t[r++];
				if (void 0 === o) return;
				let s = o[i];
				if (void 0 !== s)
					if (Array.isArray(s))
						do {
							void 0 !== (s = o[i]) && (e.push(o.time), n.push.apply(n, s)),
								(o = t[r++]);
						} while (void 0 !== o);
					else if (void 0 !== s.toArray)
						do {
							void 0 !== (s = o[i]) && (e.push(o.time), s.toArray(n, n.length)),
								(o = t[r++]);
						} while (void 0 !== o);
					else
						do {
							void 0 !== (s = o[i]) && (e.push(o.time), n.push(s)),
								(o = t[r++]);
						} while (void 0 !== o);
			},
			subclip: function (t, e, n, i, r) {
				r = r || 30;
				const o = t.clone();
				o.name = e;
				const s = [];
				for (let t = 0; t < o.tracks.length; ++t) {
					const e = o.tracks[t],
						a = e.getValueSize(),
						c = [],
						l = [];
					for (let t = 0; t < e.times.length; ++t) {
						const o = e.times[t] * r;
						if (!(o < n || o >= i)) {
							c.push(e.times[t]);
							for (let n = 0; n < a; ++n) l.push(e.values[t * a + n]);
						}
					}
					0 !== c.length &&
						((e.times = pg.convertArray(c, e.times.constructor)),
						(e.values = pg.convertArray(l, e.values.constructor)),
						s.push(e));
				}
				o.tracks = s;
				let a = 1 / 0;
				for (let t = 0; t < o.tracks.length; ++t)
					a > o.tracks[t].times[0] && (a = o.tracks[t].times[0]);
				for (let t = 0; t < o.tracks.length; ++t) o.tracks[t].shift(-1 * a);
				return o.resetDuration(), o;
			},
			makeClipAdditive: function (t, e, n, i) {
				void 0 === e && (e = 0),
					void 0 === n && (n = t),
					(void 0 === i || i <= 0) && (i = 30);
				const r = t.tracks.length,
					o = e / i;
				for (let e = 0; e < r; ++e) {
					const i = n.tracks[e],
						r = i.ValueTypeName;
					if ("bool" === r || "string" === r) continue;
					const s = t.tracks.find(function (t) {
						return t.name === i.name && t.ValueTypeName === r;
					});
					if (void 0 === s) continue;
					const a = i.getValueSize(),
						c = i.times.length - 1;
					let l;
					if (o <= i.times[0]) l = pg.arraySlice(i.values, 0, i.valueSize);
					else if (o >= i.times[c]) {
						const t = c * a;
						l = pg.arraySlice(i.values, t);
					} else {
						const t = i.createInterpolant();
						t.evaluate(o), (l = t.resultBuffer);
					}
					if ("quaternion" === r) {
						new sl(l[0], l[1], l[2], l[3]).normalize().conjugate().toArray(l);
					}
					const h = s.times.length;
					for (let t = 0; t < h; ++t) {
						const e = t * a;
						if ("quaternion" === r)
							sl.multiplyQuaternionsFlat(s.values, e, l, 0, s.values, e);
						else for (let t = 0; t < a; ++t) s.values[e + t] -= l[t];
					}
				}
				return (t.blendMode = 2501), t;
			},
		};
		function fg(t, e, n, i) {
			(this.parameterPositions = t),
				(this._cachedIndex = 0),
				(this.resultBuffer = void 0 !== i ? i : new e.constructor(n)),
				(this.sampleValues = e),
				(this.valueSize = n);
		}
		function mg(t, e, n, i) {
			fg.call(this, t, e, n, i),
				(this._weightPrev = -0),
				(this._offsetPrev = -0),
				(this._weightNext = -0),
				(this._offsetNext = -0);
		}
		function gg(t, e, n, i) {
			fg.call(this, t, e, n, i);
		}
		function vg(t, e, n, i) {
			fg.call(this, t, e, n, i);
		}
		function yg(t, e, n, i) {
			if (void 0 === t)
				throw new Error("THREE.KeyframeTrack: track name is undefined");
			if (void 0 === e || 0 === e.length)
				throw new Error(
					"THREE.KeyframeTrack: no keyframes in track named " + t
				);
			(this.name = t),
				(this.times = pg.convertArray(e, this.TimeBufferType)),
				(this.values = pg.convertArray(n, this.ValueBufferType)),
				this.setInterpolation(i || this.DefaultInterpolation);
		}
		function xg(t, e, n) {
			yg.call(this, t, e, n);
		}
		function bg(t, e, n, i) {
			yg.call(this, t, e, n, i);
		}
		function wg(t, e, n, i) {
			yg.call(this, t, e, n, i);
		}
		function _g(t, e, n, i) {
			fg.call(this, t, e, n, i);
		}
		function Mg(t, e, n, i) {
			yg.call(this, t, e, n, i);
		}
		function Sg(t, e, n, i) {
			yg.call(this, t, e, n, i);
		}
		function Tg(t, e, n, i) {
			yg.call(this, t, e, n, i);
		}
		function Eg(t, e, n, i) {
			(this.name = t),
				(this.tracks = n),
				(this.duration = void 0 !== e ? e : -1),
				(this.blendMode = void 0 !== i ? i : Rc),
				(this.uuid = Jc.generateUUID()),
				this.duration < 0 && this.resetDuration();
		}
		function Ag(t) {
			if (void 0 === t.type)
				throw new Error(
					"THREE.KeyframeTrack: track type undefined, can not parse"
				);
			const e = (function (t) {
				switch (t.toLowerCase()) {
					case "scalar":
					case "double":
					case "float":
					case "number":
					case "integer":
						return wg;
					case "vector":
					case "vector2":
					case "vector3":
					case "vector4":
						return Tg;
					case "color":
						return bg;
					case "quaternion":
						return Mg;
					case "bool":
					case "boolean":
						return xg;
					case "string":
						return Sg;
				}
				throw new Error("THREE.KeyframeTrack: Unsupported typeName: " + t);
			})(t.type);
			if (void 0 === t.times) {
				const e = [],
					n = [];
				pg.flattenJSON(t.keys, e, n, "value"), (t.times = e), (t.values = n);
			}
			return void 0 !== e.parse
				? e.parse(t)
				: new e(t.name, t.times, t.values, t.interpolation);
		}
		Object.assign(fg.prototype, {
			evaluate: function (t) {
				let e = this.parameterPositions,
					n = this._cachedIndex,
					i = e[n],
					r = e[n - 1];
				t: {
					e: {
						let o;
						n: {
							i: if (!(t < i)) {
								for (let o = n + 2; ; ) {
									if (void 0 === i) {
										if (t < r) break i;
										return (
											(n = e.length),
											(this._cachedIndex = n),
											this.afterEnd_(n - 1, t, r)
										);
									}
									if (n === o) break;
									if (((r = i), t < (i = e[++n]))) break e;
								}
								o = e.length;
								break n;
							}
							if (t >= r) break t;
							{
								const s = e[1];
								t < s && ((n = 2), (r = s));
								for (let o = n - 2; ; ) {
									if (void 0 === r)
										return (this._cachedIndex = 0), this.beforeStart_(0, t, i);
									if (n === o) break;
									if (((i = r), t >= (r = e[--n - 1]))) break e;
								}
								(o = n), (n = 0);
							}
						}
						for (; n < o; ) {
							const i = (n + o) >>> 1;
							t < e[i] ? (o = i) : (n = i + 1);
						}
						if (((i = e[n]), void 0 === (r = e[n - 1])))
							return (this._cachedIndex = 0), this.beforeStart_(0, t, i);
						if (void 0 === i)
							return (
								(n = e.length),
								(this._cachedIndex = n),
								this.afterEnd_(n - 1, r, t)
							);
					}
					(this._cachedIndex = n), this.intervalChanged_(n, r, i);
				}
				return this.interpolate_(n, r, t, i);
			},
			settings: null,
			DefaultSettings_: {},
			getSettings_: function () {
				return this.settings || this.DefaultSettings_;
			},
			copySampleValue_: function (t) {
				const e = this.resultBuffer,
					n = this.sampleValues,
					i = this.valueSize,
					r = t * i;
				for (let t = 0; t !== i; ++t) e[t] = n[r + t];
				return e;
			},
			interpolate_: function () {
				throw new Error("call to abstract method");
			},
			intervalChanged_: function () {},
		}),
			Object.assign(fg.prototype, {
				beforeStart_: fg.prototype.copySampleValue_,
				afterEnd_: fg.prototype.copySampleValue_,
			}),
			(mg.prototype = Object.assign(Object.create(fg.prototype), {
				constructor: mg,
				DefaultSettings_: { endingStart: Pc, endingEnd: Pc },
				intervalChanged_: function (t, e, n) {
					let i = this.parameterPositions,
						r = t - 2,
						o = t + 1,
						s = i[r],
						a = i[o];
					if (void 0 === s)
						switch (this.getSettings_().endingStart) {
							case 2401:
								(r = t), (s = 2 * e - n);
								break;
							case 2402:
								s = e + i[(r = i.length - 2)] - i[r + 1];
								break;
							default:
								(r = t), (s = n);
						}
					if (void 0 === a)
						switch (this.getSettings_().endingEnd) {
							case 2401:
								(o = t), (a = 2 * n - e);
								break;
							case 2402:
								(o = 1), (a = n + i[1] - i[0]);
								break;
							default:
								(o = t - 1), (a = e);
						}
					const c = 0.5 * (n - e),
						l = this.valueSize;
					(this._weightPrev = c / (e - s)),
						(this._weightNext = c / (a - n)),
						(this._offsetPrev = r * l),
						(this._offsetNext = o * l);
				},
				interpolate_: function (t, e, n, i) {
					const r = this.resultBuffer,
						o = this.sampleValues,
						s = this.valueSize,
						a = t * s,
						c = a - s,
						l = this._offsetPrev,
						h = this._offsetNext,
						u = this._weightPrev,
						d = this._weightNext,
						p = (n - e) / (i - e),
						f = p * p,
						m = f * p,
						g = -u * m + 2 * u * f - u * p,
						v = (1 + u) * m + (-1.5 - 2 * u) * f + (-0.5 + u) * p + 1,
						y = (-1 - d) * m + (1.5 + d) * f + 0.5 * p,
						x = d * m - d * f;
					for (let t = 0; t !== s; ++t)
						r[t] = g * o[l + t] + v * o[c + t] + y * o[a + t] + x * o[h + t];
					return r;
				},
			})),
			(gg.prototype = Object.assign(Object.create(fg.prototype), {
				constructor: gg,
				interpolate_: function (t, e, n, i) {
					const r = this.resultBuffer,
						o = this.sampleValues,
						s = this.valueSize,
						a = t * s,
						c = a - s,
						l = (n - e) / (i - e),
						h = 1 - l;
					for (let t = 0; t !== s; ++t) r[t] = o[c + t] * h + o[a + t] * l;
					return r;
				},
			})),
			(vg.prototype = Object.assign(Object.create(fg.prototype), {
				constructor: vg,
				interpolate_: function (t) {
					return this.copySampleValue_(t - 1);
				},
			})),
			Object.assign(yg, {
				toJSON: function (t) {
					const e = t.constructor;
					let n;
					if (void 0 !== e.toJSON) n = e.toJSON(t);
					else {
						n = {
							name: t.name,
							times: pg.convertArray(t.times, Array),
							values: pg.convertArray(t.values, Array),
						};
						const e = t.getInterpolation();
						e !== t.DefaultInterpolation && (n.interpolation = e);
					}
					return (n.type = t.ValueTypeName), n;
				},
			}),
			Object.assign(yg.prototype, {
				constructor: yg,
				TimeBufferType: Float32Array,
				ValueBufferType: Float32Array,
				DefaultInterpolation: 2301,
				InterpolantFactoryMethodDiscrete: function (t) {
					return new vg(this.times, this.values, this.getValueSize(), t);
				},
				InterpolantFactoryMethodLinear: function (t) {
					return new gg(this.times, this.values, this.getValueSize(), t);
				},
				InterpolantFactoryMethodSmooth: function (t) {
					return new mg(this.times, this.values, this.getValueSize(), t);
				},
				setInterpolation: function (t) {
					let e;
					switch (t) {
						case 2300:
							e = this.InterpolantFactoryMethodDiscrete;
							break;
						case 2301:
							e = this.InterpolantFactoryMethodLinear;
							break;
						case 2302:
							e = this.InterpolantFactoryMethodSmooth;
					}
					if (void 0 === e) {
						const e =
							"unsupported interpolation for " +
							this.ValueTypeName +
							" keyframe track named " +
							this.name;
						if (void 0 === this.createInterpolant) {
							if (t === this.DefaultInterpolation) throw new Error(e);
							this.setInterpolation(this.DefaultInterpolation);
						}
						return console.warn("THREE.KeyframeTrack:", e), this;
					}
					return (this.createInterpolant = e), this;
				},
				getInterpolation: function () {
					switch (this.createInterpolant) {
						case this.InterpolantFactoryMethodDiscrete:
							return 2300;
						case this.InterpolantFactoryMethodLinear:
							return 2301;
						case this.InterpolantFactoryMethodSmooth:
							return 2302;
					}
				},
				getValueSize: function () {
					return this.values.length / this.times.length;
				},
				shift: function (t) {
					if (0 !== t) {
						const e = this.times;
						for (let n = 0, i = e.length; n !== i; ++n) e[n] += t;
					}
					return this;
				},
				scale: function (t) {
					if (1 !== t) {
						const e = this.times;
						for (let n = 0, i = e.length; n !== i; ++n) e[n] *= t;
					}
					return this;
				},
				trim: function (t, e) {
					const n = this.times,
						i = n.length;
					let r = 0,
						o = i - 1;
					for (; r !== i && n[r] < t; ) ++r;
					for (; -1 !== o && n[o] > e; ) --o;
					if ((++o, 0 !== r || o !== i)) {
						r >= o && (r = (o = Math.max(o, 1)) - 1);
						const t = this.getValueSize();
						(this.times = pg.arraySlice(n, r, o)),
							(this.values = pg.arraySlice(this.values, r * t, o * t));
					}
					return this;
				},
				validate: function () {
					let t = !0;
					const e = this.getValueSize();
					e - Math.floor(e) != 0 &&
						(console.error(
							"THREE.KeyframeTrack: Invalid value size in track.",
							this
						),
						(t = !1));
					const n = this.times,
						i = this.values,
						r = n.length;
					0 === r &&
						(console.error("THREE.KeyframeTrack: Track is empty.", this),
						(t = !1));
					let o = null;
					for (let e = 0; e !== r; e++) {
						const i = n[e];
						if ("number" == typeof i && isNaN(i)) {
							console.error(
								"THREE.KeyframeTrack: Time is not a valid number.",
								this,
								e,
								i
							),
								(t = !1);
							break;
						}
						if (null !== o && o > i) {
							console.error(
								"THREE.KeyframeTrack: Out of order keys.",
								this,
								e,
								i,
								o
							),
								(t = !1);
							break;
						}
						o = i;
					}
					if (void 0 !== i && pg.isTypedArray(i))
						for (let e = 0, n = i.length; e !== n; ++e) {
							const n = i[e];
							if (isNaN(n)) {
								console.error(
									"THREE.KeyframeTrack: Value is not a valid number.",
									this,
									e,
									n
								),
									(t = !1);
								break;
							}
						}
					return t;
				},
				optimize: function () {
					const t = pg.arraySlice(this.times),
						e = pg.arraySlice(this.values),
						n = this.getValueSize(),
						i = 2302 === this.getInterpolation(),
						r = t.length - 1;
					let o = 1;
					for (let s = 1; s < r; ++s) {
						let r = !1;
						const a = t[s];
						if (a !== t[s + 1] && (1 !== s || a !== a[0]))
							if (i) r = !0;
							else {
								const t = s * n,
									i = t - n,
									o = t + n;
								for (let s = 0; s !== n; ++s) {
									const n = e[t + s];
									if (n !== e[i + s] || n !== e[o + s]) {
										r = !0;
										break;
									}
								}
							}
						if (r) {
							if (s !== o) {
								t[o] = t[s];
								const i = s * n,
									r = o * n;
								for (let t = 0; t !== n; ++t) e[r + t] = e[i + t];
							}
							++o;
						}
					}
					if (r > 0) {
						t[o] = t[r];
						for (let t = r * n, i = o * n, s = 0; s !== n; ++s)
							e[i + s] = e[t + s];
						++o;
					}
					return (
						o !== t.length
							? ((this.times = pg.arraySlice(t, 0, o)),
							  (this.values = pg.arraySlice(e, 0, o * n)))
							: ((this.times = t), (this.values = e)),
						this
					);
				},
				clone: function () {
					const t = pg.arraySlice(this.times, 0),
						e = pg.arraySlice(this.values, 0),
						n = new (0, this.constructor)(this.name, t, e);
					return (n.createInterpolant = this.createInterpolant), n;
				},
			}),
			(xg.prototype = Object.assign(Object.create(yg.prototype), {
				constructor: xg,
				ValueTypeName: "bool",
				ValueBufferType: Array,
				DefaultInterpolation: 2300,
				InterpolantFactoryMethodLinear: void 0,
				InterpolantFactoryMethodSmooth: void 0,
			})),
			(bg.prototype = Object.assign(Object.create(yg.prototype), {
				constructor: bg,
				ValueTypeName: "color",
			})),
			(wg.prototype = Object.assign(Object.create(yg.prototype), {
				constructor: wg,
				ValueTypeName: "number",
			})),
			(_g.prototype = Object.assign(Object.create(fg.prototype), {
				constructor: _g,
				interpolate_: function (t, e, n, i) {
					const r = this.resultBuffer,
						o = this.sampleValues,
						s = this.valueSize,
						a = (n - e) / (i - e);
					let c = t * s;
					for (let t = c + s; c !== t; c += 4)
						sl.slerpFlat(r, 0, o, c - s, o, c, a);
					return r;
				},
			})),
			(Mg.prototype = Object.assign(Object.create(yg.prototype), {
				constructor: Mg,
				ValueTypeName: "quaternion",
				DefaultInterpolation: 2301,
				InterpolantFactoryMethodLinear: function (t) {
					return new _g(this.times, this.values, this.getValueSize(), t);
				},
				InterpolantFactoryMethodSmooth: void 0,
			})),
			(Sg.prototype = Object.assign(Object.create(yg.prototype), {
				constructor: Sg,
				ValueTypeName: "string",
				ValueBufferType: Array,
				DefaultInterpolation: 2300,
				InterpolantFactoryMethodLinear: void 0,
				InterpolantFactoryMethodSmooth: void 0,
			})),
			(Tg.prototype = Object.assign(Object.create(yg.prototype), {
				constructor: Tg,
				ValueTypeName: "vector",
			})),
			Object.assign(Eg, {
				parse: function (t) {
					const e = [],
						n = t.tracks,
						i = 1 / (t.fps || 1);
					for (let t = 0, r = n.length; t !== r; ++t) e.push(Ag(n[t]).scale(i));
					return new Eg(t.name, t.duration, e, t.blendMode);
				},
				toJSON: function (t) {
					const e = [],
						n = t.tracks,
						i = {
							name: t.name,
							duration: t.duration,
							tracks: e,
							uuid: t.uuid,
							blendMode: t.blendMode,
						};
					for (let t = 0, i = n.length; t !== i; ++t) e.push(yg.toJSON(n[t]));
					return i;
				},
				CreateFromMorphTargetSequence: function (t, e, n, i) {
					const r = e.length,
						o = [];
					for (let t = 0; t < r; t++) {
						let s = [],
							a = [];
						s.push((t + r - 1) % r, t, (t + 1) % r), a.push(0, 1, 0);
						const c = pg.getKeyframeOrder(s);
						(s = pg.sortedArray(s, 1, c)),
							(a = pg.sortedArray(a, 1, c)),
							i || 0 !== s[0] || (s.push(r), a.push(a[0])),
							o.push(
								new wg(".morphTargetInfluences[" + e[t].name + "]", s, a).scale(
									1 / n
								)
							);
					}
					return new Eg(t, -1, o);
				},
				findByName: function (t, e) {
					let n = t;
					if (!Array.isArray(t)) {
						const e = t;
						n = (e.geometry && e.geometry.animations) || e.animations;
					}
					for (let t = 0; t < n.length; t++) if (n[t].name === e) return n[t];
					return null;
				},
				CreateClipsFromMorphTargetSequences: function (t, e, n) {
					const i = {},
						r = /^([\w-]*?)([\d]+)$/;
					for (let e = 0, n = t.length; e < n; e++) {
						const n = t[e],
							o = n.name.match(r);
						if (o && o.length > 1) {
							const t = o[1];
							let e = i[t];
							e || (i[t] = e = []), e.push(n);
						}
					}
					const o = [];
					for (const t in i)
						o.push(Eg.CreateFromMorphTargetSequence(t, i[t], e, n));
					return o;
				},
				parseAnimation: function (t, e) {
					if (!t)
						return (
							console.error(
								"THREE.AnimationClip: No animation in JSONLoader data."
							),
							null
						);
					const n = function (t, e, n, i, r) {
							if (0 !== n.length) {
								const o = [],
									s = [];
								pg.flattenJSON(n, o, s, i),
									0 !== o.length && r.push(new t(e, o, s));
							}
						},
						i = [],
						r = t.name || "default",
						o = t.fps || 30,
						s = t.blendMode;
					let a = t.length || -1;
					const c = t.hierarchy || [];
					for (let t = 0; t < c.length; t++) {
						const r = c[t].keys;
						if (r && 0 !== r.length)
							if (r[0].morphTargets) {
								const t = {};
								let e;
								for (e = 0; e < r.length; e++)
									if (r[e].morphTargets)
										for (let n = 0; n < r[e].morphTargets.length; n++)
											t[r[e].morphTargets[n]] = -1;
								for (const n in t) {
									const t = [],
										o = [];
									for (let i = 0; i !== r[e].morphTargets.length; ++i) {
										const i = r[e];
										t.push(i.time), o.push(i.morphTarget === n ? 1 : 0);
									}
									i.push(new wg(".morphTargetInfluence[" + n + "]", t, o));
								}
								a = t.length * (o || 1);
							} else {
								const o = ".bones[" + e[t].name + "]";
								n(Tg, o + ".position", r, "pos", i),
									n(Mg, o + ".quaternion", r, "rot", i),
									n(Tg, o + ".scale", r, "scl", i);
							}
					}
					return 0 === i.length ? null : new Eg(r, a, i, s);
				},
			}),
			Object.assign(Eg.prototype, {
				resetDuration: function () {
					let t = 0;
					for (let e = 0, n = this.tracks.length; e !== n; ++e) {
						const n = this.tracks[e];
						t = Math.max(t, n.times[n.times.length - 1]);
					}
					return (this.duration = t), this;
				},
				trim: function () {
					for (let t = 0; t < this.tracks.length; t++)
						this.tracks[t].trim(0, this.duration);
					return this;
				},
				validate: function () {
					let t = !0;
					for (let e = 0; e < this.tracks.length; e++)
						t = t && this.tracks[e].validate();
					return t;
				},
				optimize: function () {
					for (let t = 0; t < this.tracks.length; t++)
						this.tracks[t].optimize();
					return this;
				},
				clone: function () {
					const t = [];
					for (let e = 0; e < this.tracks.length; e++)
						t.push(this.tracks[e].clone());
					return new Eg(this.name, this.duration, t, this.blendMode);
				},
			});
		const Lg = {
			enabled: !1,
			files: {},
			add: function (t, e) {
				!1 !== this.enabled && (this.files[t] = e);
			},
			get: function (t) {
				if (!1 !== this.enabled) return this.files[t];
			},
			remove: function (t) {
				delete this.files[t];
			},
			clear: function () {
				this.files = {};
			},
		};
		function Pg(t, e, n) {
			const i = this;
			let r = !1,
				o = 0,
				s = 0,
				a = void 0;
			const c = [];
			(this.onStart = void 0),
				(this.onLoad = t),
				(this.onProgress = e),
				(this.onError = n),
				(this.itemStart = function (t) {
					s++, !1 === r && void 0 !== i.onStart && i.onStart(t, o, s), (r = !0);
				}),
				(this.itemEnd = function (t) {
					o++,
						void 0 !== i.onProgress && i.onProgress(t, o, s),
						o === s && ((r = !1), void 0 !== i.onLoad && i.onLoad());
				}),
				(this.itemError = function (t) {
					void 0 !== i.onError && i.onError(t);
				}),
				(this.resolveURL = function (t) {
					return a ? a(t) : t;
				}),
				(this.setURLModifier = function (t) {
					return (a = t), this;
				}),
				(this.addHandler = function (t, e) {
					return c.push(t, e), this;
				}),
				(this.removeHandler = function (t) {
					const e = c.indexOf(t);
					return -1 !== e && c.splice(e, 2), this;
				}),
				(this.getHandler = function (t) {
					for (let e = 0, n = c.length; e < n; e += 2) {
						const n = c[e],
							i = c[e + 1];
						if ((n.global && (n.lastIndex = 0), n.test(t))) return i;
					}
					return null;
				});
		}
		const Rg = new Pg();
		function Cg(t) {
			(this.manager = void 0 !== t ? t : Rg),
				(this.crossOrigin = "anonymous"),
				(this.path = ""),
				(this.resourcePath = ""),
				(this.requestHeader = {});
		}
		Object.assign(Cg.prototype, {
			load: function () {},
			loadAsync: function (t, e) {
				const n = this;
				return new Promise(function (i, r) {
					n.load(t, i, e, r);
				});
			},
			parse: function () {},
			setCrossOrigin: function (t) {
				return (this.crossOrigin = t), this;
			},
			setPath: function (t) {
				return (this.path = t), this;
			},
			setResourcePath: function (t) {
				return (this.resourcePath = t), this;
			},
			setRequestHeader: function (t) {
				return (this.requestHeader = t), this;
			},
		});
		const Og = {};
		function Dg(t) {
			Cg.call(this, t);
		}
		function Ig(t) {
			Cg.call(this, t);
		}
		function kg(t) {
			Cg.call(this, t);
		}
		function Ng(t) {
			Cg.call(this, t);
		}
		function Bg(t) {
			Cg.call(this, t);
		}
		function Fg(t) {
			Cg.call(this, t);
		}
		function zg(t) {
			Cg.call(this, t);
		}
		function Hg() {
			(this.type = "Curve"), (this.arcLengthDivisions = 200);
		}
		function Ug(t, e, n, i, r, o, s, a) {
			Hg.call(this),
				(this.type = "EllipseCurve"),
				(this.aX = t || 0),
				(this.aY = e || 0),
				(this.xRadius = n || 1),
				(this.yRadius = i || 1),
				(this.aStartAngle = r || 0),
				(this.aEndAngle = o || 2 * Math.PI),
				(this.aClockwise = s || !1),
				(this.aRotation = a || 0);
		}
		function Gg(t, e, n, i, r, o) {
			Ug.call(this, t, e, n, n, i, r, o), (this.type = "ArcCurve");
		}
		function Vg() {
			let t = 0,
				e = 0,
				n = 0,
				i = 0;
			function r(r, o, s, a) {
				(t = r),
					(e = s),
					(n = -3 * r + 3 * o - 2 * s - a),
					(i = 2 * r - 2 * o + s + a);
			}
			return {
				initCatmullRom: function (t, e, n, i, o) {
					r(e, n, o * (n - t), o * (i - e));
				},
				initNonuniformCatmullRom: function (t, e, n, i, o, s, a) {
					let c = (e - t) / o - (n - t) / (o + s) + (n - e) / s,
						l = (n - e) / s - (i - e) / (s + a) + (i - n) / a;
					r(e, n, (c *= s), (l *= s));
				},
				calc: function (r) {
					const o = r * r;
					return t + e * r + n * o + i * (o * r);
				},
			};
		}
		(Dg.prototype = Object.assign(Object.create(Cg.prototype), {
			constructor: Dg,
			load: function (t, e, n, i) {
				void 0 === t && (t = ""),
					void 0 !== this.path && (t = this.path + t),
					(t = this.manager.resolveURL(t));
				const r = this,
					o = Lg.get(t);
				if (void 0 !== o)
					return (
						r.manager.itemStart(t),
						setTimeout(function () {
							e && e(o), r.manager.itemEnd(t);
						}, 0),
						o
					);
				if (void 0 !== Og[t])
					return void Og[t].push({ onLoad: e, onProgress: n, onError: i });
				const s = t.match(/^data:(.*?)(;base64)?,(.*)$/);
				let a;
				if (s) {
					const n = s[1],
						o = !!s[2];
					let a = s[3];
					(a = decodeURIComponent(a)), o && (a = atob(a));
					try {
						let o;
						const s = (this.responseType || "").toLowerCase();
						switch (s) {
							case "arraybuffer":
							case "blob":
								const t = new Uint8Array(a.length);
								for (let e = 0; e < a.length; e++) t[e] = a.charCodeAt(e);
								o = "blob" === s ? new Blob([t.buffer], { type: n }) : t.buffer;
								break;
							case "document":
								const e = new DOMParser();
								o = e.parseFromString(a, n);
								break;
							case "json":
								o = JSON.parse(a);
								break;
							default:
								o = a;
						}
						setTimeout(function () {
							e && e(o), r.manager.itemEnd(t);
						}, 0);
					} catch (e) {
						setTimeout(function () {
							i && i(e), r.manager.itemError(t), r.manager.itemEnd(t);
						}, 0);
					}
				} else {
					(Og[t] = []),
						Og[t].push({ onLoad: e, onProgress: n, onError: i }),
						(a = new XMLHttpRequest()).open("GET", t, !0),
						a.addEventListener(
							"load",
							function (e) {
								const n = this.response,
									i = Og[t];
								if ((delete Og[t], 200 === this.status || 0 === this.status)) {
									0 === this.status &&
										console.warn("THREE.FileLoader: HTTP Status 0 received."),
										Lg.add(t, n);
									for (let t = 0, e = i.length; t < e; t++) {
										const e = i[t];
										e.onLoad && e.onLoad(n);
									}
									r.manager.itemEnd(t);
								} else {
									for (let t = 0, n = i.length; t < n; t++) {
										const n = i[t];
										n.onError && n.onError(e);
									}
									r.manager.itemError(t), r.manager.itemEnd(t);
								}
							},
							!1
						),
						a.addEventListener(
							"progress",
							function (e) {
								const n = Og[t];
								for (let t = 0, i = n.length; t < i; t++) {
									const i = n[t];
									i.onProgress && i.onProgress(e);
								}
							},
							!1
						),
						a.addEventListener(
							"error",
							function (e) {
								const n = Og[t];
								delete Og[t];
								for (let t = 0, i = n.length; t < i; t++) {
									const i = n[t];
									i.onError && i.onError(e);
								}
								r.manager.itemError(t), r.manager.itemEnd(t);
							},
							!1
						),
						a.addEventListener(
							"abort",
							function (e) {
								const n = Og[t];
								delete Og[t];
								for (let t = 0, i = n.length; t < i; t++) {
									const i = n[t];
									i.onError && i.onError(e);
								}
								r.manager.itemError(t), r.manager.itemEnd(t);
							},
							!1
						),
						void 0 !== this.responseType &&
							(a.responseType = this.responseType),
						void 0 !== this.withCredentials &&
							(a.withCredentials = this.withCredentials),
						a.overrideMimeType &&
							a.overrideMimeType(
								void 0 !== this.mimeType ? this.mimeType : "text/plain"
							);
					for (const t in this.requestHeader)
						a.setRequestHeader(t, this.requestHeader[t]);
					a.send(null);
				}
				return r.manager.itemStart(t), a;
			},
			setResponseType: function (t) {
				return (this.responseType = t), this;
			},
			setWithCredentials: function (t) {
				return (this.withCredentials = t), this;
			},
			setMimeType: function (t) {
				return (this.mimeType = t), this;
			},
		})),
			(Ig.prototype = Object.assign(Object.create(Cg.prototype), {
				constructor: Ig,
				load: function (t, e, n, i) {
					const r = this,
						o = new Dg(r.manager);
					o.setPath(r.path),
						o.load(
							t,
							function (n) {
								try {
									e(r.parse(JSON.parse(n)));
								} catch (e) {
									i ? i(e) : console.error(e), r.manager.itemError(t);
								}
							},
							n,
							i
						);
				},
				parse: function (t) {
					const e = [];
					for (let n = 0; n < t.length; n++) {
						const i = Eg.parse(t[n]);
						e.push(i);
					}
					return e;
				},
			})),
			(kg.prototype = Object.assign(Object.create(Cg.prototype), {
				constructor: kg,
				load: function (t, e, n, i) {
					const r = this,
						o = [],
						s = new Bf();
					s.image = o;
					const a = new Dg(this.manager);
					a.setPath(this.path), a.setResponseType("arraybuffer");
					let c = 0;
					function l(l) {
						a.load(
							t[l],
							function (t) {
								const n = r.parse(t, !0);
								(o[l] = {
									width: n.width,
									height: n.height,
									format: n.format,
									mipmaps: n.mipmaps,
								}),
									6 === (c += 1) &&
										(1 === n.mipmapCount && (s.minFilter = pa),
										(s.format = n.format),
										(s.needsUpdate = !0),
										e && e(s));
							},
							n,
							i
						);
					}
					if (Array.isArray(t)) for (let e = 0, n = t.length; e < n; ++e) l(e);
					else
						a.load(
							t,
							function (t) {
								const n = r.parse(t, !0);
								if (n.isCubemap) {
									const t = n.mipmaps.length / n.mipmapCount;
									for (let e = 0; e < t; e++) {
										o[e] = { mipmaps: [] };
										for (let t = 0; t < n.mipmapCount; t++)
											o[e].mipmaps.push(n.mipmaps[e * n.mipmapCount + t]),
												(o[e].format = n.format),
												(o[e].width = n.width),
												(o[e].height = n.height);
									}
								} else
									(s.image.width = n.width),
										(s.image.height = n.height),
										(s.mipmaps = n.mipmaps);
								1 === n.mipmapCount && (s.minFilter = pa),
									(s.format = n.format),
									(s.needsUpdate = !0),
									e && e(s);
							},
							n,
							i
						);
					return s;
				},
			})),
			(Ng.prototype = Object.assign(Object.create(Cg.prototype), {
				constructor: Ng,
				load: function (t, e, n, i) {
					const r = this,
						o = new Hu(),
						s = new Dg(this.manager);
					return (
						s.setResponseType("arraybuffer"),
						s.setPath(this.path),
						s.load(
							t,
							function (t) {
								const n = r.parse(t);
								n &&
									(void 0 !== n.image
										? (o.image = n.image)
										: void 0 !== n.data &&
										  ((o.image.width = n.width),
										  (o.image.height = n.height),
										  (o.image.data = n.data)),
									(o.wrapS = void 0 !== n.wrapS ? n.wrapS : ca),
									(o.wrapT = void 0 !== n.wrapT ? n.wrapT : ca),
									(o.magFilter = void 0 !== n.magFilter ? n.magFilter : pa),
									(o.minFilter = void 0 !== n.minFilter ? n.minFilter : pa),
									(o.anisotropy = void 0 !== n.anisotropy ? n.anisotropy : 1),
									void 0 !== n.format && (o.format = n.format),
									void 0 !== n.type && (o.type = n.type),
									void 0 !== n.mipmaps &&
										((o.mipmaps = n.mipmaps), (o.minFilter = ma)),
									1 === n.mipmapCount && (o.minFilter = pa),
									(o.needsUpdate = !0),
									e && e(o, n));
							},
							n,
							i
						),
						o
					);
				},
			})),
			(Bg.prototype = Object.assign(Object.create(Cg.prototype), {
				constructor: Bg,
				load: function (t, e, n, i) {
					void 0 !== this.path && (t = this.path + t),
						(t = this.manager.resolveURL(t));
					const r = this,
						o = Lg.get(t);
					if (void 0 !== o)
						return (
							r.manager.itemStart(t),
							setTimeout(function () {
								e && e(o), r.manager.itemEnd(t);
							}, 0),
							o
						);
					const s = document.createElementNS(
						"http://www.w3.org/1999/xhtml",
						"img"
					);
					function a() {
						s.removeEventListener("load", a, !1),
							s.removeEventListener("error", c, !1),
							Lg.add(t, this),
							e && e(this),
							r.manager.itemEnd(t);
					}
					function c(e) {
						s.removeEventListener("load", a, !1),
							s.removeEventListener("error", c, !1),
							i && i(e),
							r.manager.itemError(t),
							r.manager.itemEnd(t);
					}
					return (
						s.addEventListener("load", a, !1),
						s.addEventListener("error", c, !1),
						"data:" !== t.substr(0, 5) &&
							void 0 !== this.crossOrigin &&
							(s.crossOrigin = this.crossOrigin),
						r.manager.itemStart(t),
						(s.src = t),
						s
					);
				},
			})),
			(Fg.prototype = Object.assign(Object.create(Cg.prototype), {
				constructor: Fg,
				load: function (t, e, n, i) {
					const r = new td(),
						o = new Bg(this.manager);
					o.setCrossOrigin(this.crossOrigin), o.setPath(this.path);
					let s = 0;
					function a(n) {
						o.load(
							t[n],
							function (t) {
								(r.images[n] = t),
									6 === ++s && ((r.needsUpdate = !0), e && e(r));
							},
							void 0,
							i
						);
					}
					for (let e = 0; e < t.length; ++e) a(e);
					return r;
				},
			})),
			(zg.prototype = Object.assign(Object.create(Cg.prototype), {
				constructor: zg,
				load: function (t, e, n, i) {
					const r = new nl(),
						o = new Bg(this.manager);
					return (
						o.setCrossOrigin(this.crossOrigin),
						o.setPath(this.path),
						o.load(
							t,
							function (n) {
								r.image = n;
								const i =
									t.search(/\.jpe?g($|\?)/i) > 0 ||
									0 === t.search(/^data\:image\/jpeg/);
								(r.format = i ? Pa : Ra),
									(r.needsUpdate = !0),
									void 0 !== e && e(r);
							},
							n,
							i
						),
						r
					);
				},
			})),
			Object.assign(Hg.prototype, {
				getPoint: function () {
					return (
						console.warn("THREE.Curve: .getPoint() not implemented."), null
					);
				},
				getPointAt: function (t, e) {
					const n = this.getUtoTmapping(t);
					return this.getPoint(n, e);
				},
				getPoints: function (t) {
					void 0 === t && (t = 5);
					const e = [];
					for (let n = 0; n <= t; n++) e.push(this.getPoint(n / t));
					return e;
				},
				getSpacedPoints: function (t) {
					void 0 === t && (t = 5);
					const e = [];
					for (let n = 0; n <= t; n++) e.push(this.getPointAt(n / t));
					return e;
				},
				getLength: function () {
					const t = this.getLengths();
					return t[t.length - 1];
				},
				getLengths: function (t) {
					if (
						(void 0 === t && (t = this.arcLengthDivisions),
						this.cacheArcLengths &&
							this.cacheArcLengths.length === t + 1 &&
							!this.needsUpdate)
					)
						return this.cacheArcLengths;
					this.needsUpdate = !1;
					const e = [];
					let n,
						i = this.getPoint(0),
						r = 0;
					e.push(0);
					for (let o = 1; o <= t; o++)
						(r += (n = this.getPoint(o / t)).distanceTo(i)), e.push(r), (i = n);
					return (this.cacheArcLengths = e), e;
				},
				updateArcLengths: function () {
					(this.needsUpdate = !0), this.getLengths();
				},
				getUtoTmapping: function (t, e) {
					const n = this.getLengths();
					let i,
						r = 0,
						o = n.length;
					i = e || t * n[o - 1];
					let s,
						a = 0,
						c = o - 1;
					for (; a <= c; )
						if ((s = n[(r = Math.floor(a + (c - a) / 2))] - i) < 0) a = r + 1;
						else {
							if (!(s > 0)) {
								c = r;
								break;
							}
							c = r - 1;
						}
					if (n[(r = c)] === i) return r / (o - 1);
					const l = n[r];
					return (r + (i - l) / (n[r + 1] - l)) / (o - 1);
				},
				getTangent: function (t, e) {
					let n = t - 1e-4,
						i = t + 1e-4;
					n < 0 && (n = 0), i > 1 && (i = 1);
					const r = this.getPoint(n),
						o = this.getPoint(i),
						s = e || (r.isVector2 ? new Kc() : new ll());
					return s.copy(o).sub(r).normalize(), s;
				},
				getTangentAt: function (t, e) {
					const n = this.getUtoTmapping(t);
					return this.getTangent(n, e);
				},
				computeFrenetFrames: function (t, e) {
					const n = new ll(),
						i = [],
						r = [],
						o = [],
						s = new ll(),
						a = new vl();
					for (let e = 0; e <= t; e++) {
						const n = e / t;
						(i[e] = this.getTangentAt(n, new ll())), i[e].normalize();
					}
					(r[0] = new ll()), (o[0] = new ll());
					let c = Number.MAX_VALUE;
					const l = Math.abs(i[0].x),
						h = Math.abs(i[0].y),
						u = Math.abs(i[0].z);
					l <= c && ((c = l), n.set(1, 0, 0)),
						h <= c && ((c = h), n.set(0, 1, 0)),
						u <= c && n.set(0, 0, 1),
						s.crossVectors(i[0], n).normalize(),
						r[0].crossVectors(i[0], s),
						o[0].crossVectors(i[0], r[0]);
					for (let e = 1; e <= t; e++) {
						if (
							((r[e] = r[e - 1].clone()),
							(o[e] = o[e - 1].clone()),
							s.crossVectors(i[e - 1], i[e]),
							s.length() > Number.EPSILON)
						) {
							s.normalize();
							const t = Math.acos(Jc.clamp(i[e - 1].dot(i[e]), -1, 1));
							r[e].applyMatrix4(a.makeRotationAxis(s, t));
						}
						o[e].crossVectors(i[e], r[e]);
					}
					if (!0 === e) {
						let e = Math.acos(Jc.clamp(r[0].dot(r[t]), -1, 1));
						(e /= t), i[0].dot(s.crossVectors(r[0], r[t])) > 0 && (e = -e);
						for (let n = 1; n <= t; n++)
							r[n].applyMatrix4(a.makeRotationAxis(i[n], e * n)),
								o[n].crossVectors(i[n], r[n]);
					}
					return { tangents: i, normals: r, binormals: o };
				},
				clone: function () {
					return new this.constructor().copy(this);
				},
				copy: function (t) {
					return (this.arcLengthDivisions = t.arcLengthDivisions), this;
				},
				toJSON: function () {
					const t = {
						metadata: {
							version: 4.5,
							type: "Curve",
							generator: "Curve.toJSON",
						},
					};
					return (
						(t.arcLengthDivisions = this.arcLengthDivisions),
						(t.type = this.type),
						t
					);
				},
				fromJSON: function (t) {
					return (this.arcLengthDivisions = t.arcLengthDivisions), this;
				},
			}),
			(Ug.prototype = Object.create(Hg.prototype)),
			(Ug.prototype.constructor = Ug),
			(Ug.prototype.isEllipseCurve = !0),
			(Ug.prototype.getPoint = function (t, e) {
				const n = e || new Kc(),
					i = 2 * Math.PI;
				let r = this.aEndAngle - this.aStartAngle;
				const o = Math.abs(r) < Number.EPSILON;
				for (; r < 0; ) r += i;
				for (; r > i; ) r -= i;
				r < Number.EPSILON && (r = o ? 0 : i),
					!0 !== this.aClockwise || o || (r === i ? (r = -i) : (r -= i));
				const s = this.aStartAngle + t * r;
				let a = this.aX + this.xRadius * Math.cos(s),
					c = this.aY + this.yRadius * Math.sin(s);
				if (0 !== this.aRotation) {
					const t = Math.cos(this.aRotation),
						e = Math.sin(this.aRotation),
						n = a - this.aX,
						i = c - this.aY;
					(a = n * t - i * e + this.aX), (c = n * e + i * t + this.aY);
				}
				return n.set(a, c);
			}),
			(Ug.prototype.copy = function (t) {
				return (
					Hg.prototype.copy.call(this, t),
					(this.aX = t.aX),
					(this.aY = t.aY),
					(this.xRadius = t.xRadius),
					(this.yRadius = t.yRadius),
					(this.aStartAngle = t.aStartAngle),
					(this.aEndAngle = t.aEndAngle),
					(this.aClockwise = t.aClockwise),
					(this.aRotation = t.aRotation),
					this
				);
			}),
			(Ug.prototype.toJSON = function () {
				const t = Hg.prototype.toJSON.call(this);
				return (
					(t.aX = this.aX),
					(t.aY = this.aY),
					(t.xRadius = this.xRadius),
					(t.yRadius = this.yRadius),
					(t.aStartAngle = this.aStartAngle),
					(t.aEndAngle = this.aEndAngle),
					(t.aClockwise = this.aClockwise),
					(t.aRotation = this.aRotation),
					t
				);
			}),
			(Ug.prototype.fromJSON = function (t) {
				return (
					Hg.prototype.fromJSON.call(this, t),
					(this.aX = t.aX),
					(this.aY = t.aY),
					(this.xRadius = t.xRadius),
					(this.yRadius = t.yRadius),
					(this.aStartAngle = t.aStartAngle),
					(this.aEndAngle = t.aEndAngle),
					(this.aClockwise = t.aClockwise),
					(this.aRotation = t.aRotation),
					this
				);
			}),
			(Gg.prototype = Object.create(Ug.prototype)),
			(Gg.prototype.constructor = Gg),
			(Gg.prototype.isArcCurve = !0);
		const jg = new ll(),
			Wg = new Vg(),
			qg = new Vg(),
			Yg = new Vg();
		function Xg(t, e, n, i) {
			Hg.call(this),
				(this.type = "CatmullRomCurve3"),
				(this.points = t || []),
				(this.closed = e || !1),
				(this.curveType = n || "centripetal"),
				(this.tension = i || 0.5);
		}
		function Zg(t, e, n, i, r) {
			const o = 0.5 * (i - e),
				s = 0.5 * (r - n),
				a = t * t;
			return (
				(2 * n - 2 * i + o + s) * (t * a) +
				(-3 * n + 3 * i - 2 * o - s) * a +
				o * t +
				n
			);
		}
		function Jg(t, e, n, i) {
			return (
				(function (t, e) {
					const n = 1 - t;
					return n * n * e;
				})(t, e) +
				(function (t, e) {
					return 2 * (1 - t) * t * e;
				})(t, n) +
				(function (t, e) {
					return t * t * e;
				})(t, i)
			);
		}
		function Kg(t, e, n, i, r) {
			return (
				(function (t, e) {
					const n = 1 - t;
					return n * n * n * e;
				})(t, e) +
				(function (t, e) {
					const n = 1 - t;
					return 3 * n * n * t * e;
				})(t, n) +
				(function (t, e) {
					return 3 * (1 - t) * t * t * e;
				})(t, i) +
				(function (t, e) {
					return t * t * t * e;
				})(t, r)
			);
		}
		function Qg(t, e, n, i) {
			Hg.call(this),
				(this.type = "CubicBezierCurve"),
				(this.v0 = t || new Kc()),
				(this.v1 = e || new Kc()),
				(this.v2 = n || new Kc()),
				(this.v3 = i || new Kc());
		}
		function $g(t, e, n, i) {
			Hg.call(this),
				(this.type = "CubicBezierCurve3"),
				(this.v0 = t || new ll()),
				(this.v1 = e || new ll()),
				(this.v2 = n || new ll()),
				(this.v3 = i || new ll());
		}
		function tv(t, e) {
			Hg.call(this),
				(this.type = "LineCurve"),
				(this.v1 = t || new Kc()),
				(this.v2 = e || new Kc());
		}
		function ev(t, e) {
			Hg.call(this),
				(this.type = "LineCurve3"),
				(this.v1 = t || new ll()),
				(this.v2 = e || new ll());
		}
		function nv(t, e, n) {
			Hg.call(this),
				(this.type = "QuadraticBezierCurve"),
				(this.v0 = t || new Kc()),
				(this.v1 = e || new Kc()),
				(this.v2 = n || new Kc());
		}
		function iv(t, e, n) {
			Hg.call(this),
				(this.type = "QuadraticBezierCurve3"),
				(this.v0 = t || new ll()),
				(this.v1 = e || new ll()),
				(this.v2 = n || new ll());
		}
		function rv(t) {
			Hg.call(this), (this.type = "SplineCurve"), (this.points = t || []);
		}
		(Xg.prototype = Object.create(Hg.prototype)),
			(Xg.prototype.constructor = Xg),
			(Xg.prototype.isCatmullRomCurve3 = !0),
			(Xg.prototype.getPoint = function (t, e) {
				const n = e || new ll(),
					i = this.points,
					r = i.length,
					o = (r - (this.closed ? 0 : 1)) * t;
				let s,
					a,
					c,
					l,
					h = Math.floor(o),
					u = o - h;
				if (
					(this.closed
						? (h += h > 0 ? 0 : (Math.floor(Math.abs(h) / r) + 1) * r)
						: 0 === u && h === r - 1 && ((h = r - 2), (u = 1)),
					this.closed || h > 0
						? (s = i[(h - 1) % r])
						: (jg.subVectors(i[0], i[1]).add(i[0]), (s = jg)),
					(a = i[h % r]),
					(c = i[(h + 1) % r]),
					this.closed || h + 2 < r
						? (l = i[(h + 2) % r])
						: (jg.subVectors(i[r - 1], i[r - 2]).add(i[r - 1]), (l = jg)),
					"centripetal" === this.curveType || "chordal" === this.curveType)
				) {
					const t = "chordal" === this.curveType ? 0.5 : 0.25;
					let e = Math.pow(s.distanceToSquared(a), t),
						n = Math.pow(a.distanceToSquared(c), t),
						i = Math.pow(c.distanceToSquared(l), t);
					n < 1e-4 && (n = 1),
						e < 1e-4 && (e = n),
						i < 1e-4 && (i = n),
						Wg.initNonuniformCatmullRom(s.x, a.x, c.x, l.x, e, n, i),
						qg.initNonuniformCatmullRom(s.y, a.y, c.y, l.y, e, n, i),
						Yg.initNonuniformCatmullRom(s.z, a.z, c.z, l.z, e, n, i);
				} else
					"catmullrom" === this.curveType &&
						(Wg.initCatmullRom(s.x, a.x, c.x, l.x, this.tension),
						qg.initCatmullRom(s.y, a.y, c.y, l.y, this.tension),
						Yg.initCatmullRom(s.z, a.z, c.z, l.z, this.tension));
				return n.set(Wg.calc(u), qg.calc(u), Yg.calc(u)), n;
			}),
			(Xg.prototype.copy = function (t) {
				Hg.prototype.copy.call(this, t), (this.points = []);
				for (let e = 0, n = t.points.length; e < n; e++) {
					const n = t.points[e];
					this.points.push(n.clone());
				}
				return (
					(this.closed = t.closed),
					(this.curveType = t.curveType),
					(this.tension = t.tension),
					this
				);
			}),
			(Xg.prototype.toJSON = function () {
				const t = Hg.prototype.toJSON.call(this);
				t.points = [];
				for (let e = 0, n = this.points.length; e < n; e++) {
					const n = this.points[e];
					t.points.push(n.toArray());
				}
				return (
					(t.closed = this.closed),
					(t.curveType = this.curveType),
					(t.tension = this.tension),
					t
				);
			}),
			(Xg.prototype.fromJSON = function (t) {
				Hg.prototype.fromJSON.call(this, t), (this.points = []);
				for (let e = 0, n = t.points.length; e < n; e++) {
					const n = t.points[e];
					this.points.push(new ll().fromArray(n));
				}
				return (
					(this.closed = t.closed),
					(this.curveType = t.curveType),
					(this.tension = t.tension),
					this
				);
			}),
			(Qg.prototype = Object.create(Hg.prototype)),
			(Qg.prototype.constructor = Qg),
			(Qg.prototype.isCubicBezierCurve = !0),
			(Qg.prototype.getPoint = function (t, e) {
				const n = e || new Kc(),
					i = this.v0,
					r = this.v1,
					o = this.v2,
					s = this.v3;
				return n.set(Kg(t, i.x, r.x, o.x, s.x), Kg(t, i.y, r.y, o.y, s.y)), n;
			}),
			(Qg.prototype.copy = function (t) {
				return (
					Hg.prototype.copy.call(this, t),
					this.v0.copy(t.v0),
					this.v1.copy(t.v1),
					this.v2.copy(t.v2),
					this.v3.copy(t.v3),
					this
				);
			}),
			(Qg.prototype.toJSON = function () {
				const t = Hg.prototype.toJSON.call(this);
				return (
					(t.v0 = this.v0.toArray()),
					(t.v1 = this.v1.toArray()),
					(t.v2 = this.v2.toArray()),
					(t.v3 = this.v3.toArray()),
					t
				);
			}),
			(Qg.prototype.fromJSON = function (t) {
				return (
					Hg.prototype.fromJSON.call(this, t),
					this.v0.fromArray(t.v0),
					this.v1.fromArray(t.v1),
					this.v2.fromArray(t.v2),
					this.v3.fromArray(t.v3),
					this
				);
			}),
			($g.prototype = Object.create(Hg.prototype)),
			($g.prototype.constructor = $g),
			($g.prototype.isCubicBezierCurve3 = !0),
			($g.prototype.getPoint = function (t, e) {
				const n = e || new ll(),
					i = this.v0,
					r = this.v1,
					o = this.v2,
					s = this.v3;
				return (
					n.set(
						Kg(t, i.x, r.x, o.x, s.x),
						Kg(t, i.y, r.y, o.y, s.y),
						Kg(t, i.z, r.z, o.z, s.z)
					),
					n
				);
			}),
			($g.prototype.copy = function (t) {
				return (
					Hg.prototype.copy.call(this, t),
					this.v0.copy(t.v0),
					this.v1.copy(t.v1),
					this.v2.copy(t.v2),
					this.v3.copy(t.v3),
					this
				);
			}),
			($g.prototype.toJSON = function () {
				const t = Hg.prototype.toJSON.call(this);
				return (
					(t.v0 = this.v0.toArray()),
					(t.v1 = this.v1.toArray()),
					(t.v2 = this.v2.toArray()),
					(t.v3 = this.v3.toArray()),
					t
				);
			}),
			($g.prototype.fromJSON = function (t) {
				return (
					Hg.prototype.fromJSON.call(this, t),
					this.v0.fromArray(t.v0),
					this.v1.fromArray(t.v1),
					this.v2.fromArray(t.v2),
					this.v3.fromArray(t.v3),
					this
				);
			}),
			(tv.prototype = Object.create(Hg.prototype)),
			(tv.prototype.constructor = tv),
			(tv.prototype.isLineCurve = !0),
			(tv.prototype.getPoint = function (t, e) {
				const n = e || new Kc();
				return (
					1 === t
						? n.copy(this.v2)
						: (n.copy(this.v2).sub(this.v1), n.multiplyScalar(t).add(this.v1)),
					n
				);
			}),
			(tv.prototype.getPointAt = function (t, e) {
				return this.getPoint(t, e);
			}),
			(tv.prototype.getTangent = function (t, e) {
				const n = e || new Kc();
				return n.copy(this.v2).sub(this.v1).normalize(), n;
			}),
			(tv.prototype.copy = function (t) {
				return (
					Hg.prototype.copy.call(this, t),
					this.v1.copy(t.v1),
					this.v2.copy(t.v2),
					this
				);
			}),
			(tv.prototype.toJSON = function () {
				const t = Hg.prototype.toJSON.call(this);
				return (t.v1 = this.v1.toArray()), (t.v2 = this.v2.toArray()), t;
			}),
			(tv.prototype.fromJSON = function (t) {
				return (
					Hg.prototype.fromJSON.call(this, t),
					this.v1.fromArray(t.v1),
					this.v2.fromArray(t.v2),
					this
				);
			}),
			(ev.prototype = Object.create(Hg.prototype)),
			(ev.prototype.constructor = ev),
			(ev.prototype.isLineCurve3 = !0),
			(ev.prototype.getPoint = function (t, e) {
				const n = e || new ll();
				return (
					1 === t
						? n.copy(this.v2)
						: (n.copy(this.v2).sub(this.v1), n.multiplyScalar(t).add(this.v1)),
					n
				);
			}),
			(ev.prototype.getPointAt = function (t, e) {
				return this.getPoint(t, e);
			}),
			(ev.prototype.copy = function (t) {
				return (
					Hg.prototype.copy.call(this, t),
					this.v1.copy(t.v1),
					this.v2.copy(t.v2),
					this
				);
			}),
			(ev.prototype.toJSON = function () {
				const t = Hg.prototype.toJSON.call(this);
				return (t.v1 = this.v1.toArray()), (t.v2 = this.v2.toArray()), t;
			}),
			(ev.prototype.fromJSON = function (t) {
				return (
					Hg.prototype.fromJSON.call(this, t),
					this.v1.fromArray(t.v1),
					this.v2.fromArray(t.v2),
					this
				);
			}),
			(nv.prototype = Object.create(Hg.prototype)),
			(nv.prototype.constructor = nv),
			(nv.prototype.isQuadraticBezierCurve = !0),
			(nv.prototype.getPoint = function (t, e) {
				const n = e || new Kc(),
					i = this.v0,
					r = this.v1,
					o = this.v2;
				return n.set(Jg(t, i.x, r.x, o.x), Jg(t, i.y, r.y, o.y)), n;
			}),
			(nv.prototype.copy = function (t) {
				return (
					Hg.prototype.copy.call(this, t),
					this.v0.copy(t.v0),
					this.v1.copy(t.v1),
					this.v2.copy(t.v2),
					this
				);
			}),
			(nv.prototype.toJSON = function () {
				const t = Hg.prototype.toJSON.call(this);
				return (
					(t.v0 = this.v0.toArray()),
					(t.v1 = this.v1.toArray()),
					(t.v2 = this.v2.toArray()),
					t
				);
			}),
			(nv.prototype.fromJSON = function (t) {
				return (
					Hg.prototype.fromJSON.call(this, t),
					this.v0.fromArray(t.v0),
					this.v1.fromArray(t.v1),
					this.v2.fromArray(t.v2),
					this
				);
			}),
			(iv.prototype = Object.create(Hg.prototype)),
			(iv.prototype.constructor = iv),
			(iv.prototype.isQuadraticBezierCurve3 = !0),
			(iv.prototype.getPoint = function (t, e) {
				const n = e || new ll(),
					i = this.v0,
					r = this.v1,
					o = this.v2;
				return (
					n.set(
						Jg(t, i.x, r.x, o.x),
						Jg(t, i.y, r.y, o.y),
						Jg(t, i.z, r.z, o.z)
					),
					n
				);
			}),
			(iv.prototype.copy = function (t) {
				return (
					Hg.prototype.copy.call(this, t),
					this.v0.copy(t.v0),
					this.v1.copy(t.v1),
					this.v2.copy(t.v2),
					this
				);
			}),
			(iv.prototype.toJSON = function () {
				const t = Hg.prototype.toJSON.call(this);
				return (
					(t.v0 = this.v0.toArray()),
					(t.v1 = this.v1.toArray()),
					(t.v2 = this.v2.toArray()),
					t
				);
			}),
			(iv.prototype.fromJSON = function (t) {
				return (
					Hg.prototype.fromJSON.call(this, t),
					this.v0.fromArray(t.v0),
					this.v1.fromArray(t.v1),
					this.v2.fromArray(t.v2),
					this
				);
			}),
			(rv.prototype = Object.create(Hg.prototype)),
			(rv.prototype.constructor = rv),
			(rv.prototype.isSplineCurve = !0),
			(rv.prototype.getPoint = function (t, e) {
				const n = e || new Kc(),
					i = this.points,
					r = (i.length - 1) * t,
					o = Math.floor(r),
					s = r - o,
					a = i[0 === o ? o : o - 1],
					c = i[o],
					l = i[o > i.length - 2 ? i.length - 1 : o + 1],
					h = i[o > i.length - 3 ? i.length - 1 : o + 2];
				return n.set(Zg(s, a.x, c.x, l.x, h.x), Zg(s, a.y, c.y, l.y, h.y)), n;
			}),
			(rv.prototype.copy = function (t) {
				Hg.prototype.copy.call(this, t), (this.points = []);
				for (let e = 0, n = t.points.length; e < n; e++) {
					const n = t.points[e];
					this.points.push(n.clone());
				}
				return this;
			}),
			(rv.prototype.toJSON = function () {
				const t = Hg.prototype.toJSON.call(this);
				t.points = [];
				for (let e = 0, n = this.points.length; e < n; e++) {
					const n = this.points[e];
					t.points.push(n.toArray());
				}
				return t;
			}),
			(rv.prototype.fromJSON = function (t) {
				Hg.prototype.fromJSON.call(this, t), (this.points = []);
				for (let e = 0, n = t.points.length; e < n; e++) {
					const n = t.points[e];
					this.points.push(new Kc().fromArray(n));
				}
				return this;
			});
		var ov = Object.freeze({
			__proto__: null,
			ArcCurve: Gg,
			CatmullRomCurve3: Xg,
			CubicBezierCurve: Qg,
			CubicBezierCurve3: $g,
			EllipseCurve: Ug,
			LineCurve: tv,
			LineCurve3: ev,
			QuadraticBezierCurve: nv,
			QuadraticBezierCurve3: iv,
			SplineCurve: rv,
		});
		function sv() {
			Hg.call(this),
				(this.type = "CurvePath"),
				(this.curves = []),
				(this.autoClose = !1);
		}
		function av(t) {
			sv.call(this),
				(this.type = "Path"),
				(this.currentPoint = new Kc()),
				t && this.setFromPoints(t);
		}
		function cv(t) {
			av.call(this, t),
				(this.uuid = Jc.generateUUID()),
				(this.type = "Shape"),
				(this.holes = []);
		}
		function lv(t, e) {
			kl.call(this),
				(this.type = "Light"),
				(this.color = new Eh(t)),
				(this.intensity = void 0 !== e ? e : 1),
				(this.receiveShadow = void 0);
		}
		function hv(t, e, n) {
			lv.call(this, t, n),
				(this.type = "HemisphereLight"),
				(this.castShadow = void 0),
				this.position.copy(kl.DefaultUp),
				this.updateMatrix(),
				(this.groundColor = new Eh(e));
		}
		function uv(t) {
			(this.camera = t),
				(this.bias = 0),
				(this.normalBias = 0),
				(this.radius = 1),
				(this.mapSize = new Kc(512, 512)),
				(this.map = null),
				(this.mapPass = null),
				(this.matrix = new vl()),
				(this.autoUpdate = !0),
				(this.needsUpdate = !1),
				(this._frustum = new Vu()),
				(this._frameExtents = new Kc(1, 1)),
				(this._viewportCount = 1),
				(this._viewports = [new il(0, 0, 1, 1)]);
		}
		function dv() {
			uv.call(this, new ku(50, 1, 0.5, 500));
		}
		function pv(t, e, n, i, r, o) {
			lv.call(this, t, e),
				(this.type = "SpotLight"),
				this.position.copy(kl.DefaultUp),
				this.updateMatrix(),
				(this.target = new kl()),
				Object.defineProperty(this, "power", {
					get: function () {
						return this.intensity * Math.PI;
					},
					set: function (t) {
						this.intensity = t / Math.PI;
					},
				}),
				(this.distance = void 0 !== n ? n : 0),
				(this.angle = void 0 !== i ? i : Math.PI / 3),
				(this.penumbra = void 0 !== r ? r : 0),
				(this.decay = void 0 !== o ? o : 1),
				(this.shadow = new dv());
		}
		function fv() {
			uv.call(this, new ku(90, 1, 0.5, 500)),
				(this._frameExtents = new Kc(4, 2)),
				(this._viewportCount = 6),
				(this._viewports = [
					new il(2, 1, 1, 1),
					new il(0, 1, 1, 1),
					new il(3, 1, 1, 1),
					new il(1, 1, 1, 1),
					new il(3, 0, 1, 1),
					new il(1, 0, 1, 1),
				]),
				(this._cubeDirections = [
					new ll(1, 0, 0),
					new ll(-1, 0, 0),
					new ll(0, 0, 1),
					new ll(0, 0, -1),
					new ll(0, 1, 0),
					new ll(0, -1, 0),
				]),
				(this._cubeUps = [
					new ll(0, 1, 0),
					new ll(0, 1, 0),
					new ll(0, 1, 0),
					new ll(0, 1, 0),
					new ll(0, 0, 1),
					new ll(0, 0, -1),
				]);
		}
		function mv(t, e, n, i) {
			lv.call(this, t, e),
				(this.type = "PointLight"),
				Object.defineProperty(this, "power", {
					get: function () {
						return 4 * this.intensity * Math.PI;
					},
					set: function (t) {
						this.intensity = t / (4 * Math.PI);
					},
				}),
				(this.distance = void 0 !== n ? n : 0),
				(this.decay = void 0 !== i ? i : 1),
				(this.shadow = new fv());
		}
		function gv(t, e, n, i, r, o) {
			Iu.call(this),
				(this.type = "OrthographicCamera"),
				(this.zoom = 1),
				(this.view = null),
				(this.left = void 0 !== t ? t : -1),
				(this.right = void 0 !== e ? e : 1),
				(this.top = void 0 !== n ? n : 1),
				(this.bottom = void 0 !== i ? i : -1),
				(this.near = void 0 !== r ? r : 0.1),
				(this.far = void 0 !== o ? o : 2e3),
				this.updateProjectionMatrix();
		}
		function vv() {
			uv.call(this, new gv(-5, 5, 5, -5, 0.5, 500));
		}
		function yv(t, e) {
			lv.call(this, t, e),
				(this.type = "DirectionalLight"),
				this.position.copy(kl.DefaultUp),
				this.updateMatrix(),
				(this.target = new kl()),
				(this.shadow = new vv());
		}
		function xv(t, e) {
			lv.call(this, t, e),
				(this.type = "AmbientLight"),
				(this.castShadow = void 0);
		}
		function bv(t, e, n, i) {
			lv.call(this, t, e),
				(this.type = "RectAreaLight"),
				(this.width = void 0 !== n ? n : 10),
				(this.height = void 0 !== i ? i : 10);
		}
		function wv() {
			this.coefficients = [];
			for (let t = 0; t < 9; t++) this.coefficients.push(new ll());
		}
		function _v(t, e) {
			lv.call(this, void 0, e),
				(this.type = "LightProbe"),
				(this.sh = void 0 !== t ? t : new wv());
		}
		function Mv(t) {
			Cg.call(this, t), (this.textures = {});
		}
		(sv.prototype = Object.assign(Object.create(Hg.prototype), {
			constructor: sv,
			add: function (t) {
				this.curves.push(t);
			},
			closePath: function () {
				const t = this.curves[0].getPoint(0),
					e = this.curves[this.curves.length - 1].getPoint(1);
				t.equals(e) || this.curves.push(new tv(e, t));
			},
			getPoint: function (t) {
				const e = t * this.getLength(),
					n = this.getCurveLengths();
				let i = 0;
				for (; i < n.length; ) {
					if (n[i] >= e) {
						const t = n[i] - e,
							r = this.curves[i],
							o = r.getLength(),
							s = 0 === o ? 0 : 1 - t / o;
						return r.getPointAt(s);
					}
					i++;
				}
				return null;
			},
			getLength: function () {
				const t = this.getCurveLengths();
				return t[t.length - 1];
			},
			updateArcLengths: function () {
				(this.needsUpdate = !0),
					(this.cacheLengths = null),
					this.getCurveLengths();
			},
			getCurveLengths: function () {
				if (
					this.cacheLengths &&
					this.cacheLengths.length === this.curves.length
				)
					return this.cacheLengths;
				const t = [];
				let e = 0;
				for (let n = 0, i = this.curves.length; n < i; n++)
					(e += this.curves[n].getLength()), t.push(e);
				return (this.cacheLengths = t), t;
			},
			getSpacedPoints: function (t) {
				void 0 === t && (t = 40);
				const e = [];
				for (let n = 0; n <= t; n++) e.push(this.getPoint(n / t));
				return this.autoClose && e.push(e[0]), e;
			},
			getPoints: function (t) {
				t = t || 12;
				const e = [];
				let n;
				for (let i = 0, r = this.curves; i < r.length; i++) {
					const o = r[i],
						s =
							o && o.isEllipseCurve
								? 2 * t
								: o && (o.isLineCurve || o.isLineCurve3)
								? 1
								: o && o.isSplineCurve
								? t * o.points.length
								: t,
						a = o.getPoints(s);
					for (let t = 0; t < a.length; t++) {
						const i = a[t];
						(n && n.equals(i)) || (e.push(i), (n = i));
					}
				}
				return (
					this.autoClose &&
						e.length > 1 &&
						!e[e.length - 1].equals(e[0]) &&
						e.push(e[0]),
					e
				);
			},
			copy: function (t) {
				Hg.prototype.copy.call(this, t), (this.curves = []);
				for (let e = 0, n = t.curves.length; e < n; e++) {
					const n = t.curves[e];
					this.curves.push(n.clone());
				}
				return (this.autoClose = t.autoClose), this;
			},
			toJSON: function () {
				const t = Hg.prototype.toJSON.call(this);
				(t.autoClose = this.autoClose), (t.curves = []);
				for (let e = 0, n = this.curves.length; e < n; e++) {
					const n = this.curves[e];
					t.curves.push(n.toJSON());
				}
				return t;
			},
			fromJSON: function (t) {
				Hg.prototype.fromJSON.call(this, t),
					(this.autoClose = t.autoClose),
					(this.curves = []);
				for (let e = 0, n = t.curves.length; e < n; e++) {
					const n = t.curves[e];
					this.curves.push(new ov[n.type]().fromJSON(n));
				}
				return this;
			},
		})),
			(av.prototype = Object.assign(Object.create(sv.prototype), {
				constructor: av,
				setFromPoints: function (t) {
					this.moveTo(t[0].x, t[0].y);
					for (let e = 1, n = t.length; e < n; e++) this.lineTo(t[e].x, t[e].y);
					return this;
				},
				moveTo: function (t, e) {
					return this.currentPoint.set(t, e), this;
				},
				lineTo: function (t, e) {
					const n = new tv(this.currentPoint.clone(), new Kc(t, e));
					return this.curves.push(n), this.currentPoint.set(t, e), this;
				},
				quadraticCurveTo: function (t, e, n, i) {
					const r = new nv(
						this.currentPoint.clone(),
						new Kc(t, e),
						new Kc(n, i)
					);
					return this.curves.push(r), this.currentPoint.set(n, i), this;
				},
				bezierCurveTo: function (t, e, n, i, r, o) {
					const s = new Qg(
						this.currentPoint.clone(),
						new Kc(t, e),
						new Kc(n, i),
						new Kc(r, o)
					);
					return this.curves.push(s), this.currentPoint.set(r, o), this;
				},
				splineThru: function (t) {
					const e = new rv([this.currentPoint.clone()].concat(t));
					return (
						this.curves.push(e), this.currentPoint.copy(t[t.length - 1]), this
					);
				},
				arc: function (t, e, n, i, r, o) {
					const s = this.currentPoint.x,
						a = this.currentPoint.y;
					return this.absarc(t + s, e + a, n, i, r, o), this;
				},
				absarc: function (t, e, n, i, r, o) {
					return this.absellipse(t, e, n, n, i, r, o), this;
				},
				ellipse: function (t, e, n, i, r, o, s, a) {
					const c = this.currentPoint.x,
						l = this.currentPoint.y;
					return this.absellipse(t + c, e + l, n, i, r, o, s, a), this;
				},
				absellipse: function (t, e, n, i, r, o, s, a) {
					const c = new Ug(t, e, n, i, r, o, s, a);
					if (this.curves.length > 0) {
						const t = c.getPoint(0);
						t.equals(this.currentPoint) || this.lineTo(t.x, t.y);
					}
					this.curves.push(c);
					const l = c.getPoint(1);
					return this.currentPoint.copy(l), this;
				},
				copy: function (t) {
					return (
						sv.prototype.copy.call(this, t),
						this.currentPoint.copy(t.currentPoint),
						this
					);
				},
				toJSON: function () {
					const t = sv.prototype.toJSON.call(this);
					return (t.currentPoint = this.currentPoint.toArray()), t;
				},
				fromJSON: function (t) {
					return (
						sv.prototype.fromJSON.call(this, t),
						this.currentPoint.fromArray(t.currentPoint),
						this
					);
				},
			})),
			(cv.prototype = Object.assign(Object.create(av.prototype), {
				constructor: cv,
				getPointsHoles: function (t) {
					const e = [];
					for (let n = 0, i = this.holes.length; n < i; n++)
						e[n] = this.holes[n].getPoints(t);
					return e;
				},
				extractPoints: function (t) {
					return { shape: this.getPoints(t), holes: this.getPointsHoles(t) };
				},
				copy: function (t) {
					av.prototype.copy.call(this, t), (this.holes = []);
					for (let e = 0, n = t.holes.length; e < n; e++) {
						const n = t.holes[e];
						this.holes.push(n.clone());
					}
					return this;
				},
				toJSON: function () {
					const t = av.prototype.toJSON.call(this);
					(t.uuid = this.uuid), (t.holes = []);
					for (let e = 0, n = this.holes.length; e < n; e++) {
						const n = this.holes[e];
						t.holes.push(n.toJSON());
					}
					return t;
				},
				fromJSON: function (t) {
					av.prototype.fromJSON.call(this, t),
						(this.uuid = t.uuid),
						(this.holes = []);
					for (let e = 0, n = t.holes.length; e < n; e++) {
						const n = t.holes[e];
						this.holes.push(new av().fromJSON(n));
					}
					return this;
				},
			})),
			(lv.prototype = Object.assign(Object.create(kl.prototype), {
				constructor: lv,
				isLight: !0,
				copy: function (t) {
					return (
						kl.prototype.copy.call(this, t),
						this.color.copy(t.color),
						(this.intensity = t.intensity),
						this
					);
				},
				toJSON: function (t) {
					const e = kl.prototype.toJSON.call(this, t);
					return (
						(e.object.color = this.color.getHex()),
						(e.object.intensity = this.intensity),
						void 0 !== this.groundColor &&
							(e.object.groundColor = this.groundColor.getHex()),
						void 0 !== this.distance && (e.object.distance = this.distance),
						void 0 !== this.angle && (e.object.angle = this.angle),
						void 0 !== this.decay && (e.object.decay = this.decay),
						void 0 !== this.penumbra && (e.object.penumbra = this.penumbra),
						void 0 !== this.shadow && (e.object.shadow = this.shadow.toJSON()),
						e
					);
				},
			})),
			(hv.prototype = Object.assign(Object.create(lv.prototype), {
				constructor: hv,
				isHemisphereLight: !0,
				copy: function (t) {
					return (
						lv.prototype.copy.call(this, t),
						this.groundColor.copy(t.groundColor),
						this
					);
				},
			})),
			Object.assign(uv.prototype, {
				_projScreenMatrix: new vl(),
				_lightPositionWorld: new ll(),
				_lookTarget: new ll(),
				getViewportCount: function () {
					return this._viewportCount;
				},
				getFrustum: function () {
					return this._frustum;
				},
				updateMatrices: function (t) {
					const e = this.camera,
						n = this.matrix,
						i = this._projScreenMatrix,
						r = this._lookTarget,
						o = this._lightPositionWorld;
					o.setFromMatrixPosition(t.matrixWorld),
						e.position.copy(o),
						r.setFromMatrixPosition(t.target.matrixWorld),
						e.lookAt(r),
						e.updateMatrixWorld(),
						i.multiplyMatrices(e.projectionMatrix, e.matrixWorldInverse),
						this._frustum.setFromProjectionMatrix(i),
						n.set(0.5, 0, 0, 0.5, 0, 0.5, 0, 0.5, 0, 0, 0.5, 0.5, 0, 0, 0, 1),
						n.multiply(e.projectionMatrix),
						n.multiply(e.matrixWorldInverse);
				},
				getViewport: function (t) {
					return this._viewports[t];
				},
				getFrameExtents: function () {
					return this._frameExtents;
				},
				copy: function (t) {
					return (
						(this.camera = t.camera.clone()),
						(this.bias = t.bias),
						(this.radius = t.radius),
						this.mapSize.copy(t.mapSize),
						this
					);
				},
				clone: function () {
					return new this.constructor().copy(this);
				},
				toJSON: function () {
					const t = {};
					return (
						0 !== this.bias && (t.bias = this.bias),
						0 !== this.normalBias && (t.normalBias = this.normalBias),
						1 !== this.radius && (t.radius = this.radius),
						(512 === this.mapSize.x && 512 === this.mapSize.y) ||
							(t.mapSize = this.mapSize.toArray()),
						(t.camera = this.camera.toJSON(!1).object),
						delete t.camera.matrix,
						t
					);
				},
			}),
			(dv.prototype = Object.assign(Object.create(uv.prototype), {
				constructor: dv,
				isSpotLightShadow: !0,
				updateMatrices: function (t) {
					const e = this.camera,
						n = 2 * Jc.RAD2DEG * t.angle,
						i = this.mapSize.width / this.mapSize.height,
						r = t.distance || e.far;
					(n === e.fov && i === e.aspect && r === e.far) ||
						((e.fov = n),
						(e.aspect = i),
						(e.far = r),
						e.updateProjectionMatrix()),
						uv.prototype.updateMatrices.call(this, t);
				},
			})),
			(pv.prototype = Object.assign(Object.create(lv.prototype), {
				constructor: pv,
				isSpotLight: !0,
				copy: function (t) {
					return (
						lv.prototype.copy.call(this, t),
						(this.distance = t.distance),
						(this.angle = t.angle),
						(this.penumbra = t.penumbra),
						(this.decay = t.decay),
						(this.target = t.target.clone()),
						(this.shadow = t.shadow.clone()),
						this
					);
				},
			})),
			(fv.prototype = Object.assign(Object.create(uv.prototype), {
				constructor: fv,
				isPointLightShadow: !0,
				updateMatrices: function (t, e) {
					void 0 === e && (e = 0);
					const n = this.camera,
						i = this.matrix,
						r = this._lightPositionWorld,
						o = this._lookTarget,
						s = this._projScreenMatrix;
					r.setFromMatrixPosition(t.matrixWorld),
						n.position.copy(r),
						o.copy(n.position),
						o.add(this._cubeDirections[e]),
						n.up.copy(this._cubeUps[e]),
						n.lookAt(o),
						n.updateMatrixWorld(),
						i.makeTranslation(-r.x, -r.y, -r.z),
						s.multiplyMatrices(n.projectionMatrix, n.matrixWorldInverse),
						this._frustum.setFromProjectionMatrix(s);
				},
			})),
			(mv.prototype = Object.assign(Object.create(lv.prototype), {
				constructor: mv,
				isPointLight: !0,
				copy: function (t) {
					return (
						lv.prototype.copy.call(this, t),
						(this.distance = t.distance),
						(this.decay = t.decay),
						(this.shadow = t.shadow.clone()),
						this
					);
				},
			})),
			(gv.prototype = Object.assign(Object.create(Iu.prototype), {
				constructor: gv,
				isOrthographicCamera: !0,
				copy: function (t, e) {
					return (
						Iu.prototype.copy.call(this, t, e),
						(this.left = t.left),
						(this.right = t.right),
						(this.top = t.top),
						(this.bottom = t.bottom),
						(this.near = t.near),
						(this.far = t.far),
						(this.zoom = t.zoom),
						(this.view = null === t.view ? null : Object.assign({}, t.view)),
						this
					);
				},
				setViewOffset: function (t, e, n, i, r, o) {
					null === this.view &&
						(this.view = {
							enabled: !0,
							fullWidth: 1,
							fullHeight: 1,
							offsetX: 0,
							offsetY: 0,
							width: 1,
							height: 1,
						}),
						(this.view.enabled = !0),
						(this.view.fullWidth = t),
						(this.view.fullHeight = e),
						(this.view.offsetX = n),
						(this.view.offsetY = i),
						(this.view.width = r),
						(this.view.height = o),
						this.updateProjectionMatrix();
				},
				clearViewOffset: function () {
					null !== this.view && (this.view.enabled = !1),
						this.updateProjectionMatrix();
				},
				updateProjectionMatrix: function () {
					const t = (this.right - this.left) / (2 * this.zoom),
						e = (this.top - this.bottom) / (2 * this.zoom),
						n = (this.right + this.left) / 2,
						i = (this.top + this.bottom) / 2;
					let r = n - t,
						o = n + t,
						s = i + e,
						a = i - e;
					if (null !== this.view && this.view.enabled) {
						const t =
								(this.right - this.left) / this.view.fullWidth / this.zoom,
							e = (this.top - this.bottom) / this.view.fullHeight / this.zoom;
						(o = (r += t * this.view.offsetX) + t * this.view.width),
							(a = (s -= e * this.view.offsetY) - e * this.view.height);
					}
					this.projectionMatrix.makeOrthographic(
						r,
						o,
						s,
						a,
						this.near,
						this.far
					),
						this.projectionMatrixInverse.getInverse(this.projectionMatrix);
				},
				toJSON: function (t) {
					const e = kl.prototype.toJSON.call(this, t);
					return (
						(e.object.zoom = this.zoom),
						(e.object.left = this.left),
						(e.object.right = this.right),
						(e.object.top = this.top),
						(e.object.bottom = this.bottom),
						(e.object.near = this.near),
						(e.object.far = this.far),
						null !== this.view &&
							(e.object.view = Object.assign({}, this.view)),
						e
					);
				},
			})),
			(vv.prototype = Object.assign(Object.create(uv.prototype), {
				constructor: vv,
				isDirectionalLightShadow: !0,
				updateMatrices: function (t) {
					uv.prototype.updateMatrices.call(this, t);
				},
			})),
			(yv.prototype = Object.assign(Object.create(lv.prototype), {
				constructor: yv,
				isDirectionalLight: !0,
				copy: function (t) {
					return (
						lv.prototype.copy.call(this, t),
						(this.target = t.target.clone()),
						(this.shadow = t.shadow.clone()),
						this
					);
				},
			})),
			(xv.prototype = Object.assign(Object.create(lv.prototype), {
				constructor: xv,
				isAmbientLight: !0,
			})),
			(bv.prototype = Object.assign(Object.create(lv.prototype), {
				constructor: bv,
				isRectAreaLight: !0,
				copy: function (t) {
					return (
						lv.prototype.copy.call(this, t),
						(this.width = t.width),
						(this.height = t.height),
						this
					);
				},
				toJSON: function (t) {
					const e = lv.prototype.toJSON.call(this, t);
					return (
						(e.object.width = this.width), (e.object.height = this.height), e
					);
				},
			})),
			Object.assign(wv.prototype, {
				isSphericalHarmonics3: !0,
				set: function (t) {
					for (let e = 0; e < 9; e++) this.coefficients[e].copy(t[e]);
					return this;
				},
				zero: function () {
					for (let t = 0; t < 9; t++) this.coefficients[t].set(0, 0, 0);
					return this;
				},
				getAt: function (t, e) {
					const n = t.x,
						i = t.y,
						r = t.z,
						o = this.coefficients;
					return (
						e.copy(o[0]).multiplyScalar(0.282095),
						e.addScaledVector(o[1], 0.488603 * i),
						e.addScaledVector(o[2], 0.488603 * r),
						e.addScaledVector(o[3], 0.488603 * n),
						e.addScaledVector(o[4], n * i * 1.092548),
						e.addScaledVector(o[5], i * r * 1.092548),
						e.addScaledVector(o[6], 0.315392 * (3 * r * r - 1)),
						e.addScaledVector(o[7], n * r * 1.092548),
						e.addScaledVector(o[8], 0.546274 * (n * n - i * i)),
						e
					);
				},
				getIrradianceAt: function (t, e) {
					const n = t.x,
						i = t.y,
						r = t.z,
						o = this.coefficients;
					return (
						e.copy(o[0]).multiplyScalar(0.886227),
						e.addScaledVector(o[1], 1.023328 * i),
						e.addScaledVector(o[2], 1.023328 * r),
						e.addScaledVector(o[3], 1.023328 * n),
						e.addScaledVector(o[4], 0.858086 * n * i),
						e.addScaledVector(o[5], 0.858086 * i * r),
						e.addScaledVector(o[6], 0.743125 * r * r - 0.247708),
						e.addScaledVector(o[7], 0.858086 * n * r),
						e.addScaledVector(o[8], 0.429043 * (n * n - i * i)),
						e
					);
				},
				add: function (t) {
					for (let e = 0; e < 9; e++)
						this.coefficients[e].add(t.coefficients[e]);
					return this;
				},
				addScaledSH: function (t, e) {
					for (let n = 0; n < 9; n++)
						this.coefficients[n].addScaledVector(t.coefficients[n], e);
					return this;
				},
				scale: function (t) {
					for (let e = 0; e < 9; e++) this.coefficients[e].multiplyScalar(t);
					return this;
				},
				lerp: function (t, e) {
					for (let n = 0; n < 9; n++)
						this.coefficients[n].lerp(t.coefficients[n], e);
					return this;
				},
				equals: function (t) {
					for (let e = 0; e < 9; e++)
						if (!this.coefficients[e].equals(t.coefficients[e])) return !1;
					return !0;
				},
				copy: function (t) {
					return this.set(t.coefficients);
				},
				clone: function () {
					return new this.constructor().copy(this);
				},
				fromArray: function (t, e) {
					void 0 === e && (e = 0);
					const n = this.coefficients;
					for (let i = 0; i < 9; i++) n[i].fromArray(t, e + 3 * i);
					return this;
				},
				toArray: function (t, e) {
					void 0 === t && (t = []), void 0 === e && (e = 0);
					const n = this.coefficients;
					for (let i = 0; i < 9; i++) n[i].toArray(t, e + 3 * i);
					return t;
				},
			}),
			Object.assign(wv, {
				getBasisAt: function (t, e) {
					const n = t.x,
						i = t.y,
						r = t.z;
					(e[0] = 0.282095),
						(e[1] = 0.488603 * i),
						(e[2] = 0.488603 * r),
						(e[3] = 0.488603 * n),
						(e[4] = 1.092548 * n * i),
						(e[5] = 1.092548 * i * r),
						(e[6] = 0.315392 * (3 * r * r - 1)),
						(e[7] = 1.092548 * n * r),
						(e[8] = 0.546274 * (n * n - i * i));
				},
			}),
			(_v.prototype = Object.assign(Object.create(lv.prototype), {
				constructor: _v,
				isLightProbe: !0,
				copy: function (t) {
					return lv.prototype.copy.call(this, t), this.sh.copy(t.sh), this;
				},
				fromJSON: function (t) {
					return (this.intensity = t.intensity), this.sh.fromArray(t.sh), this;
				},
				toJSON: function (t) {
					const e = lv.prototype.toJSON.call(this, t);
					return (e.object.sh = this.sh.toArray()), e;
				},
			})),
			(Mv.prototype = Object.assign(Object.create(Cg.prototype), {
				constructor: Mv,
				load: function (t, e, n, i) {
					const r = this,
						o = new Dg(r.manager);
					o.setPath(r.path),
						o.load(
							t,
							function (n) {
								try {
									e(r.parse(JSON.parse(n)));
								} catch (e) {
									i ? i(e) : console.error(e), r.manager.itemError(t);
								}
							},
							n,
							i
						);
				},
				parse: function (t) {
					const e = this.textures;
					function n(t) {
						return (
							void 0 === e[t] &&
								console.warn("THREE.MaterialLoader: Undefined texture", t),
							e[t]
						);
					}
					const i = new dg[t.type]();
					if (
						(void 0 !== t.uuid && (i.uuid = t.uuid),
						void 0 !== t.name && (i.name = t.name),
						void 0 !== t.color && i.color.setHex(t.color),
						void 0 !== t.roughness && (i.roughness = t.roughness),
						void 0 !== t.metalness && (i.metalness = t.metalness),
						void 0 !== t.sheen && (i.sheen = new Eh().setHex(t.sheen)),
						void 0 !== t.emissive && i.emissive.setHex(t.emissive),
						void 0 !== t.specular && i.specular.setHex(t.specular),
						void 0 !== t.shininess && (i.shininess = t.shininess),
						void 0 !== t.clearcoat && (i.clearcoat = t.clearcoat),
						void 0 !== t.clearcoatRoughness &&
							(i.clearcoatRoughness = t.clearcoatRoughness),
						void 0 !== t.fog && (i.fog = t.fog),
						void 0 !== t.flatShading && (i.flatShading = t.flatShading),
						void 0 !== t.blending && (i.blending = t.blending),
						void 0 !== t.combine && (i.combine = t.combine),
						void 0 !== t.side && (i.side = t.side),
						void 0 !== t.opacity && (i.opacity = t.opacity),
						void 0 !== t.transparent && (i.transparent = t.transparent),
						void 0 !== t.alphaTest && (i.alphaTest = t.alphaTest),
						void 0 !== t.depthTest && (i.depthTest = t.depthTest),
						void 0 !== t.depthWrite && (i.depthWrite = t.depthWrite),
						void 0 !== t.colorWrite && (i.colorWrite = t.colorWrite),
						void 0 !== t.stencilWrite && (i.stencilWrite = t.stencilWrite),
						void 0 !== t.stencilWriteMask &&
							(i.stencilWriteMask = t.stencilWriteMask),
						void 0 !== t.stencilFunc && (i.stencilFunc = t.stencilFunc),
						void 0 !== t.stencilRef && (i.stencilRef = t.stencilRef),
						void 0 !== t.stencilFuncMask &&
							(i.stencilFuncMask = t.stencilFuncMask),
						void 0 !== t.stencilFail && (i.stencilFail = t.stencilFail),
						void 0 !== t.stencilZFail && (i.stencilZFail = t.stencilZFail),
						void 0 !== t.stencilZPass && (i.stencilZPass = t.stencilZPass),
						void 0 !== t.wireframe && (i.wireframe = t.wireframe),
						void 0 !== t.wireframeLinewidth &&
							(i.wireframeLinewidth = t.wireframeLinewidth),
						void 0 !== t.wireframeLinecap &&
							(i.wireframeLinecap = t.wireframeLinecap),
						void 0 !== t.wireframeLinejoin &&
							(i.wireframeLinejoin = t.wireframeLinejoin),
						void 0 !== t.rotation && (i.rotation = t.rotation),
						1 !== t.linewidth && (i.linewidth = t.linewidth),
						void 0 !== t.dashSize && (i.dashSize = t.dashSize),
						void 0 !== t.gapSize && (i.gapSize = t.gapSize),
						void 0 !== t.scale && (i.scale = t.scale),
						void 0 !== t.polygonOffset && (i.polygonOffset = t.polygonOffset),
						void 0 !== t.polygonOffsetFactor &&
							(i.polygonOffsetFactor = t.polygonOffsetFactor),
						void 0 !== t.polygonOffsetUnits &&
							(i.polygonOffsetUnits = t.polygonOffsetUnits),
						void 0 !== t.skinning && (i.skinning = t.skinning),
						void 0 !== t.morphTargets && (i.morphTargets = t.morphTargets),
						void 0 !== t.morphNormals && (i.morphNormals = t.morphNormals),
						void 0 !== t.dithering && (i.dithering = t.dithering),
						void 0 !== t.vertexTangents &&
							(i.vertexTangents = t.vertexTangents),
						void 0 !== t.visible && (i.visible = t.visible),
						void 0 !== t.toneMapped && (i.toneMapped = t.toneMapped),
						void 0 !== t.userData && (i.userData = t.userData),
						void 0 !== t.vertexColors &&
							("number" == typeof t.vertexColors
								? (i.vertexColors = t.vertexColors > 0)
								: (i.vertexColors = t.vertexColors)),
						void 0 !== t.uniforms)
					)
						for (const e in t.uniforms) {
							const r = t.uniforms[e];
							switch (((i.uniforms[e] = {}), r.type)) {
								case "t":
									i.uniforms[e].value = n(r.value);
									break;
								case "c":
									i.uniforms[e].value = new Eh().setHex(r.value);
									break;
								case "v2":
									i.uniforms[e].value = new Kc().fromArray(r.value);
									break;
								case "v3":
									i.uniforms[e].value = new ll().fromArray(r.value);
									break;
								case "v4":
									i.uniforms[e].value = new il().fromArray(r.value);
									break;
								case "m3":
									i.uniforms[e].value = new Qc().fromArray(r.value);
								case "m4":
									i.uniforms[e].value = new vl().fromArray(r.value);
									break;
								default:
									i.uniforms[e].value = r.value;
							}
						}
					if (
						(void 0 !== t.defines && (i.defines = t.defines),
						void 0 !== t.vertexShader && (i.vertexShader = t.vertexShader),
						void 0 !== t.fragmentShader &&
							(i.fragmentShader = t.fragmentShader),
						void 0 !== t.extensions)
					)
						for (const e in t.extensions) i.extensions[e] = t.extensions[e];
					if (
						(void 0 !== t.shading && (i.flatShading = 1 === t.shading),
						void 0 !== t.size && (i.size = t.size),
						void 0 !== t.sizeAttenuation &&
							(i.sizeAttenuation = t.sizeAttenuation),
						void 0 !== t.map && (i.map = n(t.map)),
						void 0 !== t.matcap && (i.matcap = n(t.matcap)),
						void 0 !== t.alphaMap && (i.alphaMap = n(t.alphaMap)),
						void 0 !== t.bumpMap && (i.bumpMap = n(t.bumpMap)),
						void 0 !== t.bumpScale && (i.bumpScale = t.bumpScale),
						void 0 !== t.normalMap && (i.normalMap = n(t.normalMap)),
						void 0 !== t.normalMapType && (i.normalMapType = t.normalMapType),
						void 0 !== t.normalScale)
					) {
						let e = t.normalScale;
						!1 === Array.isArray(e) && (e = [e, e]),
							(i.normalScale = new Kc().fromArray(e));
					}
					return (
						void 0 !== t.displacementMap &&
							(i.displacementMap = n(t.displacementMap)),
						void 0 !== t.displacementScale &&
							(i.displacementScale = t.displacementScale),
						void 0 !== t.displacementBias &&
							(i.displacementBias = t.displacementBias),
						void 0 !== t.roughnessMap && (i.roughnessMap = n(t.roughnessMap)),
						void 0 !== t.metalnessMap && (i.metalnessMap = n(t.metalnessMap)),
						void 0 !== t.emissiveMap && (i.emissiveMap = n(t.emissiveMap)),
						void 0 !== t.emissiveIntensity &&
							(i.emissiveIntensity = t.emissiveIntensity),
						void 0 !== t.specularMap && (i.specularMap = n(t.specularMap)),
						void 0 !== t.envMap && (i.envMap = n(t.envMap)),
						void 0 !== t.envMapIntensity &&
							(i.envMapIntensity = t.envMapIntensity),
						void 0 !== t.reflectivity && (i.reflectivity = t.reflectivity),
						void 0 !== t.refractionRatio &&
							(i.refractionRatio = t.refractionRatio),
						void 0 !== t.lightMap && (i.lightMap = n(t.lightMap)),
						void 0 !== t.lightMapIntensity &&
							(i.lightMapIntensity = t.lightMapIntensity),
						void 0 !== t.aoMap && (i.aoMap = n(t.aoMap)),
						void 0 !== t.aoMapIntensity &&
							(i.aoMapIntensity = t.aoMapIntensity),
						void 0 !== t.gradientMap && (i.gradientMap = n(t.gradientMap)),
						void 0 !== t.clearcoatMap && (i.clearcoatMap = n(t.clearcoatMap)),
						void 0 !== t.clearcoatRoughnessMap &&
							(i.clearcoatRoughnessMap = n(t.clearcoatRoughnessMap)),
						void 0 !== t.clearcoatNormalMap &&
							(i.clearcoatNormalMap = n(t.clearcoatNormalMap)),
						void 0 !== t.clearcoatNormalScale &&
							(i.clearcoatNormalScale = new Kc().fromArray(
								t.clearcoatNormalScale
							)),
						i
					);
				},
				setTextures: function (t) {
					return (this.textures = t), this;
				},
			}));
		const Sv = {
			decodeText: function (t) {
				if ("undefined" != typeof TextDecoder)
					return new TextDecoder().decode(t);
				let e = "";
				for (let n = 0, i = t.length; n < i; n++)
					e += String.fromCharCode(t[n]);
				try {
					return decodeURIComponent(escape(e));
				} catch (t) {
					return e;
				}
			},
			extractUrlBase: function (t) {
				const e = t.lastIndexOf("/");
				return -1 === e ? "./" : t.substr(0, e + 1);
			},
		};
		function Tv() {
			eu.call(this),
				(this.type = "InstancedBufferGeometry"),
				(this.instanceCount = 1 / 0);
		}
		function Ev(t, e, n, i) {
			"number" == typeof n &&
				((i = n),
				(n = !1),
				console.error(
					"THREE.InstancedBufferAttribute: The constructor now expects normalized as the third argument."
				)),
				Nh.call(this, t, e, n),
				(this.meshPerAttribute = i || 1);
		}
		function Av(t) {
			Cg.call(this, t);
		}
		(Tv.prototype = Object.assign(Object.create(eu.prototype), {
			constructor: Tv,
			isInstancedBufferGeometry: !0,
			copy: function (t) {
				return (
					eu.prototype.copy.call(this, t),
					(this.instanceCount = t.instanceCount),
					this
				);
			},
			clone: function () {
				return new this.constructor().copy(this);
			},
			toJSON: function () {
				const t = eu.prototype.toJSON.call(this);
				return (
					(t.instanceCount = this.instanceCount),
					(t.isInstancedBufferGeometry = !0),
					t
				);
			},
		})),
			(Ev.prototype = Object.assign(Object.create(Nh.prototype), {
				constructor: Ev,
				isInstancedBufferAttribute: !0,
				copy: function (t) {
					return (
						Nh.prototype.copy.call(this, t),
						(this.meshPerAttribute = t.meshPerAttribute),
						this
					);
				},
				toJSON: function () {
					const t = Nh.prototype.toJSON.call(this);
					return (
						(t.meshPerAttribute = this.meshPerAttribute),
						(t.isInstancedBufferAttribute = !0),
						t
					);
				},
			})),
			(Av.prototype = Object.assign(Object.create(Cg.prototype), {
				constructor: Av,
				load: function (t, e, n, i) {
					const r = this,
						o = new Dg(r.manager);
					o.setPath(r.path),
						o.load(
							t,
							function (n) {
								try {
									e(r.parse(JSON.parse(n)));
								} catch (e) {
									i ? i(e) : console.error(e), r.manager.itemError(t);
								}
							},
							n,
							i
						);
				},
				parse: function (t) {
					const e = {},
						n = {};
					function i(t, i) {
						if (void 0 !== e[i]) return e[i];
						const r = t.interleavedBuffers[i],
							o = (function (t, e) {
								if (void 0 !== n[e]) return n[e];
								const i = t.arrayBuffers[e],
									r = new Uint32Array(i).buffer;
								return (n[e] = r), r;
							})(t, r.buffer),
							s = new zp(new Lv[r.type](o), r.stride);
						return (s.uuid = r.uuid), (e[i] = s), s;
					}
					const r = t.isInstancedBufferGeometry ? new Tv() : new eu(),
						o = t.data.index;
					if (void 0 !== o) {
						const t = new Lv[o.type](o.array);
						r.setIndex(new Nh(t, 1));
					}
					const s = t.data.attributes;
					for (const e in s) {
						const n = s[e];
						let o;
						if (n.isInterleavedBufferAttribute) {
							o = new Up(i(t.data, n.data), n.itemSize, n.offset, n.normalized);
						} else {
							const t = new Lv[n.type](n.array);
							o = new (n.isInstancedBufferAttribute ? Ev : Nh)(
								t,
								n.itemSize,
								n.normalized
							);
						}
						void 0 !== n.name && (o.name = n.name), r.setAttribute(e, o);
					}
					const a = t.data.morphAttributes;
					if (a)
						for (const e in a) {
							const n = a[e],
								o = [];
							for (let e = 0, r = n.length; e < r; e++) {
								const r = n[e];
								let s;
								if (r.isInterleavedBufferAttribute) {
									s = new Up(
										i(t.data, r.data),
										r.itemSize,
										r.offset,
										r.normalized
									);
								} else {
									s = new Nh(new Lv[r.type](r.array), r.itemSize, r.normalized);
								}
								void 0 !== r.name && (s.name = r.name), o.push(s);
							}
							r.morphAttributes[e] = o;
						}
					t.data.morphTargetsRelative && (r.morphTargetsRelative = !0);
					const c = t.data.groups || t.data.drawcalls || t.data.offsets;
					if (void 0 !== c)
						for (let t = 0, e = c.length; t !== e; ++t) {
							const e = c[t];
							r.addGroup(e.start, e.count, e.materialIndex);
						}
					const l = t.data.boundingSphere;
					if (void 0 !== l) {
						const t = new ll();
						void 0 !== l.center && t.fromArray(l.center),
							(r.boundingSphere = new $l(t, l.radius));
					}
					return (
						t.name && (r.name = t.name),
						t.userData && (r.userData = t.userData),
						r
					);
				},
			}));
		const Lv = {
			Int8Array,
			Uint8Array,
			Uint8ClampedArray:
				"undefined" != typeof Uint8ClampedArray
					? Uint8ClampedArray
					: Uint8Array,
			Int16Array,
			Uint16Array,
			Int32Array,
			Uint32Array,
			Float32Array,
			Float64Array,
		};
		function Pv(t) {
			Cg.call(this, t);
		}
		Pv.prototype = Object.assign(Object.create(Cg.prototype), {
			constructor: Pv,
			load: function (t, e, n, i) {
				const r = this,
					o = "" === this.path ? Sv.extractUrlBase(t) : this.path;
				this.resourcePath = this.resourcePath || o;
				const s = new Dg(r.manager);
				s.setPath(this.path),
					s.load(
						t,
						function (n) {
							let o = null;
							try {
								o = JSON.parse(n);
							} catch (e) {
								return (
									void 0 !== i && i(e),
									void console.error(
										"THREE:ObjectLoader: Can't parse " + t + ".",
										e.message
									)
								);
							}
							const s = o.metadata;
							void 0 !== s &&
							void 0 !== s.type &&
							"geometry" !== s.type.toLowerCase()
								? r.parse(o, e)
								: console.error("THREE.ObjectLoader: Can't load " + t);
						},
						n,
						i
					);
			},
			parse: function (t, e) {
				const n = this.parseShape(t.shapes),
					i = this.parseGeometries(t.geometries, n),
					r = this.parseImages(t.images, function () {
						void 0 !== e && e(a);
					}),
					o = this.parseTextures(t.textures, r),
					s = this.parseMaterials(t.materials, o),
					a = this.parseObject(t.object, i, s);
				return (
					t.animations && (a.animations = this.parseAnimations(t.animations)),
					(void 0 !== t.images && 0 !== t.images.length) ||
						(void 0 !== e && e(a)),
					a
				);
			},
			parseShape: function (t) {
				const e = {};
				if (void 0 !== t)
					for (let n = 0, i = t.length; n < i; n++) {
						const i = new cv().fromJSON(t[n]);
						e[i.uuid] = i;
					}
				return e;
			},
			parseGeometries: function (t, e) {
				const n = {};
				let i;
				if (void 0 !== t) {
					const r = new Av();
					for (let o = 0, s = t.length; o < s; o++) {
						let s;
						const a = t[o];
						switch (a.type) {
							case "PlaneGeometry":
							case "PlaneBufferGeometry":
								s = new eg[a.type](
									a.width,
									a.height,
									a.widthSegments,
									a.heightSegments
								);
								break;
							case "BoxGeometry":
							case "BoxBufferGeometry":
							case "CubeGeometry":
								s = new eg[a.type](
									a.width,
									a.height,
									a.depth,
									a.widthSegments,
									a.heightSegments,
									a.depthSegments
								);
								break;
							case "CircleGeometry":
							case "CircleBufferGeometry":
								s = new eg[a.type](
									a.radius,
									a.segments,
									a.thetaStart,
									a.thetaLength
								);
								break;
							case "CylinderGeometry":
							case "CylinderBufferGeometry":
								s = new eg[a.type](
									a.radiusTop,
									a.radiusBottom,
									a.height,
									a.radialSegments,
									a.heightSegments,
									a.openEnded,
									a.thetaStart,
									a.thetaLength
								);
								break;
							case "ConeGeometry":
							case "ConeBufferGeometry":
								s = new eg[a.type](
									a.radius,
									a.height,
									a.radialSegments,
									a.heightSegments,
									a.openEnded,
									a.thetaStart,
									a.thetaLength
								);
								break;
							case "SphereGeometry":
							case "SphereBufferGeometry":
								s = new eg[a.type](
									a.radius,
									a.widthSegments,
									a.heightSegments,
									a.phiStart,
									a.phiLength,
									a.thetaStart,
									a.thetaLength
								);
								break;
							case "DodecahedronGeometry":
							case "DodecahedronBufferGeometry":
							case "IcosahedronGeometry":
							case "IcosahedronBufferGeometry":
							case "OctahedronGeometry":
							case "OctahedronBufferGeometry":
							case "TetrahedronGeometry":
							case "TetrahedronBufferGeometry":
								s = new eg[a.type](a.radius, a.detail);
								break;
							case "RingGeometry":
							case "RingBufferGeometry":
								s = new eg[a.type](
									a.innerRadius,
									a.outerRadius,
									a.thetaSegments,
									a.phiSegments,
									a.thetaStart,
									a.thetaLength
								);
								break;
							case "TorusGeometry":
							case "TorusBufferGeometry":
								s = new eg[a.type](
									a.radius,
									a.tube,
									a.radialSegments,
									a.tubularSegments,
									a.arc
								);
								break;
							case "TorusKnotGeometry":
							case "TorusKnotBufferGeometry":
								s = new eg[a.type](
									a.radius,
									a.tube,
									a.tubularSegments,
									a.radialSegments,
									a.p,
									a.q
								);
								break;
							case "TubeGeometry":
							case "TubeBufferGeometry":
								s = new eg[a.type](
									new ov[a.path.type]().fromJSON(a.path),
									a.tubularSegments,
									a.radius,
									a.radialSegments,
									a.closed
								);
								break;
							case "LatheGeometry":
							case "LatheBufferGeometry":
								s = new eg[a.type](
									a.points,
									a.segments,
									a.phiStart,
									a.phiLength
								);
								break;
							case "PolyhedronGeometry":
							case "PolyhedronBufferGeometry":
								s = new eg[a.type](a.vertices, a.indices, a.radius, a.details);
								break;
							case "ShapeGeometry":
							case "ShapeBufferGeometry":
								i = [];
								for (let t = 0, n = a.shapes.length; t < n; t++) {
									const n = e[a.shapes[t]];
									i.push(n);
								}
								s = new eg[a.type](i, a.curveSegments);
								break;
							case "ExtrudeGeometry":
							case "ExtrudeBufferGeometry":
								i = [];
								for (let t = 0, n = a.shapes.length; t < n; t++) {
									const n = e[a.shapes[t]];
									i.push(n);
								}
								const t = a.options.extrudePath;
								void 0 !== t &&
									(a.options.extrudePath = new ov[t.type]().fromJSON(t)),
									(s = new eg[a.type](i, a.options));
								break;
							case "BufferGeometry":
							case "InstancedBufferGeometry":
								s = r.parse(a);
								break;
							case "Geometry":
								console.error(
									'THREE.ObjectLoader: Loading "Geometry" is not supported anymore.'
								);
								break;
							default:
								console.warn(
									'THREE.ObjectLoader: Unsupported geometry type "' +
										a.type +
										'"'
								);
								continue;
						}
						(s.uuid = a.uuid),
							void 0 !== a.name && (s.name = a.name),
							!0 === s.isBufferGeometry &&
								void 0 !== a.userData &&
								(s.userData = a.userData),
							(n[a.uuid] = s);
					}
				}
				return n;
			},
			parseMaterials: function (t, e) {
				const n = {},
					i = {};
				if (void 0 !== t) {
					const r = new Mv();
					r.setTextures(e);
					for (let e = 0, o = t.length; e < o; e++) {
						const o = t[e];
						if ("MultiMaterial" === o.type) {
							const t = [];
							for (let e = 0; e < o.materials.length; e++) {
								const i = o.materials[e];
								void 0 === n[i.uuid] && (n[i.uuid] = r.parse(i)),
									t.push(n[i.uuid]);
							}
							i[o.uuid] = t;
						} else
							void 0 === n[o.uuid] && (n[o.uuid] = r.parse(o)),
								(i[o.uuid] = n[o.uuid]);
					}
				}
				return i;
			},
			parseAnimations: function (t) {
				const e = [];
				for (let n = 0; n < t.length; n++) {
					const i = t[n],
						r = Eg.parse(i);
					void 0 !== i.uuid && (r.uuid = i.uuid), e.push(r);
				}
				return e;
			},
			parseImages: function (t, e) {
				const n = this,
					i = {};
				let r;
				function o(t) {
					return (
						n.manager.itemStart(t),
						r.load(
							t,
							function () {
								n.manager.itemEnd(t);
							},
							void 0,
							function () {
								n.manager.itemError(t), n.manager.itemEnd(t);
							}
						)
					);
				}
				if (void 0 !== t && t.length > 0) {
					const s = new Pg(e);
					(r = new Bg(s)).setCrossOrigin(this.crossOrigin);
					for (let e = 0, r = t.length; e < r; e++) {
						const r = t[e],
							s = r.url;
						if (Array.isArray(s)) {
							i[r.uuid] = [];
							for (let t = 0, e = s.length; t < e; t++) {
								const e = s[t],
									a = /^(\/\/)|([a-z]+:(\/\/)?)/i.test(e)
										? e
										: n.resourcePath + e;
								i[r.uuid].push(o(a));
							}
						} else {
							const t = /^(\/\/)|([a-z]+:(\/\/)?)/i.test(r.url)
								? r.url
								: n.resourcePath + r.url;
							i[r.uuid] = o(t);
						}
					}
				}
				return i;
			},
			parseTextures: function (t, e) {
				function n(t, e) {
					return "number" == typeof t
						? t
						: (console.warn(
								"THREE.ObjectLoader.parseTexture: Constant should be in numeric form.",
								t
						  ),
						  e[t]);
				}
				const i = {};
				if (void 0 !== t)
					for (let r = 0, o = t.length; r < o; r++) {
						const o = t[r];
						let s;
						void 0 === o.image &&
							console.warn(
								'THREE.ObjectLoader: No "image" specified for',
								o.uuid
							),
							void 0 === e[o.image] &&
								console.warn("THREE.ObjectLoader: Undefined image", o.image),
							((s = Array.isArray(e[o.image])
								? new td(e[o.image])
								: new nl(e[o.image])).needsUpdate = !0),
							(s.uuid = o.uuid),
							void 0 !== o.name && (s.name = o.name),
							void 0 !== o.mapping && (s.mapping = n(o.mapping, Rv)),
							void 0 !== o.offset && s.offset.fromArray(o.offset),
							void 0 !== o.repeat && s.repeat.fromArray(o.repeat),
							void 0 !== o.center && s.center.fromArray(o.center),
							void 0 !== o.rotation && (s.rotation = o.rotation),
							void 0 !== o.wrap &&
								((s.wrapS = n(o.wrap[0], Cv)), (s.wrapT = n(o.wrap[1], Cv))),
							void 0 !== o.format && (s.format = o.format),
							void 0 !== o.type && (s.type = o.type),
							void 0 !== o.encoding && (s.encoding = o.encoding),
							void 0 !== o.minFilter && (s.minFilter = n(o.minFilter, Ov)),
							void 0 !== o.magFilter && (s.magFilter = n(o.magFilter, Ov)),
							void 0 !== o.anisotropy && (s.anisotropy = o.anisotropy),
							void 0 !== o.flipY && (s.flipY = o.flipY),
							void 0 !== o.premultiplyAlpha &&
								(s.premultiplyAlpha = o.premultiplyAlpha),
							void 0 !== o.unpackAlignment &&
								(s.unpackAlignment = o.unpackAlignment),
							(i[o.uuid] = s);
					}
				return i;
			},
			parseObject: function (t, e, n) {
				let i, r, o;
				function s(t) {
					return (
						void 0 === e[t] &&
							console.warn("THREE.ObjectLoader: Undefined geometry", t),
						e[t]
					);
				}
				function a(t) {
					if (void 0 !== t) {
						if (Array.isArray(t)) {
							const e = [];
							for (let i = 0, r = t.length; i < r; i++) {
								const r = t[i];
								void 0 === n[r] &&
									console.warn("THREE.ObjectLoader: Undefined material", r),
									e.push(n[r]);
							}
							return e;
						}
						return (
							void 0 === n[t] &&
								console.warn("THREE.ObjectLoader: Undefined material", t),
							n[t]
						);
					}
				}
				switch (t.type) {
					case "Scene":
						(i = new Nl()),
							void 0 !== t.background &&
								Number.isInteger(t.background) &&
								(i.background = new Eh(t.background)),
							void 0 !== t.fog &&
								("Fog" === t.fog.type
									? (i.fog = new Fp(t.fog.color, t.fog.near, t.fog.far))
									: "FogExp2" === t.fog.type &&
									  (i.fog = new Bp(t.fog.color, t.fog.density)));
						break;
					case "PerspectiveCamera":
						(i = new ku(t.fov, t.aspect, t.near, t.far)),
							void 0 !== t.focus && (i.focus = t.focus),
							void 0 !== t.zoom && (i.zoom = t.zoom),
							void 0 !== t.filmGauge && (i.filmGauge = t.filmGauge),
							void 0 !== t.filmOffset && (i.filmOffset = t.filmOffset),
							void 0 !== t.view && (i.view = Object.assign({}, t.view));
						break;
					case "OrthographicCamera":
						(i = new gv(t.left, t.right, t.top, t.bottom, t.near, t.far)),
							void 0 !== t.zoom && (i.zoom = t.zoom),
							void 0 !== t.view && (i.view = Object.assign({}, t.view));
						break;
					case "AmbientLight":
						i = new xv(t.color, t.intensity);
						break;
					case "DirectionalLight":
						i = new yv(t.color, t.intensity);
						break;
					case "PointLight":
						i = new mv(t.color, t.intensity, t.distance, t.decay);
						break;
					case "RectAreaLight":
						i = new bv(t.color, t.intensity, t.width, t.height);
						break;
					case "SpotLight":
						i = new pv(
							t.color,
							t.intensity,
							t.distance,
							t.angle,
							t.penumbra,
							t.decay
						);
						break;
					case "HemisphereLight":
						i = new hv(t.color, t.groundColor, t.intensity);
						break;
					case "LightProbe":
						i = new _v().fromJSON(t);
						break;
					case "SkinnedMesh":
						console.warn(
							"THREE.ObjectLoader.parseObject() does not support SkinnedMesh yet."
						);
					case "Mesh":
						i = new xu((r = s(t.geometry)), (o = a(t.material)));
						break;
					case "InstancedMesh":
						(r = s(t.geometry)), (o = a(t.material));
						const e = t.count,
							n = t.instanceMatrix;
						(i = new vf(r, o, e)).instanceMatrix = new Nh(
							new Float32Array(n.array),
							16
						);
						break;
					case "LOD":
						i = new af();
						break;
					case "Line":
						i = new Sf(s(t.geometry), a(t.material), t.mode);
						break;
					case "LineLoop":
						i = new Lf(s(t.geometry), a(t.material));
						break;
					case "LineSegments":
						i = new Af(s(t.geometry), a(t.material));
						break;
					case "PointCloud":
					case "Points":
						i = new If(s(t.geometry), a(t.material));
						break;
					case "Sprite":
						i = new nf(a(t.material));
						break;
					case "Group":
						i = new Cp();
						break;
					default:
						i = new kl();
				}
				if (
					((i.uuid = t.uuid),
					void 0 !== t.name && (i.name = t.name),
					void 0 !== t.matrix
						? (i.matrix.fromArray(t.matrix),
						  void 0 !== t.matrixAutoUpdate &&
								(i.matrixAutoUpdate = t.matrixAutoUpdate),
						  i.matrixAutoUpdate &&
								i.matrix.decompose(i.position, i.quaternion, i.scale))
						: (void 0 !== t.position && i.position.fromArray(t.position),
						  void 0 !== t.rotation && i.rotation.fromArray(t.rotation),
						  void 0 !== t.quaternion && i.quaternion.fromArray(t.quaternion),
						  void 0 !== t.scale && i.scale.fromArray(t.scale)),
					void 0 !== t.castShadow && (i.castShadow = t.castShadow),
					void 0 !== t.receiveShadow && (i.receiveShadow = t.receiveShadow),
					t.shadow &&
						(void 0 !== t.shadow.bias && (i.shadow.bias = t.shadow.bias),
						void 0 !== t.shadow.normalBias &&
							(i.shadow.normalBias = t.shadow.normalBias),
						void 0 !== t.shadow.radius && (i.shadow.radius = t.shadow.radius),
						void 0 !== t.shadow.mapSize &&
							i.shadow.mapSize.fromArray(t.shadow.mapSize),
						void 0 !== t.shadow.camera &&
							(i.shadow.camera = this.parseObject(t.shadow.camera))),
					void 0 !== t.visible && (i.visible = t.visible),
					void 0 !== t.frustumCulled && (i.frustumCulled = t.frustumCulled),
					void 0 !== t.renderOrder && (i.renderOrder = t.renderOrder),
					void 0 !== t.userData && (i.userData = t.userData),
					void 0 !== t.layers && (i.layers.mask = t.layers),
					void 0 !== t.children)
				) {
					const r = t.children;
					for (let t = 0; t < r.length; t++)
						i.add(this.parseObject(r[t], e, n));
				}
				if ("LOD" === t.type) {
					void 0 !== t.autoUpdate && (i.autoUpdate = t.autoUpdate);
					const e = t.levels;
					for (let t = 0; t < e.length; t++) {
						const n = e[t],
							r = i.getObjectByProperty("uuid", n.object);
						void 0 !== r && i.addLevel(r, n.distance);
					}
				}
				return i;
			},
		});
		const Rv = {
				UVMapping: 300,
				CubeReflectionMapping: ea,
				CubeRefractionMapping: na,
				EquirectangularReflectionMapping: ia,
				EquirectangularRefractionMapping: ra,
				CubeUVReflectionMapping: oa,
				CubeUVRefractionMapping: sa,
			},
			Cv = {
				RepeatWrapping: aa,
				ClampToEdgeWrapping: ca,
				MirroredRepeatWrapping: la,
			},
			Ov = {
				NearestFilter: ha,
				NearestMipmapNearestFilter: ua,
				NearestMipmapLinearFilter: da,
				LinearFilter: pa,
				LinearMipmapNearestFilter: fa,
				LinearMipmapLinearFilter: ma,
			};
		function Dv(t) {
			"undefined" == typeof createImageBitmap &&
				console.warn(
					"THREE.ImageBitmapLoader: createImageBitmap() not supported."
				),
				"undefined" == typeof fetch &&
					console.warn("THREE.ImageBitmapLoader: fetch() not supported."),
				Cg.call(this, t),
				(this.options = { premultiplyAlpha: "none" });
		}
		function Iv() {
			(this.type = "ShapePath"),
				(this.color = new Eh()),
				(this.subPaths = []),
				(this.currentPath = null);
		}
		function kv(t) {
			(this.type = "Font"), (this.data = t);
		}
		function Nv(t, e, n, i, r) {
			const o = r.glyphs[t] || r.glyphs["?"];
			if (!o)
				return void console.error(
					'THREE.Font: character "' +
						t +
						'" does not exists in font family ' +
						r.familyName +
						"."
				);
			const s = new Iv();
			let a, c, l, h, u, d, p, f;
			if (o.o) {
				const t = o._cachedOutline || (o._cachedOutline = o.o.split(" "));
				for (let r = 0, o = t.length; r < o; ) {
					switch (t[r++]) {
						case "m":
							(a = t[r++] * e + n), (c = t[r++] * e + i), s.moveTo(a, c);
							break;
						case "l":
							(a = t[r++] * e + n), (c = t[r++] * e + i), s.lineTo(a, c);
							break;
						case "q":
							(l = t[r++] * e + n),
								(h = t[r++] * e + i),
								(u = t[r++] * e + n),
								(d = t[r++] * e + i),
								s.quadraticCurveTo(u, d, l, h);
							break;
						case "b":
							(l = t[r++] * e + n),
								(h = t[r++] * e + i),
								(u = t[r++] * e + n),
								(d = t[r++] * e + i),
								(p = t[r++] * e + n),
								(f = t[r++] * e + i),
								s.bezierCurveTo(u, d, p, f, l, h);
					}
				}
			}
			return { offsetX: o.ha * e, path: s };
		}
		function Bv(t) {
			Cg.call(this, t);
		}
		let Fv;
		(Dv.prototype = Object.assign(Object.create(Cg.prototype), {
			constructor: Dv,
			isImageBitmapLoader: !0,
			setOptions: function (t) {
				return (this.options = t), this;
			},
			load: function (t, e, n, i) {
				void 0 === t && (t = ""),
					void 0 !== this.path && (t = this.path + t),
					(t = this.manager.resolveURL(t));
				const r = this,
					o = Lg.get(t);
				if (void 0 !== o)
					return (
						r.manager.itemStart(t),
						setTimeout(function () {
							e && e(o), r.manager.itemEnd(t);
						}, 0),
						o
					);
				fetch(t)
					.then(function (t) {
						return t.blob();
					})
					.then(function (t) {
						return createImageBitmap(t, r.options);
					})
					.then(function (n) {
						Lg.add(t, n), e && e(n), r.manager.itemEnd(t);
					})
					.catch(function (e) {
						i && i(e), r.manager.itemError(t), r.manager.itemEnd(t);
					}),
					r.manager.itemStart(t);
			},
		})),
			Object.assign(Iv.prototype, {
				moveTo: function (t, e) {
					return (
						(this.currentPath = new av()),
						this.subPaths.push(this.currentPath),
						this.currentPath.moveTo(t, e),
						this
					);
				},
				lineTo: function (t, e) {
					return this.currentPath.lineTo(t, e), this;
				},
				quadraticCurveTo: function (t, e, n, i) {
					return this.currentPath.quadraticCurveTo(t, e, n, i), this;
				},
				bezierCurveTo: function (t, e, n, i, r, o) {
					return this.currentPath.bezierCurveTo(t, e, n, i, r, o), this;
				},
				splineThru: function (t) {
					return this.currentPath.splineThru(t), this;
				},
				toShapes: function (t, e) {
					function n(t) {
						const e = [];
						for (let n = 0, i = t.length; n < i; n++) {
							const i = t[n],
								r = new cv();
							(r.curves = i.curves), e.push(r);
						}
						return e;
					}
					function i(t, e) {
						const n = e.length;
						let i = !1;
						for (let r = n - 1, o = 0; o < n; r = o++) {
							let n = e[r],
								s = e[o],
								a = s.x - n.x,
								c = s.y - n.y;
							if (Math.abs(c) > Number.EPSILON) {
								if (
									(c < 0 && ((n = e[o]), (a = -a), (s = e[r]), (c = -c)),
									t.y < n.y || t.y > s.y)
								)
									continue;
								if (t.y === n.y) {
									if (t.x === n.x) return !0;
								} else {
									const e = c * (t.x - n.x) - a * (t.y - n.y);
									if (0 === e) return !0;
									if (e < 0) continue;
									i = !i;
								}
							} else {
								if (t.y !== n.y) continue;
								if ((s.x <= t.x && t.x <= n.x) || (n.x <= t.x && t.x <= s.x))
									return !0;
							}
						}
						return i;
					}
					const r = Rm.isClockWise,
						o = this.subPaths;
					if (0 === o.length) return [];
					if (!0 === e) return n(o);
					let s,
						a,
						c,
						l = [];
					if (1 === o.length)
						return (a = o[0]), ((c = new cv()).curves = a.curves), l.push(c), l;
					let h = !r(o[0].getPoints());
					h = t ? !h : h;
					const u = [],
						d = [];
					let p,
						f,
						m = [],
						g = 0;
					(d[g] = void 0), (m[g] = []);
					for (let e = 0, n = o.length; e < n; e++)
						(s = r((p = (a = o[e]).getPoints()))),
							(s = t ? !s : s)
								? (!h && d[g] && g++,
								  (d[g] = { s: new cv(), p }),
								  (d[g].s.curves = a.curves),
								  h && g++,
								  (m[g] = []))
								: m[g].push({ h: a, p: p[0] });
					if (!d[0]) return n(o);
					if (d.length > 1) {
						let t = !1;
						const e = [];
						for (let t = 0, e = d.length; t < e; t++) u[t] = [];
						for (let n = 0, r = d.length; n < r; n++) {
							const r = m[n];
							for (let o = 0; o < r.length; o++) {
								const s = r[o];
								let a = !0;
								for (let r = 0; r < d.length; r++)
									i(s.p, d[r].p) &&
										(n !== r && e.push({ froms: n, tos: r, hole: o }),
										a ? ((a = !1), u[r].push(s)) : (t = !0));
								a && u[n].push(s);
							}
						}
						e.length > 0 && (t || (m = u));
					}
					for (let t = 0, e = d.length; t < e; t++) {
						(c = d[t].s), l.push(c);
						for (let e = 0, n = (f = m[t]).length; e < n; e++)
							c.holes.push(f[e].h);
					}
					return l;
				},
			}),
			Object.assign(kv.prototype, {
				isFont: !0,
				generateShapes: function (t, e) {
					void 0 === e && (e = 100);
					const n = [],
						i = (function (t, e, n) {
							const i = Array.from ? Array.from(t) : String(t).split(""),
								r = e / n.resolution,
								o =
									(n.boundingBox.yMax -
										n.boundingBox.yMin +
										n.underlineThickness) *
									r,
								s = [];
							let a = 0,
								c = 0;
							for (let t = 0; t < i.length; t++) {
								const e = i[t];
								if ("\n" === e) (a = 0), (c -= o);
								else {
									const t = Nv(e, r, a, c, n);
									(a += t.offsetX), s.push(t.path);
								}
							}
							return s;
						})(t, e, this.data);
					for (let t = 0, e = i.length; t < e; t++)
						Array.prototype.push.apply(n, i[t].toShapes());
					return n;
				},
			}),
			(Bv.prototype = Object.assign(Object.create(Cg.prototype), {
				constructor: Bv,
				load: function (t, e, n, i) {
					const r = this,
						o = new Dg(this.manager);
					o.setPath(this.path),
						o.load(
							t,
							function (t) {
								let n;
								try {
									n = JSON.parse(t);
								} catch (e) {
									console.warn(
										"THREE.FontLoader: typeface.js support is being deprecated. Use typeface.json instead."
									),
										(n = JSON.parse(t.substring(65, t.length - 2)));
								}
								const i = r.parse(n);
								e && e(i);
							},
							n,
							i
						);
				},
				parse: function (t) {
					return new kv(t);
				},
			}));
		const zv = {
			getContext: function () {
				return (
					void 0 === Fv &&
						(Fv = new (window.AudioContext || window.webkitAudioContext)()),
					Fv
				);
			},
			setContext: function (t) {
				Fv = t;
			},
		};
		function Hv(t) {
			Cg.call(this, t);
		}
		function Uv(t, e, n) {
			_v.call(this, void 0, n);
			const i = new Eh().set(t),
				r = new Eh().set(e),
				o = new ll(i.r, i.g, i.b),
				s = new ll(r.r, r.g, r.b),
				a = Math.sqrt(Math.PI),
				c = a * Math.sqrt(0.75);
			this.sh.coefficients[0].copy(o).add(s).multiplyScalar(a),
				this.sh.coefficients[1].copy(o).sub(s).multiplyScalar(c);
		}
		function Gv(t, e) {
			_v.call(this, void 0, e);
			const n = new Eh().set(t);
			this.sh.coefficients[0]
				.set(n.r, n.g, n.b)
				.multiplyScalar(2 * Math.sqrt(Math.PI));
		}
		(Hv.prototype = Object.assign(Object.create(Cg.prototype), {
			constructor: Hv,
			load: function (t, e, n, i) {
				const r = this,
					o = new Dg(r.manager);
				o.setResponseType("arraybuffer"),
					o.setPath(r.path),
					o.load(
						t,
						function (n) {
							try {
								const o = n.slice(0);
								zv.getContext().decodeAudioData(o, function (t) {
									e(t);
								});
							} catch (e) {
								i ? i(e) : console.error(e), r.manager.itemError(t);
							}
						},
						n,
						i
					);
			},
		})),
			(Uv.prototype = Object.assign(Object.create(_v.prototype), {
				constructor: Uv,
				isHemisphereLightProbe: !0,
				copy: function (t) {
					return _v.prototype.copy.call(this, t), this;
				},
				toJSON: function (t) {
					return _v.prototype.toJSON.call(this, t);
				},
			})),
			(Gv.prototype = Object.assign(Object.create(_v.prototype), {
				constructor: Gv,
				isAmbientLightProbe: !0,
				copy: function (t) {
					return _v.prototype.copy.call(this, t), this;
				},
				toJSON: function (t) {
					return _v.prototype.toJSON.call(this, t);
				},
			}));
		const Vv = new vl(),
			jv = new vl();
		function Wv(t) {
			(this.autoStart = void 0 === t || t),
				(this.startTime = 0),
				(this.oldTime = 0),
				(this.elapsedTime = 0),
				(this.running = !1);
		}
		Object.assign(
			function () {
				(this.type = "StereoCamera"),
					(this.aspect = 1),
					(this.eyeSep = 0.064),
					(this.cameraL = new ku()),
					this.cameraL.layers.enable(1),
					(this.cameraL.matrixAutoUpdate = !1),
					(this.cameraR = new ku()),
					this.cameraR.layers.enable(2),
					(this.cameraR.matrixAutoUpdate = !1),
					(this._cache = {
						focus: null,
						fov: null,
						aspect: null,
						near: null,
						far: null,
						zoom: null,
						eyeSep: null,
					});
			}.prototype,
			{
				update: function (t) {
					const e = this._cache;
					if (
						e.focus !== t.focus ||
						e.fov !== t.fov ||
						e.aspect !== t.aspect * this.aspect ||
						e.near !== t.near ||
						e.far !== t.far ||
						e.zoom !== t.zoom ||
						e.eyeSep !== this.eyeSep
					) {
						(e.focus = t.focus),
							(e.fov = t.fov),
							(e.aspect = t.aspect * this.aspect),
							(e.near = t.near),
							(e.far = t.far),
							(e.zoom = t.zoom),
							(e.eyeSep = this.eyeSep);
						const n = t.projectionMatrix.clone(),
							i = e.eyeSep / 2,
							r = (i * e.near) / e.focus,
							o = (e.near * Math.tan(Jc.DEG2RAD * e.fov * 0.5)) / e.zoom;
						let s, a;
						(jv.elements[12] = -i),
							(Vv.elements[12] = i),
							(s = -o * e.aspect + r),
							(a = o * e.aspect + r),
							(n.elements[0] = (2 * e.near) / (a - s)),
							(n.elements[8] = (a + s) / (a - s)),
							this.cameraL.projectionMatrix.copy(n),
							(s = -o * e.aspect - r),
							(a = o * e.aspect - r),
							(n.elements[0] = (2 * e.near) / (a - s)),
							(n.elements[8] = (a + s) / (a - s)),
							this.cameraR.projectionMatrix.copy(n);
					}
					this.cameraL.matrixWorld.copy(t.matrixWorld).multiply(jv),
						this.cameraR.matrixWorld.copy(t.matrixWorld).multiply(Vv);
				},
			}
		),
			Object.assign(Wv.prototype, {
				start: function () {
					(this.startTime = (
						"undefined" == typeof performance ? Date : performance
					).now()),
						(this.oldTime = this.startTime),
						(this.elapsedTime = 0),
						(this.running = !0);
				},
				stop: function () {
					this.getElapsedTime(), (this.running = !1), (this.autoStart = !1);
				},
				getElapsedTime: function () {
					return this.getDelta(), this.elapsedTime;
				},
				getDelta: function () {
					let t = 0;
					if (this.autoStart && !this.running) return this.start(), 0;
					if (this.running) {
						const e = (
							"undefined" == typeof performance ? Date : performance
						).now();
						(t = (e - this.oldTime) / 1e3),
							(this.oldTime = e),
							(this.elapsedTime += t);
					}
					return t;
				},
			});
		const qv = new ll(),
			Yv = new sl(),
			Xv = new ll(),
			Zv = new ll();
		function Jv() {
			kl.call(this),
				(this.type = "AudioListener"),
				(this.context = zv.getContext()),
				(this.gain = this.context.createGain()),
				this.gain.connect(this.context.destination),
				(this.filter = null),
				(this.timeDelta = 0),
				(this._clock = new Wv());
		}
		function Kv(t) {
			kl.call(this),
				(this.type = "Audio"),
				(this.listener = t),
				(this.context = t.context),
				(this.gain = this.context.createGain()),
				this.gain.connect(t.getInput()),
				(this.autoplay = !1),
				(this.buffer = null),
				(this.detune = 0),
				(this.loop = !1),
				(this.loopStart = 0),
				(this.loopEnd = 0),
				(this.offset = 0),
				(this.duration = void 0),
				(this.playbackRate = 1),
				(this.isPlaying = !1),
				(this.hasPlaybackControl = !0),
				(this.sourceType = "empty"),
				(this._startedAt = 0),
				(this._progress = 0),
				(this.filters = []);
		}
		(Jv.prototype = Object.assign(Object.create(kl.prototype), {
			constructor: Jv,
			getInput: function () {
				return this.gain;
			},
			removeFilter: function () {
				return (
					null !== this.filter &&
						(this.gain.disconnect(this.filter),
						this.filter.disconnect(this.context.destination),
						this.gain.connect(this.context.destination),
						(this.filter = null)),
					this
				);
			},
			getFilter: function () {
				return this.filter;
			},
			setFilter: function (t) {
				return (
					null !== this.filter
						? (this.gain.disconnect(this.filter),
						  this.filter.disconnect(this.context.destination))
						: this.gain.disconnect(this.context.destination),
					(this.filter = t),
					this.gain.connect(this.filter),
					this.filter.connect(this.context.destination),
					this
				);
			},
			getMasterVolume: function () {
				return this.gain.gain.value;
			},
			setMasterVolume: function (t) {
				return (
					this.gain.gain.setTargetAtTime(t, this.context.currentTime, 0.01),
					this
				);
			},
			updateMatrixWorld: function (t) {
				kl.prototype.updateMatrixWorld.call(this, t);
				const e = this.context.listener,
					n = this.up;
				if (
					((this.timeDelta = this._clock.getDelta()),
					this.matrixWorld.decompose(qv, Yv, Xv),
					Zv.set(0, 0, -1).applyQuaternion(Yv),
					e.positionX)
				) {
					const t = this.context.currentTime + this.timeDelta;
					e.positionX.linearRampToValueAtTime(qv.x, t),
						e.positionY.linearRampToValueAtTime(qv.y, t),
						e.positionZ.linearRampToValueAtTime(qv.z, t),
						e.forwardX.linearRampToValueAtTime(Zv.x, t),
						e.forwardY.linearRampToValueAtTime(Zv.y, t),
						e.forwardZ.linearRampToValueAtTime(Zv.z, t),
						e.upX.linearRampToValueAtTime(n.x, t),
						e.upY.linearRampToValueAtTime(n.y, t),
						e.upZ.linearRampToValueAtTime(n.z, t);
				} else
					e.setPosition(qv.x, qv.y, qv.z),
						e.setOrientation(Zv.x, Zv.y, Zv.z, n.x, n.y, n.z);
			},
		})),
			(Kv.prototype = Object.assign(Object.create(kl.prototype), {
				constructor: Kv,
				getOutput: function () {
					return this.gain;
				},
				setNodeSource: function (t) {
					return (
						(this.hasPlaybackControl = !1),
						(this.sourceType = "audioNode"),
						(this.source = t),
						this.connect(),
						this
					);
				},
				setMediaElementSource: function (t) {
					return (
						(this.hasPlaybackControl = !1),
						(this.sourceType = "mediaNode"),
						(this.source = this.context.createMediaElementSource(t)),
						this.connect(),
						this
					);
				},
				setMediaStreamSource: function (t) {
					return (
						(this.hasPlaybackControl = !1),
						(this.sourceType = "mediaStreamNode"),
						(this.source = this.context.createMediaStreamSource(t)),
						this.connect(),
						this
					);
				},
				setBuffer: function (t) {
					return (
						(this.buffer = t),
						(this.sourceType = "buffer"),
						this.autoplay && this.play(),
						this
					);
				},
				play: function (t) {
					if ((void 0 === t && (t = 0), !0 === this.isPlaying))
						return void console.warn("THREE.Audio: Audio is already playing.");
					if (!1 === this.hasPlaybackControl)
						return void console.warn(
							"THREE.Audio: this Audio has no playback control."
						);
					this._startedAt = this.context.currentTime + t;
					const e = this.context.createBufferSource();
					return (
						(e.buffer = this.buffer),
						(e.loop = this.loop),
						(e.loopStart = this.loopStart),
						(e.loopEnd = this.loopEnd),
						(e.onended = this.onEnded.bind(this)),
						e.start(
							this._startedAt,
							this._progress + this.offset,
							this.duration
						),
						(this.isPlaying = !0),
						(this.source = e),
						this.setDetune(this.detune),
						this.setPlaybackRate(this.playbackRate),
						this.connect()
					);
				},
				pause: function () {
					if (!1 !== this.hasPlaybackControl)
						return (
							!0 === this.isPlaying &&
								((this._progress +=
									Math.max(this.context.currentTime - this._startedAt, 0) *
									this.playbackRate),
								!0 === this.loop &&
									(this._progress =
										this._progress % (this.duration || this.buffer.duration)),
								this.source.stop(),
								(this.source.onended = null),
								(this.isPlaying = !1)),
							this
						);
					console.warn("THREE.Audio: this Audio has no playback control.");
				},
				stop: function () {
					if (!1 !== this.hasPlaybackControl)
						return (
							(this._progress = 0),
							this.source.stop(),
							(this.source.onended = null),
							(this.isPlaying = !1),
							this
						);
					console.warn("THREE.Audio: this Audio has no playback control.");
				},
				connect: function () {
					if (this.filters.length > 0) {
						this.source.connect(this.filters[0]);
						for (let t = 1, e = this.filters.length; t < e; t++)
							this.filters[t - 1].connect(this.filters[t]);
						this.filters[this.filters.length - 1].connect(this.getOutput());
					} else this.source.connect(this.getOutput());
					return this;
				},
				disconnect: function () {
					if (this.filters.length > 0) {
						this.source.disconnect(this.filters[0]);
						for (let t = 1, e = this.filters.length; t < e; t++)
							this.filters[t - 1].disconnect(this.filters[t]);
						this.filters[this.filters.length - 1].disconnect(this.getOutput());
					} else this.source.disconnect(this.getOutput());
					return this;
				},
				getFilters: function () {
					return this.filters;
				},
				setFilters: function (t) {
					return (
						t || (t = []),
						!0 === this.isPlaying
							? (this.disconnect(), (this.filters = t), this.connect())
							: (this.filters = t),
						this
					);
				},
				setDetune: function (t) {
					if (((this.detune = t), void 0 !== this.source.detune))
						return (
							!0 === this.isPlaying &&
								this.source.detune.setTargetAtTime(
									this.detune,
									this.context.currentTime,
									0.01
								),
							this
						);
				},
				getDetune: function () {
					return this.detune;
				},
				getFilter: function () {
					return this.getFilters()[0];
				},
				setFilter: function (t) {
					return this.setFilters(t ? [t] : []);
				},
				setPlaybackRate: function (t) {
					if (!1 !== this.hasPlaybackControl)
						return (
							(this.playbackRate = t),
							!0 === this.isPlaying &&
								this.source.playbackRate.setTargetAtTime(
									this.playbackRate,
									this.context.currentTime,
									0.01
								),
							this
						);
					console.warn("THREE.Audio: this Audio has no playback control.");
				},
				getPlaybackRate: function () {
					return this.playbackRate;
				},
				onEnded: function () {
					this.isPlaying = !1;
				},
				getLoop: function () {
					return !1 === this.hasPlaybackControl
						? (console.warn("THREE.Audio: this Audio has no playback control."),
						  !1)
						: this.loop;
				},
				setLoop: function (t) {
					if (!1 !== this.hasPlaybackControl)
						return (
							(this.loop = t),
							!0 === this.isPlaying && (this.source.loop = this.loop),
							this
						);
					console.warn("THREE.Audio: this Audio has no playback control.");
				},
				setLoopStart: function (t) {
					return (this.loopStart = t), this;
				},
				setLoopEnd: function (t) {
					return (this.loopEnd = t), this;
				},
				getVolume: function () {
					return this.gain.gain.value;
				},
				setVolume: function (t) {
					return (
						this.gain.gain.setTargetAtTime(t, this.context.currentTime, 0.01),
						this
					);
				},
			}));
		const Qv = new ll(),
			$v = new sl(),
			ty = new ll(),
			ey = new ll();
		function ny(t) {
			Kv.call(this, t),
				(this.panner = this.context.createPanner()),
				(this.panner.panningModel = "HRTF"),
				this.panner.connect(this.gain);
		}
		function iy(t, e) {
			(this.analyser = t.context.createAnalyser()),
				(this.analyser.fftSize = void 0 !== e ? e : 2048),
				(this.data = new Uint8Array(this.analyser.frequencyBinCount)),
				t.getOutput().connect(this.analyser);
		}
		function ry(t, e, n) {
			let i, r, o;
			switch (((this.binding = t), (this.valueSize = n), e)) {
				case "quaternion":
					(i = this._slerp),
						(r = this._slerpAdditive),
						(o = this._setAdditiveIdentityQuaternion),
						(this.buffer = new Float64Array(6 * n)),
						(this._workIndex = 5);
					break;
				case "string":
				case "bool":
					(i = this._select),
						(r = this._select),
						(o = this._setAdditiveIdentityOther),
						(this.buffer = new Array(5 * n));
					break;
				default:
					(i = this._lerp),
						(r = this._lerpAdditive),
						(o = this._setAdditiveIdentityNumeric),
						(this.buffer = new Float64Array(5 * n));
			}
			(this._mixBufferRegion = i),
				(this._mixBufferRegionAdditive = r),
				(this._setIdentity = o),
				(this._origIndex = 3),
				(this._addIndex = 4),
				(this.cumulativeWeight = 0),
				(this.cumulativeWeightAdditive = 0),
				(this.useCount = 0),
				(this.referenceCount = 0);
		}
		(ny.prototype = Object.assign(Object.create(Kv.prototype), {
			constructor: ny,
			getOutput: function () {
				return this.panner;
			},
			getRefDistance: function () {
				return this.panner.refDistance;
			},
			setRefDistance: function (t) {
				return (this.panner.refDistance = t), this;
			},
			getRolloffFactor: function () {
				return this.panner.rolloffFactor;
			},
			setRolloffFactor: function (t) {
				return (this.panner.rolloffFactor = t), this;
			},
			getDistanceModel: function () {
				return this.panner.distanceModel;
			},
			setDistanceModel: function (t) {
				return (this.panner.distanceModel = t), this;
			},
			getMaxDistance: function () {
				return this.panner.maxDistance;
			},
			setMaxDistance: function (t) {
				return (this.panner.maxDistance = t), this;
			},
			setDirectionalCone: function (t, e, n) {
				return (
					(this.panner.coneInnerAngle = t),
					(this.panner.coneOuterAngle = e),
					(this.panner.coneOuterGain = n),
					this
				);
			},
			updateMatrixWorld: function (t) {
				if (
					(kl.prototype.updateMatrixWorld.call(this, t),
					!0 === this.hasPlaybackControl && !1 === this.isPlaying)
				)
					return;
				this.matrixWorld.decompose(Qv, $v, ty),
					ey.set(0, 0, 1).applyQuaternion($v);
				const e = this.panner;
				if (e.positionX) {
					const t = this.context.currentTime + this.listener.timeDelta;
					e.positionX.linearRampToValueAtTime(Qv.x, t),
						e.positionY.linearRampToValueAtTime(Qv.y, t),
						e.positionZ.linearRampToValueAtTime(Qv.z, t),
						e.orientationX.linearRampToValueAtTime(ey.x, t),
						e.orientationY.linearRampToValueAtTime(ey.y, t),
						e.orientationZ.linearRampToValueAtTime(ey.z, t);
				} else
					e.setPosition(Qv.x, Qv.y, Qv.z), e.setOrientation(ey.x, ey.y, ey.z);
			},
		})),
			Object.assign(iy.prototype, {
				getFrequencyData: function () {
					return this.analyser.getByteFrequencyData(this.data), this.data;
				},
				getAverageFrequency: function () {
					let t = 0;
					const e = this.getFrequencyData();
					for (let n = 0; n < e.length; n++) t += e[n];
					return t / e.length;
				},
			}),
			Object.assign(ry.prototype, {
				accumulate: function (t, e) {
					const n = this.buffer,
						i = this.valueSize,
						r = t * i + i;
					let o = this.cumulativeWeight;
					if (0 === o) {
						for (let t = 0; t !== i; ++t) n[r + t] = n[t];
						o = e;
					} else {
						const t = e / (o += e);
						this._mixBufferRegion(n, r, 0, t, i);
					}
					this.cumulativeWeight = o;
				},
				accumulateAdditive: function (t) {
					const e = this.buffer,
						n = this.valueSize,
						i = n * this._addIndex;
					0 === this.cumulativeWeightAdditive && this._setIdentity(),
						this._mixBufferRegionAdditive(e, i, 0, t, n),
						(this.cumulativeWeightAdditive += t);
				},
				apply: function (t) {
					const e = this.valueSize,
						n = this.buffer,
						i = t * e + e,
						r = this.cumulativeWeight,
						o = this.cumulativeWeightAdditive,
						s = this.binding;
					if (
						((this.cumulativeWeight = 0),
						(this.cumulativeWeightAdditive = 0),
						r < 1)
					) {
						const t = e * this._origIndex;
						this._mixBufferRegion(n, i, t, 1 - r, e);
					}
					o > 0 &&
						this._mixBufferRegionAdditive(n, i, this._addIndex * e, 1, e);
					for (let t = e, r = e + e; t !== r; ++t)
						if (n[t] !== n[t + e]) {
							s.setValue(n, i);
							break;
						}
				},
				saveOriginalState: function () {
					const t = this.binding,
						e = this.buffer,
						n = this.valueSize,
						i = n * this._origIndex;
					t.getValue(e, i);
					for (let t = n, r = i; t !== r; ++t) e[t] = e[i + (t % n)];
					this._setIdentity(),
						(this.cumulativeWeight = 0),
						(this.cumulativeWeightAdditive = 0);
				},
				restoreOriginalState: function () {
					const t = 3 * this.valueSize;
					this.binding.setValue(this.buffer, t);
				},
				_setAdditiveIdentityNumeric: function () {
					const t = this._addIndex * this.valueSize,
						e = t + this.valueSize;
					for (let n = t; n < e; n++) this.buffer[n] = 0;
				},
				_setAdditiveIdentityQuaternion: function () {
					this._setAdditiveIdentityNumeric(),
						(this.buffer[4 * this._addIndex + 3] = 1);
				},
				_setAdditiveIdentityOther: function () {
					const t = this._origIndex * this.valueSize,
						e = this._addIndex * this.valueSize;
					for (let n = 0; n < this.valueSize; n++)
						this.buffer[e + n] = this.buffer[t + n];
				},
				_select: function (t, e, n, i, r) {
					if (i >= 0.5) for (let i = 0; i !== r; ++i) t[e + i] = t[n + i];
				},
				_slerp: function (t, e, n, i) {
					sl.slerpFlat(t, e, t, e, t, n, i);
				},
				_slerpAdditive: function (t, e, n, i, r) {
					const o = this._workIndex * r;
					sl.multiplyQuaternionsFlat(t, o, t, e, t, n),
						sl.slerpFlat(t, e, t, e, t, o, i);
				},
				_lerp: function (t, e, n, i, r) {
					const o = 1 - i;
					for (let s = 0; s !== r; ++s) {
						const r = e + s;
						t[r] = t[r] * o + t[n + s] * i;
					}
				},
				_lerpAdditive: function (t, e, n, i, r) {
					for (let o = 0; o !== r; ++o) {
						const r = e + o;
						t[r] = t[r] + t[n + o] * i;
					}
				},
			});
		const oy = new RegExp("[\\[\\]\\.:\\/]", "g"),
			sy = "[^" + "\\[\\]\\.:\\/".replace("\\.", "") + "]",
			ay = /((?:WC+[\/:])*)/.source.replace("WC", "[^\\[\\]\\.:\\/]"),
			cy = /(WCOD+)?/.source.replace("WCOD", sy),
			ly = /(?:\.(WC+)(?:\[(.+)\])?)?/.source.replace("WC", "[^\\[\\]\\.:\\/]"),
			hy = /\.(WC+)(?:\[(.+)\])?/.source.replace("WC", "[^\\[\\]\\.:\\/]"),
			uy = new RegExp("^" + ay + cy + ly + hy + "$"),
			dy = ["material", "materials", "bones"];
		function py(t, e, n) {
			const i = n || fy.parseTrackName(e);
			(this._targetGroup = t), (this._bindings = t.subscribe_(e, i));
		}
		function fy(t, e, n) {
			(this.path = e),
				(this.parsedPath = n || fy.parseTrackName(e)),
				(this.node = fy.findNode(t, this.parsedPath.nodeName) || t),
				(this.rootNode = t);
		}
		function my(t, e, n, i) {
			(this._mixer = t),
				(this._clip = e),
				(this._localRoot = n || null),
				(this.blendMode = i || e.blendMode);
			const r = e.tracks,
				o = r.length,
				s = new Array(o),
				a = { endingStart: Pc, endingEnd: Pc };
			for (let t = 0; t !== o; ++t) {
				const e = r[t].createInterpolant(null);
				(s[t] = e), (e.settings = a);
			}
			(this._interpolantSettings = a),
				(this._interpolants = s),
				(this._propertyBindings = new Array(o)),
				(this._cacheIndex = null),
				(this._byClipCacheIndex = null),
				(this._timeScaleInterpolant = null),
				(this._weightInterpolant = null),
				(this.loop = Lc),
				(this._loopCount = -1),
				(this._startTime = null),
				(this.time = 0),
				(this.timeScale = 1),
				(this._effectiveTimeScale = 1),
				(this.weight = 1),
				(this._effectiveWeight = 1),
				(this.repetitions = 1 / 0),
				(this.paused = !1),
				(this.enabled = !0),
				(this.clampWhenFinished = !1),
				(this.zeroSlopeAtStart = !0),
				(this.zeroSlopeAtEnd = !0);
		}
		function gy(t) {
			(this._root = t),
				this._initMemoryManager(),
				(this._accuIndex = 0),
				(this.time = 0),
				(this.timeScale = 1);
		}
		function vy(t) {
			"string" == typeof t &&
				(console.warn("THREE.Uniform: Type parameter is no longer needed."),
				(t = arguments[1])),
				(this.value = t);
		}
		function yy(t, e, n) {
			zp.call(this, t, e), (this.meshPerAttribute = n || 1);
		}
		function xy(t, e, n, i) {
			(this.ray = new ah(t, e)),
				(this.near = n || 0),
				(this.far = i || 1 / 0),
				(this.camera = null),
				(this.layers = new wl()),
				(this.params = {
					Mesh: {},
					Line: { threshold: 1 },
					LOD: {},
					Points: { threshold: 1 },
					Sprite: {},
				}),
				Object.defineProperties(this.params, {
					PointCloud: {
						get: function () {
							return (
								console.warn(
									"THREE.Raycaster: params.PointCloud has been renamed to params.Points."
								),
								this.Points
							);
						},
					},
				});
		}
		function by(t, e) {
			return t.distance - e.distance;
		}
		function wy(t, e, n, i) {
			if ((t.layers.test(e.layers) && t.raycast(e, n), !0 === i)) {
				const i = t.children;
				for (let t = 0, r = i.length; t < r; t++) wy(i[t], e, n, !0);
			}
		}
		Object.assign(py.prototype, {
			getValue: function (t, e) {
				this.bind();
				const n = this._targetGroup.nCachedObjects_,
					i = this._bindings[n];
				void 0 !== i && i.getValue(t, e);
			},
			setValue: function (t, e) {
				const n = this._bindings;
				for (
					let i = this._targetGroup.nCachedObjects_, r = n.length;
					i !== r;
					++i
				)
					n[i].setValue(t, e);
			},
			bind: function () {
				const t = this._bindings;
				for (
					let e = this._targetGroup.nCachedObjects_, n = t.length;
					e !== n;
					++e
				)
					t[e].bind();
			},
			unbind: function () {
				const t = this._bindings;
				for (
					let e = this._targetGroup.nCachedObjects_, n = t.length;
					e !== n;
					++e
				)
					t[e].unbind();
			},
		}),
			Object.assign(fy, {
				Composite: py,
				create: function (t, e, n) {
					return t && t.isAnimationObjectGroup
						? new fy.Composite(t, e, n)
						: new fy(t, e, n);
				},
				sanitizeNodeName: function (t) {
					return t.replace(/\s/g, "_").replace(oy, "");
				},
				parseTrackName: function (t) {
					const e = uy.exec(t);
					if (!e)
						throw new Error("PropertyBinding: Cannot parse trackName: " + t);
					const n = {
							nodeName: e[2],
							objectName: e[3],
							objectIndex: e[4],
							propertyName: e[5],
							propertyIndex: e[6],
						},
						i = n.nodeName && n.nodeName.lastIndexOf(".");
					if (void 0 !== i && -1 !== i) {
						const t = n.nodeName.substring(i + 1);
						-1 !== dy.indexOf(t) &&
							((n.nodeName = n.nodeName.substring(0, i)), (n.objectName = t));
					}
					if (null === n.propertyName || 0 === n.propertyName.length)
						throw new Error(
							"PropertyBinding: can not parse propertyName from trackName: " + t
						);
					return n;
				},
				findNode: function (t, e) {
					if (
						!e ||
						"" === e ||
						"." === e ||
						-1 === e ||
						e === t.name ||
						e === t.uuid
					)
						return t;
					if (t.skeleton) {
						const n = t.skeleton.getBoneByName(e);
						if (void 0 !== n) return n;
					}
					if (t.children) {
						const n = function (t) {
								for (let i = 0; i < t.length; i++) {
									const r = t[i];
									if (r.name === e || r.uuid === e) return r;
									const o = n(r.children);
									if (o) return o;
								}
								return null;
							},
							i = n(t.children);
						if (i) return i;
					}
					return null;
				},
			}),
			Object.assign(fy.prototype, {
				_getValue_unavailable: function () {},
				_setValue_unavailable: function () {},
				BindingType: {
					Direct: 0,
					EntireArray: 1,
					ArrayElement: 2,
					HasFromToArray: 3,
				},
				Versioning: { None: 0, NeedsUpdate: 1, MatrixWorldNeedsUpdate: 2 },
				GetterByBindingType: [
					function (t, e) {
						t[e] = this.node[this.propertyName];
					},
					function (t, e) {
						const n = this.resolvedProperty;
						for (let i = 0, r = n.length; i !== r; ++i) t[e++] = n[i];
					},
					function (t, e) {
						t[e] = this.resolvedProperty[this.propertyIndex];
					},
					function (t, e) {
						this.resolvedProperty.toArray(t, e);
					},
				],
				SetterByBindingTypeAndVersioning: [
					[
						function (t, e) {
							this.targetObject[this.propertyName] = t[e];
						},
						function (t, e) {
							(this.targetObject[this.propertyName] = t[e]),
								(this.targetObject.needsUpdate = !0);
						},
						function (t, e) {
							(this.targetObject[this.propertyName] = t[e]),
								(this.targetObject.matrixWorldNeedsUpdate = !0);
						},
					],
					[
						function (t, e) {
							const n = this.resolvedProperty;
							for (let i = 0, r = n.length; i !== r; ++i) n[i] = t[e++];
						},
						function (t, e) {
							const n = this.resolvedProperty;
							for (let i = 0, r = n.length; i !== r; ++i) n[i] = t[e++];
							this.targetObject.needsUpdate = !0;
						},
						function (t, e) {
							const n = this.resolvedProperty;
							for (let i = 0, r = n.length; i !== r; ++i) n[i] = t[e++];
							this.targetObject.matrixWorldNeedsUpdate = !0;
						},
					],
					[
						function (t, e) {
							this.resolvedProperty[this.propertyIndex] = t[e];
						},
						function (t, e) {
							(this.resolvedProperty[this.propertyIndex] = t[e]),
								(this.targetObject.needsUpdate = !0);
						},
						function (t, e) {
							(this.resolvedProperty[this.propertyIndex] = t[e]),
								(this.targetObject.matrixWorldNeedsUpdate = !0);
						},
					],
					[
						function (t, e) {
							this.resolvedProperty.fromArray(t, e);
						},
						function (t, e) {
							this.resolvedProperty.fromArray(t, e),
								(this.targetObject.needsUpdate = !0);
						},
						function (t, e) {
							this.resolvedProperty.fromArray(t, e),
								(this.targetObject.matrixWorldNeedsUpdate = !0);
						},
					],
				],
				getValue: function (t, e) {
					this.bind(), this.getValue(t, e);
				},
				setValue: function (t, e) {
					this.bind(), this.setValue(t, e);
				},
				bind: function () {
					let t = this.node,
						e = this.parsedPath,
						n = e.objectName,
						i = e.propertyName,
						r = e.propertyIndex;
					if (
						(t ||
							((t = fy.findNode(this.rootNode, e.nodeName) || this.rootNode),
							(this.node = t)),
						(this.getValue = this._getValue_unavailable),
						(this.setValue = this._setValue_unavailable),
						!t)
					)
						return void console.error(
							"THREE.PropertyBinding: Trying to update node for track: " +
								this.path +
								" but it wasn't found."
						);
					if (n) {
						let i = e.objectIndex;
						switch (n) {
							case "materials":
								if (!t.material)
									return void console.error(
										"THREE.PropertyBinding: Can not bind to material as node does not have a material.",
										this
									);
								if (!t.material.materials)
									return void console.error(
										"THREE.PropertyBinding: Can not bind to material.materials as node.material does not have a materials array.",
										this
									);
								t = t.material.materials;
								break;
							case "bones":
								if (!t.skeleton)
									return void console.error(
										"THREE.PropertyBinding: Can not bind to bones as node does not have a skeleton.",
										this
									);
								t = t.skeleton.bones;
								for (let e = 0; e < t.length; e++)
									if (t[e].name === i) {
										i = e;
										break;
									}
								break;
							default:
								if (void 0 === t[n])
									return void console.error(
										"THREE.PropertyBinding: Can not bind to objectName of node undefined.",
										this
									);
								t = t[n];
						}
						if (void 0 !== i) {
							if (void 0 === t[i])
								return void console.error(
									"THREE.PropertyBinding: Trying to bind to objectIndex of objectName, but is undefined.",
									this,
									t
								);
							t = t[i];
						}
					}
					const o = t[i];
					if (void 0 === o) {
						const n = e.nodeName;
						return void console.error(
							"THREE.PropertyBinding: Trying to update property for track: " +
								n +
								"." +
								i +
								" but it wasn't found.",
							t
						);
					}
					let s = this.Versioning.None;
					(this.targetObject = t),
						void 0 !== t.needsUpdate
							? (s = this.Versioning.NeedsUpdate)
							: void 0 !== t.matrixWorldNeedsUpdate &&
							  (s = this.Versioning.MatrixWorldNeedsUpdate);
					let a = this.BindingType.Direct;
					if (void 0 !== r) {
						if ("morphTargetInfluences" === i) {
							if (!t.geometry)
								return void console.error(
									"THREE.PropertyBinding: Can not bind to morphTargetInfluences because node does not have a geometry.",
									this
								);
							if (!t.geometry.isBufferGeometry)
								return void console.error(
									"THREE.PropertyBinding: Can not bind to morphTargetInfluences on THREE.Geometry. Use THREE.BufferGeometry instead.",
									this
								);
							if (!t.geometry.morphAttributes)
								return void console.error(
									"THREE.PropertyBinding: Can not bind to morphTargetInfluences because node does not have a geometry.morphAttributes.",
									this
								);
							void 0 !== t.morphTargetDictionary[r] &&
								(r = t.morphTargetDictionary[r]);
						}
						(a = this.BindingType.ArrayElement),
							(this.resolvedProperty = o),
							(this.propertyIndex = r);
					} else
						void 0 !== o.fromArray && void 0 !== o.toArray
							? ((a = this.BindingType.HasFromToArray),
							  (this.resolvedProperty = o))
							: Array.isArray(o)
							? ((a = this.BindingType.EntireArray),
							  (this.resolvedProperty = o))
							: (this.propertyName = i);
					(this.getValue = this.GetterByBindingType[a]),
						(this.setValue = this.SetterByBindingTypeAndVersioning[a][s]);
				},
				unbind: function () {
					(this.node = null),
						(this.getValue = this._getValue_unbound),
						(this.setValue = this._setValue_unbound);
				},
			}),
			Object.assign(fy.prototype, {
				_getValue_unbound: fy.prototype.getValue,
				_setValue_unbound: fy.prototype.setValue,
			}),
			Object.assign(
				function () {
					(this.uuid = Jc.generateUUID()),
						(this._objects = Array.prototype.slice.call(arguments)),
						(this.nCachedObjects_ = 0);
					const t = {};
					this._indicesByUUID = t;
					for (let e = 0, n = arguments.length; e !== n; ++e)
						t[arguments[e].uuid] = e;
					(this._paths = []),
						(this._parsedPaths = []),
						(this._bindings = []),
						(this._bindingsIndicesByPath = {});
					const e = this;
					this.stats = {
						objects: {
							get total() {
								return e._objects.length;
							},
							get inUse() {
								return this.total - e.nCachedObjects_;
							},
						},
						get bindingsPerObject() {
							return e._bindings.length;
						},
					};
				}.prototype,
				{
					isAnimationObjectGroup: !0,
					add: function () {
						const t = this._objects,
							e = this._indicesByUUID,
							n = this._paths,
							i = this._parsedPaths,
							r = this._bindings,
							o = r.length;
						let s = void 0,
							a = t.length,
							c = this.nCachedObjects_;
						for (let l = 0, h = arguments.length; l !== h; ++l) {
							const h = arguments[l],
								u = h.uuid;
							let d = e[u];
							if (void 0 === d) {
								(d = a++), (e[u] = d), t.push(h);
								for (let t = 0, e = o; t !== e; ++t)
									r[t].push(new fy(h, n[t], i[t]));
							} else if (d < c) {
								s = t[d];
								const a = --c,
									l = t[a];
								(e[l.uuid] = d), (t[d] = l), (e[u] = a), (t[a] = h);
								for (let t = 0, e = o; t !== e; ++t) {
									const e = r[t],
										o = e[a];
									let s = e[d];
									(e[d] = o),
										void 0 === s && (s = new fy(h, n[t], i[t])),
										(e[a] = s);
								}
							} else
								t[d] !== s &&
									console.error(
										"THREE.AnimationObjectGroup: Different objects with the same UUID detected. Clean the caches or recreate your infrastructure when reloading scenes."
									);
						}
						this.nCachedObjects_ = c;
					},
					remove: function () {
						const t = this._objects,
							e = this._indicesByUUID,
							n = this._bindings,
							i = n.length;
						let r = this.nCachedObjects_;
						for (let o = 0, s = arguments.length; o !== s; ++o) {
							const s = arguments[o],
								a = s.uuid,
								c = e[a];
							if (void 0 !== c && c >= r) {
								const o = r++,
									l = t[o];
								(e[l.uuid] = c), (t[c] = l), (e[a] = o), (t[o] = s);
								for (let t = 0, e = i; t !== e; ++t) {
									const e = n[t],
										i = e[o],
										r = e[c];
									(e[c] = i), (e[o] = r);
								}
							}
						}
						this.nCachedObjects_ = r;
					},
					uncache: function () {
						const t = this._objects,
							e = this._indicesByUUID,
							n = this._bindings,
							i = n.length;
						let r = this.nCachedObjects_,
							o = t.length;
						for (let s = 0, a = arguments.length; s !== a; ++s) {
							const a = arguments[s].uuid,
								c = e[a];
							if (void 0 !== c)
								if ((delete e[a], c < r)) {
									const s = --r,
										a = t[s],
										l = --o,
										h = t[l];
									(e[a.uuid] = c),
										(t[c] = a),
										(e[h.uuid] = s),
										(t[s] = h),
										t.pop();
									for (let t = 0, e = i; t !== e; ++t) {
										const e = n[t],
											i = e[s],
											r = e[l];
										(e[c] = i), (e[s] = r), e.pop();
									}
								} else {
									const r = --o,
										s = t[r];
									(e[s.uuid] = c), (t[c] = s), t.pop();
									for (let t = 0, e = i; t !== e; ++t) {
										const e = n[t];
										(e[c] = e[r]), e.pop();
									}
								}
						}
						this.nCachedObjects_ = r;
					},
					subscribe_: function (t, e) {
						let n = this._bindingsIndicesByPath,
							i = n[t],
							r = this._bindings;
						if (void 0 !== i) return r[i];
						const o = this._paths,
							s = this._parsedPaths,
							a = this._objects,
							c = a.length,
							l = this.nCachedObjects_,
							h = new Array(c);
						(i = r.length), (n[t] = i), o.push(t), s.push(e), r.push(h);
						for (let n = l, i = a.length; n !== i; ++n) {
							const i = a[n];
							h[n] = new fy(i, t, e);
						}
						return h;
					},
					unsubscribe_: function (t) {
						const e = this._bindingsIndicesByPath,
							n = e[t];
						if (void 0 !== n) {
							const i = this._paths,
								r = this._parsedPaths,
								o = this._bindings,
								s = o.length - 1,
								a = o[s];
							(e[t[s]] = n),
								(o[n] = a),
								o.pop(),
								(r[n] = r[s]),
								r.pop(),
								(i[n] = i[s]),
								i.pop();
						}
					},
				}
			),
			Object.assign(my.prototype, {
				play: function () {
					return this._mixer._activateAction(this), this;
				},
				stop: function () {
					return this._mixer._deactivateAction(this), this.reset();
				},
				reset: function () {
					return (
						(this.paused = !1),
						(this.enabled = !0),
						(this.time = 0),
						(this._loopCount = -1),
						(this._startTime = null),
						this.stopFading().stopWarping()
					);
				},
				isRunning: function () {
					return (
						this.enabled &&
						!this.paused &&
						0 !== this.timeScale &&
						null === this._startTime &&
						this._mixer._isActiveAction(this)
					);
				},
				isScheduled: function () {
					return this._mixer._isActiveAction(this);
				},
				startAt: function (t) {
					return (this._startTime = t), this;
				},
				setLoop: function (t, e) {
					return (this.loop = t), (this.repetitions = e), this;
				},
				setEffectiveWeight: function (t) {
					return (
						(this.weight = t),
						(this._effectiveWeight = this.enabled ? t : 0),
						this.stopFading()
					);
				},
				getEffectiveWeight: function () {
					return this._effectiveWeight;
				},
				fadeIn: function (t) {
					return this._scheduleFading(t, 0, 1);
				},
				fadeOut: function (t) {
					return this._scheduleFading(t, 1, 0);
				},
				crossFadeFrom: function (t, e, n) {
					if ((t.fadeOut(e), this.fadeIn(e), n)) {
						const n = this._clip.duration,
							i = t._clip.duration,
							r = i / n,
							o = n / i;
						t.warp(1, r, e), this.warp(o, 1, e);
					}
					return this;
				},
				crossFadeTo: function (t, e, n) {
					return t.crossFadeFrom(this, e, n);
				},
				stopFading: function () {
					let t = this._weightInterpolant;
					return (
						null !== t &&
							((this._weightInterpolant = null),
							this._mixer._takeBackControlInterpolant(t)),
						this
					);
				},
				setEffectiveTimeScale: function (t) {
					return (
						(this.timeScale = t),
						(this._effectiveTimeScale = this.paused ? 0 : t),
						this.stopWarping()
					);
				},
				getEffectiveTimeScale: function () {
					return this._effectiveTimeScale;
				},
				setDuration: function (t) {
					return (this.timeScale = this._clip.duration / t), this.stopWarping();
				},
				syncWith: function (t) {
					return (
						(this.time = t.time),
						(this.timeScale = t.timeScale),
						this.stopWarping()
					);
				},
				halt: function (t) {
					return this.warp(this._effectiveTimeScale, 0, t);
				},
				warp: function (t, e, n) {
					const i = this._mixer,
						r = i.time,
						o = this.timeScale;
					let s = this._timeScaleInterpolant;
					null === s &&
						((s = i._lendControlInterpolant()),
						(this._timeScaleInterpolant = s));
					const a = s.parameterPositions,
						c = s.sampleValues;
					return (
						(a[0] = r), (a[1] = r + n), (c[0] = t / o), (c[1] = e / o), this
					);
				},
				stopWarping: function () {
					let t = this._timeScaleInterpolant;
					return (
						null !== t &&
							((this._timeScaleInterpolant = null),
							this._mixer._takeBackControlInterpolant(t)),
						this
					);
				},
				getMixer: function () {
					return this._mixer;
				},
				getClip: function () {
					return this._clip;
				},
				getRoot: function () {
					return this._localRoot || this._mixer._root;
				},
				_update: function (t, e, n, i) {
					if (!this.enabled) return void this._updateWeight(t);
					const r = this._startTime;
					if (null !== r) {
						const i = (t - r) * n;
						if (i < 0 || 0 === n) return;
						(this._startTime = null), (e = n * i);
					}
					e *= this._updateTimeScale(t);
					const o = this._updateTime(e),
						s = this._updateWeight(t);
					if (s > 0) {
						const t = this._interpolants,
							e = this._propertyBindings;
						switch (this.blendMode) {
							case 2501:
								for (let n = 0, i = t.length; n !== i; ++n)
									t[n].evaluate(o), e[n].accumulateAdditive(s);
								break;
							case Rc:
							default:
								for (let n = 0, r = t.length; n !== r; ++n)
									t[n].evaluate(o), e[n].accumulate(i, s);
						}
					}
				},
				_updateWeight: function (t) {
					let e = 0;
					if (this.enabled) {
						e = this.weight;
						const n = this._weightInterpolant;
						if (null !== n) {
							const i = n.evaluate(t)[0];
							(e *= i),
								t > n.parameterPositions[1] &&
									(this.stopFading(), 0 === i && (this.enabled = !1));
						}
					}
					return (this._effectiveWeight = e), e;
				},
				_updateTimeScale: function (t) {
					let e = 0;
					if (!this.paused) {
						e = this.timeScale;
						const n = this._timeScaleInterpolant;
						if (null !== n) {
							(e *= n.evaluate(t)[0]),
								t > n.parameterPositions[1] &&
									(this.stopWarping(),
									0 === e ? (this.paused = !0) : (this.timeScale = e));
						}
					}
					return (this._effectiveTimeScale = e), e;
				},
				_updateTime: function (t) {
					const e = this._clip.duration,
						n = this.loop;
					let i = this.time + t,
						r = this._loopCount;
					const o = 2202 === n;
					if (0 === t) return -1 === r ? i : o && 1 == (1 & r) ? e - i : i;
					if (2200 === n) {
						-1 === r && ((this._loopCount = 0), this._setEndings(!0, !0, !1));
						t: {
							if (i >= e) i = e;
							else {
								if (!(i < 0)) {
									this.time = i;
									break t;
								}
								i = 0;
							}
							this.clampWhenFinished ? (this.paused = !0) : (this.enabled = !1),
								(this.time = i),
								this._mixer.dispatchEvent({
									type: "finished",
									action: this,
									direction: t < 0 ? -1 : 1,
								});
						}
					} else {
						if (
							(-1 === r &&
								(t >= 0
									? ((r = 0), this._setEndings(!0, 0 === this.repetitions, o))
									: this._setEndings(0 === this.repetitions, !0, o)),
							i >= e || i < 0)
						) {
							const n = Math.floor(i / e);
							(i -= e * n), (r += Math.abs(n));
							const s = this.repetitions - r;
							if (s <= 0)
								this.clampWhenFinished
									? (this.paused = !0)
									: (this.enabled = !1),
									(i = t > 0 ? e : 0),
									(this.time = i),
									this._mixer.dispatchEvent({
										type: "finished",
										action: this,
										direction: t > 0 ? 1 : -1,
									});
							else {
								if (1 === s) {
									const e = t < 0;
									this._setEndings(e, !e, o);
								} else this._setEndings(!1, !1, o);
								(this._loopCount = r),
									(this.time = i),
									this._mixer.dispatchEvent({
										type: "loop",
										action: this,
										loopDelta: n,
									});
							}
						} else this.time = i;
						if (o && 1 == (1 & r)) return e - i;
					}
					return i;
				},
				_setEndings: function (t, e, n) {
					const i = this._interpolantSettings;
					n
						? ((i.endingStart = 2401), (i.endingEnd = 2401))
						: ((i.endingStart = t ? (this.zeroSlopeAtStart ? 2401 : Pc) : 2402),
						  (i.endingEnd = e ? (this.zeroSlopeAtEnd ? 2401 : Pc) : 2402));
				},
				_scheduleFading: function (t, e, n) {
					const i = this._mixer,
						r = i.time;
					let o = this._weightInterpolant;
					null === o &&
						((o = i._lendControlInterpolant()), (this._weightInterpolant = o));
					const s = o.parameterPositions,
						a = o.sampleValues;
					return (s[0] = r), (a[0] = e), (s[1] = r + t), (a[1] = n), this;
				},
			}),
			(gy.prototype = Object.assign(Object.create(Xc.prototype), {
				constructor: gy,
				_bindAction: function (t, e) {
					const n = t._localRoot || this._root,
						i = t._clip.tracks,
						r = i.length,
						o = t._propertyBindings,
						s = t._interpolants,
						a = n.uuid,
						c = this._bindingsByRootAndName;
					let l = c[a];
					void 0 === l && ((l = {}), (c[a] = l));
					for (let t = 0; t !== r; ++t) {
						const r = i[t],
							c = r.name;
						let h = l[c];
						if (void 0 !== h) o[t] = h;
						else {
							if (void 0 !== (h = o[t])) {
								null === h._cacheIndex &&
									(++h.referenceCount, this._addInactiveBinding(h, a, c));
								continue;
							}
							const i = e && e._propertyBindings[t].binding.parsedPath;
							++(h = new ry(
								fy.create(n, c, i),
								r.ValueTypeName,
								r.getValueSize()
							)).referenceCount,
								this._addInactiveBinding(h, a, c),
								(o[t] = h);
						}
						s[t].resultBuffer = h.buffer;
					}
				},
				_activateAction: function (t) {
					if (!this._isActiveAction(t)) {
						if (null === t._cacheIndex) {
							const e = (t._localRoot || this._root).uuid,
								n = t._clip.uuid,
								i = this._actionsByClip[n];
							this._bindAction(t, i && i.knownActions[0]),
								this._addInactiveAction(t, n, e);
						}
						const e = t._propertyBindings;
						for (let t = 0, n = e.length; t !== n; ++t) {
							const n = e[t];
							0 == n.useCount++ &&
								(this._lendBinding(n), n.saveOriginalState());
						}
						this._lendAction(t);
					}
				},
				_deactivateAction: function (t) {
					if (this._isActiveAction(t)) {
						const e = t._propertyBindings;
						for (let t = 0, n = e.length; t !== n; ++t) {
							const n = e[t];
							0 == --n.useCount &&
								(n.restoreOriginalState(), this._takeBackBinding(n));
						}
						this._takeBackAction(t);
					}
				},
				_initMemoryManager: function () {
					(this._actions = []),
						(this._nActiveActions = 0),
						(this._actionsByClip = {}),
						(this._bindings = []),
						(this._nActiveBindings = 0),
						(this._bindingsByRootAndName = {}),
						(this._controlInterpolants = []),
						(this._nActiveControlInterpolants = 0);
					const t = this;
					this.stats = {
						actions: {
							get total() {
								return t._actions.length;
							},
							get inUse() {
								return t._nActiveActions;
							},
						},
						bindings: {
							get total() {
								return t._bindings.length;
							},
							get inUse() {
								return t._nActiveBindings;
							},
						},
						controlInterpolants: {
							get total() {
								return t._controlInterpolants.length;
							},
							get inUse() {
								return t._nActiveControlInterpolants;
							},
						},
					};
				},
				_isActiveAction: function (t) {
					const e = t._cacheIndex;
					return null !== e && e < this._nActiveActions;
				},
				_addInactiveAction: function (t, e, n) {
					const i = this._actions,
						r = this._actionsByClip;
					let o = r[e];
					if (void 0 === o)
						(o = { knownActions: [t], actionByRoot: {} }),
							(t._byClipCacheIndex = 0),
							(r[e] = o);
					else {
						const e = o.knownActions;
						(t._byClipCacheIndex = e.length), e.push(t);
					}
					(t._cacheIndex = i.length), i.push(t), (o.actionByRoot[n] = t);
				},
				_removeInactiveAction: function (t) {
					const e = this._actions,
						n = e[e.length - 1],
						i = t._cacheIndex;
					(n._cacheIndex = i), (e[i] = n), e.pop(), (t._cacheIndex = null);
					const r = t._clip.uuid,
						o = this._actionsByClip,
						s = o[r],
						a = s.knownActions,
						c = a[a.length - 1],
						l = t._byClipCacheIndex;
					(c._byClipCacheIndex = l),
						(a[l] = c),
						a.pop(),
						(t._byClipCacheIndex = null),
						delete s.actionByRoot[(t._localRoot || this._root).uuid],
						0 === a.length && delete o[r],
						this._removeInactiveBindingsForAction(t);
				},
				_removeInactiveBindingsForAction: function (t) {
					const e = t._propertyBindings;
					for (let t = 0, n = e.length; t !== n; ++t) {
						const n = e[t];
						0 == --n.referenceCount && this._removeInactiveBinding(n);
					}
				},
				_lendAction: function (t) {
					const e = this._actions,
						n = t._cacheIndex,
						i = this._nActiveActions++,
						r = e[i];
					(t._cacheIndex = i), (e[i] = t), (r._cacheIndex = n), (e[n] = r);
				},
				_takeBackAction: function (t) {
					const e = this._actions,
						n = t._cacheIndex,
						i = --this._nActiveActions,
						r = e[i];
					(t._cacheIndex = i), (e[i] = t), (r._cacheIndex = n), (e[n] = r);
				},
				_addInactiveBinding: function (t, e, n) {
					const i = this._bindingsByRootAndName,
						r = this._bindings;
					let o = i[e];
					void 0 === o && ((o = {}), (i[e] = o)),
						(o[n] = t),
						(t._cacheIndex = r.length),
						r.push(t);
				},
				_removeInactiveBinding: function (t) {
					const e = this._bindings,
						n = t.binding,
						i = n.rootNode.uuid,
						r = n.path,
						o = this._bindingsByRootAndName,
						s = o[i],
						a = e[e.length - 1],
						c = t._cacheIndex;
					(a._cacheIndex = c),
						(e[c] = a),
						e.pop(),
						delete s[r],
						0 === Object.keys(s).length && delete o[i];
				},
				_lendBinding: function (t) {
					const e = this._bindings,
						n = t._cacheIndex,
						i = this._nActiveBindings++,
						r = e[i];
					(t._cacheIndex = i), (e[i] = t), (r._cacheIndex = n), (e[n] = r);
				},
				_takeBackBinding: function (t) {
					const e = this._bindings,
						n = t._cacheIndex,
						i = --this._nActiveBindings,
						r = e[i];
					(t._cacheIndex = i), (e[i] = t), (r._cacheIndex = n), (e[n] = r);
				},
				_lendControlInterpolant: function () {
					const t = this._controlInterpolants,
						e = this._nActiveControlInterpolants++;
					let n = t[e];
					return (
						void 0 === n &&
							(((n = new gg(
								new Float32Array(2),
								new Float32Array(2),
								1,
								this._controlInterpolantsResultBuffer
							)).__cacheIndex = e),
							(t[e] = n)),
						n
					);
				},
				_takeBackControlInterpolant: function (t) {
					const e = this._controlInterpolants,
						n = t.__cacheIndex,
						i = --this._nActiveControlInterpolants,
						r = e[i];
					(t.__cacheIndex = i), (e[i] = t), (r.__cacheIndex = n), (e[n] = r);
				},
				_controlInterpolantsResultBuffer: new Float32Array(1),
				clipAction: function (t, e, n) {
					const i = e || this._root,
						r = i.uuid;
					let o = "string" == typeof t ? Eg.findByName(i, t) : t;
					const s = null !== o ? o.uuid : t;
					let a = this._actionsByClip[s],
						c = null;
					if (
						(void 0 === n && (n = null !== o ? o.blendMode : Rc), void 0 !== a)
					) {
						const t = a.actionByRoot[r];
						if (void 0 !== t && t.blendMode === n) return t;
						(c = a.knownActions[0]), null === o && (o = c._clip);
					}
					if (null === o) return null;
					const l = new my(this, o, e, n);
					return this._bindAction(l, c), this._addInactiveAction(l, s, r), l;
				},
				existingAction: function (t, e) {
					const n = e || this._root,
						i = n.uuid,
						r = "string" == typeof t ? Eg.findByName(n, t) : t,
						o = r ? r.uuid : t,
						s = this._actionsByClip[o];
					return (void 0 !== s && s.actionByRoot[i]) || null;
				},
				stopAllAction: function () {
					const t = this._actions;
					for (let e = this._nActiveActions - 1; e >= 0; --e) t[e].stop();
					return this;
				},
				update: function (t) {
					t *= this.timeScale;
					const e = this._actions,
						n = this._nActiveActions,
						i = (this.time += t),
						r = Math.sign(t),
						o = (this._accuIndex ^= 1);
					for (let s = 0; s !== n; ++s) {
						e[s]._update(i, t, r, o);
					}
					const s = this._bindings,
						a = this._nActiveBindings;
					for (let t = 0; t !== a; ++t) s[t].apply(o);
					return this;
				},
				setTime: function (t) {
					this.time = 0;
					for (let t = 0; t < this._actions.length; t++)
						this._actions[t].time = 0;
					return this.update(t);
				},
				getRoot: function () {
					return this._root;
				},
				uncacheClip: function (t) {
					const e = this._actions,
						n = t.uuid,
						i = this._actionsByClip,
						r = i[n];
					if (void 0 !== r) {
						const t = r.knownActions;
						for (let n = 0, i = t.length; n !== i; ++n) {
							const i = t[n];
							this._deactivateAction(i);
							const r = i._cacheIndex,
								o = e[e.length - 1];
							(i._cacheIndex = null),
								(i._byClipCacheIndex = null),
								(o._cacheIndex = r),
								(e[r] = o),
								e.pop(),
								this._removeInactiveBindingsForAction(i);
						}
						delete i[n];
					}
				},
				uncacheRoot: function (t) {
					const e = t.uuid,
						n = this._actionsByClip;
					for (const t in n) {
						const i = n[t].actionByRoot[e];
						void 0 !== i &&
							(this._deactivateAction(i), this._removeInactiveAction(i));
					}
					const i = this._bindingsByRootAndName[e];
					if (void 0 !== i)
						for (const t in i) {
							const e = i[t];
							e.restoreOriginalState(), this._removeInactiveBinding(e);
						}
				},
				uncacheAction: function (t, e) {
					const n = this.existingAction(t, e);
					null !== n &&
						(this._deactivateAction(n), this._removeInactiveAction(n));
				},
			})),
			(vy.prototype.clone = function () {
				return new vy(
					void 0 === this.value.clone ? this.value : this.value.clone()
				);
			}),
			(yy.prototype = Object.assign(Object.create(zp.prototype), {
				constructor: yy,
				isInstancedInterleavedBuffer: !0,
				copy: function (t) {
					return (
						zp.prototype.copy.call(this, t),
						(this.meshPerAttribute = t.meshPerAttribute),
						this
					);
				},
				clone: function (t) {
					const e = zp.prototype.clone.call(this, t);
					return (e.meshPerAttribute = this.meshPerAttribute), e;
				},
				toJSON: function (t) {
					const e = zp.prototype.toJSON.call(this, t);
					return (
						(e.isInstancedInterleavedBuffer = !0),
						(e.meshPerAttribute = this.meshPerAttribute),
						e
					);
				},
			})),
			Object.assign(xy.prototype, {
				set: function (t, e) {
					this.ray.set(t, e);
				},
				setFromCamera: function (t, e) {
					e && e.isPerspectiveCamera
						? (this.ray.origin.setFromMatrixPosition(e.matrixWorld),
						  this.ray.direction
								.set(t.x, t.y, 0.5)
								.unproject(e)
								.sub(this.ray.origin)
								.normalize(),
						  (this.camera = e))
						: e && e.isOrthographicCamera
						? (this.ray.origin
								.set(t.x, t.y, (e.near + e.far) / (e.near - e.far))
								.unproject(e),
						  this.ray.direction
								.set(0, 0, -1)
								.transformDirection(e.matrixWorld),
						  (this.camera = e))
						: console.error("THREE.Raycaster: Unsupported camera type.");
				},
				intersectObject: function (t, e, n) {
					const i = n || [];
					return wy(t, this, i, e), i.sort(by), i;
				},
				intersectObjects: function (t, e, n) {
					const i = n || [];
					if (!1 === Array.isArray(t))
						return (
							console.warn(
								"THREE.Raycaster.intersectObjects: objects is not an Array."
							),
							i
						);
					for (let n = 0, r = t.length; n < r; n++) wy(t[n], this, i, e);
					return i.sort(by), i;
				},
			}),
			Object.assign(
				function (t, e, n) {
					return (
						(this.radius = void 0 !== t ? t : 1),
						(this.phi = void 0 !== e ? e : 0),
						(this.theta = void 0 !== n ? n : 0),
						this
					);
				}.prototype,
				{
					set: function (t, e, n) {
						return (this.radius = t), (this.phi = e), (this.theta = n), this;
					},
					clone: function () {
						return new this.constructor().copy(this);
					},
					copy: function (t) {
						return (
							(this.radius = t.radius),
							(this.phi = t.phi),
							(this.theta = t.theta),
							this
						);
					},
					makeSafe: function () {
						return (
							(this.phi = Math.max(1e-6, Math.min(Math.PI - 1e-6, this.phi))),
							this
						);
					},
					setFromVector3: function (t) {
						return this.setFromCartesianCoords(t.x, t.y, t.z);
					},
					setFromCartesianCoords: function (t, e, n) {
						return (
							(this.radius = Math.sqrt(t * t + e * e + n * n)),
							0 === this.radius
								? ((this.theta = 0), (this.phi = 0))
								: ((this.theta = Math.atan2(t, n)),
								  (this.phi = Math.acos(Jc.clamp(e / this.radius, -1, 1)))),
							this
						);
					},
				}
			),
			Object.assign(
				function (t, e, n) {
					return (
						(this.radius = void 0 !== t ? t : 1),
						(this.theta = void 0 !== e ? e : 0),
						(this.y = void 0 !== n ? n : 0),
						this
					);
				}.prototype,
				{
					set: function (t, e, n) {
						return (this.radius = t), (this.theta = e), (this.y = n), this;
					},
					clone: function () {
						return new this.constructor().copy(this);
					},
					copy: function (t) {
						return (
							(this.radius = t.radius),
							(this.theta = t.theta),
							(this.y = t.y),
							this
						);
					},
					setFromVector3: function (t) {
						return this.setFromCartesianCoords(t.x, t.y, t.z);
					},
					setFromCartesianCoords: function (t, e, n) {
						return (
							(this.radius = Math.sqrt(t * t + n * n)),
							(this.theta = Math.atan2(t, n)),
							(this.y = e),
							this
						);
					},
				}
			);
		const _y = new Kc();
		function My(t, e) {
			(this.min = void 0 !== t ? t : new Kc(1 / 0, 1 / 0)),
				(this.max = void 0 !== e ? e : new Kc(-1 / 0, -1 / 0));
		}
		Object.assign(My.prototype, {
			set: function (t, e) {
				return this.min.copy(t), this.max.copy(e), this;
			},
			setFromPoints: function (t) {
				this.makeEmpty();
				for (let e = 0, n = t.length; e < n; e++) this.expandByPoint(t[e]);
				return this;
			},
			setFromCenterAndSize: function (t, e) {
				const n = _y.copy(e).multiplyScalar(0.5);
				return this.min.copy(t).sub(n), this.max.copy(t).add(n), this;
			},
			clone: function () {
				return new this.constructor().copy(this);
			},
			copy: function (t) {
				return this.min.copy(t.min), this.max.copy(t.max), this;
			},
			makeEmpty: function () {
				return (
					(this.min.x = this.min.y = 1 / 0),
					(this.max.x = this.max.y = -1 / 0),
					this
				);
			},
			isEmpty: function () {
				return this.max.x < this.min.x || this.max.y < this.min.y;
			},
			getCenter: function (t) {
				return (
					void 0 === t &&
						(console.warn("THREE.Box2: .getCenter() target is now required"),
						(t = new Kc())),
					this.isEmpty()
						? t.set(0, 0)
						: t.addVectors(this.min, this.max).multiplyScalar(0.5)
				);
			},
			getSize: function (t) {
				return (
					void 0 === t &&
						(console.warn("THREE.Box2: .getSize() target is now required"),
						(t = new Kc())),
					this.isEmpty() ? t.set(0, 0) : t.subVectors(this.max, this.min)
				);
			},
			expandByPoint: function (t) {
				return this.min.min(t), this.max.max(t), this;
			},
			expandByVector: function (t) {
				return this.min.sub(t), this.max.add(t), this;
			},
			expandByScalar: function (t) {
				return this.min.addScalar(-t), this.max.addScalar(t), this;
			},
			containsPoint: function (t) {
				return !(
					t.x < this.min.x ||
					t.x > this.max.x ||
					t.y < this.min.y ||
					t.y > this.max.y
				);
			},
			containsBox: function (t) {
				return (
					this.min.x <= t.min.x &&
					t.max.x <= this.max.x &&
					this.min.y <= t.min.y &&
					t.max.y <= this.max.y
				);
			},
			getParameter: function (t, e) {
				return (
					void 0 === e &&
						(console.warn("THREE.Box2: .getParameter() target is now required"),
						(e = new Kc())),
					e.set(
						(t.x - this.min.x) / (this.max.x - this.min.x),
						(t.y - this.min.y) / (this.max.y - this.min.y)
					)
				);
			},
			intersectsBox: function (t) {
				return !(
					t.max.x < this.min.x ||
					t.min.x > this.max.x ||
					t.max.y < this.min.y ||
					t.min.y > this.max.y
				);
			},
			clampPoint: function (t, e) {
				return (
					void 0 === e &&
						(console.warn("THREE.Box2: .clampPoint() target is now required"),
						(e = new Kc())),
					e.copy(t).clamp(this.min, this.max)
				);
			},
			distanceToPoint: function (t) {
				return _y.copy(t).clamp(this.min, this.max).sub(t).length();
			},
			intersect: function (t) {
				return this.min.max(t.min), this.max.min(t.max), this;
			},
			union: function (t) {
				return this.min.min(t.min), this.max.max(t.max), this;
			},
			translate: function (t) {
				return this.min.add(t), this.max.add(t), this;
			},
			equals: function (t) {
				return t.min.equals(this.min) && t.max.equals(this.max);
			},
		});
		const Sy = new ll(),
			Ty = new ll();
		function Ey(t, e) {
			(this.start = void 0 !== t ? t : new ll()),
				(this.end = void 0 !== e ? e : new ll());
		}
		function Ay(t) {
			kl.call(this),
				(this.material = t),
				(this.render = function () {}),
				(this.hasPositions = !1),
				(this.hasNormals = !1),
				(this.hasColors = !1),
				(this.hasUvs = !1),
				(this.positionArray = null),
				(this.normalArray = null),
				(this.colorArray = null),
				(this.uvArray = null),
				(this.count = 0);
		}
		Object.assign(Ey.prototype, {
			set: function (t, e) {
				return this.start.copy(t), this.end.copy(e), this;
			},
			clone: function () {
				return new this.constructor().copy(this);
			},
			copy: function (t) {
				return this.start.copy(t.start), this.end.copy(t.end), this;
			},
			getCenter: function (t) {
				return (
					void 0 === t &&
						(console.warn("THREE.Line3: .getCenter() target is now required"),
						(t = new ll())),
					t.addVectors(this.start, this.end).multiplyScalar(0.5)
				);
			},
			delta: function (t) {
				return (
					void 0 === t &&
						(console.warn("THREE.Line3: .delta() target is now required"),
						(t = new ll())),
					t.subVectors(this.end, this.start)
				);
			},
			distanceSq: function () {
				return this.start.distanceToSquared(this.end);
			},
			distance: function () {
				return this.start.distanceTo(this.end);
			},
			at: function (t, e) {
				return (
					void 0 === e &&
						(console.warn("THREE.Line3: .at() target is now required"),
						(e = new ll())),
					this.delta(e).multiplyScalar(t).add(this.start)
				);
			},
			closestPointToPointParameter: function (t, e) {
				Sy.subVectors(t, this.start), Ty.subVectors(this.end, this.start);
				const n = Ty.dot(Ty);
				let i = Ty.dot(Sy) / n;
				return e && (i = Jc.clamp(i, 0, 1)), i;
			},
			closestPointToPoint: function (t, e, n) {
				const i = this.closestPointToPointParameter(t, e);
				return (
					void 0 === n &&
						(console.warn(
							"THREE.Line3: .closestPointToPoint() target is now required"
						),
						(n = new ll())),
					this.delta(n).multiplyScalar(i).add(this.start)
				);
			},
			applyMatrix4: function (t) {
				return this.start.applyMatrix4(t), this.end.applyMatrix4(t), this;
			},
			equals: function (t) {
				return t.start.equals(this.start) && t.end.equals(this.end);
			},
		}),
			(Ay.prototype = Object.create(kl.prototype)),
			(Ay.prototype.constructor = Ay),
			(Ay.prototype.isImmediateRenderObject = !0);
		const Ly = new ll();
		function Py(t, e) {
			kl.call(this),
				(this.light = t),
				this.light.updateMatrixWorld(),
				(this.matrix = t.matrixWorld),
				(this.matrixAutoUpdate = !1),
				(this.color = e);
			const n = new eu(),
				i = [
					0, 0, 0, 0, 0, 1, 0, 0, 0, 1, 0, 1, 0, 0, 0, -1, 0, 1, 0, 0, 0, 0, 1,
					1, 0, 0, 0, 0, -1, 1,
				];
			for (let t = 0, e = 1, n = 32; t < n; t++, e++) {
				const r = (t / n) * Math.PI * 2,
					o = (e / n) * Math.PI * 2;
				i.push(Math.cos(r), Math.sin(r), 1, Math.cos(o), Math.sin(o), 1);
			}
			n.setAttribute("position", new jh(i, 3));
			const r = new yf({ fog: !1, toneMapped: !1 });
			(this.cone = new Af(n, r)), this.add(this.cone), this.update();
		}
		(Py.prototype = Object.create(kl.prototype)),
			(Py.prototype.constructor = Py),
			(Py.prototype.dispose = function () {
				this.cone.geometry.dispose(), this.cone.material.dispose();
			}),
			(Py.prototype.update = function () {
				this.light.updateMatrixWorld();
				const t = this.light.distance ? this.light.distance : 1e3,
					e = t * Math.tan(this.light.angle);
				this.cone.scale.set(e, e, t),
					Ly.setFromMatrixPosition(this.light.target.matrixWorld),
					this.cone.lookAt(Ly),
					void 0 !== this.color
						? this.cone.material.color.set(this.color)
						: this.cone.material.color.copy(this.light.color);
			});
		const Ry = new ll(),
			Cy = new vl(),
			Oy = new vl();
		function Dy(t) {
			const e = (function t(e) {
					const n = [];
					e && e.isBone && n.push(e);
					for (let i = 0; i < e.children.length; i++)
						n.push.apply(n, t(e.children[i]));
					return n;
				})(t),
				n = new eu(),
				i = [],
				r = [],
				o = new Eh(0, 0, 1),
				s = new Eh(0, 1, 0);
			for (let t = 0; t < e.length; t++) {
				const n = e[t];
				n.parent &&
					n.parent.isBone &&
					(i.push(0, 0, 0),
					i.push(0, 0, 0),
					r.push(o.r, o.g, o.b),
					r.push(s.r, s.g, s.b));
			}
			n.setAttribute("position", new jh(i, 3)),
				n.setAttribute("color", new jh(r, 3));
			const a = new yf({
				vertexColors: !0,
				depthTest: !1,
				depthWrite: !1,
				toneMapped: !1,
				transparent: !0,
			});
			Af.call(this, n, a),
				(this.type = "SkeletonHelper"),
				(this.root = t),
				(this.bones = e),
				(this.matrix = t.matrixWorld),
				(this.matrixAutoUpdate = !1);
		}
		function Iy(t, e, n) {
			(this.light = t), this.light.updateMatrixWorld(), (this.color = n);
			const i = new Hm(e, 4, 2),
				r = new Dh({ wireframe: !0, fog: !1, toneMapped: !1 });
			xu.call(this, i, r),
				(this.type = "PointLightHelper"),
				(this.matrix = this.light.matrixWorld),
				(this.matrixAutoUpdate = !1),
				this.update();
		}
		(Dy.prototype = Object.create(Af.prototype)),
			(Dy.prototype.constructor = Dy),
			(Dy.prototype.isSkeletonHelper = !0),
			(Dy.prototype.updateMatrixWorld = function (t) {
				const e = this.bones,
					n = this.geometry,
					i = n.getAttribute("position");
				Oy.getInverse(this.root.matrixWorld);
				for (let t = 0, n = 0; t < e.length; t++) {
					const r = e[t];
					r.parent &&
						r.parent.isBone &&
						(Cy.multiplyMatrices(Oy, r.matrixWorld),
						Ry.setFromMatrixPosition(Cy),
						i.setXYZ(n, Ry.x, Ry.y, Ry.z),
						Cy.multiplyMatrices(Oy, r.parent.matrixWorld),
						Ry.setFromMatrixPosition(Cy),
						i.setXYZ(n + 1, Ry.x, Ry.y, Ry.z),
						(n += 2));
				}
				(n.getAttribute("position").needsUpdate = !0),
					kl.prototype.updateMatrixWorld.call(this, t);
			}),
			(Iy.prototype = Object.create(xu.prototype)),
			(Iy.prototype.constructor = Iy),
			(Iy.prototype.dispose = function () {
				this.geometry.dispose(), this.material.dispose();
			}),
			(Iy.prototype.update = function () {
				void 0 !== this.color
					? this.material.color.set(this.color)
					: this.material.color.copy(this.light.color);
			});
		const ky = new ll(),
			Ny = new Eh(),
			By = new Eh();
		function Fy(t, e, n) {
			kl.call(this),
				(this.light = t),
				this.light.updateMatrixWorld(),
				(this.matrix = t.matrixWorld),
				(this.matrixAutoUpdate = !1),
				(this.color = n);
			const i = new Xf(e);
			i.rotateY(0.5 * Math.PI),
				(this.material = new Dh({ wireframe: !0, fog: !1, toneMapped: !1 })),
				void 0 === this.color && (this.material.vertexColors = !0);
			const r = i.getAttribute("position"),
				o = new Float32Array(3 * r.count);
			i.setAttribute("color", new Nh(o, 3)),
				this.add(new xu(i, this.material)),
				this.update();
		}
		function zy(t, e, n, i) {
			(t = t || 10),
				(e = e || 10),
				(n = new Eh(void 0 !== n ? n : 4473924)),
				(i = new Eh(void 0 !== i ? i : 8947848));
			const r = e / 2,
				o = t / e,
				s = t / 2,
				a = [],
				c = [];
			for (let t = 0, l = 0, h = -s; t <= e; t++, h += o) {
				a.push(-s, 0, h, s, 0, h), a.push(h, 0, -s, h, 0, s);
				const e = t === r ? n : i;
				e.toArray(c, l),
					(l += 3),
					e.toArray(c, l),
					(l += 3),
					e.toArray(c, l),
					(l += 3),
					e.toArray(c, l),
					(l += 3);
			}
			const l = new eu();
			l.setAttribute("position", new jh(a, 3)),
				l.setAttribute("color", new jh(c, 3));
			const h = new yf({ vertexColors: !0, toneMapped: !1 });
			Af.call(this, l, h), (this.type = "GridHelper");
		}
		function Hy(t, e, n, i, r, o) {
			(t = t || 10),
				(e = e || 16),
				(n = n || 8),
				(i = i || 64),
				(r = new Eh(void 0 !== r ? r : 4473924)),
				(o = new Eh(void 0 !== o ? o : 8947848));
			const s = [],
				a = [];
			for (let n = 0; n <= e; n++) {
				const i = (n / e) * (2 * Math.PI),
					c = Math.sin(i) * t,
					l = Math.cos(i) * t;
				s.push(0, 0, 0), s.push(c, 0, l);
				const h = 1 & n ? r : o;
				a.push(h.r, h.g, h.b), a.push(h.r, h.g, h.b);
			}
			for (let e = 0; e <= n; e++) {
				const c = 1 & e ? r : o,
					l = t - (t / n) * e;
				for (let t = 0; t < i; t++) {
					let e = (t / i) * (2 * Math.PI),
						n = Math.sin(e) * l,
						r = Math.cos(e) * l;
					s.push(n, 0, r),
						a.push(c.r, c.g, c.b),
						(e = ((t + 1) / i) * (2 * Math.PI)),
						(n = Math.sin(e) * l),
						(r = Math.cos(e) * l),
						s.push(n, 0, r),
						a.push(c.r, c.g, c.b);
				}
			}
			const c = new eu();
			c.setAttribute("position", new jh(s, 3)),
				c.setAttribute("color", new jh(a, 3));
			const l = new yf({ vertexColors: !0, toneMapped: !1 });
			Af.call(this, c, l), (this.type = "PolarGridHelper");
		}
		(Fy.prototype = Object.create(kl.prototype)),
			(Fy.prototype.constructor = Fy),
			(Fy.prototype.dispose = function () {
				this.children[0].geometry.dispose(),
					this.children[0].material.dispose();
			}),
			(Fy.prototype.update = function () {
				const t = this.children[0];
				if (void 0 !== this.color) this.material.color.set(this.color);
				else {
					const e = t.geometry.getAttribute("color");
					Ny.copy(this.light.color), By.copy(this.light.groundColor);
					for (let t = 0, n = e.count; t < n; t++) {
						const i = t < n / 2 ? Ny : By;
						e.setXYZ(t, i.r, i.g, i.b);
					}
					e.needsUpdate = !0;
				}
				t.lookAt(ky.setFromMatrixPosition(this.light.matrixWorld).negate());
			}),
			(zy.prototype = Object.assign(Object.create(Af.prototype), {
				constructor: zy,
				copy: function (t) {
					return (
						Af.prototype.copy.call(this, t),
						this.geometry.copy(t.geometry),
						this.material.copy(t.material),
						this
					);
				},
				clone: function () {
					return new this.constructor().copy(this);
				},
			})),
			(Hy.prototype = Object.create(Af.prototype)),
			(Hy.prototype.constructor = Hy);
		const Uy = new ll(),
			Gy = new ll(),
			Vy = new ll();
		function jy(t, e, n) {
			kl.call(this),
				(this.light = t),
				this.light.updateMatrixWorld(),
				(this.matrix = t.matrixWorld),
				(this.matrixAutoUpdate = !1),
				(this.color = n),
				void 0 === e && (e = 1);
			let i = new eu();
			i.setAttribute(
				"position",
				new jh([-e, e, 0, e, e, 0, e, -e, 0, -e, -e, 0, -e, e, 0], 3)
			);
			const r = new yf({ fog: !1, toneMapped: !1 });
			(this.lightPlane = new Sf(i, r)),
				this.add(this.lightPlane),
				(i = new eu()).setAttribute("position", new jh([0, 0, 0, 0, 0, 1], 3)),
				(this.targetLine = new Sf(i, r)),
				this.add(this.targetLine),
				this.update();
		}
		(jy.prototype = Object.create(kl.prototype)),
			(jy.prototype.constructor = jy),
			(jy.prototype.dispose = function () {
				this.lightPlane.geometry.dispose(),
					this.lightPlane.material.dispose(),
					this.targetLine.geometry.dispose(),
					this.targetLine.material.dispose();
			}),
			(jy.prototype.update = function () {
				Uy.setFromMatrixPosition(this.light.matrixWorld),
					Gy.setFromMatrixPosition(this.light.target.matrixWorld),
					Vy.subVectors(Gy, Uy),
					this.lightPlane.lookAt(Gy),
					void 0 !== this.color
						? (this.lightPlane.material.color.set(this.color),
						  this.targetLine.material.color.set(this.color))
						: (this.lightPlane.material.color.copy(this.light.color),
						  this.targetLine.material.color.copy(this.light.color)),
					this.targetLine.lookAt(Gy),
					(this.targetLine.scale.z = Vy.length());
			});
		const Wy = new ll(),
			qy = new Iu();
		function Yy(t) {
			const e = new eu(),
				n = new yf({ color: 16777215, vertexColors: !0, toneMapped: !1 }),
				i = [],
				r = [],
				o = {},
				s = new Eh(16755200),
				a = new Eh(16711680),
				c = new Eh(43775),
				l = new Eh(16777215),
				h = new Eh(3355443);
			function u(t, e, n) {
				d(t, n), d(e, n);
			}
			function d(t, e) {
				i.push(0, 0, 0),
					r.push(e.r, e.g, e.b),
					void 0 === o[t] && (o[t] = []),
					o[t].push(i.length / 3 - 1);
			}
			u("n1", "n2", s),
				u("n2", "n4", s),
				u("n4", "n3", s),
				u("n3", "n1", s),
				u("f1", "f2", s),
				u("f2", "f4", s),
				u("f4", "f3", s),
				u("f3", "f1", s),
				u("n1", "f1", s),
				u("n2", "f2", s),
				u("n3", "f3", s),
				u("n4", "f4", s),
				u("p", "n1", a),
				u("p", "n2", a),
				u("p", "n3", a),
				u("p", "n4", a),
				u("u1", "u2", c),
				u("u2", "u3", c),
				u("u3", "u1", c),
				u("c", "t", l),
				u("p", "c", h),
				u("cn1", "cn2", h),
				u("cn3", "cn4", h),
				u("cf1", "cf2", h),
				u("cf3", "cf4", h),
				e.setAttribute("position", new jh(i, 3)),
				e.setAttribute("color", new jh(r, 3)),
				Af.call(this, e, n),
				(this.type = "CameraHelper"),
				(this.camera = t),
				this.camera.updateProjectionMatrix &&
					this.camera.updateProjectionMatrix(),
				(this.matrix = t.matrixWorld),
				(this.matrixAutoUpdate = !1),
				(this.pointMap = o),
				this.update();
		}
		function Xy(t, e, n, i, r, o, s) {
			Wy.set(r, o, s).unproject(i);
			const a = e[t];
			if (void 0 !== a) {
				const t = n.getAttribute("position");
				for (let e = 0, n = a.length; e < n; e++)
					t.setXYZ(a[e], Wy.x, Wy.y, Wy.z);
			}
		}
		(Yy.prototype = Object.create(Af.prototype)),
			(Yy.prototype.constructor = Yy),
			(Yy.prototype.update = function () {
				const t = this.geometry,
					e = this.pointMap;
				qy.projectionMatrixInverse.copy(this.camera.projectionMatrixInverse),
					Xy("c", e, t, qy, 0, 0, -1),
					Xy("t", e, t, qy, 0, 0, 1),
					Xy("n1", e, t, qy, -1, -1, -1),
					Xy("n2", e, t, qy, 1, -1, -1),
					Xy("n3", e, t, qy, -1, 1, -1),
					Xy("n4", e, t, qy, 1, 1, -1),
					Xy("f1", e, t, qy, -1, -1, 1),
					Xy("f2", e, t, qy, 1, -1, 1),
					Xy("f3", e, t, qy, -1, 1, 1),
					Xy("f4", e, t, qy, 1, 1, 1),
					Xy("u1", e, t, qy, 0.7, 1.1, -1),
					Xy("u2", e, t, qy, -0.7, 1.1, -1),
					Xy("u3", e, t, qy, 0, 2, -1),
					Xy("cf1", e, t, qy, -1, 0, 1),
					Xy("cf2", e, t, qy, 1, 0, 1),
					Xy("cf3", e, t, qy, 0, -1, 1),
					Xy("cf4", e, t, qy, 0, 1, 1),
					Xy("cn1", e, t, qy, -1, 0, -1),
					Xy("cn2", e, t, qy, 1, 0, -1),
					Xy("cn3", e, t, qy, 0, -1, -1),
					Xy("cn4", e, t, qy, 0, 1, -1),
					(t.getAttribute("position").needsUpdate = !0);
			});
		const Zy = new Jl();
		function Jy(t, e) {
			(this.object = t), void 0 === e && (e = 16776960);
			const n = new Uint16Array([
					0, 1, 1, 2, 2, 3, 3, 0, 4, 5, 5, 6, 6, 7, 7, 4, 0, 4, 1, 5, 2, 6, 3,
					7,
				]),
				i = new Float32Array(24),
				r = new eu();
			r.setIndex(new Nh(n, 1)),
				r.setAttribute("position", new Nh(i, 3)),
				Af.call(this, r, new yf({ color: e, toneMapped: !1 })),
				(this.type = "BoxHelper"),
				(this.matrixAutoUpdate = !1),
				this.update();
		}
		function Ky(t, e) {
			(this.type = "Box3Helper"), (this.box = t), (e = e || 16776960);
			const n = new Uint16Array([
					0, 1, 1, 2, 2, 3, 3, 0, 4, 5, 5, 6, 6, 7, 7, 4, 0, 4, 1, 5, 2, 6, 3,
					7,
				]),
				i = new eu();
			i.setIndex(new Nh(n, 1)),
				i.setAttribute(
					"position",
					new jh(
						[
							1, 1, 1, -1, 1, 1, -1, -1, 1, 1, -1, 1, 1, 1, -1, -1, 1, -1, -1,
							-1, -1, 1, -1, -1,
						],
						3
					)
				),
				Af.call(this, i, new yf({ color: e, toneMapped: !1 })),
				(this.type = "Box3Helper"),
				this.geometry.computeBoundingSphere();
		}
		function Qy(t, e, n) {
			(this.plane = t), (this.size = void 0 === e ? 1 : e);
			const i = void 0 !== n ? n : 16776960,
				r = new eu();
			r.setAttribute(
				"position",
				new jh(
					[
						1, -1, 1, -1, 1, 1, -1, -1, 1, 1, 1, 1, -1, 1, 1, -1, -1, 1, 1, -1,
						1, 1, 1, 1, 0, 0, 1, 0, 0, 0,
					],
					3
				)
			),
				r.computeBoundingSphere(),
				Sf.call(this, r, new yf({ color: i, toneMapped: !1 })),
				(this.type = "PlaneHelper");
			const o = new eu();
			o.setAttribute(
				"position",
				new jh([1, 1, 1, -1, 1, 1, -1, -1, 1, 1, 1, 1, -1, -1, 1, 1, -1, 1], 3)
			),
				o.computeBoundingSphere(),
				this.add(
					new xu(
						o,
						new Dh({
							color: i,
							opacity: 0.2,
							transparent: !0,
							depthWrite: !1,
							toneMapped: !1,
						})
					)
				);
		}
		(Jy.prototype = Object.create(Af.prototype)),
			(Jy.prototype.constructor = Jy),
			(Jy.prototype.update = function (t) {
				if (
					(void 0 !== t &&
						console.warn("THREE.BoxHelper: .update() has no longer arguments."),
					void 0 !== this.object && Zy.setFromObject(this.object),
					Zy.isEmpty())
				)
					return;
				const e = Zy.min,
					n = Zy.max,
					i = this.geometry.attributes.position,
					r = i.array;
				(r[0] = n.x),
					(r[1] = n.y),
					(r[2] = n.z),
					(r[3] = e.x),
					(r[4] = n.y),
					(r[5] = n.z),
					(r[6] = e.x),
					(r[7] = e.y),
					(r[8] = n.z),
					(r[9] = n.x),
					(r[10] = e.y),
					(r[11] = n.z),
					(r[12] = n.x),
					(r[13] = n.y),
					(r[14] = e.z),
					(r[15] = e.x),
					(r[16] = n.y),
					(r[17] = e.z),
					(r[18] = e.x),
					(r[19] = e.y),
					(r[20] = e.z),
					(r[21] = n.x),
					(r[22] = e.y),
					(r[23] = e.z),
					(i.needsUpdate = !0),
					this.geometry.computeBoundingSphere();
			}),
			(Jy.prototype.setFromObject = function (t) {
				return (this.object = t), this.update(), this;
			}),
			(Jy.prototype.copy = function (t) {
				return Af.prototype.copy.call(this, t), (this.object = t.object), this;
			}),
			(Jy.prototype.clone = function () {
				return new this.constructor().copy(this);
			}),
			(Ky.prototype = Object.create(Af.prototype)),
			(Ky.prototype.constructor = Ky),
			(Ky.prototype.updateMatrixWorld = function (t) {
				const e = this.box;
				e.isEmpty() ||
					(e.getCenter(this.position),
					e.getSize(this.scale),
					this.scale.multiplyScalar(0.5),
					kl.prototype.updateMatrixWorld.call(this, t));
			}),
			(Qy.prototype = Object.create(Sf.prototype)),
			(Qy.prototype.constructor = Qy),
			(Qy.prototype.updateMatrixWorld = function (t) {
				let e = -this.plane.constant;
				Math.abs(e) < 1e-8 && (e = 1e-8),
					this.scale.set(0.5 * this.size, 0.5 * this.size, e),
					(this.children[0].material.side = e < 0 ? fs : ps),
					this.lookAt(this.plane.normal),
					kl.prototype.updateMatrixWorld.call(this, t);
			});
		const $y = new ll();
		let tx, ex;
		function nx(t, e, n, i, r, o) {
			kl.call(this),
				(this.type = "ArrowHelper"),
				void 0 === t && (t = new ll(0, 0, 1)),
				void 0 === e && (e = new ll(0, 0, 0)),
				void 0 === n && (n = 1),
				void 0 === i && (i = 16776960),
				void 0 === r && (r = 0.2 * n),
				void 0 === o && (o = 0.2 * r),
				void 0 === tx &&
					((tx = new eu()).setAttribute(
						"position",
						new jh([0, 0, 0, 0, 1, 0], 3)
					),
					(ex = new Jm(0, 0.5, 1, 5, 1)).translate(0, -0.5, 0)),
				this.position.copy(e),
				(this.line = new Sf(tx, new yf({ color: i, toneMapped: !1 }))),
				(this.line.matrixAutoUpdate = !1),
				this.add(this.line),
				(this.cone = new xu(ex, new Dh({ color: i, toneMapped: !1 }))),
				(this.cone.matrixAutoUpdate = !1),
				this.add(this.cone),
				this.setDirection(t),
				this.setLength(n, r, o);
		}
		function ix(t) {
			const e = [
					0,
					0,
					0,
					(t = t || 1),
					0,
					0,
					0,
					0,
					0,
					0,
					t,
					0,
					0,
					0,
					0,
					0,
					0,
					t,
				],
				n = new eu();
			n.setAttribute("position", new jh(e, 3)),
				n.setAttribute(
					"color",
					new jh(
						[1, 0, 0, 1, 0.6, 0, 0, 1, 0, 0.6, 1, 0, 0, 0, 1, 0, 0.6, 1],
						3
					)
				);
			const i = new yf({ vertexColors: !0, toneMapped: !1 });
			Af.call(this, n, i), (this.type = "AxesHelper");
		}
		(nx.prototype = Object.create(kl.prototype)),
			(nx.prototype.constructor = nx),
			(nx.prototype.setDirection = function (t) {
				if (t.y > 0.99999) this.quaternion.set(0, 0, 0, 1);
				else if (t.y < -0.99999) this.quaternion.set(1, 0, 0, 0);
				else {
					$y.set(t.z, 0, -t.x).normalize();
					const e = Math.acos(t.y);
					this.quaternion.setFromAxisAngle($y, e);
				}
			}),
			(nx.prototype.setLength = function (t, e, n) {
				void 0 === e && (e = 0.2 * t),
					void 0 === n && (n = 0.2 * e),
					this.line.scale.set(1, Math.max(1e-4, t - e), 1),
					this.line.updateMatrix(),
					this.cone.scale.set(n, e, n),
					(this.cone.position.y = t),
					this.cone.updateMatrix();
			}),
			(nx.prototype.setColor = function (t) {
				this.line.material.color.set(t), this.cone.material.color.set(t);
			}),
			(nx.prototype.copy = function (t) {
				return (
					kl.prototype.copy.call(this, t, !1),
					this.line.copy(t.line),
					this.cone.copy(t.cone),
					this
				);
			}),
			(nx.prototype.clone = function () {
				return new this.constructor().copy(this);
			}),
			(ix.prototype = Object.create(Af.prototype)),
			(ix.prototype.constructor = ix);
		const rx = 4,
			ox = 8,
			sx = Math.pow(2, ox),
			ax = [0.125, 0.215, 0.35, 0.446, 0.526, 0.582],
			cx = ox - rx + 1 + ax.length,
			lx = 20,
			hx = { [Oc]: 0, [Dc]: 1, [kc]: 2, [Bc]: 3, [Fc]: 4, [zc]: 5, [Ic]: 6 },
			ux = new gv(),
			{
				_lodPlanes: dx,
				_sizeLods: px,
				_sigmas: fx,
			} = (function () {
				const t = [],
					e = [],
					n = [];
				let i = ox;
				for (let r = 0; r < cx; r++) {
					const o = Math.pow(2, i);
					e.push(o);
					let s = 1 / o;
					r > ox - rx ? (s = ax[r - ox + rx - 1]) : 0 == r && (s = 0),
						n.push(s);
					const a = 1 / (o - 1),
						c = -a / 2,
						l = 1 + a / 2,
						h = [c, c, l, c, l, l, c, c, l, l, c, l],
						u = 6,
						d = 6,
						p = 3,
						f = 2,
						m = 1,
						g = new Float32Array(p * d * u),
						v = new Float32Array(f * d * u),
						y = new Float32Array(m * d * u);
					for (let t = 0; t < u; t++) {
						const e = ((t % 3) * 2) / 3 - 1,
							n = t > 2 ? 0 : -1,
							i = [
								e,
								n,
								0,
								e + 2 / 3,
								n,
								0,
								e + 2 / 3,
								n + 1,
								0,
								e,
								n,
								0,
								e + 2 / 3,
								n + 1,
								0,
								e,
								n + 1,
								0,
							];
						g.set(i, p * d * t), v.set(h, f * d * t);
						const r = [t, t, t, t, t, t];
						y.set(r, m * d * t);
					}
					const x = new eu();
					x.setAttribute("position", new Nh(g, p)),
						x.setAttribute("uv", new Nh(v, f)),
						x.setAttribute("faceIndex", new Nh(y, m)),
						t.push(x),
						i > rx && i--;
				}
				return { _lodPlanes: t, _sizeLods: e, _sigmas: n };
			})();
		let mx = null;
		const gx = (1 + Math.sqrt(5)) / 2,
			vx = 1 / gx,
			yx = [
				new ll(1, 1, 1),
				new ll(-1, 1, 1),
				new ll(1, 1, -1),
				new ll(-1, 1, -1),
				new ll(0, gx, vx),
				new ll(0, gx, -vx),
				new ll(vx, 0, gx),
				new ll(-vx, 0, gx),
				new ll(gx, vx, 0),
				new ll(-gx, vx, 0),
			];
		function xx(t) {
			(this._renderer = t),
				(this._pingPongRenderTarget = null),
				(this._blurMaterial = (function (t) {
					const e = new Float32Array(t),
						n = new ll(0, 1, 0);
					return new ig({
						name: "SphericalGaussianBlur",
						defines: { n: t },
						uniforms: {
							envMap: { value: null },
							samples: { value: 1 },
							weights: { value: e },
							latitudinal: { value: !1 },
							dTheta: { value: 0 },
							mipInt: { value: 0 },
							poleAxis: { value: n },
							inputEncoding: { value: hx[Oc] },
							outputEncoding: { value: hx[Oc] },
						},
						vertexShader: Sx(),
						fragmentShader: `\nprecision mediump float;\nprecision mediump int;\nvarying vec3 vOutputDirection;\nuniform sampler2D envMap;\nuniform int samples;\nuniform float weights[n];\nuniform bool latitudinal;\nuniform float dTheta;\nuniform float mipInt;\nuniform vec3 poleAxis;\n\n${Tx()}\n\n#define ENVMAP_TYPE_CUBE_UV\n#include <cube_uv_reflection_fragment>\n\nvec3 getSample(float theta, vec3 axis) {\n\tfloat cosTheta = cos(theta);\n\t// Rodrigues' axis-angle rotation\n\tvec3 sampleDirection = vOutputDirection * cosTheta\n\t\t+ cross(axis, vOutputDirection) * sin(theta)\n\t\t+ axis * dot(axis, vOutputDirection) * (1.0 - cosTheta);\n\treturn bilinearCubeUV(envMap, sampleDirection, mipInt);\n}\n\nvoid main() {\n\tvec3 axis = latitudinal ? poleAxis : cross(poleAxis, vOutputDirection);\n\tif (all(equal(axis, vec3(0.0))))\n\t\taxis = vec3(vOutputDirection.z, 0.0, - vOutputDirection.x);\n\taxis = normalize(axis);\n\tgl_FragColor = vec4(0.0);\n\tgl_FragColor.rgb += weights[0] * getSample(0.0, axis);\n\tfor (int i = 1; i < n; i++) {\n\t\tif (i >= samples)\n\t\t\tbreak;\n\t\tfloat theta = dTheta * float(i);\n\t\tgl_FragColor.rgb += weights[i] * getSample(-1.0 * theta, axis);\n\t\tgl_FragColor.rgb += weights[i] * getSample(theta, axis);\n\t}\n\tgl_FragColor = linearToOutputTexel(gl_FragColor);\n}\n\t\t`,
						blending: gs,
						depthTest: !1,
						depthWrite: !1,
					});
				})(lx)),
				(this._equirectShader = null),
				(this._cubemapShader = null),
				this._compileMaterial(this._blurMaterial);
		}
		function bx(t) {
			const e = new rl(3 * sx, 3 * sx, t);
			return (
				(e.texture.mapping = oa),
				(e.texture.name = "PMREM.cubeUv"),
				(e.scissorTest = !0),
				e
			);
		}
		function wx(t, e, n, i, r) {
			t.viewport.set(e, n, i, r), t.scissor.set(e, n, i, r);
		}
		function _x() {
			return new ig({
				name: "EquirectangularToCubeUV",
				uniforms: {
					envMap: { value: null },
					texelSize: { value: new Kc(1, 1) },
					inputEncoding: { value: hx[Oc] },
					outputEncoding: { value: hx[Oc] },
				},
				vertexShader: Sx(),
				fragmentShader: `\nprecision mediump float;\nprecision mediump int;\nvarying vec3 vOutputDirection;\nuniform sampler2D envMap;\nuniform vec2 texelSize;\n\n${Tx()}\n\n#include <common>\n\nvoid main() {\n\tgl_FragColor = vec4(0.0);\n\tvec3 outputDirection = normalize(vOutputDirection);\n\tvec2 uv = equirectUv( outputDirection );\n\tvec2 f = fract(uv / texelSize - 0.5);\n\tuv -= f * texelSize;\n\tvec3 tl = envMapTexelToLinear(texture2D(envMap, uv)).rgb;\n\tuv.x += texelSize.x;\n\tvec3 tr = envMapTexelToLinear(texture2D(envMap, uv)).rgb;\n\tuv.y += texelSize.y;\n\tvec3 br = envMapTexelToLinear(texture2D(envMap, uv)).rgb;\n\tuv.x -= texelSize.x;\n\tvec3 bl = envMapTexelToLinear(texture2D(envMap, uv)).rgb;\n\tvec3 tm = mix(tl, tr, f.x);\n\tvec3 bm = mix(bl, br, f.x);\n\tgl_FragColor.rgb = mix(tm, bm, f.y);\n\tgl_FragColor = linearToOutputTexel(gl_FragColor);\n}\n\t\t`,
				blending: gs,
				depthTest: !1,
				depthWrite: !1,
			});
		}
		function Mx() {
			return new ig({
				name: "CubemapToCubeUV",
				uniforms: {
					envMap: { value: null },
					inputEncoding: { value: hx[Oc] },
					outputEncoding: { value: hx[Oc] },
				},
				vertexShader: Sx(),
				fragmentShader: `\nprecision mediump float;\nprecision mediump int;\nvarying vec3 vOutputDirection;\nuniform samplerCube envMap;\n\n${Tx()}\n\nvoid main() {\n\tgl_FragColor = vec4(0.0);\n\tgl_FragColor.rgb = envMapTexelToLinear(textureCube(envMap, vec3( - vOutputDirection.x, vOutputDirection.yz ))).rgb;\n\tgl_FragColor = linearToOutputTexel(gl_FragColor);\n}\n\t\t`,
				blending: gs,
				depthTest: !1,
				depthWrite: !1,
			});
		}
		function Sx() {
			return "\nprecision mediump float;\nprecision mediump int;\nattribute vec3 position;\nattribute vec2 uv;\nattribute float faceIndex;\nvarying vec3 vOutputDirection;\n\n// RH coordinate system; PMREM face-indexing convention\nvec3 getDirection(vec2 uv, float face) {\n\tuv = 2.0 * uv - 1.0;\n\tvec3 direction = vec3(uv, 1.0);\n\tif (face == 0.0) {\n\t\tdirection = direction.zyx; // ( 1, v, u ) pos x\n\t} else if (face == 1.0) {\n\t\tdirection = direction.xzy;\n\t\tdirection.xz *= -1.0; // ( -u, 1, -v ) pos y\n\t} else if (face == 2.0) {\n\t\tdirection.x *= -1.0; // ( -u, v, 1 ) pos z\n\t} else if (face == 3.0) {\n\t\tdirection = direction.zyx;\n\t\tdirection.xz *= -1.0; // ( -1, v, -u ) neg x\n\t} else if (face == 4.0) {\n\t\tdirection = direction.xzy;\n\t\tdirection.xy *= -1.0; // ( -u, -1, v ) neg y\n\t} else if (face == 5.0) {\n\t\tdirection.z *= -1.0; // ( u, v, -1 ) neg z\n\t}\n\treturn direction;\n}\n\nvoid main() {\n\tvOutputDirection = getDirection(uv, faceIndex);\n\tgl_Position = vec4( position, 1.0 );\n}\n\t";
		}
		function Tx() {
			return "\nuniform int inputEncoding;\nuniform int outputEncoding;\n\n#include <encodings_pars_fragment>\n\nvec4 inputTexelToLinear(vec4 value){\n\tif(inputEncoding == 0){\n\t\treturn value;\n\t}else if(inputEncoding == 1){\n\t\treturn sRGBToLinear(value);\n\t}else if(inputEncoding == 2){\n\t\treturn RGBEToLinear(value);\n\t}else if(inputEncoding == 3){\n\t\treturn RGBMToLinear(value, 7.0);\n\t}else if(inputEncoding == 4){\n\t\treturn RGBMToLinear(value, 16.0);\n\t}else if(inputEncoding == 5){\n\t\treturn RGBDToLinear(value, 256.0);\n\t}else{\n\t\treturn GammaToLinear(value, 2.2);\n\t}\n}\n\nvec4 linearToOutputTexel(vec4 value){\n\tif(outputEncoding == 0){\n\t\treturn value;\n\t}else if(outputEncoding == 1){\n\t\treturn LinearTosRGB(value);\n\t}else if(outputEncoding == 2){\n\t\treturn LinearToRGBE(value);\n\t}else if(outputEncoding == 3){\n\t\treturn LinearToRGBM(value, 7.0);\n\t}else if(outputEncoding == 4){\n\t\treturn LinearToRGBM(value, 16.0);\n\t}else if(outputEncoding == 5){\n\t\treturn LinearToRGBD(value, 256.0);\n\t}else{\n\t\treturn LinearToGamma(value, 2.2);\n\t}\n}\n\nvec4 envMapTexelToLinear(vec4 color) {\n\treturn inputTexelToLinear(color);\n}\n\t";
		}
		xx.prototype = {
			constructor: xx,
			fromScene: function (t, e = 0, n = 0.1, i = 100) {
				mx = this._renderer.getRenderTarget();
				const r = this._allocateTargets();
				return (
					this._sceneToCubeUV(t, n, i, r),
					e > 0 && this._blur(r, 0, 0, e),
					this._applyPMREM(r),
					this._cleanup(r),
					r
				);
			},
			fromEquirectangular: function (t) {
				return this._fromTexture(t);
			},
			fromCubemap: function (t) {
				return this._fromTexture(t);
			},
			compileCubemapShader: function () {
				null === this._cubemapShader &&
					((this._cubemapShader = Mx()),
					this._compileMaterial(this._cubemapShader));
			},
			compileEquirectangularShader: function () {
				null === this._equirectShader &&
					((this._equirectShader = _x()),
					this._compileMaterial(this._equirectShader));
			},
			dispose: function () {
				this._blurMaterial.dispose(),
					null !== this._cubemapShader && this._cubemapShader.dispose(),
					null !== this._equirectShader && this._equirectShader.dispose();
				for (let t = 0; t < dx.length; t++) dx[t].dispose();
			},
			_cleanup: function (t) {
				this._pingPongRenderTarget.dispose(),
					this._renderer.setRenderTarget(mx),
					(t.scissorTest = !1),
					wx(t, 0, 0, t.width, t.height);
			},
			_fromTexture: function (t) {
				mx = this._renderer.getRenderTarget();
				const e = this._allocateTargets(t);
				return (
					this._textureToCubeUV(t, e), this._applyPMREM(e), this._cleanup(e), e
				);
			},
			_allocateTargets: function (t) {
				const e = {
						magFilter: ha,
						minFilter: ha,
						generateMipmaps: !1,
						type: ga,
						format: Da,
						encoding: (function (t) {
							return (
								void 0 !== t &&
								t.type === ga &&
								(t.encoding === Oc || t.encoding === Dc || t.encoding === Ic)
							);
						})(t)
							? t.encoding
							: kc,
						depthBuffer: !1,
						stencilBuffer: !1,
					},
					n = bx(e);
				return (n.depthBuffer = !t), (this._pingPongRenderTarget = bx(e)), n;
			},
			_compileMaterial: function (t) {
				const e = new xu(dx[0], t);
				this._renderer.compile(e, ux);
			},
			_sceneToCubeUV: function (t, e, n, i) {
				const r = new ku(90, 1, e, n),
					o = [1, -1, 1, 1, 1, 1],
					s = [1, 1, 1, -1, -1, -1],
					a = this._renderer,
					c = a.outputEncoding,
					l = a.toneMapping,
					h = a.getClearColor(),
					u = a.getClearAlpha();
				(a.toneMapping = Zs), (a.outputEncoding = Oc);
				let d = t.background;
				if (d && d.isColor) {
					d.convertSRGBToLinear();
					const e = Math.max(d.r, d.g, d.b),
						n = Math.min(Math.max(Math.ceil(Math.log2(e)), -128), 127);
					d = d.multiplyScalar(Math.pow(2, -n));
					const i = (n + 128) / 255;
					a.setClearColor(d, i), (t.background = null);
				}
				for (let e = 0; e < 6; e++) {
					const n = e % 3;
					0 == n
						? (r.up.set(0, o[e], 0), r.lookAt(s[e], 0, 0))
						: 1 == n
						? (r.up.set(0, 0, o[e]), r.lookAt(0, s[e], 0))
						: (r.up.set(0, o[e], 0), r.lookAt(0, 0, s[e])),
						wx(i, n * sx, e > 2 ? sx : 0, sx, sx),
						a.setRenderTarget(i),
						a.render(t, r);
				}
				(a.toneMapping = l), (a.outputEncoding = c), a.setClearColor(h, u);
			},
			_textureToCubeUV: function (t, e) {
				const n = this._renderer;
				t.isCubeTexture
					? null == this._cubemapShader && (this._cubemapShader = Mx())
					: null == this._equirectShader && (this._equirectShader = _x());
				const i = t.isCubeTexture ? this._cubemapShader : this._equirectShader,
					r = new xu(dx[0], i),
					o = i.uniforms;
				(o.envMap.value = t),
					t.isCubeTexture ||
						o.texelSize.value.set(1 / t.image.width, 1 / t.image.height),
					(o.inputEncoding.value = hx[t.encoding]),
					(o.outputEncoding.value = hx[e.texture.encoding]),
					wx(e, 0, 0, 3 * sx, 2 * sx),
					n.setRenderTarget(e),
					n.render(r, ux);
			},
			_applyPMREM: function (t) {
				const e = this._renderer,
					n = e.autoClear;
				e.autoClear = !1;
				for (let e = 1; e < cx; e++) {
					const n = Math.sqrt(fx[e] * fx[e] - fx[e - 1] * fx[e - 1]),
						i = yx[(e - 1) % yx.length];
					this._blur(t, e - 1, e, n, i);
				}
				e.autoClear = n;
			},
			_blur: function (t, e, n, i, r) {
				const o = this._pingPongRenderTarget;
				this._halfBlur(t, o, e, n, i, "latitudinal", r),
					this._halfBlur(o, t, n, n, i, "longitudinal", r);
			},
			_halfBlur: function (t, e, n, i, r, o, s) {
				const a = this._renderer,
					c = this._blurMaterial;
				"latitudinal" !== o &&
					"longitudinal" !== o &&
					console.error(
						"blur direction must be either latitudinal or longitudinal!"
					);
				const l = new xu(dx[i], c),
					h = c.uniforms,
					u = px[n] - 1,
					d = isFinite(r) ? Math.PI / (2 * u) : (2 * Math.PI) / (2 * lx - 1),
					p = r / d,
					f = isFinite(r) ? 1 + Math.floor(3 * p) : lx;
				f > lx &&
					console.warn(
						`sigmaRadians, ${r}, is too large and will clip, as it requested ${f} samples when the maximum is set to ${lx}`
					);
				const m = [];
				let g = 0;
				for (let t = 0; t < lx; ++t) {
					const e = t / p,
						n = Math.exp((-e * e) / 2);
					m.push(n), 0 == t ? (g += n) : t < f && (g += 2 * n);
				}
				for (let t = 0; t < m.length; t++) m[t] = m[t] / g;
				(h.envMap.value = t.texture),
					(h.samples.value = f),
					(h.weights.value = m),
					(h.latitudinal.value = "latitudinal" === o),
					s && (h.poleAxis.value = s),
					(h.dTheta.value = d),
					(h.mipInt.value = ox - n),
					(h.inputEncoding.value = hx[t.texture.encoding]),
					(h.outputEncoding.value = hx[t.texture.encoding]);
				const v = px[i];
				wx(
					e,
					3 * Math.max(0, sx - 2 * v),
					(0 === i ? 0 : 2 * sx) + 2 * v * (i > ox - rx ? i - ox + rx : 0),
					3 * v,
					2 * v
				),
					a.setRenderTarget(e),
					a.render(l, ux);
			},
		};
		function Ex(t) {
			console.warn(
				"THREE.Spline has been removed. Use THREE.CatmullRomCurve3 instead."
			),
				Xg.call(this, t),
				(this.type = "catmullrom");
		}
		(Hg.create = function (t, e) {
			return (
				console.log("THREE.Curve.create() has been deprecated"),
				(t.prototype = Object.create(Hg.prototype)),
				(t.prototype.constructor = t),
				(t.prototype.getPoint = e),
				t
			);
		}),
			Object.assign(sv.prototype, {
				createPointsGeometry: function (t) {
					console.warn(
						"THREE.CurvePath: .createPointsGeometry() has been removed. Use new THREE.Geometry().setFromPoints( points ) instead."
					);
					const e = this.getPoints(t);
					return this.createGeometry(e);
				},
				createSpacedPointsGeometry: function (t) {
					console.warn(
						"THREE.CurvePath: .createSpacedPointsGeometry() has been removed. Use new THREE.Geometry().setFromPoints( points ) instead."
					);
					const e = this.getSpacedPoints(t);
					return this.createGeometry(e);
				},
				createGeometry: function (t) {
					console.warn(
						"THREE.CurvePath: .createGeometry() has been removed. Use new THREE.Geometry().setFromPoints( points ) instead."
					);
					const e = new Eu();
					for (let n = 0, i = t.length; n < i; n++) {
						const i = t[n];
						e.vertices.push(new ll(i.x, i.y, i.z || 0));
					}
					return e;
				},
			}),
			Object.assign(av.prototype, {
				fromPoints: function (t) {
					return (
						console.warn(
							"THREE.Path: .fromPoints() has been renamed to .setFromPoints()."
						),
						this.setFromPoints(t)
					);
				},
			}),
			Object.create(Xg.prototype),
			Object.create(Xg.prototype),
			(Ex.prototype = Object.create(Xg.prototype)),
			Object.assign(Ex.prototype, {
				initFromArray: function () {
					console.error("THREE.Spline: .initFromArray() has been removed.");
				},
				getControlPointsArray: function () {
					console.error(
						"THREE.Spline: .getControlPointsArray() has been removed."
					);
				},
				reparametrizeByArcLength: function () {
					console.error(
						"THREE.Spline: .reparametrizeByArcLength() has been removed."
					);
				},
			}),
			(zy.prototype.setColors = function () {
				console.error(
					"THREE.GridHelper: setColors() has been deprecated, pass them in the constructor instead."
				);
			}),
			(Dy.prototype.update = function () {
				console.error(
					"THREE.SkeletonHelper: update() no longer needs to be called."
				);
			}),
			Object.assign(Cg.prototype, {
				extractUrlBase: function (t) {
					return (
						console.warn(
							"THREE.Loader: .extractUrlBase() has been deprecated. Use THREE.LoaderUtils.extractUrlBase() instead."
						),
						Sv.extractUrlBase(t)
					);
				},
			}),
			(Cg.Handlers = {
				add: function () {
					console.error(
						"THREE.Loader: Handlers.add() has been removed. Use LoadingManager.addHandler() instead."
					);
				},
				get: function () {
					console.error(
						"THREE.Loader: Handlers.get() has been removed. Use LoadingManager.getHandler() instead."
					);
				},
			}),
			Object.assign(Pv.prototype, {
				setTexturePath: function (t) {
					return (
						console.warn(
							"THREE.ObjectLoader: .setTexturePath() has been renamed to .setResourcePath()."
						),
						this.setResourcePath(t)
					);
				},
			}),
			Object.assign(My.prototype, {
				center: function (t) {
					return (
						console.warn(
							"THREE.Box2: .center() has been renamed to .getCenter()."
						),
						this.getCenter(t)
					);
				},
				empty: function () {
					return (
						console.warn(
							"THREE.Box2: .empty() has been renamed to .isEmpty()."
						),
						this.isEmpty()
					);
				},
				isIntersectionBox: function (t) {
					return (
						console.warn(
							"THREE.Box2: .isIntersectionBox() has been renamed to .intersectsBox()."
						),
						this.intersectsBox(t)
					);
				},
				size: function (t) {
					return (
						console.warn("THREE.Box2: .size() has been renamed to .getSize()."),
						this.getSize(t)
					);
				},
			}),
			Object.assign(Jl.prototype, {
				center: function (t) {
					return (
						console.warn(
							"THREE.Box3: .center() has been renamed to .getCenter()."
						),
						this.getCenter(t)
					);
				},
				empty: function () {
					return (
						console.warn(
							"THREE.Box3: .empty() has been renamed to .isEmpty()."
						),
						this.isEmpty()
					);
				},
				isIntersectionBox: function (t) {
					return (
						console.warn(
							"THREE.Box3: .isIntersectionBox() has been renamed to .intersectsBox()."
						),
						this.intersectsBox(t)
					);
				},
				isIntersectionSphere: function (t) {
					return (
						console.warn(
							"THREE.Box3: .isIntersectionSphere() has been renamed to .intersectsSphere()."
						),
						this.intersectsSphere(t)
					);
				},
				size: function (t) {
					return (
						console.warn("THREE.Box3: .size() has been renamed to .getSize()."),
						this.getSize(t)
					);
				},
			}),
			Object.assign($l.prototype, {
				empty: function () {
					return (
						console.warn(
							"THREE.Sphere: .empty() has been renamed to .isEmpty()."
						),
						this.isEmpty()
					);
				},
			}),
			(Vu.prototype.setFromMatrix = function (t) {
				return (
					console.warn(
						"THREE.Frustum: .setFromMatrix() has been renamed to .setFromProjectionMatrix()."
					),
					this.setFromProjectionMatrix(t)
				);
			}),
			(Ey.prototype.center = function (t) {
				return (
					console.warn(
						"THREE.Line3: .center() has been renamed to .getCenter()."
					),
					this.getCenter(t)
				);
			}),
			Object.assign(Jc, {
				random16: function () {
					return (
						console.warn(
							"THREE.Math: .random16() has been deprecated. Use Math.random() instead."
						),
						Math.random()
					);
				},
				nearestPowerOfTwo: function (t) {
					return (
						console.warn(
							"THREE.Math: .nearestPowerOfTwo() has been renamed to .floorPowerOfTwo()."
						),
						Jc.floorPowerOfTwo(t)
					);
				},
				nextPowerOfTwo: function (t) {
					return (
						console.warn(
							"THREE.Math: .nextPowerOfTwo() has been renamed to .ceilPowerOfTwo()."
						),
						Jc.ceilPowerOfTwo(t)
					);
				},
			}),
			Object.assign(Qc.prototype, {
				flattenToArrayOffset: function (t, e) {
					return (
						console.warn(
							"THREE.Matrix3: .flattenToArrayOffset() has been deprecated. Use .toArray() instead."
						),
						this.toArray(t, e)
					);
				},
				multiplyVector3: function (t) {
					return (
						console.warn(
							"THREE.Matrix3: .multiplyVector3() has been removed. Use vector.applyMatrix3( matrix ) instead."
						),
						t.applyMatrix3(this)
					);
				},
				multiplyVector3Array: function () {
					console.error(
						"THREE.Matrix3: .multiplyVector3Array() has been removed."
					);
				},
				applyToBufferAttribute: function (t) {
					return (
						console.warn(
							"THREE.Matrix3: .applyToBufferAttribute() has been removed. Use attribute.applyMatrix3( matrix ) instead."
						),
						t.applyMatrix3(this)
					);
				},
				applyToVector3Array: function () {
					console.error(
						"THREE.Matrix3: .applyToVector3Array() has been removed."
					);
				},
			}),
			Object.assign(vl.prototype, {
				extractPosition: function (t) {
					return (
						console.warn(
							"THREE.Matrix4: .extractPosition() has been renamed to .copyPosition()."
						),
						this.copyPosition(t)
					);
				},
				flattenToArrayOffset: function (t, e) {
					return (
						console.warn(
							"THREE.Matrix4: .flattenToArrayOffset() has been deprecated. Use .toArray() instead."
						),
						this.toArray(t, e)
					);
				},
				getPosition: function () {
					return (
						console.warn(
							"THREE.Matrix4: .getPosition() has been removed. Use Vector3.setFromMatrixPosition( matrix ) instead."
						),
						new ll().setFromMatrixColumn(this, 3)
					);
				},
				setRotationFromQuaternion: function (t) {
					return (
						console.warn(
							"THREE.Matrix4: .setRotationFromQuaternion() has been renamed to .makeRotationFromQuaternion()."
						),
						this.makeRotationFromQuaternion(t)
					);
				},
				multiplyToArray: function () {
					console.warn("THREE.Matrix4: .multiplyToArray() has been removed.");
				},
				multiplyVector3: function (t) {
					return (
						console.warn(
							"THREE.Matrix4: .multiplyVector3() has been removed. Use vector.applyMatrix4( matrix ) instead."
						),
						t.applyMatrix4(this)
					);
				},
				multiplyVector4: function (t) {
					return (
						console.warn(
							"THREE.Matrix4: .multiplyVector4() has been removed. Use vector.applyMatrix4( matrix ) instead."
						),
						t.applyMatrix4(this)
					);
				},
				multiplyVector3Array: function () {
					console.error(
						"THREE.Matrix4: .multiplyVector3Array() has been removed."
					);
				},
				rotateAxis: function (t) {
					console.warn(
						"THREE.Matrix4: .rotateAxis() has been removed. Use Vector3.transformDirection( matrix ) instead."
					),
						t.transformDirection(this);
				},
				crossVector: function (t) {
					return (
						console.warn(
							"THREE.Matrix4: .crossVector() has been removed. Use vector.applyMatrix4( matrix ) instead."
						),
						t.applyMatrix4(this)
					);
				},
				translate: function () {
					console.error("THREE.Matrix4: .translate() has been removed.");
				},
				rotateX: function () {
					console.error("THREE.Matrix4: .rotateX() has been removed.");
				},
				rotateY: function () {
					console.error("THREE.Matrix4: .rotateY() has been removed.");
				},
				rotateZ: function () {
					console.error("THREE.Matrix4: .rotateZ() has been removed.");
				},
				rotateByAxis: function () {
					console.error("THREE.Matrix4: .rotateByAxis() has been removed.");
				},
				applyToBufferAttribute: function (t) {
					return (
						console.warn(
							"THREE.Matrix4: .applyToBufferAttribute() has been removed. Use attribute.applyMatrix4( matrix ) instead."
						),
						t.applyMatrix4(this)
					);
				},
				applyToVector3Array: function () {
					console.error(
						"THREE.Matrix4: .applyToVector3Array() has been removed."
					);
				},
				makeFrustum: function (t, e, n, i, r, o) {
					return (
						console.warn(
							"THREE.Matrix4: .makeFrustum() has been removed. Use .makePerspective( left, right, top, bottom, near, far ) instead."
						),
						this.makePerspective(t, e, i, n, r, o)
					);
				},
			}),
			(uh.prototype.isIntersectionLine = function (t) {
				return (
					console.warn(
						"THREE.Plane: .isIntersectionLine() has been renamed to .intersectsLine()."
					),
					this.intersectsLine(t)
				);
			}),
			(sl.prototype.multiplyVector3 = function (t) {
				return (
					console.warn(
						"THREE.Quaternion: .multiplyVector3() has been removed. Use is now vector.applyQuaternion( quaternion ) instead."
					),
					t.applyQuaternion(this)
				);
			}),
			Object.assign(ah.prototype, {
				isIntersectionBox: function (t) {
					return (
						console.warn(
							"THREE.Ray: .isIntersectionBox() has been renamed to .intersectsBox()."
						),
						this.intersectsBox(t)
					);
				},
				isIntersectionPlane: function (t) {
					return (
						console.warn(
							"THREE.Ray: .isIntersectionPlane() has been renamed to .intersectsPlane()."
						),
						this.intersectsPlane(t)
					);
				},
				isIntersectionSphere: function (t) {
					return (
						console.warn(
							"THREE.Ray: .isIntersectionSphere() has been renamed to .intersectsSphere()."
						),
						this.intersectsSphere(t)
					);
				},
			}),
			Object.assign(_h.prototype, {
				area: function () {
					return (
						console.warn(
							"THREE.Triangle: .area() has been renamed to .getArea()."
						),
						this.getArea()
					);
				},
				barycoordFromPoint: function (t, e) {
					return (
						console.warn(
							"THREE.Triangle: .barycoordFromPoint() has been renamed to .getBarycoord()."
						),
						this.getBarycoord(t, e)
					);
				},
				midpoint: function (t) {
					return (
						console.warn(
							"THREE.Triangle: .midpoint() has been renamed to .getMidpoint()."
						),
						this.getMidpoint(t)
					);
				},
				normal: function (t) {
					return (
						console.warn(
							"THREE.Triangle: .normal() has been renamed to .getNormal()."
						),
						this.getNormal(t)
					);
				},
				plane: function (t) {
					return (
						console.warn(
							"THREE.Triangle: .plane() has been renamed to .getPlane()."
						),
						this.getPlane(t)
					);
				},
			}),
			Object.assign(_h, {
				barycoordFromPoint: function (t, e, n, i, r) {
					return (
						console.warn(
							"THREE.Triangle: .barycoordFromPoint() has been renamed to .getBarycoord()."
						),
						_h.getBarycoord(t, e, n, i, r)
					);
				},
				normal: function (t, e, n, i) {
					return (
						console.warn(
							"THREE.Triangle: .normal() has been renamed to .getNormal()."
						),
						_h.getNormal(t, e, n, i)
					);
				},
			}),
			Object.assign(cv.prototype, {
				extractAllPoints: function (t) {
					return (
						console.warn(
							"THREE.Shape: .extractAllPoints() has been removed. Use .extractPoints() instead."
						),
						this.extractPoints(t)
					);
				},
				extrude: function (t) {
					return (
						console.warn(
							"THREE.Shape: .extrude() has been removed. Use ExtrudeGeometry() instead."
						),
						new Dm(this, t)
					);
				},
				makeGeometry: function (t) {
					return (
						console.warn(
							"THREE.Shape: .makeGeometry() has been removed. Use ShapeGeometry() instead."
						),
						new Wm(this, t)
					);
				},
			}),
			Object.assign(Kc.prototype, {
				fromAttribute: function (t, e, n) {
					return (
						console.warn(
							"THREE.Vector2: .fromAttribute() has been renamed to .fromBufferAttribute()."
						),
						this.fromBufferAttribute(t, e, n)
					);
				},
				distanceToManhattan: function (t) {
					return (
						console.warn(
							"THREE.Vector2: .distanceToManhattan() has been renamed to .manhattanDistanceTo()."
						),
						this.manhattanDistanceTo(t)
					);
				},
				lengthManhattan: function () {
					return (
						console.warn(
							"THREE.Vector2: .lengthManhattan() has been renamed to .manhattanLength()."
						),
						this.manhattanLength()
					);
				},
			}),
			Object.assign(ll.prototype, {
				setEulerFromRotationMatrix: function () {
					console.error(
						"THREE.Vector3: .setEulerFromRotationMatrix() has been removed. Use Euler.setFromRotationMatrix() instead."
					);
				},
				setEulerFromQuaternion: function () {
					console.error(
						"THREE.Vector3: .setEulerFromQuaternion() has been removed. Use Euler.setFromQuaternion() instead."
					);
				},
				getPositionFromMatrix: function (t) {
					return (
						console.warn(
							"THREE.Vector3: .getPositionFromMatrix() has been renamed to .setFromMatrixPosition()."
						),
						this.setFromMatrixPosition(t)
					);
				},
				getScaleFromMatrix: function (t) {
					return (
						console.warn(
							"THREE.Vector3: .getScaleFromMatrix() has been renamed to .setFromMatrixScale()."
						),
						this.setFromMatrixScale(t)
					);
				},
				getColumnFromMatrix: function (t, e) {
					return (
						console.warn(
							"THREE.Vector3: .getColumnFromMatrix() has been renamed to .setFromMatrixColumn()."
						),
						this.setFromMatrixColumn(e, t)
					);
				},
				applyProjection: function (t) {
					return (
						console.warn(
							"THREE.Vector3: .applyProjection() has been removed. Use .applyMatrix4( m ) instead."
						),
						this.applyMatrix4(t)
					);
				},
				fromAttribute: function (t, e, n) {
					return (
						console.warn(
							"THREE.Vector3: .fromAttribute() has been renamed to .fromBufferAttribute()."
						),
						this.fromBufferAttribute(t, e, n)
					);
				},
				distanceToManhattan: function (t) {
					return (
						console.warn(
							"THREE.Vector3: .distanceToManhattan() has been renamed to .manhattanDistanceTo()."
						),
						this.manhattanDistanceTo(t)
					);
				},
				lengthManhattan: function () {
					return (
						console.warn(
							"THREE.Vector3: .lengthManhattan() has been renamed to .manhattanLength()."
						),
						this.manhattanLength()
					);
				},
			}),
			Object.assign(il.prototype, {
				fromAttribute: function (t, e, n) {
					return (
						console.warn(
							"THREE.Vector4: .fromAttribute() has been renamed to .fromBufferAttribute()."
						),
						this.fromBufferAttribute(t, e, n)
					);
				},
				lengthManhattan: function () {
					return (
						console.warn(
							"THREE.Vector4: .lengthManhattan() has been renamed to .manhattanLength()."
						),
						this.manhattanLength()
					);
				},
			}),
			Object.assign(Eu.prototype, {
				computeTangents: function () {
					console.error("THREE.Geometry: .computeTangents() has been removed.");
				},
				computeLineDistances: function () {
					console.error(
						"THREE.Geometry: .computeLineDistances() has been removed. Use THREE.Line.computeLineDistances() instead."
					);
				},
				applyMatrix: function (t) {
					return (
						console.warn(
							"THREE.Geometry: .applyMatrix() has been renamed to .applyMatrix4()."
						),
						this.applyMatrix4(t)
					);
				},
			}),
			Object.assign(kl.prototype, {
				getChildByName: function (t) {
					return (
						console.warn(
							"THREE.Object3D: .getChildByName() has been renamed to .getObjectByName()."
						),
						this.getObjectByName(t)
					);
				},
				renderDepth: function () {
					console.warn(
						"THREE.Object3D: .renderDepth has been removed. Use .renderOrder, instead."
					);
				},
				translate: function (t, e) {
					return (
						console.warn(
							"THREE.Object3D: .translate() has been removed. Use .translateOnAxis( axis, distance ) instead."
						),
						this.translateOnAxis(e, t)
					);
				},
				getWorldRotation: function () {
					console.error(
						"THREE.Object3D: .getWorldRotation() has been removed. Use THREE.Object3D.getWorldQuaternion( target ) instead."
					);
				},
				applyMatrix: function (t) {
					return (
						console.warn(
							"THREE.Object3D: .applyMatrix() has been renamed to .applyMatrix4()."
						),
						this.applyMatrix4(t)
					);
				},
			}),
			Object.defineProperties(kl.prototype, {
				eulerOrder: {
					get: function () {
						return (
							console.warn(
								"THREE.Object3D: .eulerOrder is now .rotation.order."
							),
							this.rotation.order
						);
					},
					set: function (t) {
						console.warn("THREE.Object3D: .eulerOrder is now .rotation.order."),
							(this.rotation.order = t);
					},
				},
				useQuaternion: {
					get: function () {
						console.warn(
							"THREE.Object3D: .useQuaternion has been removed. The library now uses quaternions by default."
						);
					},
					set: function () {
						console.warn(
							"THREE.Object3D: .useQuaternion has been removed. The library now uses quaternions by default."
						);
					},
				},
			}),
			Object.assign(xu.prototype, {
				setDrawMode: function () {
					console.error(
						"THREE.Mesh: .setDrawMode() has been removed. The renderer now always assumes THREE.TrianglesDrawMode. Transform your geometry via BufferGeometryUtils.toTrianglesDrawMode() if necessary."
					);
				},
			}),
			Object.defineProperties(xu.prototype, {
				drawMode: {
					get: function () {
						return (
							console.error(
								"THREE.Mesh: .drawMode has been removed. The renderer now always assumes THREE.TrianglesDrawMode."
							),
							0
						);
					},
					set: function () {
						console.error(
							"THREE.Mesh: .drawMode has been removed. The renderer now always assumes THREE.TrianglesDrawMode. Transform your geometry via BufferGeometryUtils.toTrianglesDrawMode() if necessary."
						);
					},
				},
			}),
			Object.defineProperties(af.prototype, {
				objects: {
					get: function () {
						return (
							console.warn("THREE.LOD: .objects has been renamed to .levels."),
							this.levels
						);
					},
				},
			}),
			Object.defineProperty(uf.prototype, "useVertexTexture", {
				get: function () {
					console.warn("THREE.Skeleton: useVertexTexture has been removed.");
				},
				set: function () {
					console.warn("THREE.Skeleton: useVertexTexture has been removed.");
				},
			}),
			(cf.prototype.initBones = function () {
				console.error("THREE.SkinnedMesh: initBones() has been removed.");
			}),
			Object.defineProperty(Hg.prototype, "__arcLengthDivisions", {
				get: function () {
					return (
						console.warn(
							"THREE.Curve: .__arcLengthDivisions is now .arcLengthDivisions."
						),
						this.arcLengthDivisions
					);
				},
				set: function (t) {
					console.warn(
						"THREE.Curve: .__arcLengthDivisions is now .arcLengthDivisions."
					),
						(this.arcLengthDivisions = t);
				},
			}),
			(ku.prototype.setLens = function (t, e) {
				console.warn(
					"THREE.PerspectiveCamera.setLens is deprecated. Use .setFocalLength and .filmGauge for a photographic setup."
				),
					void 0 !== e && (this.filmGauge = e),
					this.setFocalLength(t);
			}),
			Object.defineProperties(lv.prototype, {
				onlyShadow: {
					set: function () {
						console.warn("THREE.Light: .onlyShadow has been removed.");
					},
				},
				shadowCameraFov: {
					set: function (t) {
						console.warn(
							"THREE.Light: .shadowCameraFov is now .shadow.camera.fov."
						),
							(this.shadow.camera.fov = t);
					},
				},
				shadowCameraLeft: {
					set: function (t) {
						console.warn(
							"THREE.Light: .shadowCameraLeft is now .shadow.camera.left."
						),
							(this.shadow.camera.left = t);
					},
				},
				shadowCameraRight: {
					set: function (t) {
						console.warn(
							"THREE.Light: .shadowCameraRight is now .shadow.camera.right."
						),
							(this.shadow.camera.right = t);
					},
				},
				shadowCameraTop: {
					set: function (t) {
						console.warn(
							"THREE.Light: .shadowCameraTop is now .shadow.camera.top."
						),
							(this.shadow.camera.top = t);
					},
				},
				shadowCameraBottom: {
					set: function (t) {
						console.warn(
							"THREE.Light: .shadowCameraBottom is now .shadow.camera.bottom."
						),
							(this.shadow.camera.bottom = t);
					},
				},
				shadowCameraNear: {
					set: function (t) {
						console.warn(
							"THREE.Light: .shadowCameraNear is now .shadow.camera.near."
						),
							(this.shadow.camera.near = t);
					},
				},
				shadowCameraFar: {
					set: function (t) {
						console.warn(
							"THREE.Light: .shadowCameraFar is now .shadow.camera.far."
						),
							(this.shadow.camera.far = t);
					},
				},
				shadowCameraVisible: {
					set: function () {
						console.warn(
							"THREE.Light: .shadowCameraVisible has been removed. Use new THREE.CameraHelper( light.shadow.camera ) instead."
						);
					},
				},
				shadowBias: {
					set: function (t) {
						console.warn("THREE.Light: .shadowBias is now .shadow.bias."),
							(this.shadow.bias = t);
					},
				},
				shadowDarkness: {
					set: function () {
						console.warn("THREE.Light: .shadowDarkness has been removed.");
					},
				},
				shadowMapWidth: {
					set: function (t) {
						console.warn(
							"THREE.Light: .shadowMapWidth is now .shadow.mapSize.width."
						),
							(this.shadow.mapSize.width = t);
					},
				},
				shadowMapHeight: {
					set: function (t) {
						console.warn(
							"THREE.Light: .shadowMapHeight is now .shadow.mapSize.height."
						),
							(this.shadow.mapSize.height = t);
					},
				},
			}),
			Object.defineProperties(Nh.prototype, {
				length: {
					get: function () {
						return (
							console.warn(
								"THREE.BufferAttribute: .length has been deprecated. Use .count instead."
							),
							this.array.length
						);
					},
				},
				dynamic: {
					get: function () {
						return (
							console.warn(
								"THREE.BufferAttribute: .dynamic has been deprecated. Use .usage instead."
							),
							this.usage === Yc
						);
					},
					set: function () {
						console.warn(
							"THREE.BufferAttribute: .dynamic has been deprecated. Use .usage instead."
						),
							this.setUsage(Yc);
					},
				},
			}),
			Object.assign(Nh.prototype, {
				setDynamic: function (t) {
					return (
						console.warn(
							"THREE.BufferAttribute: .setDynamic() has been deprecated. Use .setUsage() instead."
						),
						this.setUsage(!0 === t ? Yc : qc),
						this
					);
				},
				copyIndicesArray: function () {
					console.error(
						"THREE.BufferAttribute: .copyIndicesArray() has been removed."
					);
				},
				setArray: function () {
					console.error(
						"THREE.BufferAttribute: .setArray has been removed. Use BufferGeometry .setAttribute to replace/resize attribute buffers"
					);
				},
			}),
			Object.assign(eu.prototype, {
				addIndex: function (t) {
					console.warn(
						"THREE.BufferGeometry: .addIndex() has been renamed to .setIndex()."
					),
						this.setIndex(t);
				},
				addAttribute: function (t, e) {
					return (
						console.warn(
							"THREE.BufferGeometry: .addAttribute() has been renamed to .setAttribute()."
						),
						(e && e.isBufferAttribute) || (e && e.isInterleavedBufferAttribute)
							? "index" === t
								? (console.warn(
										"THREE.BufferGeometry.addAttribute: Use .setIndex() for index attribute."
								  ),
								  this.setIndex(e),
								  this)
								: this.setAttribute(t, e)
							: (console.warn(
									"THREE.BufferGeometry: .addAttribute() now expects ( name, attribute )."
							  ),
							  this.setAttribute(t, new Nh(arguments[1], arguments[2])))
					);
				},
				addDrawCall: function (t, e, n) {
					void 0 !== n &&
						console.warn(
							"THREE.BufferGeometry: .addDrawCall() no longer supports indexOffset."
						),
						console.warn(
							"THREE.BufferGeometry: .addDrawCall() is now .addGroup()."
						),
						this.addGroup(t, e);
				},
				clearDrawCalls: function () {
					console.warn(
						"THREE.BufferGeometry: .clearDrawCalls() is now .clearGroups()."
					),
						this.clearGroups();
				},
				computeTangents: function () {
					console.warn(
						"THREE.BufferGeometry: .computeTangents() has been removed."
					);
				},
				computeOffsets: function () {
					console.warn(
						"THREE.BufferGeometry: .computeOffsets() has been removed."
					);
				},
				removeAttribute: function (t) {
					return (
						console.warn(
							"THREE.BufferGeometry: .removeAttribute() has been renamed to .deleteAttribute()."
						),
						this.deleteAttribute(t)
					);
				},
				applyMatrix: function (t) {
					return (
						console.warn(
							"THREE.BufferGeometry: .applyMatrix() has been renamed to .applyMatrix4()."
						),
						this.applyMatrix4(t)
					);
				},
			}),
			Object.defineProperties(eu.prototype, {
				drawcalls: {
					get: function () {
						return (
							console.error(
								"THREE.BufferGeometry: .drawcalls has been renamed to .groups."
							),
							this.groups
						);
					},
				},
				offsets: {
					get: function () {
						return (
							console.warn(
								"THREE.BufferGeometry: .offsets has been renamed to .groups."
							),
							this.groups
						);
					},
				},
			}),
			Object.defineProperties(Tv.prototype, {
				maxInstancedCount: {
					get: function () {
						return (
							console.warn(
								"THREE.InstancedBufferGeometry: .maxInstancedCount has been renamed to .instanceCount."
							),
							this.instanceCount
						);
					},
					set: function (t) {
						console.warn(
							"THREE.InstancedBufferGeometry: .maxInstancedCount has been renamed to .instanceCount."
						),
							(this.instanceCount = t);
					},
				},
			}),
			Object.defineProperties(xy.prototype, {
				linePrecision: {
					get: function () {
						return (
							console.warn(
								"THREE.Raycaster: .linePrecision has been deprecated. Use .params.Line.threshold instead."
							),
							this.params.Line.threshold
						);
					},
					set: function (t) {
						console.warn(
							"THREE.Raycaster: .linePrecision has been deprecated. Use .params.Line.threshold instead."
						),
							(this.params.Line.threshold = t);
					},
				},
			}),
			Object.defineProperties(zp.prototype, {
				dynamic: {
					get: function () {
						return (
							console.warn(
								"THREE.InterleavedBuffer: .length has been deprecated. Use .usage instead."
							),
							this.usage === Yc
						);
					},
					set: function (t) {
						console.warn(
							"THREE.InterleavedBuffer: .length has been deprecated. Use .usage instead."
						),
							this.setUsage(t);
					},
				},
			}),
			Object.assign(zp.prototype, {
				setDynamic: function (t) {
					return (
						console.warn(
							"THREE.InterleavedBuffer: .setDynamic() has been deprecated. Use .setUsage() instead."
						),
						this.setUsage(!0 === t ? Yc : qc),
						this
					);
				},
				setArray: function () {
					console.error(
						"THREE.InterleavedBuffer: .setArray has been removed. Use BufferGeometry .setAttribute to replace/resize attribute buffers"
					);
				},
			}),
			Object.assign(Im.prototype, {
				getArrays: function () {
					console.error(
						"THREE.ExtrudeBufferGeometry: .getArrays() has been removed."
					);
				},
				addShapeList: function () {
					console.error(
						"THREE.ExtrudeBufferGeometry: .addShapeList() has been removed."
					);
				},
				addShape: function () {
					console.error(
						"THREE.ExtrudeBufferGeometry: .addShape() has been removed."
					);
				},
			}),
			Object.defineProperties(vy.prototype, {
				dynamic: {
					set: function () {
						console.warn(
							"THREE.Uniform: .dynamic has been removed. Use object.onBeforeRender() instead."
						);
					},
				},
				onUpdate: {
					value: function () {
						return (
							console.warn(
								"THREE.Uniform: .onUpdate() has been removed. Use object.onBeforeRender() instead."
							),
							this
						);
					},
				},
			}),
			Object.defineProperties(Oh.prototype, {
				wrapAround: {
					get: function () {
						console.warn("THREE.Material: .wrapAround has been removed.");
					},
					set: function () {
						console.warn("THREE.Material: .wrapAround has been removed.");
					},
				},
				overdraw: {
					get: function () {
						console.warn("THREE.Material: .overdraw has been removed.");
					},
					set: function () {
						console.warn("THREE.Material: .overdraw has been removed.");
					},
				},
				wrapRGB: {
					get: function () {
						return (
							console.warn("THREE.Material: .wrapRGB has been removed."),
							new Eh()
						);
					},
				},
				shading: {
					get: function () {
						console.error(
							"THREE." +
								this.type +
								": .shading has been removed. Use the boolean .flatShading instead."
						);
					},
					set: function (t) {
						console.warn(
							"THREE." +
								this.type +
								": .shading has been removed. Use the boolean .flatShading instead."
						),
							(this.flatShading = 1 === t);
					},
				},
				stencilMask: {
					get: function () {
						return (
							console.warn(
								"THREE." +
									this.type +
									": .stencilMask has been removed. Use .stencilFuncMask instead."
							),
							this.stencilFuncMask
						);
					},
					set: function (t) {
						console.warn(
							"THREE." +
								this.type +
								": .stencilMask has been removed. Use .stencilFuncMask instead."
						),
							(this.stencilFuncMask = t);
					},
				},
			}),
			Object.defineProperties(sg.prototype, {
				metal: {
					get: function () {
						return (
							console.warn(
								"THREE.MeshPhongMaterial: .metal has been removed. Use THREE.MeshStandardMaterial instead."
							),
							!1
						);
					},
					set: function () {
						console.warn(
							"THREE.MeshPhongMaterial: .metal has been removed. Use THREE.MeshStandardMaterial instead"
						);
					},
				},
			}),
			Object.defineProperties(Du.prototype, {
				derivatives: {
					get: function () {
						return (
							console.warn(
								"THREE.ShaderMaterial: .derivatives has been moved to .extensions.derivatives."
							),
							this.extensions.derivatives
						);
					},
					set: function (t) {
						console.warn(
							"THREE. ShaderMaterial: .derivatives has been moved to .extensions.derivatives."
						),
							(this.extensions.derivatives = t);
					},
				},
			}),
			Object.assign(kp.prototype, {
				clearTarget: function (t, e, n, i) {
					console.warn(
						"THREE.WebGLRenderer: .clearTarget() has been deprecated. Use .setRenderTarget() and .clear() instead."
					),
						this.setRenderTarget(t),
						this.clear(e, n, i);
				},
				animate: function (t) {
					console.warn(
						"THREE.WebGLRenderer: .animate() is now .setAnimationLoop()."
					),
						this.setAnimationLoop(t);
				},
				getCurrentRenderTarget: function () {
					return (
						console.warn(
							"THREE.WebGLRenderer: .getCurrentRenderTarget() is now .getRenderTarget()."
						),
						this.getRenderTarget()
					);
				},
				getMaxAnisotropy: function () {
					return (
						console.warn(
							"THREE.WebGLRenderer: .getMaxAnisotropy() is now .capabilities.getMaxAnisotropy()."
						),
						this.capabilities.getMaxAnisotropy()
					);
				},
				getPrecision: function () {
					return (
						console.warn(
							"THREE.WebGLRenderer: .getPrecision() is now .capabilities.precision."
						),
						this.capabilities.precision
					);
				},
				resetGLState: function () {
					return (
						console.warn(
							"THREE.WebGLRenderer: .resetGLState() is now .state.reset()."
						),
						this.state.reset()
					);
				},
				supportsFloatTextures: function () {
					return (
						console.warn(
							"THREE.WebGLRenderer: .supportsFloatTextures() is now .extensions.get( 'OES_texture_float' )."
						),
						this.extensions.get("OES_texture_float")
					);
				},
				supportsHalfFloatTextures: function () {
					return (
						console.warn(
							"THREE.WebGLRenderer: .supportsHalfFloatTextures() is now .extensions.get( 'OES_texture_half_float' )."
						),
						this.extensions.get("OES_texture_half_float")
					);
				},
				supportsStandardDerivatives: function () {
					return (
						console.warn(
							"THREE.WebGLRenderer: .supportsStandardDerivatives() is now .extensions.get( 'OES_standard_derivatives' )."
						),
						this.extensions.get("OES_standard_derivatives")
					);
				},
				supportsCompressedTextureS3TC: function () {
					return (
						console.warn(
							"THREE.WebGLRenderer: .supportsCompressedTextureS3TC() is now .extensions.get( 'WEBGL_compressed_texture_s3tc' )."
						),
						this.extensions.get("WEBGL_compressed_texture_s3tc")
					);
				},
				supportsCompressedTexturePVRTC: function () {
					return (
						console.warn(
							"THREE.WebGLRenderer: .supportsCompressedTexturePVRTC() is now .extensions.get( 'WEBGL_compressed_texture_pvrtc' )."
						),
						this.extensions.get("WEBGL_compressed_texture_pvrtc")
					);
				},
				supportsBlendMinMax: function () {
					return (
						console.warn(
							"THREE.WebGLRenderer: .supportsBlendMinMax() is now .extensions.get( 'EXT_blend_minmax' )."
						),
						this.extensions.get("EXT_blend_minmax")
					);
				},
				supportsVertexTextures: function () {
					return (
						console.warn(
							"THREE.WebGLRenderer: .supportsVertexTextures() is now .capabilities.vertexTextures."
						),
						this.capabilities.vertexTextures
					);
				},
				supportsInstancedArrays: function () {
					return (
						console.warn(
							"THREE.WebGLRenderer: .supportsInstancedArrays() is now .extensions.get( 'ANGLE_instanced_arrays' )."
						),
						this.extensions.get("ANGLE_instanced_arrays")
					);
				},
				enableScissorTest: function (t) {
					console.warn(
						"THREE.WebGLRenderer: .enableScissorTest() is now .setScissorTest()."
					),
						this.setScissorTest(t);
				},
				initMaterial: function () {
					console.warn(
						"THREE.WebGLRenderer: .initMaterial() has been removed."
					);
				},
				addPrePlugin: function () {
					console.warn(
						"THREE.WebGLRenderer: .addPrePlugin() has been removed."
					);
				},
				addPostPlugin: function () {
					console.warn(
						"THREE.WebGLRenderer: .addPostPlugin() has been removed."
					);
				},
				updateShadowMap: function () {
					console.warn(
						"THREE.WebGLRenderer: .updateShadowMap() has been removed."
					);
				},
				setFaceCulling: function () {
					console.warn(
						"THREE.WebGLRenderer: .setFaceCulling() has been removed."
					);
				},
				allocTextureUnit: function () {
					console.warn(
						"THREE.WebGLRenderer: .allocTextureUnit() has been removed."
					);
				},
				setTexture: function () {
					console.warn("THREE.WebGLRenderer: .setTexture() has been removed.");
				},
				setTexture2D: function () {
					console.warn(
						"THREE.WebGLRenderer: .setTexture2D() has been removed."
					);
				},
				setTextureCube: function () {
					console.warn(
						"THREE.WebGLRenderer: .setTextureCube() has been removed."
					);
				},
				getActiveMipMapLevel: function () {
					return (
						console.warn(
							"THREE.WebGLRenderer: .getActiveMipMapLevel() is now .getActiveMipmapLevel()."
						),
						this.getActiveMipmapLevel()
					);
				},
			}),
			Object.defineProperties(kp.prototype, {
				shadowMapEnabled: {
					get: function () {
						return this.shadowMap.enabled;
					},
					set: function (t) {
						console.warn(
							"THREE.WebGLRenderer: .shadowMapEnabled is now .shadowMap.enabled."
						),
							(this.shadowMap.enabled = t);
					},
				},
				shadowMapType: {
					get: function () {
						return this.shadowMap.type;
					},
					set: function (t) {
						console.warn(
							"THREE.WebGLRenderer: .shadowMapType is now .shadowMap.type."
						),
							(this.shadowMap.type = t);
					},
				},
				shadowMapCullFace: {
					get: function () {
						console.warn(
							"THREE.WebGLRenderer: .shadowMapCullFace has been removed. Set Material.shadowSide instead."
						);
					},
					set: function () {
						console.warn(
							"THREE.WebGLRenderer: .shadowMapCullFace has been removed. Set Material.shadowSide instead."
						);
					},
				},
				context: {
					get: function () {
						return (
							console.warn(
								"THREE.WebGLRenderer: .context has been removed. Use .getContext() instead."
							),
							this.getContext()
						);
					},
				},
				vr: {
					get: function () {
						return (
							console.warn("THREE.WebGLRenderer: .vr has been renamed to .xr"),
							this.xr
						);
					},
				},
				gammaInput: {
					get: function () {
						return (
							console.warn(
								"THREE.WebGLRenderer: .gammaInput has been removed. Set the encoding for textures via Texture.encoding instead."
							),
							!1
						);
					},
					set: function () {
						console.warn(
							"THREE.WebGLRenderer: .gammaInput has been removed. Set the encoding for textures via Texture.encoding instead."
						);
					},
				},
				gammaOutput: {
					get: function () {
						return (
							console.warn(
								"THREE.WebGLRenderer: .gammaOutput has been removed. Set WebGLRenderer.outputEncoding instead."
							),
							!1
						);
					},
					set: function (t) {
						console.warn(
							"THREE.WebGLRenderer: .gammaOutput has been removed. Set WebGLRenderer.outputEncoding instead."
						),
							(this.outputEncoding = !0 === t ? Dc : Oc);
					},
				},
				toneMappingWhitePoint: {
					get: function () {
						return (
							console.warn(
								"THREE.WebGLRenderer: .toneMappingWhitePoint has been removed."
							),
							1
						);
					},
					set: function () {
						console.warn(
							"THREE.WebGLRenderer: .toneMappingWhitePoint has been removed."
						);
					},
				},
			}),
			Object.defineProperties(Lp.prototype, {
				cullFace: {
					get: function () {
						console.warn(
							"THREE.WebGLRenderer: .shadowMap.cullFace has been removed. Set Material.shadowSide instead."
						);
					},
					set: function () {
						console.warn(
							"THREE.WebGLRenderer: .shadowMap.cullFace has been removed. Set Material.shadowSide instead."
						);
					},
				},
				renderReverseSided: {
					get: function () {
						console.warn(
							"THREE.WebGLRenderer: .shadowMap.renderReverseSided has been removed. Set Material.shadowSide instead."
						);
					},
					set: function () {
						console.warn(
							"THREE.WebGLRenderer: .shadowMap.renderReverseSided has been removed. Set Material.shadowSide instead."
						);
					},
				},
				renderSingleSided: {
					get: function () {
						console.warn(
							"THREE.WebGLRenderer: .shadowMap.renderSingleSided has been removed. Set Material.shadowSide instead."
						);
					},
					set: function () {
						console.warn(
							"THREE.WebGLRenderer: .shadowMap.renderSingleSided has been removed. Set Material.shadowSide instead."
						);
					},
				},
			}),
			Object.defineProperties(rl.prototype, {
				wrapS: {
					get: function () {
						return (
							console.warn(
								"THREE.WebGLRenderTarget: .wrapS is now .texture.wrapS."
							),
							this.texture.wrapS
						);
					},
					set: function (t) {
						console.warn(
							"THREE.WebGLRenderTarget: .wrapS is now .texture.wrapS."
						),
							(this.texture.wrapS = t);
					},
				},
				wrapT: {
					get: function () {
						return (
							console.warn(
								"THREE.WebGLRenderTarget: .wrapT is now .texture.wrapT."
							),
							this.texture.wrapT
						);
					},
					set: function (t) {
						console.warn(
							"THREE.WebGLRenderTarget: .wrapT is now .texture.wrapT."
						),
							(this.texture.wrapT = t);
					},
				},
				magFilter: {
					get: function () {
						return (
							console.warn(
								"THREE.WebGLRenderTarget: .magFilter is now .texture.magFilter."
							),
							this.texture.magFilter
						);
					},
					set: function (t) {
						console.warn(
							"THREE.WebGLRenderTarget: .magFilter is now .texture.magFilter."
						),
							(this.texture.magFilter = t);
					},
				},
				minFilter: {
					get: function () {
						return (
							console.warn(
								"THREE.WebGLRenderTarget: .minFilter is now .texture.minFilter."
							),
							this.texture.minFilter
						);
					},
					set: function (t) {
						console.warn(
							"THREE.WebGLRenderTarget: .minFilter is now .texture.minFilter."
						),
							(this.texture.minFilter = t);
					},
				},
				anisotropy: {
					get: function () {
						return (
							console.warn(
								"THREE.WebGLRenderTarget: .anisotropy is now .texture.anisotropy."
							),
							this.texture.anisotropy
						);
					},
					set: function (t) {
						console.warn(
							"THREE.WebGLRenderTarget: .anisotropy is now .texture.anisotropy."
						),
							(this.texture.anisotropy = t);
					},
				},
				offset: {
					get: function () {
						return (
							console.warn(
								"THREE.WebGLRenderTarget: .offset is now .texture.offset."
							),
							this.texture.offset
						);
					},
					set: function (t) {
						console.warn(
							"THREE.WebGLRenderTarget: .offset is now .texture.offset."
						),
							(this.texture.offset = t);
					},
				},
				repeat: {
					get: function () {
						return (
							console.warn(
								"THREE.WebGLRenderTarget: .repeat is now .texture.repeat."
							),
							this.texture.repeat
						);
					},
					set: function (t) {
						console.warn(
							"THREE.WebGLRenderTarget: .repeat is now .texture.repeat."
						),
							(this.texture.repeat = t);
					},
				},
				format: {
					get: function () {
						return (
							console.warn(
								"THREE.WebGLRenderTarget: .format is now .texture.format."
							),
							this.texture.format
						);
					},
					set: function (t) {
						console.warn(
							"THREE.WebGLRenderTarget: .format is now .texture.format."
						),
							(this.texture.format = t);
					},
				},
				type: {
					get: function () {
						return (
							console.warn(
								"THREE.WebGLRenderTarget: .type is now .texture.type."
							),
							this.texture.type
						);
					},
					set: function (t) {
						console.warn(
							"THREE.WebGLRenderTarget: .type is now .texture.type."
						),
							(this.texture.type = t);
					},
				},
				generateMipmaps: {
					get: function () {
						return (
							console.warn(
								"THREE.WebGLRenderTarget: .generateMipmaps is now .texture.generateMipmaps."
							),
							this.texture.generateMipmaps
						);
					},
					set: function (t) {
						console.warn(
							"THREE.WebGLRenderTarget: .generateMipmaps is now .texture.generateMipmaps."
						),
							(this.texture.generateMipmaps = t);
					},
				},
			}),
			Object.defineProperties(Kv.prototype, {
				load: {
					value: function (t) {
						console.warn(
							"THREE.Audio: .load has been deprecated. Use THREE.AudioLoader instead."
						);
						const e = this;
						return (
							new Hv().load(t, function (t) {
								e.setBuffer(t);
							}),
							this
						);
					},
				},
				startTime: {
					set: function () {
						console.warn("THREE.Audio: .startTime is now .play( delay ).");
					},
				},
			}),
			(iy.prototype.getData = function () {
				return (
					console.warn(
						"THREE.AudioAnalyser: .getData() is now .getFrequencyData()."
					),
					this.getFrequencyData()
				);
			}),
			(Fu.prototype.updateCubeMap = function (t, e) {
				return (
					console.warn("THREE.CubeCamera: .updateCubeMap() is now .update()."),
					this.update(t, e)
				);
			});
		(tl.crossOrigin = void 0),
			(tl.loadTexture = function (t, e, n, i) {
				console.warn(
					"THREE.ImageUtils.loadTexture has been deprecated. Use THREE.TextureLoader() instead."
				);
				const r = new zg();
				r.setCrossOrigin(this.crossOrigin);
				const o = r.load(t, n, void 0, i);
				return e && (o.mapping = e), o;
			}),
			(tl.loadTextureCube = function (t, e, n, i) {
				console.warn(
					"THREE.ImageUtils.loadTextureCube has been deprecated. Use THREE.CubeTextureLoader() instead."
				);
				const r = new Fg();
				r.setCrossOrigin(this.crossOrigin);
				const o = r.load(t, n, void 0, i);
				return e && (o.mapping = e), o;
			}),
			(tl.loadCompressedTexture = function () {
				console.error(
					"THREE.ImageUtils.loadCompressedTexture has been removed. Use THREE.DDSLoader instead."
				);
			}),
			(tl.loadCompressedTextureCube = function () {
				console.error(
					"THREE.ImageUtils.loadCompressedTextureCube has been removed. Use THREE.DDSLoader instead."
				);
			});
		"undefined" != typeof __THREE_DEVTOOLS__ &&
			__THREE_DEVTOOLS__.dispatchEvent(
				new CustomEvent("register", { detail: { revision: "118" } })
			);
		var Ax,
			Lx,
			Px,
			Rx,
			Cx,
			Ox,
			Dx,
			Ix,
			kx = (function () {
				function t(t) {
					Cg.call(this, t),
						(this.dracoLoader = null),
						(this.ddsLoader = null),
						(this.pluginCallbacks = []),
						this.register(function (t) {
							return new o(t);
						});
				}
				t.prototype = Object.assign(Object.create(Cg.prototype), {
					constructor: t,
					load: function (t, e, n, i) {
						var r,
							o = this;
						(r =
							"" !== this.resourcePath
								? this.resourcePath
								: "" !== this.path
								? this.path
								: Sv.extractUrlBase(t)),
							o.manager.itemStart(t);
						var s = function (e) {
								i ? i(e) : console.error(e),
									o.manager.itemError(t),
									o.manager.itemEnd(t);
							},
							a = new Dg(o.manager);
						a.setPath(this.path),
							a.setResponseType("arraybuffer"),
							a.setRequestHeader(this.requestHeader),
							"use-credentials" === o.crossOrigin && a.setWithCredentials(!0),
							a.load(
								t,
								function (n) {
									try {
										o.parse(
											n,
											r,
											function (n) {
												e(n), o.manager.itemEnd(t);
											},
											s
										);
									} catch (t) {
										s(t);
									}
								},
								n,
								s
							);
					},
					setDRACOLoader: function (t) {
						return (this.dracoLoader = t), this;
					},
					setDDSLoader: function (t) {
						return (this.ddsLoader = t), this;
					},
					register: function (t) {
						return (
							-1 === this.pluginCallbacks.indexOf(t) &&
								this.pluginCallbacks.push(t),
							this
						);
					},
					unregister: function (t) {
						return (
							-1 !== this.pluginCallbacks.indexOf(t) &&
								this.pluginCallbacks.splice(this.pluginCallbacks.indexOf(t), 1),
							this
						);
					},
					parse: function (t, o, u, f) {
						var m,
							g = {},
							v = {};
						if ("string" == typeof t) m = t;
						else if (Sv.decodeText(new Uint8Array(t, 0, 4)) === s) {
							try {
								g[e.KHR_BINARY_GLTF] = new (function (t) {
									(this.name = e.KHR_BINARY_GLTF),
										(this.content = null),
										(this.body = null);
									var n = new DataView(t, 0, a);
									if (
										((this.header = {
											magic: Sv.decodeText(new Uint8Array(t.slice(0, 4))),
											version: n.getUint32(4, !0),
											length: n.getUint32(8, !0),
										}),
										this.header.magic !== s)
									)
										throw new Error(
											"THREE.GLTFLoader: Unsupported glTF-Binary header."
										);
									if (this.header.version < 2)
										throw new Error(
											"THREE.GLTFLoader: Legacy binary file detected."
										);
									var i = new DataView(t, a),
										r = 0;
									for (; r < i.byteLength; ) {
										var o = i.getUint32(r, !0);
										r += 4;
										var l = i.getUint32(r, !0);
										if (((r += 4), l === c.JSON)) {
											var h = new Uint8Array(t, a + r, o);
											this.content = Sv.decodeText(h);
										} else if (l === c.BIN) {
											var u = a + r;
											this.body = t.slice(u, u + o);
										}
										r += o;
									}
									if (null === this.content)
										throw new Error(
											"THREE.GLTFLoader: JSON content not found."
										);
								})(t);
							} catch (t) {
								return void (f && f(t));
							}
							m = g[e.KHR_BINARY_GLTF].content;
						} else m = Sv.decodeText(new Uint8Array(t));
						var y = JSON.parse(m);
						if (void 0 === y.asset || y.asset.version[0] < 2)
							f &&
								f(
									new Error(
										"THREE.GLTFLoader: Unsupported asset. glTF versions >=2.0 are supported."
									)
								);
						else {
							var x = new F(y, {
								path: o || this.resourcePath || "",
								crossOrigin: this.crossOrigin,
								manager: this.manager,
							});
							x.fileLoader.setRequestHeader(this.requestHeader);
							for (var b = 0; b < this.pluginCallbacks.length; b++) {
								var w = this.pluginCallbacks[b](x);
								(v[w.name] = w), (g[w.name] = !0);
							}
							if (y.extensionsUsed)
								for (b = 0; b < y.extensionsUsed.length; ++b) {
									var _ = y.extensionsUsed[b],
										M = y.extensionsRequired || [];
									switch (_) {
										case e.KHR_LIGHTS_PUNCTUAL:
											g[_] = new i(y);
											break;
										case e.KHR_MATERIALS_UNLIT:
											g[_] = new r();
											break;
										case e.KHR_MATERIALS_PBR_SPECULAR_GLOSSINESS:
											g[_] = new d();
											break;
										case e.KHR_DRACO_MESH_COMPRESSION:
											g[_] = new l(y, this.dracoLoader);
											break;
										case e.MSFT_TEXTURE_DDS:
											g[_] = new n(this.ddsLoader);
											break;
										case e.KHR_TEXTURE_TRANSFORM:
											g[_] = new h();
											break;
										case e.KHR_MESH_QUANTIZATION:
											g[_] = new p();
											break;
										default:
											M.indexOf(_) >= 0 &&
												void 0 === v[_] &&
												console.warn(
													'THREE.GLTFLoader: Unknown extension "' + _ + '".'
												);
									}
								}
							x.setExtensions(g), x.setPlugins(v), x.parse(u, f);
						}
					},
				});
				var e = {
					KHR_BINARY_GLTF: "KHR_binary_glTF",
					KHR_DRACO_MESH_COMPRESSION: "KHR_draco_mesh_compression",
					KHR_LIGHTS_PUNCTUAL: "KHR_lights_punctual",
					KHR_MATERIALS_CLEARCOAT: "KHR_materials_clearcoat",
					KHR_MATERIALS_PBR_SPECULAR_GLOSSINESS:
						"KHR_materials_pbrSpecularGlossiness",
					KHR_MATERIALS_UNLIT: "KHR_materials_unlit",
					KHR_TEXTURE_TRANSFORM: "KHR_texture_transform",
					KHR_MESH_QUANTIZATION: "KHR_mesh_quantization",
					MSFT_TEXTURE_DDS: "MSFT_texture_dds",
				};
				function n(t) {
					if (!t)
						throw new Error(
							"THREE.GLTFLoader: Attempting to load .dds texture without importing DDSLoader"
						);
					(this.name = e.MSFT_TEXTURE_DDS), (this.ddsLoader = t);
				}
				function i(t) {
					this.name = e.KHR_LIGHTS_PUNCTUAL;
					var n = (t.extensions && t.extensions[e.KHR_LIGHTS_PUNCTUAL]) || {};
					this.lightDefs = n.lights || [];
				}
				function r() {
					this.name = e.KHR_MATERIALS_UNLIT;
				}
				function o(t) {
					(this.parser = t), (this.name = e.KHR_MATERIALS_CLEARCOAT);
				}
				(i.prototype.loadLight = function (t) {
					var e,
						n = this.lightDefs[t],
						i = new Eh(16777215);
					void 0 !== n.color && i.fromArray(n.color);
					var r = void 0 !== n.range ? n.range : 0;
					switch (n.type) {
						case "directional":
							(e = new yv(i)).target.position.set(0, 0, -1), e.add(e.target);
							break;
						case "point":
							(e = new mv(i)).distance = r;
							break;
						case "spot":
							((e = new pv(i)).distance = r),
								(n.spot = n.spot || {}),
								(n.spot.innerConeAngle =
									void 0 !== n.spot.innerConeAngle ? n.spot.innerConeAngle : 0),
								(n.spot.outerConeAngle =
									void 0 !== n.spot.outerConeAngle
										? n.spot.outerConeAngle
										: Math.PI / 4),
								(e.angle = n.spot.outerConeAngle),
								(e.penumbra =
									1 - n.spot.innerConeAngle / n.spot.outerConeAngle),
								e.target.position.set(0, 0, -1),
								e.add(e.target);
							break;
						default:
							throw new Error(
								'THREE.GLTFLoader: Unexpected light type, "' + n.type + '".'
							);
					}
					return (
						e.position.set(0, 0, 0),
						(e.decay = 2),
						void 0 !== n.intensity && (e.intensity = n.intensity),
						(e.name = n.name || "light_" + t),
						Promise.resolve(e)
					);
				}),
					(r.prototype.getMaterialType = function () {
						return Dh;
					}),
					(r.prototype.extendParams = function (t, e, n) {
						var i = [];
						(t.color = new Eh(1, 1, 1)), (t.opacity = 1);
						var r = e.pbrMetallicRoughness;
						if (r) {
							if (Array.isArray(r.baseColorFactor)) {
								var o = r.baseColorFactor;
								t.color.fromArray(o), (t.opacity = o[3]);
							}
							void 0 !== r.baseColorTexture &&
								i.push(n.assignTexture(t, "map", r.baseColorTexture));
						}
						return Promise.all(i);
					}),
					(o.prototype.getMaterialType = function () {
						return og;
					}),
					(o.prototype.extendMaterialParams = function (t, e) {
						var n = this.parser,
							i = n.json.materials[t];
						if (!i.extensions || !i.extensions[this.name])
							return Promise.resolve();
						var r = [],
							o = i.extensions[this.name];
						if (
							(void 0 !== o.clearcoatFactor &&
								(e.clearcoat = o.clearcoatFactor),
							void 0 !== o.clearcoatTexture &&
								r.push(n.assignTexture(e, "clearcoatMap", o.clearcoatTexture)),
							void 0 !== o.clearcoatRoughnessFactor &&
								(e.clearcoatRoughness = o.clearcoatRoughnessFactor),
							void 0 !== o.clearcoatRoughnessTexture &&
								r.push(
									n.assignTexture(
										e,
										"clearcoatRoughnessMap",
										o.clearcoatRoughnessTexture
									)
								),
							void 0 !== o.clearcoatNormalTexture &&
								(r.push(
									n.assignTexture(
										e,
										"clearcoatNormalMap",
										o.clearcoatNormalTexture
									)
								),
								void 0 !== o.clearcoatNormalTexture.scale))
						) {
							var s = o.clearcoatNormalTexture.scale;
							e.clearcoatNormalScale = new Kc(s, s);
						}
						return Promise.all(r);
					});
				var s = "glTF",
					a = 12,
					c = { JSON: 1313821514, BIN: 5130562 };
				function l(t, n) {
					if (!n)
						throw new Error(
							"THREE.GLTFLoader: No DRACOLoader instance provided."
						);
					(this.name = e.KHR_DRACO_MESH_COMPRESSION),
						(this.json = t),
						(this.dracoLoader = n),
						this.dracoLoader.preload();
				}
				function h() {
					this.name = e.KHR_TEXTURE_TRANSFORM;
				}
				function u(t) {
					rg.call(this), (this.isGLTFSpecularGlossinessMaterial = !0);
					var e = [
							"#ifdef USE_SPECULARMAP",
							"\tuniform sampler2D specularMap;",
							"#endif",
						].join("\n"),
						n = [
							"#ifdef USE_GLOSSINESSMAP",
							"\tuniform sampler2D glossinessMap;",
							"#endif",
						].join("\n"),
						i = [
							"vec3 specularFactor = specular;",
							"#ifdef USE_SPECULARMAP",
							"\tvec4 texelSpecular = texture2D( specularMap, vUv );",
							"\ttexelSpecular = sRGBToLinear( texelSpecular );",
							"\t// reads channel RGB, compatible with a glTF Specular-Glossiness (RGBA) texture",
							"\tspecularFactor *= texelSpecular.rgb;",
							"#endif",
						].join("\n"),
						r = [
							"float glossinessFactor = glossiness;",
							"#ifdef USE_GLOSSINESSMAP",
							"\tvec4 texelGlossiness = texture2D( glossinessMap, vUv );",
							"\t// reads channel A, compatible with a glTF Specular-Glossiness (RGBA) texture",
							"\tglossinessFactor *= texelGlossiness.a;",
							"#endif",
						].join("\n"),
						o = [
							"PhysicalMaterial material;",
							"material.diffuseColor = diffuseColor.rgb;",
							"vec3 dxy = max( abs( dFdx( geometryNormal ) ), abs( dFdy( geometryNormal ) ) );",
							"float geometryRoughness = max( max( dxy.x, dxy.y ), dxy.z );",
							"material.specularRoughness = max( 1.0 - glossinessFactor, 0.0525 );// 0.0525 corresponds to the base mip of a 256 cubemap.",
							"material.specularRoughness += geometryRoughness;",
							"material.specularRoughness = min( material.specularRoughness, 1.0 );",
							"material.specularColor = specularFactor.rgb;",
						].join("\n"),
						s = {
							specular: { value: new Eh().setHex(16777215) },
							glossiness: { value: 1 },
							specularMap: { value: null },
							glossinessMap: { value: null },
						};
					(this._extraUniforms = s),
						(this.onBeforeCompile = function (t) {
							for (var a in s) t.uniforms[a] = s[a];
							(t.fragmentShader = t.fragmentShader.replace(
								"uniform float roughness;",
								"uniform vec3 specular;"
							)),
								(t.fragmentShader = t.fragmentShader.replace(
									"uniform float metalness;",
									"uniform float glossiness;"
								)),
								(t.fragmentShader = t.fragmentShader.replace(
									"#include <roughnessmap_pars_fragment>",
									e
								)),
								(t.fragmentShader = t.fragmentShader.replace(
									"#include <metalnessmap_pars_fragment>",
									n
								)),
								(t.fragmentShader = t.fragmentShader.replace(
									"#include <roughnessmap_fragment>",
									i
								)),
								(t.fragmentShader = t.fragmentShader.replace(
									"#include <metalnessmap_fragment>",
									r
								)),
								(t.fragmentShader = t.fragmentShader.replace(
									"#include <lights_physical_fragment>",
									o
								));
						}),
						Object.defineProperties(this, {
							specular: {
								get: function () {
									return s.specular.value;
								},
								set: function (t) {
									s.specular.value = t;
								},
							},
							specularMap: {
								get: function () {
									return s.specularMap.value;
								},
								set: function (t) {
									s.specularMap.value = t;
								},
							},
							glossiness: {
								get: function () {
									return s.glossiness.value;
								},
								set: function (t) {
									s.glossiness.value = t;
								},
							},
							glossinessMap: {
								get: function () {
									return s.glossinessMap.value;
								},
								set: function (t) {
									(s.glossinessMap.value = t),
										t
											? ((this.defines.USE_GLOSSINESSMAP = ""),
											  (this.defines.USE_ROUGHNESSMAP = ""))
											: (delete this.defines.USE_ROUGHNESSMAP,
											  delete this.defines.USE_GLOSSINESSMAP);
								},
							},
						}),
						delete this.metalness,
						delete this.roughness,
						delete this.metalnessMap,
						delete this.roughnessMap,
						this.setValues(t);
				}
				function d() {
					return {
						name: e.KHR_MATERIALS_PBR_SPECULAR_GLOSSINESS,
						specularGlossinessParams: [
							"color",
							"map",
							"lightMap",
							"lightMapIntensity",
							"aoMap",
							"aoMapIntensity",
							"emissive",
							"emissiveIntensity",
							"emissiveMap",
							"bumpMap",
							"bumpScale",
							"normalMap",
							"normalMapType",
							"displacementMap",
							"displacementScale",
							"displacementBias",
							"specularMap",
							"specular",
							"glossinessMap",
							"glossiness",
							"alphaMap",
							"envMap",
							"envMapIntensity",
							"refractionRatio",
						],
						getMaterialType: function () {
							return u;
						},
						extendParams: function (t, e, n) {
							var i = e.extensions[this.name];
							(t.color = new Eh(1, 1, 1)), (t.opacity = 1);
							var r = [];
							if (Array.isArray(i.diffuseFactor)) {
								var o = i.diffuseFactor;
								t.color.fromArray(o), (t.opacity = o[3]);
							}
							if (
								(void 0 !== i.diffuseTexture &&
									r.push(n.assignTexture(t, "map", i.diffuseTexture)),
								(t.emissive = new Eh(0, 0, 0)),
								(t.glossiness =
									void 0 !== i.glossinessFactor ? i.glossinessFactor : 1),
								(t.specular = new Eh(1, 1, 1)),
								Array.isArray(i.specularFactor) &&
									t.specular.fromArray(i.specularFactor),
								void 0 !== i.specularGlossinessTexture)
							) {
								var s = i.specularGlossinessTexture;
								r.push(n.assignTexture(t, "glossinessMap", s)),
									r.push(n.assignTexture(t, "specularMap", s));
							}
							return Promise.all(r);
						},
						createMaterial: function (t) {
							var e = new u(t);
							return (
								(e.fog = !0),
								(e.color = t.color),
								(e.map = void 0 === t.map ? null : t.map),
								(e.lightMap = null),
								(e.lightMapIntensity = 1),
								(e.aoMap = void 0 === t.aoMap ? null : t.aoMap),
								(e.aoMapIntensity = 1),
								(e.emissive = t.emissive),
								(e.emissiveIntensity = 1),
								(e.emissiveMap =
									void 0 === t.emissiveMap ? null : t.emissiveMap),
								(e.bumpMap = void 0 === t.bumpMap ? null : t.bumpMap),
								(e.bumpScale = 1),
								(e.normalMap = void 0 === t.normalMap ? null : t.normalMap),
								(e.normalMapType = Gc),
								t.normalScale && (e.normalScale = t.normalScale),
								(e.displacementMap = null),
								(e.displacementScale = 1),
								(e.displacementBias = 0),
								(e.specularMap =
									void 0 === t.specularMap ? null : t.specularMap),
								(e.specular = t.specular),
								(e.glossinessMap =
									void 0 === t.glossinessMap ? null : t.glossinessMap),
								(e.glossiness = t.glossiness),
								(e.alphaMap = null),
								(e.envMap = void 0 === t.envMap ? null : t.envMap),
								(e.envMapIntensity = 1),
								(e.refractionRatio = 0.98),
								e
							);
						},
					};
				}
				function p() {
					this.name = e.KHR_MESH_QUANTIZATION;
				}
				function f(t, e, n, i) {
					fg.call(this, t, e, n, i);
				}
				(l.prototype.decodePrimitive = function (t, e) {
					var n = this.json,
						i = this.dracoLoader,
						r = t.extensions[this.name].bufferView,
						o = t.extensions[this.name].attributes,
						s = {},
						a = {},
						c = {};
					for (var l in o) {
						var h = E[l] || l.toLowerCase();
						s[h] = o[l];
					}
					for (l in t.attributes) {
						h = E[l] || l.toLowerCase();
						if (void 0 !== o[l]) {
							var u = n.accessors[t.attributes[l]],
								d = _[u.componentType];
							(c[h] = d), (a[h] = !0 === u.normalized);
						}
					}
					return e.getDependency("bufferView", r).then(function (t) {
						return new Promise(function (e) {
							i.decodeDracoFile(
								t,
								function (t) {
									for (var n in t.attributes) {
										var i = t.attributes[n],
											r = a[n];
										void 0 !== r && (i.normalized = r);
									}
									e(t);
								},
								s,
								c
							);
						});
					});
				}),
					(h.prototype.extendTexture = function (t, e) {
						return (
							(t = t.clone()),
							void 0 !== e.offset && t.offset.fromArray(e.offset),
							void 0 !== e.rotation && (t.rotation = e.rotation),
							void 0 !== e.scale && t.repeat.fromArray(e.scale),
							void 0 !== e.texCoord &&
								console.warn(
									'THREE.GLTFLoader: Custom UV sets in "' +
										this.name +
										'" extension not yet supported.'
								),
							(t.needsUpdate = !0),
							t
						);
					}),
					(u.prototype = Object.create(rg.prototype)),
					(u.prototype.constructor = u),
					(u.prototype.copy = function (t) {
						return (
							rg.prototype.copy.call(this, t),
							(this.specularMap = t.specularMap),
							this.specular.copy(t.specular),
							(this.glossinessMap = t.glossinessMap),
							(this.glossiness = t.glossiness),
							delete this.metalness,
							delete this.roughness,
							delete this.metalnessMap,
							delete this.roughnessMap,
							this
						);
					}),
					(f.prototype = Object.create(fg.prototype)),
					(f.prototype.constructor = f),
					(f.prototype.copySampleValue_ = function (t) {
						for (
							var e = this.resultBuffer,
								n = this.sampleValues,
								i = this.valueSize,
								r = t * i * 3 + i,
								o = 0;
							o !== i;
							o++
						)
							e[o] = n[r + o];
						return e;
					}),
					(f.prototype.beforeStart_ = f.prototype.copySampleValue_),
					(f.prototype.afterEnd_ = f.prototype.copySampleValue_),
					(f.prototype.interpolate_ = function (t, e, n, i) {
						for (
							var r = this.resultBuffer,
								o = this.sampleValues,
								s = this.valueSize,
								a = 2 * s,
								c = 3 * s,
								l = i - e,
								h = (n - e) / l,
								u = h * h,
								d = u * h,
								p = t * c,
								f = p - c,
								m = -2 * d + 3 * u,
								g = d - u,
								v = 1 - m,
								y = g - u + h,
								x = 0;
							x !== s;
							x++
						) {
							var b = o[f + x + s],
								w = o[f + x + a] * l,
								_ = o[p + x + s],
								M = o[p + x] * l;
							r[x] = v * b + y * w + m * _ + g * M;
						}
						return r;
					});
				var m = 0,
					g = 1,
					v = 2,
					y = 3,
					x = 4,
					b = 5,
					w = 6,
					_ = {
						5120: Int8Array,
						5121: Uint8Array,
						5122: Int16Array,
						5123: Uint16Array,
						5125: Uint32Array,
						5126: Float32Array,
					},
					M = { 9728: ha, 9729: pa, 9984: ua, 9985: fa, 9986: da, 9987: ma },
					S = { 33071: ca, 33648: la, 10497: aa },
					T = {
						SCALAR: 1,
						VEC2: 2,
						VEC3: 3,
						VEC4: 4,
						MAT2: 4,
						MAT3: 9,
						MAT4: 16,
					},
					E = {
						POSITION: "position",
						NORMAL: "normal",
						TANGENT: "tangent",
						TEXCOORD_0: "uv",
						TEXCOORD_1: "uv2",
						COLOR_0: "color",
						WEIGHTS_0: "skinWeight",
						JOINTS_0: "skinIndex",
					},
					A = {
						scale: "scale",
						translation: "position",
						rotation: "quaternion",
						weights: "morphTargetInfluences",
					},
					L = { CUBICSPLINE: void 0, LINEAR: 2301, STEP: 2300 },
					P = "OPAQUE",
					R = "MASK",
					C = "BLEND",
					O = { "image/png": Ra, "image/jpeg": Pa };
				function D(t, e) {
					return "string" != typeof t || "" === t
						? ""
						: (/^https?:\/\//i.test(e) &&
								/^\//.test(t) &&
								(e = e.replace(/(^https?:\/\/[^\/]+).*/i, "$1")),
						  /^(https?:)?\/\//i.test(t)
								? t
								: /^data:.*,.*$/i.test(t)
								? t
								: /^blob:.*$/i.test(t)
								? t
								: e + t);
				}
				function I(t, e, n) {
					for (var i in n.extensions)
						void 0 === t[i] &&
							((e.userData.gltfExtensions = e.userData.gltfExtensions || {}),
							(e.userData.gltfExtensions[i] = n.extensions[i]));
				}
				function k(t, e) {
					void 0 !== e.extras &&
						("object" == typeof e.extras
							? Object.assign(t.userData, e.extras)
							: console.warn(
									"THREE.GLTFLoader: Ignoring primitive type .extras, " +
										e.extras
							  ));
				}
				function N(t, e) {
					if ((t.updateMorphTargets(), void 0 !== e.weights))
						for (var n = 0, i = e.weights.length; n < i; n++)
							t.morphTargetInfluences[n] = e.weights[n];
					if (e.extras && Array.isArray(e.extras.targetNames)) {
						var r = e.extras.targetNames;
						if (t.morphTargetInfluences.length === r.length) {
							t.morphTargetDictionary = {};
							for (n = 0, i = r.length; n < i; n++)
								t.morphTargetDictionary[r[n]] = n;
						} else
							console.warn(
								"THREE.GLTFLoader: Invalid extras.targetNames length. Ignoring names."
							);
					}
				}
				function B(t) {
					for (
						var e = "", n = Object.keys(t).sort(), i = 0, r = n.length;
						i < r;
						i++
					)
						e += n[i] + ":" + t[n[i]] + ";";
					return e;
				}
				function F(t, e) {
					(this.json = t || {}),
						(this.extensions = {}),
						(this.plugins = {}),
						(this.options = e || {}),
						(this.cache = new (function () {
							var t = {};
							return {
								get: function (e) {
									return t[e];
								},
								add: function (e, n) {
									t[e] = n;
								},
								remove: function (e) {
									delete t[e];
								},
								removeAll: function () {
									t = {};
								},
							};
						})()),
						(this.associations = new Map()),
						(this.primitiveCache = {}),
						"undefined" != typeof createImageBitmap &&
						!1 === /Firefox/.test(navigator.userAgent)
							? (this.textureLoader = new Dv(this.options.manager))
							: (this.textureLoader = new zg(this.options.manager)),
						this.textureLoader.setCrossOrigin(this.options.crossOrigin),
						(this.fileLoader = new Dg(this.options.manager)),
						this.fileLoader.setResponseType("arraybuffer"),
						"use-credentials" === this.options.crossOrigin &&
							this.fileLoader.setWithCredentials(!0);
				}
				function z(t, e, n) {
					var i = e.attributes,
						r = [];
					function o(e, i) {
						return n.getDependency("accessor", e).then(function (e) {
							t.setAttribute(i, e);
						});
					}
					for (var s in i) {
						var a = E[s] || s.toLowerCase();
						a in t.attributes || r.push(o(i[s], a));
					}
					if (void 0 !== e.indices && !t.index) {
						var c = n.getDependency("accessor", e.indices).then(function (e) {
							t.setIndex(e);
						});
						r.push(c);
					}
					return (
						k(t, e),
						(function (t, e, n) {
							var i = e.attributes,
								r = new Jl();
							if (void 0 !== i.POSITION) {
								var o = (d = n.json.accessors[i.POSITION]).min,
									s = d.max;
								if (void 0 !== o && void 0 !== s) {
									r.set(new ll(o[0], o[1], o[2]), new ll(s[0], s[1], s[2]));
									var a = e.targets;
									if (void 0 !== a) {
										for (
											var c = new ll(), l = new ll(), h = 0, u = a.length;
											h < u;
											h++
										) {
											var d,
												p = a[h];
											if (void 0 !== p.POSITION)
												(o = (d = n.json.accessors[p.POSITION]).min),
													(s = d.max),
													void 0 !== o && void 0 !== s
														? (l.setX(Math.max(Math.abs(o[0]), Math.abs(s[0]))),
														  l.setY(Math.max(Math.abs(o[1]), Math.abs(s[1]))),
														  l.setZ(Math.max(Math.abs(o[2]), Math.abs(s[2]))),
														  c.max(l))
														: console.warn(
																"THREE.GLTFLoader: Missing min/max properties for accessor POSITION."
														  );
										}
										r.expandByVector(c);
									}
									t.boundingBox = r;
									var f = new $l();
									r.getCenter(f.center),
										(f.radius = r.min.distanceTo(r.max) / 2),
										(t.boundingSphere = f);
								} else
									console.warn(
										"THREE.GLTFLoader: Missing min/max properties for accessor POSITION."
									);
							}
						})(t, e, n),
						Promise.all(r).then(function () {
							return void 0 !== e.targets
								? (function (t, e, n) {
										for (
											var i = !1, r = !1, o = 0, s = e.length;
											o < s &&
											(void 0 !== (l = e[o]).POSITION && (i = !0),
											void 0 !== l.NORMAL && (r = !0),
											!i || !r);
											o++
										);
										if (!i && !r) return Promise.resolve(t);
										var a = [],
											c = [];
										for (o = 0, s = e.length; o < s; o++) {
											var l = e[o];
											if (i) {
												var h =
													void 0 !== l.POSITION
														? n.getDependency("accessor", l.POSITION)
														: t.attributes.position;
												a.push(h);
											}
											r &&
												((h =
													void 0 !== l.NORMAL
														? n.getDependency("accessor", l.NORMAL)
														: t.attributes.normal),
												c.push(h));
										}
										return Promise.all([Promise.all(a), Promise.all(c)]).then(
											function (e) {
												var n = e[0],
													o = e[1];
												return (
													i && (t.morphAttributes.position = n),
													r && (t.morphAttributes.normal = o),
													(t.morphTargetsRelative = !0),
													t
												);
											}
										);
								  })(t, e.targets, n)
								: t;
						})
					);
				}
				function H(t, e) {
					var n = t.getIndex();
					if (null === n) {
						var i = [],
							r = t.getAttribute("position");
						if (void 0 === r)
							return (
								console.error(
									"THREE.GLTFLoader.toTrianglesDrawMode(): Undefined position attribute. Processing not possible."
								),
								t
							);
						for (var o = 0; o < r.count; o++) i.push(o);
						t.setIndex(i), (n = t.getIndex());
					}
					var s = n.count - 2,
						a = [];
					if (e === Cc)
						for (o = 1; o <= s; o++)
							a.push(n.getX(0)), a.push(n.getX(o)), a.push(n.getX(o + 1));
					else
						for (o = 0; o < s; o++)
							o % 2 == 0
								? (a.push(n.getX(o)),
								  a.push(n.getX(o + 1)),
								  a.push(n.getX(o + 2)))
								: (a.push(n.getX(o + 2)),
								  a.push(n.getX(o + 1)),
								  a.push(n.getX(o)));
					a.length / 3 !== s &&
						console.error(
							"THREE.GLTFLoader.toTrianglesDrawMode(): Unable to generate correct amount of triangles."
						);
					var c = t.clone();
					return c.setIndex(a), c;
				}
				return (
					(F.prototype.setExtensions = function (t) {
						this.extensions = t;
					}),
					(F.prototype.setPlugins = function (t) {
						this.plugins = t;
					}),
					(F.prototype.parse = function (t, e) {
						var n = this,
							i = this.json,
							r = this.extensions;
						this.cache.removeAll(),
							this.markDefs(),
							Promise.all([
								this.getDependencies("scene"),
								this.getDependencies("animation"),
								this.getDependencies("camera"),
							])
								.then(function (e) {
									var o = {
										scene: e[0][i.scene || 0],
										scenes: e[0],
										animations: e[1],
										cameras: e[2],
										asset: i.asset,
										parser: n,
										userData: {},
									};
									I(r, o, i), k(o, i), t(o);
								})
								.catch(e);
					}),
					(F.prototype.markDefs = function () {
						for (
							var t = this.json.nodes || [],
								e = this.json.skins || [],
								n = this.json.meshes || [],
								i = {},
								r = {},
								o = 0,
								s = e.length;
							o < s;
							o++
						)
							for (var a = e[o].joints, c = 0, l = a.length; c < l; c++)
								t[a[c]].isBone = !0;
						for (var h = 0, u = t.length; h < u; h++) {
							var d = t[h];
							void 0 !== d.mesh &&
								(void 0 === i[d.mesh] && (i[d.mesh] = r[d.mesh] = 0),
								i[d.mesh]++,
								void 0 !== d.skin && (n[d.mesh].isSkinnedMesh = !0));
						}
						(this.json.meshReferences = i), (this.json.meshUses = r);
					}),
					(F.prototype._invokeOne = function (t) {
						var e = Object.values(this.plugins);
						e.push(this);
						for (var n = 0; n < e.length; n++) {
							var i = t(e[n]);
							if (i) return i;
						}
					}),
					(F.prototype._invokeAll = function (t) {
						var e = Object.values(this.plugins);
						e.unshift(this);
						for (var n = [], i = 0; i < e.length; i++) n.push(t(e[i]));
						return Promise.all(n);
					}),
					(F.prototype.getDependency = function (t, n) {
						var i = t + ":" + n,
							r = this.cache.get(i);
						if (!r) {
							switch (t) {
								case "scene":
									r = this.loadScene(n);
									break;
								case "node":
									r = this.loadNode(n);
									break;
								case "mesh":
									r = this._invokeOne(function (t) {
										return t.loadMesh && t.loadMesh(n);
									});
									break;
								case "accessor":
									r = this.loadAccessor(n);
									break;
								case "bufferView":
									r = this._invokeOne(function (t) {
										return t.loadBufferView && t.loadBufferView(n);
									});
									break;
								case "buffer":
									r = this.loadBuffer(n);
									break;
								case "material":
									r = this._invokeOne(function (t) {
										return t.loadMaterial && t.loadMaterial(n);
									});
									break;
								case "texture":
									r = this.loadTexture(n);
									break;
								case "skin":
									r = this.loadSkin(n);
									break;
								case "animation":
									r = this.loadAnimation(n);
									break;
								case "camera":
									r = this.loadCamera(n);
									break;
								case "light":
									r = this.extensions[e.KHR_LIGHTS_PUNCTUAL].loadLight(n);
									break;
								default:
									throw new Error("Unknown type: " + t);
							}
							this.cache.add(i, r);
						}
						return r;
					}),
					(F.prototype.getDependencies = function (t) {
						var e = this.cache.get(t);
						if (!e) {
							var n = this,
								i = this.json[t + ("mesh" === t ? "es" : "s")] || [];
							(e = Promise.all(
								i.map(function (e, i) {
									return n.getDependency(t, i);
								})
							)),
								this.cache.add(t, e);
						}
						return e;
					}),
					(F.prototype.loadBuffer = function (t) {
						var n = this.json.buffers[t],
							i = this.fileLoader;
						if (n.type && "arraybuffer" !== n.type)
							throw new Error(
								"THREE.GLTFLoader: " + n.type + " buffer type is not supported."
							);
						if (void 0 === n.uri && 0 === t)
							return Promise.resolve(this.extensions[e.KHR_BINARY_GLTF].body);
						var r = this.options;
						return new Promise(function (t, e) {
							i.load(D(n.uri, r.path), t, void 0, function () {
								e(
									new Error(
										'THREE.GLTFLoader: Failed to load buffer "' + n.uri + '".'
									)
								);
							});
						});
					}),
					(F.prototype.loadBufferView = function (t) {
						var e = this.json.bufferViews[t];
						return this.getDependency("buffer", e.buffer).then(function (t) {
							var n = e.byteLength || 0,
								i = e.byteOffset || 0;
							return t.slice(i, i + n);
						});
					}),
					(F.prototype.loadAccessor = function (t) {
						var e = this,
							n = this.json,
							i = this.json.accessors[t];
						if (void 0 === i.bufferView && void 0 === i.sparse)
							return Promise.resolve(null);
						var r = [];
						return (
							void 0 !== i.bufferView
								? r.push(this.getDependency("bufferView", i.bufferView))
								: r.push(null),
							void 0 !== i.sparse &&
								(r.push(
									this.getDependency("bufferView", i.sparse.indices.bufferView)
								),
								r.push(
									this.getDependency("bufferView", i.sparse.values.bufferView)
								)),
							Promise.all(r).then(function (t) {
								var r,
									o = t[0],
									s = T[i.type],
									a = _[i.componentType],
									c = a.BYTES_PER_ELEMENT,
									l = c * s,
									h = i.byteOffset || 0,
									u =
										void 0 !== i.bufferView
											? n.bufferViews[i.bufferView].byteStride
											: void 0,
									d = !0 === i.normalized;
								if (u && u !== l) {
									var p = Math.floor(h / u),
										f =
											"InterleavedBuffer:" +
											i.bufferView +
											":" +
											i.componentType +
											":" +
											p +
											":" +
											i.count,
										m = e.cache.get(f);
									m ||
										((m = new zp(new a(o, p * u, (i.count * u) / c), u / c)),
										e.cache.add(f, m)),
										(r = new Up(m, s, (h % u) / c, d));
								} else r = new Nh(null === o ? new a(i.count * s) : new a(o, h, i.count * s), s, d);
								if (void 0 !== i.sparse) {
									var g = T.SCALAR,
										v = _[i.sparse.indices.componentType],
										y = i.sparse.indices.byteOffset || 0,
										x = i.sparse.values.byteOffset || 0,
										b = new v(t[1], y, i.sparse.count * g),
										w = new a(t[2], x, i.sparse.count * s);
									null !== o &&
										(r = new Nh(r.array.slice(), r.itemSize, r.normalized));
									for (var M = 0, S = b.length; M < S; M++) {
										var E = b[M];
										if (
											(r.setX(E, w[M * s]),
											s >= 2 && r.setY(E, w[M * s + 1]),
											s >= 3 && r.setZ(E, w[M * s + 2]),
											s >= 4 && r.setW(E, w[M * s + 3]),
											s >= 5)
										)
											throw new Error(
												"THREE.GLTFLoader: Unsupported itemSize in sparse BufferAttribute."
											);
									}
								}
								return r;
							})
						);
					}),
					(F.prototype.loadTexture = function (t) {
						var n,
							i = this,
							r = this.json,
							o = this.options,
							s = this.textureLoader,
							a = self.URL || self.webkitURL,
							c = r.textures[t],
							l = c.extensions || {},
							h = (n = l[e.MSFT_TEXTURE_DDS]
								? r.images[l[e.MSFT_TEXTURE_DDS].source]
								: r.images[c.source]).uri,
							u = !1;
						return (
							void 0 !== n.bufferView &&
								(h = i
									.getDependency("bufferView", n.bufferView)
									.then(function (t) {
										u = !0;
										var e = new Blob([t], { type: n.mimeType });
										return (h = a.createObjectURL(e));
									})),
							Promise.resolve(h)
								.then(function (t) {
									var n = o.manager.getHandler(t);
									return (
										n ||
											(n = l[e.MSFT_TEXTURE_DDS]
												? i.extensions[e.MSFT_TEXTURE_DDS].ddsLoader
												: s),
										new Promise(function (e, i) {
											var r = e;
											!0 === n.isImageBitmapLoader &&
												(r = function (t) {
													e(new Ff(t));
												}),
												n.load(D(t, o.path), r, void 0, i);
										})
									);
								})
								.then(function (e) {
									!0 === u && a.revokeObjectURL(h),
										(e.flipY = !1),
										c.name && (e.name = c.name),
										n.mimeType in O && (e.format = O[n.mimeType]);
									var o = (r.samplers || {})[c.sampler] || {};
									return (
										(e.magFilter = M[o.magFilter] || pa),
										(e.minFilter = M[o.minFilter] || ma),
										(e.wrapS = S[o.wrapS] || aa),
										(e.wrapT = S[o.wrapT] || aa),
										i.associations.set(e, { type: "textures", index: t }),
										e
									);
								})
						);
					}),
					(F.prototype.assignTexture = function (t, n, i) {
						var r = this;
						return this.getDependency("texture", i.index).then(function (o) {
							if (!o.isCompressedTexture)
								switch (n) {
									case "aoMap":
									case "emissiveMap":
									case "metalnessMap":
									case "normalMap":
									case "roughnessMap":
										o.format = Pa;
								}
							if (
								(void 0 === i.texCoord ||
									0 == i.texCoord ||
									("aoMap" === n && 1 == i.texCoord) ||
									console.warn(
										"THREE.GLTFLoader: Custom UV set " +
											i.texCoord +
											" for texture " +
											n +
											" not yet supported."
									),
								r.extensions[e.KHR_TEXTURE_TRANSFORM])
							) {
								var s =
									void 0 !== i.extensions
										? i.extensions[e.KHR_TEXTURE_TRANSFORM]
										: void 0;
								if (s) {
									var a = r.associations.get(o);
									(o = r.extensions[e.KHR_TEXTURE_TRANSFORM].extendTexture(
										o,
										s
									)),
										r.associations.set(o, a);
								}
							}
							t[n] = o;
						});
					}),
					(F.prototype.assignFinalMaterial = function (t) {
						var e = t.geometry,
							n = t.material,
							i = void 0 !== e.attributes.tangent,
							r = void 0 !== e.attributes.color,
							o = void 0 === e.attributes.normal,
							s = !0 === t.isSkinnedMesh,
							a = Object.keys(e.morphAttributes).length > 0,
							c = a && void 0 !== e.morphAttributes.normal;
						if (t.isPoints) {
							var l = "PointsMaterial:" + n.uuid,
								h = this.cache.get(l);
							h ||
								((h = new Pf()),
								Oh.prototype.copy.call(h, n),
								h.color.copy(n.color),
								(h.map = n.map),
								(h.sizeAttenuation = !1),
								this.cache.add(l, h)),
								(n = h);
						} else if (t.isLine) {
							l = "LineBasicMaterial:" + n.uuid;
							var u = this.cache.get(l);
							u ||
								((u = new yf()),
								Oh.prototype.copy.call(u, n),
								u.color.copy(n.color),
								this.cache.add(l, u)),
								(n = u);
						}
						if (i || r || o || s || a) {
							l = "ClonedMaterial:" + n.uuid + ":";
							n.isGLTFSpecularGlossinessMaterial &&
								(l += "specular-glossiness:"),
								s && (l += "skinning:"),
								i && (l += "vertex-tangents:"),
								r && (l += "vertex-colors:"),
								o && (l += "flat-shading:"),
								a && (l += "morph-targets:"),
								c && (l += "morph-normals:");
							var d = this.cache.get(l);
							d ||
								((d = n.clone()),
								s && (d.skinning = !0),
								i && (d.vertexTangents = !0),
								r && (d.vertexColors = !0),
								o && (d.flatShading = !0),
								a && (d.morphTargets = !0),
								c && (d.morphNormals = !0),
								this.cache.add(l, d),
								this.associations.set(d, this.associations.get(n))),
								(n = d);
						}
						n.aoMap &&
							void 0 === e.attributes.uv2 &&
							void 0 !== e.attributes.uv &&
							e.setAttribute("uv2", e.attributes.uv),
							n.normalScale && !i && (n.normalScale.y = -n.normalScale.y),
							n.clearcoatNormalScale &&
								!i &&
								(n.clearcoatNormalScale.y = -n.clearcoatNormalScale.y),
							(t.material = n);
					}),
					(F.prototype.getMaterialType = function () {
						return rg;
					}),
					(F.prototype.loadMaterial = function (t) {
						var n,
							i = this,
							r = this.json,
							o = this.extensions,
							s = r.materials[t],
							a = {},
							c = s.extensions || {},
							l = [];
						if (c[e.KHR_MATERIALS_PBR_SPECULAR_GLOSSINESS]) {
							var h = o[e.KHR_MATERIALS_PBR_SPECULAR_GLOSSINESS];
							(n = h.getMaterialType()), l.push(h.extendParams(a, s, i));
						} else if (c[e.KHR_MATERIALS_UNLIT]) {
							var d = o[e.KHR_MATERIALS_UNLIT];
							(n = d.getMaterialType()), l.push(d.extendParams(a, s, i));
						} else {
							var p = s.pbrMetallicRoughness || {};
							if (
								((a.color = new Eh(1, 1, 1)),
								(a.opacity = 1),
								Array.isArray(p.baseColorFactor))
							) {
								var f = p.baseColorFactor;
								a.color.fromArray(f), (a.opacity = f[3]);
							}
							void 0 !== p.baseColorTexture &&
								l.push(i.assignTexture(a, "map", p.baseColorTexture)),
								(a.metalness =
									void 0 !== p.metallicFactor ? p.metallicFactor : 1),
								(a.roughness =
									void 0 !== p.roughnessFactor ? p.roughnessFactor : 1),
								void 0 !== p.metallicRoughnessTexture &&
									(l.push(
										i.assignTexture(
											a,
											"metalnessMap",
											p.metallicRoughnessTexture
										)
									),
									l.push(
										i.assignTexture(
											a,
											"roughnessMap",
											p.metallicRoughnessTexture
										)
									)),
								(n = this._invokeOne(function (e) {
									return e.getMaterialType && e.getMaterialType(t);
								})),
								l.push(
									this._invokeAll(function (e) {
										return (
											e.extendMaterialParams && e.extendMaterialParams(t, a)
										);
									})
								);
						}
						!0 === s.doubleSided && (a.side = ms);
						var m = s.alphaMode || P;
						return (
							m === C
								? ((a.transparent = !0), (a.depthWrite = !1))
								: ((a.transparent = !1),
								  m === R &&
										(a.alphaTest =
											void 0 !== s.alphaCutoff ? s.alphaCutoff : 0.5)),
							void 0 !== s.normalTexture &&
								n !== Dh &&
								(l.push(i.assignTexture(a, "normalMap", s.normalTexture)),
								(a.normalScale = new Kc(1, 1)),
								void 0 !== s.normalTexture.scale &&
									a.normalScale.set(
										s.normalTexture.scale,
										s.normalTexture.scale
									)),
							void 0 !== s.occlusionTexture &&
								n !== Dh &&
								(l.push(i.assignTexture(a, "aoMap", s.occlusionTexture)),
								void 0 !== s.occlusionTexture.strength &&
									(a.aoMapIntensity = s.occlusionTexture.strength)),
							void 0 !== s.emissiveFactor &&
								n !== Dh &&
								(a.emissive = new Eh().fromArray(s.emissiveFactor)),
							void 0 !== s.emissiveTexture &&
								n !== Dh &&
								l.push(i.assignTexture(a, "emissiveMap", s.emissiveTexture)),
							Promise.all(l).then(function () {
								var r;
								return (
									(r =
										n === u
											? o[
													e.KHR_MATERIALS_PBR_SPECULAR_GLOSSINESS
											  ].createMaterial(a)
											: new n(a)),
									s.name && (r.name = s.name),
									r.map && (r.map.encoding = Dc),
									r.emissiveMap && (r.emissiveMap.encoding = Dc),
									k(r, s),
									i.associations.set(r, { type: "materials", index: t }),
									s.extensions && I(o, r, s),
									r
								);
							})
						);
					}),
					(F.prototype.loadGeometries = function (t) {
						var n = this,
							i = this.extensions,
							r = this.primitiveCache;
						function o(t) {
							return i[e.KHR_DRACO_MESH_COMPRESSION]
								.decodePrimitive(t, n)
								.then(function (e) {
									return z(e, t, n);
								});
						}
						for (var s, a, c = [], l = 0, h = t.length; l < h; l++) {
							var u,
								d = t[l],
								p =
									(void 0,
									(a =
										(s = d).extensions &&
										s.extensions[e.KHR_DRACO_MESH_COMPRESSION])
										? "draco:" +
										  a.bufferView +
										  ":" +
										  a.indices +
										  ":" +
										  B(a.attributes)
										: s.indices + ":" + B(s.attributes) + ":" + s.mode),
								f = r[p];
							if (f) c.push(f.promise);
							else
								(u =
									d.extensions && d.extensions[e.KHR_DRACO_MESH_COMPRESSION]
										? o(d)
										: z(new eu(), d, n)),
									(r[p] = { primitive: d, promise: u }),
									c.push(u);
						}
						return Promise.all(c);
					}),
					(F.prototype.loadMesh = function (t) {
						for (
							var e,
								n = this,
								i = this.json.meshes[t],
								r = i.primitives,
								o = [],
								s = 0,
								a = r.length;
							s < a;
							s++
						) {
							var c =
								void 0 === r[s].material
									? (void 0 === (e = this.cache).DefaultMaterial &&
											(e.DefaultMaterial = new rg({
												color: 16777215,
												emissive: 0,
												metalness: 1,
												roughness: 1,
												transparent: !1,
												depthTest: !0,
												side: ps,
											})),
									  e.DefaultMaterial)
									: this.getDependency("material", r[s].material);
							o.push(c);
						}
						return (
							o.push(n.loadGeometries(r)),
							Promise.all(o).then(function (e) {
								for (
									var o = e.slice(0, e.length - 1),
										s = e[e.length - 1],
										a = [],
										c = 0,
										l = s.length;
									c < l;
									c++
								) {
									var h,
										u = s[c],
										d = r[c],
										p = o[c];
									if (
										d.mode === x ||
										d.mode === b ||
										d.mode === w ||
										void 0 === d.mode
									)
										!0 !==
											(h = !0 === i.isSkinnedMesh ? new cf(u, p) : new xu(u, p))
												.isSkinnedMesh ||
											h.geometry.attributes.skinWeight.normalized ||
											h.normalizeSkinWeights(),
											d.mode === b
												? (h.geometry = H(h.geometry, 1))
												: d.mode === w && (h.geometry = H(h.geometry, Cc));
									else if (d.mode === g) h = new Af(u, p);
									else if (d.mode === y) h = new Sf(u, p);
									else if (d.mode === v) h = new Lf(u, p);
									else {
										if (d.mode !== m)
											throw new Error(
												"THREE.GLTFLoader: Primitive mode unsupported: " +
													d.mode
											);
										h = new If(u, p);
									}
									Object.keys(h.geometry.morphAttributes).length > 0 && N(h, i),
										(h.name = i.name || "mesh_" + t),
										s.length > 1 && (h.name += "_" + c),
										k(h, i),
										n.assignFinalMaterial(h),
										a.push(h);
								}
								if (1 === a.length) return a[0];
								var f = new Cp();
								for (c = 0, l = a.length; c < l; c++) f.add(a[c]);
								return f;
							})
						);
					}),
					(F.prototype.loadCamera = function (t) {
						var e,
							n = this.json.cameras[t],
							i = n[n.type];
						if (i)
							return (
								"perspective" === n.type
									? (e = new ku(
											Jc.radToDeg(i.yfov),
											i.aspectRatio || 1,
											i.znear || 1,
											i.zfar || 2e6
									  ))
									: "orthographic" === n.type &&
									  (e = new gv(
											-i.xmag,
											i.xmag,
											i.ymag,
											-i.ymag,
											i.znear,
											i.zfar
									  )),
								n.name && (e.name = n.name),
								k(e, n),
								Promise.resolve(e)
							);
						console.warn("THREE.GLTFLoader: Missing camera parameters.");
					}),
					(F.prototype.loadSkin = function (t) {
						var e = this.json.skins[t],
							n = { joints: e.joints };
						return void 0 === e.inverseBindMatrices
							? Promise.resolve(n)
							: this.getDependency("accessor", e.inverseBindMatrices).then(
									function (t) {
										return (n.inverseBindMatrices = t), n;
									}
							  );
					}),
					(F.prototype.loadAnimation = function (t) {
						for (
							var e = this.json.animations[t],
								n = [],
								i = [],
								r = [],
								o = [],
								s = [],
								a = 0,
								c = e.channels.length;
							a < c;
							a++
						) {
							var l = e.channels[a],
								h = e.samplers[l.sampler],
								u = l.target,
								d = void 0 !== u.node ? u.node : u.id,
								p = void 0 !== e.parameters ? e.parameters[h.input] : h.input,
								m = void 0 !== e.parameters ? e.parameters[h.output] : h.output;
							n.push(this.getDependency("node", d)),
								i.push(this.getDependency("accessor", p)),
								r.push(this.getDependency("accessor", m)),
								o.push(h),
								s.push(u);
						}
						return Promise.all([
							Promise.all(n),
							Promise.all(i),
							Promise.all(r),
							Promise.all(o),
							Promise.all(s),
						]).then(function (n) {
							for (
								var i = n[0],
									r = n[1],
									o = n[2],
									s = n[3],
									a = n[4],
									c = [],
									l = 0,
									h = i.length;
								l < h;
								l++
							) {
								var u = i[l],
									d = r[l],
									p = o[l],
									m = s[l],
									g = a[l];
								if (void 0 !== u) {
									var v;
									switch (
										(u.updateMatrix(), (u.matrixAutoUpdate = !0), A[g.path])
									) {
										case A.weights:
											v = wg;
											break;
										case A.rotation:
											v = Mg;
											break;
										case A.position:
										case A.scale:
										default:
											v = Tg;
									}
									var y = u.name ? u.name : u.uuid,
										x = void 0 !== m.interpolation ? L[m.interpolation] : 2301,
										b = [];
									A[g.path] === A.weights
										? u.traverse(function (t) {
												!0 === t.isMesh &&
													t.morphTargetInfluences &&
													b.push(t.name ? t.name : t.uuid);
										  })
										: b.push(y);
									var w = p.array;
									if (p.normalized) {
										var _;
										if (w.constructor === Int8Array) _ = 1 / 127;
										else if (w.constructor === Uint8Array) _ = 1 / 255;
										else if (w.constructor == Int16Array) _ = 1 / 32767;
										else {
											if (w.constructor !== Uint16Array)
												throw new Error(
													"THREE.GLTFLoader: Unsupported output accessor component type."
												);
											_ = 1 / 65535;
										}
										for (
											var M = new Float32Array(w.length), S = 0, T = w.length;
											S < T;
											S++
										)
											M[S] = w[S] * _;
										w = M;
									}
									for (S = 0, T = b.length; S < T; S++) {
										var E = new v(b[S] + "." + A[g.path], d.array, w, x);
										"CUBICSPLINE" === m.interpolation &&
											((E.createInterpolant = function (t) {
												return new f(
													this.times,
													this.values,
													this.getValueSize() / 3,
													t
												);
											}),
											(E.createInterpolant.isInterpolantFactoryMethodGLTFCubicSpline =
												!0)),
											c.push(E);
									}
								}
							}
							return new Eg(e.name ? e.name : "animation_" + t, void 0, c);
						});
					}),
					(F.prototype.loadNode = function (t) {
						var n,
							i = this.json,
							r = this.extensions,
							o = this,
							s = i.meshReferences,
							a = i.meshUses,
							c = i.nodes[t];
						return ((n = []),
						void 0 !== c.mesh &&
							n.push(
								o.getDependency("mesh", c.mesh).then(function (t) {
									var e;
									if (s[c.mesh] > 1) {
										var n = a[c.mesh]++;
										(e = t.clone()).name += "_instance_" + n;
									} else e = t;
									return (
										void 0 !== c.weights &&
											e.traverse(function (t) {
												if (t.isMesh)
													for (var e = 0, n = c.weights.length; e < n; e++)
														t.morphTargetInfluences[e] = c.weights[e];
											}),
										e
									);
								})
							),
						void 0 !== c.camera && n.push(o.getDependency("camera", c.camera)),
						c.extensions &&
							c.extensions[e.KHR_LIGHTS_PUNCTUAL] &&
							void 0 !== c.extensions[e.KHR_LIGHTS_PUNCTUAL].light &&
							n.push(
								o.getDependency(
									"light",
									c.extensions[e.KHR_LIGHTS_PUNCTUAL].light
								)
							),
						Promise.all(n)).then(function (e) {
							var n;
							if (
								(n =
									!0 === c.isBone
										? new df()
										: e.length > 1
										? new Cp()
										: 1 === e.length
										? e[0]
										: new kl()) !== e[0]
							)
								for (var i = 0, s = e.length; i < s; i++) n.add(e[i]);
							if (
								(c.name &&
									((n.userData.name = c.name),
									(n.name = fy.sanitizeNodeName(c.name))),
								k(n, c),
								c.extensions && I(r, n, c),
								void 0 !== c.matrix)
							) {
								var a = new vl();
								a.fromArray(c.matrix), n.applyMatrix4(a);
							} else void 0 !== c.translation && n.position.fromArray(c.translation), void 0 !== c.rotation && n.quaternion.fromArray(c.rotation), void 0 !== c.scale && n.scale.fromArray(c.scale);
							return o.associations.set(n, { type: "nodes", index: t }), n;
						});
					}),
					(F.prototype.loadScene = (function () {
						function t(e, n, i, r) {
							var o = i.nodes[e];
							return r
								.getDependency("node", e)
								.then(function (t) {
									return void 0 === o.skin
										? t
										: r
												.getDependency("skin", o.skin)
												.then(function (t) {
													for (
														var n = [], i = 0, o = (e = t).joints.length;
														i < o;
														i++
													)
														n.push(r.getDependency("node", e.joints[i]));
													return Promise.all(n);
												})
												.then(function (n) {
													return (
														t.traverse(function (t) {
															if (t.isMesh) {
																for (
																	var i = [], r = [], o = 0, s = n.length;
																	o < s;
																	o++
																) {
																	var a = n[o];
																	if (a) {
																		i.push(a);
																		var c = new vl();
																		void 0 !== e.inverseBindMatrices &&
																			c.fromArray(
																				e.inverseBindMatrices.array,
																				16 * o
																			),
																			r.push(c);
																	} else
																		console.warn(
																			'THREE.GLTFLoader: Joint "%s" could not be found.',
																			e.joints[o]
																		);
																}
																t.bind(new uf(i, r), t.matrixWorld);
															}
														}),
														t
													);
												});
									var e;
								})
								.then(function (e) {
									n.add(e);
									var s = [];
									if (o.children)
										for (var a = o.children, c = 0, l = a.length; c < l; c++) {
											var h = a[c];
											s.push(t(h, e, i, r));
										}
									return Promise.all(s);
								});
						}
						return function (e) {
							var n = this.json,
								i = this.extensions,
								r = this.json.scenes[e],
								o = new Cp();
							r.name && (o.name = r.name), k(o, r), r.extensions && I(i, o, r);
							for (
								var s = r.nodes || [], a = [], c = 0, l = s.length;
								c < l;
								c++
							)
								a.push(t(s[c], o, n, this));
							return Promise.all(a).then(function () {
								return o;
							});
						};
					})()),
					t
				);
			})(),
			Nx = (function () {
				function t(e) {
					p()(this, t),
						this._bind(),
						(this.el = e),
						(this.bounds = {
							width: _.windowWidth,
							height: _.windowHeight,
							mouseX: 0,
							headerHeight: _.isGreaterThan767 ? 100 : 80,
						}),
						(this.domEmojis = Array.prototype.slice.call(
							document.querySelectorAll(".nav-emoji")
						)),
						(this.domEmojiTriggers = Array.prototype.slice.call(
							document.querySelectorAll(".mode-triggers .trigger")
						)),
						(this.domLogo = document.querySelector(".logo")),
						(this.emojiDrawerOpen = !1),
						(this.tieDie = document.querySelector(".third-media")),
						(this.emojis = {}),
						(this.emojiList = []),
						(this.mode = 0),
						(this.pointerEventEls = _.isGreaterThan767
							? M.header.querySelectorAll(".logo, .nav-emoji")
							: M.header.querySelectorAll(".logo, .nav-emoji:not(.contact)")),
						(this.darkMode = !1),
						(this.emojiGutter = _.isMobile ? 40 : 50),
						(this.mobileOffset = _.isMobile ? 15 : 0),
						(this.gltfLoader = new kx()),
						(this.backdropZindex = 1),
						(this.modelsLoaded = 0),
						(this.headerIn = !1),
						(this.dom = {
							email: document.querySelector(".domgl-email"),
							lollipop: document.querySelector(".domgl-lollipop"),
							heart: document.querySelector(".domgl-heart"),
						}),
						this.init(),
						this._addEvents(),
						this.run();
				}
				return (
					m()(t, [
						{
							key: "_bind",
							value: function () {
								var t = this;
								["run", "onResize", "hideShowLogo"].forEach(function (e) {
									return (t[e] = t[e].bind(t));
								});
							},
						},
						{
							key: "_addEvents",
							value: function () {
								var t = this;
								this.domEmojiTriggers.forEach(function (e, n) {
									e.addEventListener("click", function () {
										var e;
										if (
											(er.to(t.emojiList[n].scene.rotation, 0.5, {
												y: 6,
												ease: "sine.inOut",
												onUpdate: function () {
													S.renderer.render(S.scene, S.camera);
												},
												onComplete: function () {
													er.set(t.emojiList[n].scene.rotation, { y: 0 }),
														S.renderer.render(S.scene, S.camera);
												},
											}),
											er.set(t.hitboxBounds[n], { lerpedEase: 0.03 }),
											er.delayedCall(0.52, function () {
												er.to(t.hitboxBounds[n], 0.5, {
													lerpedEase: 0.1,
													ease: "sine.inOut",
												});
											}),
											0 === n)
										)
											er.to(t.emojiList[n].scene.rotation, 0.5, {
												x: 0,
												ease: "sine.inOut",
											}),
												(e = _.tripMode ? (t.darkMode ? 0 : 2) : 1),
												t.setMode(e);
										else if (t.mode !== n) {
											var i;
											(i = _.tripMode ? 1 : t.darkMode ? 0 : 2), t.setMode(i);
										}
									});
								}),
									this.domLogo.addEventListener("click", function () {
										"home" === _.namespace &&
											er.to(document.documentElement, {
												scrollTop: 0,
												duration: 0.8,
												ease: "expo.inOut",
											});
									}),
									_.isMobile ||
										(this.domEmojis[1].addEventListener(
											"mouseenter",
											function () {
												t.revealOtherEmojis();
											}
										),
										this.domEmojis[1].addEventListener(
											"mouseleave",
											function () {
												t.hideOtherEmojis();
											}
										)),
									_.isMobile ||
										(this.domLogo.addEventListener("mousedown", function () {
											er.to(t.sphere.position, {
												z: -120,
												duration: 0.5,
												ease: "expo.out",
												onUpdate: function () {
													S.renderer.render(S.scene, S.camera);
												},
											});
										}),
										this.domLogo.addEventListener("mouseup", function () {
											er.to(t.sphere.position, {
												z: -100,
												duration: 1,
												ease: "expo.out",
												onUpdate: function () {
													S.renderer.render(S.scene, S.camera);
												},
											});
										}),
										this.hitboxBounds.forEach(function (e, n) {
											var i;
											e.el.addEventListener("mouseenter", function () {
												(i = 0 === n ? t.emojis.email : t.emojiList[n - 1]),
													(e.prevX = i.scene.rotation.x),
													(e.prevY = i.scene.rotation.y),
													er.to(e, 0.5, {
														lerpedEase: 0.1,
														ease: "sine.inOut",
													});
											}),
												e.el.addEventListener("mouseleave", function () {
													er.set(e, { lerpedEase: 0.03 });
												}),
												e.el.addEventListener(
													"mousemove",
													function (r) {
														i = 0 === n ? t.emojis.email : t.emojiList[n - 1];
														var o = t.getValues(r, e, n);
														(e.prevX = y(e.prevX, o.tiltX, e.lerpedEase)),
															(e.prevY = y(e.prevY, o.tiltY, e.lerpedEase)),
															er.set(i.scene.rotation, {
																x: e.prevX,
																y: e.prevY,
															}),
															S.renderer.render(S.scene, S.camera);
													},
													{ passive: !0 }
												),
												e.el.addEventListener("mouseleave", function () {
													(i = 0 === n ? t.emojis.email : t.emojiList[n - 1]),
														er.to(i.scene.rotation, 0.5, {
															y: 0,
															x: 0,
															ease: "sine.inOut",
															onUpdate: function () {
																S.renderer.render(S.scene, S.camera);
															},
														});
												});
										}));
							},
						},
						{
							key: "onResize",
							value: function () {
								this.getBounds(),
									(S.camera.left = -_.windowWidth / 2),
									(S.camera.right = _.windowWidth / 2),
									(S.camera.top = _.windowHeight / 2),
									(S.camera.bottom = -_.windowHeight / 2),
									S.camera.updateProjectionMatrix(),
									S.renderer.setSize(this.bounds.width, this.bounds.height),
									(this.emojis.lollipop.origY = this.coords[0].y),
									(this.emojis.lollipop.hiddenY =
										this.coords[2].y + this.bounds.headerHeight),
									(this.emojis.heart.origY = this.coords[0].y),
									(this.emojis.heart.hiddenY =
										this.coords[2].y + this.bounds.headerHeight),
									(this.emojis.email.origY = this.coords[0].y),
									(this.emojis.email.hiddenY =
										this.coords[2].y + this.bounds.headerHeight),
									this.sphere.position.set(0, this.coords[0].y, -100),
									this.emojis.email.scene.position.set(
										this.coords[2].x,
										this.coords[2].y,
										-100
									),
									this.emojis.heart.scene.position.set(
										this.coords[1].x,
										this.coords[1].y,
										-100
									),
									this.emojis.lollipop.scene.position.set(
										this.coords[0].x,
										this.coords[0].y,
										-100
									),
									S.renderer.render(S.scene, S.camera),
									this.hideOtherEmojis();
							},
						},
						{
							key: "getBounds",
							value: function () {
								(this.bounds.width = _.windowWidth),
									(this.bounds.height = _.windowHeight);
								var t = this.dom.email.getBoundingClientRect(),
									e = this.dom.lollipop.getBoundingClientRect(),
									n = this.dom.heart.getBoundingClientRect();
								this.coords = [
									{
										type: "lollipop",
										x: e.left + e.width / 2 - _.windowWidth / 2,
										y: _.windowHeight / 2 - (e.top + e.height / 2),
									},
									{
										type: "heart",
										x: n.left + n.width / 2 - _.windowWidth / 2,
										y: _.windowHeight / 2 - (n.top + n.height / 2),
									},
									{
										type: "email",
										x: t.left + t.width / 2 - _.windowWidth / 2,
										y: _.windowHeight / 2 - (t.top + t.height / 2),
									},
								];
							},
						},
						{
							key: "loadModels",
							value: function () {
								var t = this;
								_.isGreaterThan767 &&
									this.gltfLoader.load(
										`${domain_url}assets/emoji/envelope.glb`,
										function (e) {
											e.scene.scale.set(0.09, 0.09, 0.09),
												e.scene.position.set(
													t.coords[2].x,
													t.coords[2].y,
													-100
												);
											var n = e.scene.children[0].children[0].material;
											n.color.setHex(16737126),
												(n.roughness = 0.45),
												(n.metalness = 0.12),
												(n.emissiveIntensity = 1),
												(n.needsUpdate = !0),
												console.log(n),
												t.domEmojis[0].addEventListener("click", function () {
													er.to(e.scene.rotation, {
														y: 6,
														duration: 0.5,
														ease: "sine.inOut",
														onUpdate: function () {
															S.renderer.render(S.scene, S.camera);
														},
														onComplete: function () {
															er.set(e.scene.rotation, { y: 0 }),
																S.renderer.render(S.scene, S.camera);
														},
													}),
														er.set(t.hitboxBounds[0], { lerpedEase: 0.03 });
												}),
												(t.emojis.email = {
													origY: e.scene.position.y,
													hiddenY: t.coords[2].y + t.bounds.headerHeight,
													scene: e.scene,
												}),
												S.scene.add(e.scene),
												er.set(t.emojis.email.scene.position, {
													y: t.emojis.email.hiddenY,
												}),
												er.set(t.emojis.email.scene.rotation, { y: 6 }),
												t.modelsLoaded++;
										}
									);
								var e = new zg();
								(this.whiteHeartTexture = !1), (this.heartMaterial = !1);
								e.load(
									`${domain_url}/assets/emoji/heart-test.glb`,
									function (e) {
										(e.flipY = !1),
											t.heartMaterial
												? (t.heartMaterial.emissiveMap = t.whiteHeartTexture)
												: (t.whiteHeartTexture = e);
									}
								),
									this.gltfLoader.load(
										`${domain_url}/assets/emoji/heart-test.glb`,
										function (e) {
											e.scene.scale.set(0.08, 0.08, 0.08),
												e.scene.position.set(
													t.coords[1].x,
													t.coords[1].y,
													-100
												),
												e.scene.traverse(function (e) {
													e instanceof xu &&
														((e.userData.emissiveMap = e.material.emissiveMap),
														t.whiteHeartTexture
															? (e.material.emissiveMap = t.whiteHeartTexture)
															: (t.heartMaterial = e.material),
														(e.material.emissive = new Eh(14277081)),
														e.material.color.setHex(15921906),
														(e.material.roughness = 0.45),
														(e.material.metalness = 0.12),
														(e.material.emissiveIntensity = 0.85),
														(e.receiveShadow = !1),
														(e.castShadow = !1),
														(e.material.needsUpdate = !0));
												}),
												(e.scene.children[0].material.depthWrite = !0),
												(t.emojis.heart = {
													origY: e.scene.position.y,
													hiddenY: t.coords[2].y + t.bounds.headerHeight,
													scene: e.scene,
												}),
												t.modelsLoaded++,
												(t.emojiList[1] = t.emojis.heart),
												S.scene.add(e.scene),
												er.set(t.emojis.heart.scene.rotation, { y: 6 }),
												er.set(t.emojis.heart.scene.position, {
													y: t.emojis.heart.hiddenY,
												});
										}
									),
									this.gltfLoader.load(
										`${domain_url}assets/emoji/lollipop.glb`,
										function (e) {
											e.scene.scale.set(0.085, 0.085, 0.085),
												e.scene.position.set(
													t.coords[0].x,
													t.coords[0].y,
													-100
												),
												(t.emojis.lollipop = {
													origY: e.scene.position.y,
													hiddenY: t.coords[2].y + t.bounds.headerHeight,
													scene: e.scene,
												}),
												(t.emojiList[0] = t.emojis.lollipop),
												S.scene.add(e.scene),
												er.set(t.emojis.lollipop.scene.rotation, { y: -6 }),
												er.set(t.emojis.lollipop.scene.position, {
													y: t.emojis.lollipop.hiddenY,
												}),
												t.modelsLoaded++;
										}
									);
								var n = new zm(20, 20, 20),
									i = new og({
										color: new Eh(16777215),
										emissive: new Eh(7829367),
										roughness: 0,
										metalness: 0,
									});
								(this.sphere = new xu(n, i)),
									this.sphere.position.set(0, this.coords[0].y, -100),
									S.scene.add(this.sphere),
									(this.sphere.receiveShadow = !1),
									(this.sphere.castShadow = !0);
								var r = new Xu(_.isMobile ? 60 : 100, 100),
									o = new ng();
								(o.opacity = 0.7),
									(this.plane = new xu(r, o)),
									this.plane.position.set(0, this.coords[0].y, -120),
									(this.plane.castShadow = !1),
									(this.plane.receiveShadow = !0),
									S.scene.add(this.plane),
									(this.dummy = this.sphere.clone()),
									this.dummy.position.set(0, this.coords[0].y, -100),
									(this.dummy.visible = !1),
									S.scene.add(this.dummy),
									(this.directionalLight.target = this.dummy),
									er.set(
										[
											this.sphere.position,
											this.plane.position,
											this.dummy.position,
										],
										{ y: this.coords[2].y + this.bounds.headerHeight }
									),
									this.modelsLoaded++;
							},
						},
						{
							key: "init",
							value: function () {
								var t = this;
								this.getBounds(), this.getHitboxPositions();
								var e = new yv(16777215, 0.5);
								S.scene.add(e),
									e.position.set(40, 0.5 * this.bounds.height, 50),
									(e.castShadow = !0),
									(e.shadow.mapSize.width = 4096),
									(e.shadow.mapSize.height = 4096),
									(e.shadow.camera.near = 1),
									(e.shadow.camera.far = 400),
									(e.shadow.camera.left = -_.windowWidth / 2),
									(e.shadow.camera.right = _.windowWidth / 2),
									(e.shadow.camera.top = _.windowHeight / 2),
									(e.shadow.camera.bottom = -_.windowHeight / 2),
									(this.directionalLight = e),
									this.loadModels();
								var n = document.querySelector(".logo-hitbox"),
									i = n.getBoundingClientRect(),
									r = {
										el: n,
										top: i.top,
										left: i.left,
										width: i.width,
										height: i.height,
										prevShiftX: 40,
										prevShiftY: 0.5 * this.bounds.height,
										lerpedEase: 0.03,
									};
								n.addEventListener("mouseenter", function (t) {
									er.fromTo(
										r,
										0.5,
										{ lerpedEase: 0.03 },
										{ lerpedEase: 0.12, ease: "sine.inOut" }
									);
								}),
									n.addEventListener(
										"mousemove",
										function (n) {
											var i = t.get2DValues(n, r);
											(r.prevShiftX = y(r.prevShiftX, i.shiftX, r.lerpedEase)),
												(r.prevShiftY = y(
													r.prevShiftY,
													i.shiftY,
													r.lerpedEase
												)),
												er.set(e.position, {
													x: r.prevShiftX,
													y: r.prevShiftY,
												}),
												S.renderer.render(S.scene, S.camera);
										},
										{ passive: !0 }
									),
									n.addEventListener("mouseleave", function () {
										(r.prevShiftX = 40),
											(r.prevShiftY = 0.5 * t.bounds.height),
											er.set(r, { lerpedEase: 0.03 }),
											er.to(e.position, 0.45, {
												x: 40,
												y: 0.5 * t.bounds.height,
												ease: "sine.inOut",
												onUpdate: function () {
													S.renderer.render(S.scene, S.camera);
												},
											});
									});
							},
						},
						{
							key: "showHeader",
							value: function () {
								er.set(this.pointerEventEls, { pointerEvents: "all" }),
									_.isGreaterThan767
										? this.showEmail(!1)
										: er.fromTo(
												M.hammy,
												0.7,
												{ autoAlpha: 0, y: -Cx.bounds.headerHeight },
												{ autoAlpha: 1, y: 0, ease: "sine.inOut", force3D: !0 }
										  ),
									_.tripMode ? this.showLollipop(!1) : this.showHeart(!1),
									this.showLogo(!1),
									this.renderCycle(0.8);
							},
						},
						{
							key: "hideHeader",
							value: function () {
								er.set(this.pointerEventEls, { pointerEvents: "none" }),
									_.isGreaterThan767
										? this.hideEmail(!1)
										: er.to(M.hammy, 0.7, {
												y: -Cx.bounds.headerHeight,
												ease: "sine.inOut",
										  }),
									_.tripMode ? this.hideLollipop(!1) : this.hideHeart(!1),
									this.hideLogo(!1),
									this.renderCycle(0.8);
							},
						},
						{
							key: "hideEmail",
							value: function () {
								var t =
									!(arguments.length > 0 && void 0 !== arguments[0]) ||
									arguments[0];
								er.to(this.emojis.email.scene.position, 0.7, {
									y: this.emojis.email.hiddenY,
									ease: "sine.inOut",
								}),
									er.to(this.emojis.email.scene.rotation, 0.8, {
										y: 6,
										ease: "sine.inOut",
									}),
									t && this.renderCycle(0.8);
							},
						},
						{
							key: "hideLollipop",
							value: function () {
								var t =
									!(arguments.length > 0 && void 0 !== arguments[0]) ||
									arguments[0];
								er.to(this.emojis.lollipop.scene.rotation, 0.8, {
									y: 6,
									ease: "sine.inOut",
								}),
									er.to(this.emojis.lollipop.scene.position, 0.7, {
										y: this.emojis.lollipop.hiddenY,
										ease: "sine.inOut",
									}),
									t && this.renderCycle(0.8);
							},
						},
						{
							key: "hideHeart",
							value: function () {
								var t =
									!(arguments.length > 0 && void 0 !== arguments[0]) ||
									arguments[0];
								er.to(this.emojis.heart.scene.rotation, 0.8, {
									y: 6,
									ease: "sine.inOut",
								}),
									er.to(this.emojis.heart.scene.position, 0.7, {
										y: this.emojis.heart.hiddenY,
										ease: "sine.inOut",
									}),
									t && this.renderCycle(0.8);
							},
						},
						{
							key: "hideLogo",
							value: function () {
								var t =
									!(arguments.length > 0 && void 0 !== arguments[0]) ||
									arguments[0];
								er.to(
									[
										this.sphere.position,
										this.plane.position,
										this.dummy.position,
									],
									0.7,
									{ y: this.emojis.lollipop.hiddenY, ease: "sine.inOut" }
								),
									t && this.renderCycle(0.8);
							},
						},
						{
							key: "showEmail",
							value: function () {
								var t =
									!(arguments.length > 0 && void 0 !== arguments[0]) ||
									arguments[0];
								er.to(this.emojis.email.scene.position, 0.7, {
									y: this.emojis.email.origY,
									ease: "sine.inOut",
								}),
									er.to(this.emojis.email.scene.rotation, 0.8, {
										y: 0,
										ease: "sine.inOut",
									}),
									t && this.renderCycle(0.8);
							},
						},
						{
							key: "showLollipop",
							value: function () {
								var t =
									!(arguments.length > 0 && void 0 !== arguments[0]) ||
									arguments[0];
								er.to(this.emojis.lollipop.scene.rotation, 0.8, {
									y: 0,
									ease: "sine.inOut",
								}),
									er.to(this.emojis.lollipop.scene.position, 0.7, {
										y: this.emojis.lollipop.origY,
										ease: "sine.inOut",
									}),
									t && this.renderCycle(0.8);
							},
						},
						{
							key: "showHeart",
							value: function () {
								var t =
									!(arguments.length > 0 && void 0 !== arguments[0]) ||
									arguments[0];
								er.to(this.emojis.heart.scene.rotation, 0.8, {
									y: 0,
									ease: "sine.inOut",
								}),
									er.to(this.emojis.heart.scene.position, 0.7, {
										y: this.emojis.heart.origY,
										ease: "sine.inOut",
									}),
									t && this.renderCycle(0.8);
							},
						},
						{
							key: "showLogo",
							value: function () {
								var t =
									!(arguments.length > 0 && void 0 !== arguments[0]) ||
									arguments[0];
								er.to(
									[
										this.sphere.position,
										this.plane.position,
										this.dummy.position,
									],
									0.7,
									{ y: this.coords[0].y, ease: "sine.inOut" }
								),
									t && this.renderCycle(0.7);
							},
						},
						{
							key: "renderCycle",
							value: function (t) {
								er.to({ x: 0 }, t, {
									x: 100,
									ease: "none",
									onUpdate: function () {
										S.renderer.render(S.scene, S.camera);
									},
								});
							},
						},
						{
							key: "getValues",
							value: function (t, e, n) {
								var i, r;
								return (
									(i = (t.clientX - e.left) / e.width),
									(r = (t.clientY - e.top) / e.height),
									(i = Math.min(Math.max(i, 0), 1)),
									(r = Math.min(Math.max(r, 0), 1)),
									{
										tiltY: (-1 * (1.3 - 1.3 * i * 2)).toFixed(2),
										tiltX: (1.3 * r * 2 - 1.3).toFixed(2),
									}
								);
							},
						},
						{
							key: "get2DValues",
							value: function (t, e) {
								var n, i;
								(n = (t.clientX - e.left) / e.width),
									(i = (t.clientY - e.top) / e.height),
									(n = Math.min(Math.max(n, 0), 1)),
									(i = Math.min(Math.max(i, 0), 1));
								var r = v(n, 0, 1, -150, 150);
								return {
									shiftY: v(
										i,
										0,
										1,
										0.5 * this.bounds.height + 60,
										0.5 * this.bounds.height - 200
									),
									shiftX: r,
								};
							},
						},
						{
							key: "getHitboxPositions",
							value: function () {
								(this.emojiHitboxes =
									document.querySelectorAll("#header .hitbox")),
									(this.hitboxBounds = []);
								for (var t = 0; t < this.emojiHitboxes.length; t++) {
									var e = this.emojiHitboxes[t],
										n = e.getBoundingClientRect();
									this.hitboxBounds.push({
										el: e,
										top: n.top,
										left: n.left,
										width: n.width,
										height: n.height,
										prevX: 0,
										prevY: 0,
										lerpedEase: 0.03,
									});
								}
							},
						},
						{
							key: "revealOtherEmojis",
							value: function () {
								this.emojiDrawerOpen ||
									((this.emojiDrawerOpen = !0),
									_.tripMode ? this.showHeart() : this.showLollipop());
							},
						},
						{
							key: "hideOtherEmojis",
							value: function () {
								console.log("hiding other emojis"),
									this.emojiDrawerOpen &&
										((this.emojiDrawerOpen = !1),
										_.tripMode ? this.hideHeart() : this.hideLollipop());
							},
						},
						{
							key: "setMode",
							value: function (t) {
								var e = this;
								(this.mode = t), this.backdropZindex++;
								var n = document.querySelectorAll(".custom-font");
								switch (this.mode) {
									case 0:
										M.tieDieMedia.paused || M.tieDieMedia.pause(),
											er.to("html", 0.5, {
												"--primary": "#FFFFFF",
												ease: "sine.out",
											}),
											er.set("html", { "--secondary": "#000000" }),
											er.set(M.drawers, {
												"--primary": "#000000",
												"--secondary": "#FFFFFF",
											}),
											"work" === _.namespace &&
												M.workMobileFilterEl &&
												er.set(M.workMobileFilterEl, {
													clearProps: "--primary, --secondary",
												}),
											er.set(M.blackBackdrop, { zIndex: this.backdropZindex }),
											er.to(M.blackBackdrop, 0.5, {
												opacity: 1,
												onComplete: function () {
													er.set(M.whiteBackdrop, { opacity: 0 });
												},
											}),
											er.to(n, 0.25, {
												opacity: 0,
												ease: "sine.out",
												onComplete: function () {
													er.set(document.body, {
														"--font": "white-theme-font",
														"--font2": "black-theme-font",
														"--font3": "third-theme-font",
													}),
														er.to(n, 0.25, { opacity: 1, ease: "sine.out" });
												},
											}),
											(_.tripMode = !1),
											(this.darkMode = !1),
											this.emojis.heart.scene.traverse(function (t) {
												t instanceof xu &&
													((t.material.emissiveMap = e.whiteHeartTexture),
													(t.material.emissive = new Eh(14277081)),
													t.material.color.setHex(15921906),
													(t.material.needsUpdate = !0));
											}),
											er.to(this.tieDie, {
												autoAlpha: 0,
												duration: 0.5,
												ease: "sine.inOut",
												force3D: !0,
											}),
											er.to(this.emojis.heart.scene.position, {
												x: this.coords[1].x,
												duration: 0.5,
												ease: "sine.inOut",
												onUpdate: function () {
													S.renderer.render(S.scene, S.camera);
												},
											}),
											er.to(this.emojis.lollipop.scene.position, {
												x: this.coords[0].x,
												duration: 0.5,
												ease: "sine.inOut",
												onUpdate: function () {
													S.renderer.render(S.scene, S.camera);
												},
											}),
											(this.emojiList = [
												this.emojis.lollipop,
												this.emojis.heart,
											]);
										break;
									case 1:
										M.tieDieMedia.paused && M.tieDieMedia.play(),
											er.to("html", 0.5, {
												"--primary": "#ffffff",
												ease: "sine.out",
											}),
											er.set("html", { "--secondary": "#000000" }),
											er.set(M.drawers, {
												"--primary": "#000000",
												"--secondary": "#ffffff",
											}),
											"work" === _.namespace &&
												M.workMobileFilterEl &&
												er.set(M.workMobileFilterEl, {
													"--primary": "#000000",
													"--secondary": "#ffffff",
												}),
											er.to(n, 0.25, {
												opacity: 0,
												ease: "sine.out",
												onComplete: function () {
													er.set(document.body, {
														"--font": "third-theme-font",
														"--font2": "white-theme-font",
														"--font3": "black-theme-font",
													}),
														er.to(n, 0.25, { opacity: 1, ease: "sine.out" });
												},
											}),
											er.set(M.whiteBackdrop, { zIndex: this.backdropZindex }),
											er.to(M.whiteBackdrop, 0.5, {
												opacity: 1,
												onComplete: function () {
													er.set(M.blackBackdrop, { opacity: 0 });
												},
											}),
											(_.tripMode = !0),
											er.to(this.tieDie, {
												autoAlpha: 1,
												duration: 0.5,
												ease: "sine.inOut",
												force3D: !0,
												onComplete: function () {},
											}),
											er.to(this.emojis.heart.scene.position, {
												x: this.coords[0].x,
												duration: 0.5,
												ease: "sine.inOut",
												onUpdate: function () {
													S.renderer.render(S.scene, S.camera);
												},
											}),
											er.to(this.emojis.lollipop.scene.position, {
												x: this.coords[1].x,
												duration: 0.5,
												ease: "sine.inOut",
												onUpdate: function () {
													S.renderer.render(S.scene, S.camera);
												},
											}),
											(this.emojiList = [
												this.emojis.heart,
												this.emojis.lollipop,
											]);
										break;
									case 2:
										M.tieDieMedia.paused || M.tieDieMedia.pause(),
											er.to("html", 0.5, {
												"--primary": "#000000",
												ease: "sine.out",
											}),
											er.set("html", { "--secondary": "#ffffff" }),
											er.set(M.drawers, {
												"--primary": "#ffffff",
												"--secondary": "#000000",
											}),
											"work" === _.namespace &&
												M.workMobileFilterEl &&
												er.set(M.workMobileFilterEl, {
													clearProps: "--primary, --secondary",
												}),
											er.to(n, 0.25, {
												opacity: 0,
												ease: "sine.out",
												onComplete: function () {
													er.set(document.body, {
														"--font": "black-theme-font",
														"--font2": "white-theme-font",
														"--font3": "third-theme-font",
													}),
														er.to(n, 0.25, { opacity: 1, ease: "sine.out" });
												},
											}),
											er.set(M.whiteBackdrop, { zIndex: this.backdropZindex }),
											er.to(M.whiteBackdrop, 0.5, {
												opacity: 1,
												onComplete: function () {
													er.set(M.blackBackdrop, { opacity: 0 });
												},
											}),
											(_.tripMode = !1),
											(this.darkMode = !0),
											this.emojis.heart.scene.traverse(function (t) {
												t instanceof xu &&
													((t.material.emissiveMap = t.userData.emissiveMap),
													t.material.color.setHex(3355443),
													(t.material.needsUpdate = !0));
											}),
											er.to(this.tieDie, {
												autoAlpha: 0,
												duration: 0.5,
												ease: "sine.inOut",
												force3D: !0,
											}),
											er.to(this.emojis.heart.scene.position, {
												x: this.coords[1].x,
												duration: 0.5,
												ease: "sine.inOut",
												onUpdate: function () {
													S.renderer.render(S.scene, S.camera);
												},
											}),
											er.to(this.emojis.lollipop.scene.position, {
												x: this.coords[0].x,
												duration: 0.5,
												ease: "sine.inOut",
												onUpdate: function () {
													S.renderer.render(S.scene, S.camera);
												},
											}),
											(this.emojiList = [
												this.emojis.lollipop,
												this.emojis.heart,
											]);
								}
							},
						},
						{
							key: "run",
							value: function (t) {
								(this.raf = requestAnimationFrame(this.run)),
									(this.counter += 0.01);
							},
						},
						{
							key: "hideShowLogo",
							value: function () {
								document.body.scrollTop > 10 && this.logoShowing
									? (this.logoShowing = !1)
									: document.body.scrollTop < 10 &&
									  !this.logoShowing &&
									  (this.logoShowing = !0);
							},
						},
						{
							key: "kill",
							value: function () {
								cancelAnimationFrame(this.raf);
							},
						},
					]),
					t
				);
			})(),
			Bx = n(5),
			Fx = n.n(Bx),
			zx = (function () {
				function t(e) {
					p()(this, t),
						e &&
							(x(this, ["hide", "show"]),
							(this.dom = { el: e, close: e.querySelector(".close") }),
							(this.state = { isOpen: !1 }),
							(this.fadeOutPoint = 999999999),
							this.setupDom(),
							this.addEvents());
				}
				return (
					m()(t, [
						{
							key: "addEvents",
							value: function () {
								var t = this;
								this.dom.close.addEventListener("click", function () {
									t.hide();
								}),
									er.delayedCall(15, this.hide);
							},
						},
						{
							key: "setupDom",
							value: function () {
								er.set(this.dom.el, { yPercent: 108, autoAlpha: 1 }),
									er.set(this.dom.close, { yPercent: 100 });
							},
						},
						{
							key: "hide",
							value: function () {
								var t =
										arguments.length > 0 && void 0 !== arguments[0]
											? arguments[0]
											: 0.5,
									e =
										arguments.length > 1 && void 0 !== arguments[1]
											? arguments[1]
											: "expo.in";
								this.state.isOpen &&
									((this.state.isOpen = !1),
									er.to(this.dom.el, t, {
										yPercent: 100,
										ease: e,
										display: "none",
									}));
							},
						},
						{
							key: "show",
							value: function () {
								var t =
										arguments.length > 0 && void 0 !== arguments[0]
											? arguments[0]
											: 0.6,
									e =
										arguments.length > 1 && void 0 !== arguments[1]
											? arguments[1]
											: "expo.out";
								this.state.isOpen ||
									((this.state.isOpen = !0),
									"object" === Fx()(Ax) && null !== Ax.data
										? (this.fadeOutPoint = Ax.data.current + _.windowHeight)
										: (this.fadeOutPoint =
												document.documentElement.scrollTop + _.windowHeight),
									er.to([this.dom.el, this.dom.close], t, {
										yPercent: 0,
										stagger: 0.05,
										ease: e,
									}));
							},
						},
					]),
					t
				);
			})(),
			Hx = (function () {
				function t() {
					p()(this, t),
						(this.timeline = new er.timeline()),
						(this.inProgress = "none"),
						(this.aboutEntranceActive = !1),
						er.set(M.aboutHand, { xPercent: 100, opacity: 1 });
				}
				return (
					m()(t, [
						{
							key: "openAboutMenu",
							value: function () {
								var t = this;
								(this.inProgress = "menuOpen"),
									this.timeline.clear(),
									this.aboutEntranceActive
										? this.timeline.to(M.aboutHand, 1.2, {
												scale: 0.79,
												yPercent: -9,
												rotation: -7,
												xPercent: 2,
												ease: "power3.out",
												force3D: !0,
										  })
										: this.timeline
												.set(M.aboutHand, { scale: 0.79, yPercent: -16 })
												.to(M.aboutHand, 1.2, {
													yPercent: -9,
													rotation: -7,
													xPercent: 2,
													ease: "power3.out",
													force3D: !0,
												}),
									this.timeline.to(M.aboutHand, 0.9, {
										immediateRender: !1,
										rotation: 12,
										yPercent: -14,
										xPercent: 100,
										ease: "power3.inOut",
										force3D: !0,
										onComplete: function () {
											t.inProgress = "none";
										},
									});
							},
						},
						{
							key: "aboutPageEntrance",
							value: function () {
								var t = this;
								(this.aboutEntranceActive = !0),
									(this.inProgress = "pageEntrance"),
									this.timeline.clear(),
									this.timeline
										.set(M.aboutHand, { scale: 1 })
										.fromTo(
											M.aboutHand,
											1.8,
											{ rotation: 40, yPercent: 0, xPercent: 100 },
											{
												xPercent: 2,
												yPercent: 4,
												rotation: -5,
												ease: "power3.out",
												force3D: !0,
											}
										)
										.to(
											M.aboutHand,
											1,
											{
												immediateRender: !1,
												rotation: 10,
												yPercent: -10,
												xPercent: 100,
												ease: "power3.inOut",
												force3D: !0,
												onComplete: function () {
													t.aboutEntranceActive = !1;
												},
											},
											"-=.3"
										);
							},
						},
						{
							key: "closeAboutMenu",
							value: function () {
								var t = this;
								(this.inProgress = "menuClose"),
									this.timeline.clear(),
									this.timeline.to(M.aboutHand, 1.5, {
										rotation: 10,
										yPercent: -10,
										xPercent: 100,
										ease: "power3.out",
										force3D: !0,
										onComplete: function () {
											t.inProgress = "none";
										},
									});
							},
						},
					]),
					t
				);
			})(),
			Ux = (function () {
				function t(e) {
					p()(this, t),
						(this.isMobile = _.isMobile),
						this.bindMethods(),
						(this.el = e.querySelector(".drawer-content")),
						(this.thisDrawerTLs = []),
						(this.offsetVal = 0),
						(this.transitioning = !1),
						(this.scrolledMediaCount = 0),
						(this.scrolledMediaFired = 0),
						(this.type = e.classList.contains("work") ? "work" : "about");
					var n = this.el.querySelectorAll("[data-d-entrance]"),
						i = this.el.querySelectorAll(".media-within");
					(this.dom = { el: this.el, scrollBasedElems: n, scrolledMedia: i }),
						(this.scrollBasedElems = null),
						(this.raf = null),
						(this.state = { resizing: !1 }),
						(this.data = {
							threshold: 200,
							current: 0,
							last: 0,
							height: 0,
							max: 0,
						});
					for (var r = this.dom.scrollBasedElems.length, o = 0; o < r; o++) {
						var s = this.dom.scrollBasedElems[o],
							a = s.dataset.dEntrance,
							c = new er.timeline({ paused: !0 });
						switch (a) {
							case "stagger-fade":
								var l = s.querySelectorAll(".s-el");
								c.fromTo(
									l,
									1.1,
									{ y: 40, opacity: 0 },
									{
										y: 0,
										opacity: 1,
										clearProps: "transform",
										ease: "power3.out",
										stagger: 0.12,
										force3D: !0,
									}
								),
									this.thisDrawerTLs.push(c);
								break;
							case "basic-fade":
								c.fromTo(
									s,
									1.1,
									{ y: 40, opacity: 0 },
									{
										y: 0,
										opacity: 1,
										clearProps: "transform",
										ease: "power3.out",
										force3D: !0,
									}
								),
									this.thisDrawerTLs.push(c);
								break;
							case "basic-fade-up":
								c.fromTo(
									s,
									1,
									{ scale: 0.965, opacity: 0 },
									{
										scale: 1,
										opacity: 1,
										clearProps: "transform",
										ease: "power3.out",
										force3D: !0,
									}
								),
									this.thisDrawerTLs.push(c);
								break;
							case "wipe-bg":
								var h = s.querySelector(".wipe-bg"),
									u = s.querySelectorAll("a");
								er.set(u, { opacity: 0 }),
									c
										.to(h, 1.2, {
											scaleY: 1,
											ease: "expo.out",
											force3D: !0,
											transformOrigin: "50% 0%",
										})
										.set(u, { opacity: 1 })
										.to(h, 1, {
											scaleY: 0,
											ease: "expo.out",
											clearProps: "transform",
											force3D: !0,
											transformOrigin: "50% 100%",
										}),
									this.thisDrawerTLs.push(c);
						}
					}
					this.init();
				}
				return (
					m()(t, [
						{
							key: "bindMethods",
							value: function () {
								var t = this;
								["run", "resize"].forEach(function (e) {
									return (t[e] = t[e].bind(t));
								});
							},
						},
						{
							key: "init",
							value: function () {
								this.on(), console.log("drawer init", this);
							},
						},
						{
							key: "on",
							value: function () {
								this.getBounding(), this.getCache();
							},
						},
						{
							key: "run",
							value: function () {
								this.state.resizing ||
									this.transitioning ||
									((this.data.current = this.el.scrollTop),
									this.checkScrolledMedia(),
									this.playPauseVideos(),
									this.checkScrollBasedLoadins(),
									this.requestAnimationFrame());
							},
						},
						{
							key: "playPauseVideos",
							value: function () {
								if (0 !== this.data.current)
									for (var t = 0; t < this.videosDataLength; t++) {
										var e = this.videosData[t],
											n = this.isVisible(e, 50).isVisible;
										n
											? e.playing || (e.el.play(), (e.playing = !0))
											: !n &&
											  e.playing &&
											  (e.el.pause(),
											  (e.el.currentTime = 0),
											  (e.playing = !1));
									}
							},
						},
						{
							key: "getVideos",
							value: function () {
								var t = this.el.querySelectorAll("video.d-auto");
								this.videosData = [];
								for (var e = 0; e < t.length; e++) {
									var n = t[e].getBoundingClientRect();
									this.videosData.push({
										el: t[e],
										playing: !1,
										top: n.top,
										bottom: n.bottom,
									});
								}
								this.videosDataLength = this.videosData.length;
							},
						},
						{
							key: "getScrollBasedSections",
							value: function () {
								if (this.dom.scrollBasedElems) {
									this.scrollBasedElems = [];
									for (
										var t = this.dom.scrollBasedElems.length, e = 0;
										e < t;
										e++
									)
										if (!(e < this.offsetVal)) {
											var n = this.dom.scrollBasedElems[e],
												i = n.getBoundingClientRect();
											this.scrollBasedElems.push({
												el: n,
												played: !1,
												top: i.top,
												bottom: i.bottom,
												height: i.bottom - i.top,
												offset:
													_.windowWidth < 768
														? n.dataset.offsetMobile * _.windowHeight
														: n.dataset.offset * _.windowHeight,
											});
										}
								}
							},
						},
						{
							key: "checkScrollBasedLoadins",
							value: function () {
								if (
									0 !== this.data.current &&
									this.scrollBasedElems &&
									this.thisDrawerTLs.length !== this.offsetVal
								)
									for (
										var t = this.scrollBasedElems.length, e = 0;
										e < t;
										e++
									) {
										var n = this.scrollBasedElems[e];
										n.played ||
											(this.data.current + n.offset > n.top &&
												(this.thisDrawerTLs[this.offsetVal].play(),
												this.offsetVal++,
												(n.played = !0)));
									}
							},
						},
						{
							key: "getScrolledMedia",
							value: function () {
								if (this.dom.scrolledMedia) {
									this.scrolledMediaData = [];
									for (var t = 0; t < this.dom.scrolledMedia.length; t++) {
										var e = this.dom.scrolledMedia[t],
											n = e.getBoundingClientRect();
										this.scrolledMediaCount++,
											this.scrolledMediaData.push({
												mediaEls: e.querySelectorAll(".preload"),
												loaded: !1,
												top: n.top,
												bottom: n.bottom,
												height: n.bottom - n.top,
											});
									}
								}
							},
						},
						{
							key: "checkScrolledMedia",
							value: function () {
								if (
									0 !== this.data.current &&
									this.scrolledMediaData &&
									this.scrolledMediaFired !== this.scrolledMediaCount
								)
									for (var t = 0; t < this.scrolledMediaData.length; t++) {
										var e = this.scrolledMediaData[t];
										e.loaded ||
											(this.data.current + _.windowHeight > e.top &&
												(Ix.loadImages(e.mediaEls, "nodeList", function () {}),
												this.scrolledMediaFired++,
												(e.loaded = !0)));
									}
							},
						},
						{
							key: "requestAnimationFrame",
							value: (function (t) {
								function e() {
									return t.apply(this, arguments);
								}
								return (
									(e.toString = function () {
										return t.toString();
									}),
									e
								);
							})(function () {
								this.raf = requestAnimationFrame(this.run);
							}),
						},
						{
							key: "cancelAnimationFrame",
							value: (function (t) {
								function e() {
									return t.apply(this, arguments);
								}
								return (
									(e.toString = function () {
										return t.toString();
									}),
									e
								);
							})(function () {
								cancelAnimationFrame(this.raf);
							}),
						},
						{
							key: "getCache",
							value: function () {
								this.getVideos(),
									this.getScrolledMedia(),
									this.getScrollBasedSections();
							},
						},
						{
							key: "isVisible",
							value: function (t, e) {
								var n = e || this.data.threshold,
									i = t.top - this.data.current,
									r = t.bottom - this.data.current,
									o = i < n + this.data.height && r > -n;
								return { isVisible: o, start: i, end: r };
							},
						},
						{
							key: "getBounding",
							value: function () {
								(this.data.height = _.windowHeight),
									(this.data.max =
										this.el.querySelector(".inner").getBoundingClientRect()
											.height - this.data.height);
							},
						},
						{
							key: "resize",
							value: function () {
								var t =
									arguments.length > 0 &&
									void 0 !== arguments[0] &&
									arguments[0];
								(this.state.resizing = !0),
									t || (this.getCache(), this.getBounding()),
									(this.state.resizing = !1);
							},
						},
						{
							key: "destroy",
							value: function () {
								(this.transitioning = !0),
									(this.state.rafCancelled = !0),
									this.cancelAnimationFrame(),
									(this.dom = null),
									(this.data = null),
									(this.raf = null);
							},
						},
					]),
					t
				);
			})(),
			Gx = [],
			Vx = new er.timeline({
				paused: !0,
				repeat: -1,
				onReverseComplete: function () {
					Vx.pause();
				},
			});
		Vx.fromTo(M.bttHand, 0.7, { y: 0 }, { y: 20, ease: "sine.out" }).to(
			M.bttHand,
			0.7,
			{ y: 0, ease: "sine.out" }
		);
		var jx = function () {
				var t,
					e =
						arguments.length > 0 && void 0 !== arguments[0]
							? arguments[0]
							: null;
				if (
					((_.namespace = e),
					(t = _.isGreaterThan767
						? document.querySelectorAll(".dr")
						: document.querySelectorAll(".mr")).length > 0)
				)
					for (var n = 0; n < t.length; n++)
						t[n].parentElement.removeChild(t[n]);
				_.isMobile ||
					(function () {
						for (
							var t = document.querySelectorAll(
									".work-tile:not(.fw) .cover:not(.bound), .view-work .featured-project .cover"
								),
								e = function (e) {
									var n = t[e];
									n.classList.add("bound");
									var i = !1;
									n.addEventListener("mouseenter", function () {
										i && i.kill(),
											(i = er.to(n, 13, {
												scale: 1.09,
												force3D: !0,
												ease: "sine.out",
											}));
									}),
										n.addEventListener("mouseleave", function () {
											i && i.kill(),
												(i = er.to(n, 1.3, {
													scale: 1,
													force3D: !0,
													clearProps: "transform",
													ease: "expo.out",
												}));
										});
								},
								n = 0;
							n < t.length;
							n++
						)
							e(n);
					})();
				var i = document.querySelectorAll(".preload-critical");
				if (i.length > 0)
					Ix.loadImages(i, "nodeList", function (t) {
						ir();
						var n = setInterval(function () {
							if (!0 === _.transitionFinished) {
								clearInterval(n),
									nr(e),
									setTimeout(function () {
										Ax = new Yo({});
									}, 50),
									rr();
								var t = document.querySelectorAll('a[href^="mailto:"]');
								Array.prototype.slice.call(t).forEach(function (t) {
									or(t);
								}),
									sr();
								var i = document.querySelectorAll(
									".switch-text:not(.is-bound)"
								);
								if (
									(Array.prototype.slice.call(i).forEach(function (t) {
										ar(t);
									}),
									!_.isMobile)
								) {
									var r = document.querySelectorAll(
										".parallax-hover:not(.is-bound)"
									);
									Array.prototype.slice.call(r).forEach(function (t) {
										Gx.push(new Zo(t));
									});
								}
							}
						}, 20);
					});
				else {
					ir();
					var r = setInterval(function () {
						if (!0 === _.transitionFinished) {
							clearInterval(r),
								nr(e),
								setTimeout(function () {
									Ax = new Yo({});
								}, 50),
								rr();
							var t = document.querySelectorAll('a[href^="mailto:"]');
							Array.prototype.slice.call(t).forEach(function (t) {
								or(t);
							}),
								sr();
							var n = document.querySelectorAll(".switch-text:not(.is-bound)");
							if (
								(Array.prototype.slice.call(n).forEach(function (t) {
									ar(t);
								}),
								!_.isMobile)
							) {
								var i = document.querySelectorAll(
									".parallax-hover:not(.is-bound)"
								);
								Array.prototype.slice.call(i).forEach(function (t) {
									Gx.push(new Zo(t));
								});
							}
						}
					}, 20);
				}
			},
			Wx = n(3),
			qx = n.n(Wx),
			Yx = n(4),
			Xx = n.n(Yx),
			Zx = n(2),
			Jx = n.n(Zx);
		function Kx(t) {
			var e = (function () {
				if ("undefined" == typeof Reflect || !Reflect.construct) return !1;
				if (Reflect.construct.sham) return !1;
				if ("function" == typeof Proxy) return !0;
				try {
					return (
						Date.prototype.toString.call(
							Reflect.construct(Date, [], function () {})
						),
						!0
					);
				} catch (t) {
					return !1;
				}
			})();
			return function () {
				var n,
					i = Jx()(t);
				if (e) {
					var r = Jx()(this).constructor;
					n = Reflect.construct(i, arguments, r);
				} else n = i.apply(this, arguments);
				return Xx()(this, n);
			};
		}
		var Qx = (function (t) {
				qx()(n, t);
				var e = Kx(n);
				function n() {
					return p()(this, n), e.apply(this, arguments);
				}
				return (
					m()(n, [
						{ key: "onEnter", value: function () {} },
						{ key: "onEnterCompleted", value: function () {} },
						{ key: "onLeave", value: function () {} },
						{ key: "onLeaveCompleted", value: function () {} },
					]),
					n
				);
			})(u.Renderer),
			$x = (function () {
				function t(e, n) {
					if ((p()(this, t), e && n)) {
						x(this, ["filter", "setFilter", "clearFilter", "setActiveTrigger"]),
							(this.dom = {
								filterWrapper: e,
								filterItemsWrapper: n,
								triggers: e.querySelectorAll(".filter-el"),
								filterItems: n.querySelectorAll(".work-tile"),
							}),
							(this.currentFilter = null),
							this._addEvents();
						var i = b();
						i && i.filter
							? (this.setFilter(i.filter, !0), this.setActiveTrigger(i.filter))
							: er.set(".view-work .work-grid", { opacity: 1 });
					}
				}
				return (
					m()(t, [
						{
							key: "_addEvents",
							value: function () {
								var t = this;
								this.dom.triggers.forEach(function (e) {
									var n = e.dataset.filter;
									"all" === n
										? e.addEventListener("click", function () {
												t.clearFilter(), t.setActiveTrigger(n);
										  })
										: e.addEventListener("click", function () {
												t.setFilter(n), t.setActiveTrigger(n);
										  });
								});
							},
						},
						{
							key: "setActiveTrigger",
							value: function (t) {
								for (
									var e = this.dom.filterWrapper.querySelector(
											"[data-filter=".concat(t, "]")
										),
										n = this.dom.triggers.length,
										i = 0;
									i < n;
									i++
								) {
									this.dom.triggers[i].classList.remove("is-active");
								}
								e.classList.add("is-active");
							},
						},
						{
							key: "clearFilter",
							value: function () {
								var t = this;
								this.animateWrapperOut(function () {
									t.currentFilter = null;
									for (var e = t.dom.filterItems.length, n = 0; n < e; n++) {
										var i = t.dom.filterItems[n],
											r = "work-tile";
										if (0 === n) {
											r += " fw featured-project hide-context";
											var o = i.querySelectorAll(".cover");
											o[0].classList.remove("hidden"),
												o[1].classList.add("hidden");
										} else r += n % 2 == 0 ? " is-right" : " is-left";
										i.setAttribute("class", r),
											i.querySelector(".preload") &&
												i.classList.add("media-within");
									}
									Ax && "function" == typeof Ax.resize && Ax.resize(),
										t.animateWrapperIn();
								});
							},
						},
						{
							key: "setFilter",
							value: function (t, e) {
								var n = this;
								if (((this.currentFilter = t), e))
									this.currentFilter && this.filter(!0);
								else {
									this.animateWrapperOut(function () {
										n.currentFilter && n.filter();
									});
								}
							},
						},
						{
							key: "filter",
							value: function () {
								for (
									var t =
											arguments.length > 0 &&
											void 0 !== arguments[0] &&
											arguments[0],
										e = this.dom.filterItems.length,
										n = 0,
										i = 0;
									i < e;
									i++
								) {
									var r = this.dom.filterItems[i],
										o = void 0;
									if (
										(r.dataset.filters.includes(this.currentFilter)
											? ((o = n % 2 == 0 ? "is-left" : "is-right"), (n += 1))
											: (o = "is-hidden"),
										r.classList.remove("fw"),
										r.classList.contains("featured-project"))
									) {
										var s = r.querySelectorAll(".cover");
										s[0].classList.add("hidden"),
											s[1].classList.remove("hidden");
									}
									r.classList.remove("featured-project"),
										r.classList.remove("is-left"),
										r.classList.remove("is-right"),
										r.classList.remove("is-hidden"),
										r.classList.add(o),
										r.querySelector(".preload") &&
											r.classList.add("media-within");
								}
								if (t) {
									var a = document.querySelectorAll(
										".view-work .work-grid .work-tile:nth-child(-n + 4) .preload"
									);
									setTimeout(function () {
										Ix.loadImages(a, "nodeList", function () {});
									}, 100),
										Ax && "function" == typeof Ax.resize && Ax.resize();
								} else
									Ax.resize(),
										Ax.checkScrolledMedia(!0),
										Ax.checkScrollBasedLoadins(!0);
								this.animateWrapperIn();
							},
						},
						{
							key: "animateWrapperOut",
							value: function (t) {
								er.to(this.dom.filterItemsWrapper, 0.4, {
									y: 40,
									opacity: 0,
									ease: "sine.in",
									force3D: !0,
									onComplete: t,
								});
							},
						},
						{
							key: "animateWrapperIn",
							value: function () {
								er.to(this.dom.filterItemsWrapper, 0.3, {
									y: 0,
									opacity: 1,
									ease: "sine.out",
									force3D: !0,
									clearProps: "transform",
								});
							},
						},
					]),
					t
				);
			})();
		function tb(t) {
			var e = (function () {
				if ("undefined" == typeof Reflect || !Reflect.construct) return !1;
				if (Reflect.construct.sham) return !1;
				if ("function" == typeof Proxy) return !0;
				try {
					return (
						Date.prototype.toString.call(
							Reflect.construct(Date, [], function () {})
						),
						!0
					);
				} catch (t) {
					return !1;
				}
			})();
			return function () {
				var n,
					i = Jx()(t);
				if (e) {
					var r = Jx()(this).constructor;
					n = Reflect.construct(i, arguments, r);
				} else n = i.apply(this, arguments);
				return Xx()(this, n);
			};
		}
		var eb = (function (t) {
				qx()(n, t);
				var e = tb(n);
				function n() {
					return p()(this, n), e.apply(this, arguments);
				}
				return (
					m()(n, [
						{
							key: "onEnter",
							value: function () {
								_.isGreaterThan767 ||
									(M.workMobileFilterEl = document.querySelector(
										".mobile-filter-wrapper"
									));
							},
						},
						{
							key: "onEnterCompleted",
							value: function () {
								var t = this,
									e = setInterval(function () {
										if (Ax && "function" == typeof Ax.resize) {
											clearInterval(e);
											var n =
													(_.windowWidth || window.innerWidth) < 768
														? document.querySelectorAll(
																".hero .mobile-filter-wrapper"
														  )
														: document.querySelectorAll(
																".hero .filter-wrapper"
														  ),
												i = document.querySelectorAll(".view-work .work-grid"),
												r = n[n.length - 1],
												o = i[i.length - 1];
											t.filter = new $x(r, o);
										}
									}, 10);
							},
						},
						{ key: "onLeave", value: function () {} },
						{ key: "onLeaveCompleted", value: function () {} },
					]),
					n
				);
			})(u.Renderer),
			nb = (function () {
				function t(e) {
					p()(this, t),
						(this.slider = e),
						(this.allSlides = e.querySelectorAll(".slide-outer")),
						(this.slidesLength = this.allSlides.length),
						(this.prevTrigger = e.querySelector(".left")),
						(this.nextTrigger = e.querySelector(".right")),
						(this.prevBtn = e.querySelector(".nav-buttons .prev")),
						(this.nextBtn = e.querySelector(".nav-buttons .next")),
						_.isMobile ||
							((this.prevArrow = e.querySelector(".slider-arrow.prev")),
							(this.nextArrow = e.querySelector(".slider-arrow.next")),
							(this.prevArrowInner = this.prevArrow.querySelector(".inner")),
							(this.nextArrowInner = this.nextArrow.querySelector(".inner")),
							(this.prevArrowTL = new er.timeline()),
							(this.nextArrowTL = new er.timeline())),
						this.init();
				}
				return (
					m()(t, [
						{
							key: "init",
							value: function () {
								this.getCache(),
									this.bindEvents(),
									_.isMobile || this.setupEls(),
									console.log(this);
							},
						},
						{
							key: "getCache",
							value: function () {
								if (
									((this.data = {
										thisSlideIdx: 0,
										prevSlideIdx: 0,
										forwardTL: new er.timeline(),
										backwardTL: new er.timeline(),
										animating: !1,
										zIndex: 3,
										indexNum: this.slider.querySelector(".index .current"),
									}),
									!_.isMobile)
								) {
									var t = this.slider
										.querySelector(".ar-wrapper")
										.getBoundingClientRect();
									this.data.sliderEdges = {
										top: t.top,
										left: t.left,
										right: t.right,
										bottom: t.bottom,
										xCenter: t.width / 2 + t.left,
									};
									var e = this.prevArrow.getBoundingClientRect();
									(this.data.arrowWidth = e.width / 2),
										(this.data.arrowHeight = e.height / 2),
										(this.data.xReversePrevPos = 0),
										(this.data.yReversePrevPos = 0),
										(this.data.xforwardPrevPos = 0),
										(this.data.yforwardPrevPos = 0);
								}
							},
						},
						{
							key: "bindEvents",
							value: function () {
								var t = this;
								this.prevTrigger.addEventListener("click", function () {
									!0 !== t.data.animating &&
										((t.data.animating = !0), t.reverse());
								}),
									this.nextTrigger.addEventListener("click", function () {
										!0 !== t.data.animating &&
											((t.data.animating = !0), t.forward());
									}),
									this.prevBtn.addEventListener("click", function () {
										!0 !== t.data.animating &&
											((t.data.animating = !0), t.reverse());
									}),
									this.nextBtn.addEventListener("click", function () {
										!0 !== t.data.animating &&
											((t.data.animating = !0), t.forward());
									}),
									_.isMobile ||
										(this.prevTrigger.addEventListener(
											"mouseenter",
											function () {
												t.showArrow("prev");
											}
										),
										this.prevTrigger.addEventListener(
											"mouseleave",
											function () {
												t.hideArrow("prev");
											}
										),
										this.prevTrigger.addEventListener(
											"mousemove",
											function (e) {
												t.prevMouseMove(e);
											},
											{ passive: !0 }
										),
										this.nextTrigger.addEventListener(
											"mouseenter",
											function () {
												t.showArrow("next");
											}
										),
										this.nextTrigger.addEventListener(
											"mouseleave",
											function () {
												t.hideArrow("next");
											}
										),
										this.nextTrigger.addEventListener(
											"mousemove",
											function (e) {
												t.nextMouseMove(e);
											},
											{ passive: !0 }
										));
							},
						},
						{
							key: "setupEls",
							value: function () {
								er.set([this.prevArrowInner, this.nextArrowInner], {
									opacity: 0,
									scale: 0.35,
								});
							},
						},
						{
							key: "swapSliderIndex",
							value: function () {
								var t =
										arguments.length > 0 &&
										void 0 !== arguments[0] &&
										arguments[0],
									e =
										arguments.length > 1 &&
										void 0 !== arguments[1] &&
										arguments[1];
								this.data.zIndex++,
									(this.data.prevSlideIdx = this.data.thisSlideIdx),
									this.pauseVideo(this.allSlides[this.data.prevSlideIdx]),
									!1 === t
										? e
											? (this.data.thisSlideIdx--,
											  this.data.thisSlideIdx < 0 &&
													(this.data.thisSlideIdx = this.slidesLength - 1))
											: (this.data.thisSlideIdx++,
											  this.data.thisSlideIdx === this.slidesLength &&
													(this.data.thisSlideIdx = 0))
										: (this.data.thisSlideIdx = t),
									this.playVideo(this.allSlides[this.data.thisSlideIdx]),
									er.set(this.allSlides[this.data.prevSlideIdx], {
										zIndex: this.data.zIndex,
									}),
									er.set(this.allSlides[this.data.thisSlideIdx], {
										zIndex: this.data.zIndex + 1,
									}),
									(this.data.indexNum.textContent =
										this.data.thisSlideIdx + 1 > 9
											? this.data.thisSlideIdx + 1
											: "0" + (this.data.thisSlideIdx + 1));
							},
						},
						{
							key: "showArrow",
							value: function (t) {
								"prev" === t
									? (this.prevArrowTL.clear(),
									  this.prevArrowTL.to(
											this.prevArrowInner,
											0.5,
											{ opacity: 1, scale: 1, ease: "expo.out" },
											0
									  ))
									: (this.nextArrowTL.clear(),
									  this.nextArrowTL.to(
											this.nextArrowInner,
											0.5,
											{ opacity: 1, scale: 1, ease: "expo.out" },
											0
									  ));
							},
						},
						{
							key: "hideArrow",
							value: function (t) {
								"prev" === t
									? (this.prevArrowTL.clear(),
									  this.prevArrowTL.to(
											this.prevArrowInner,
											0.5,
											{
												opacity: 0,
												scale: 0.35,
												ease: "expo.out",
												force3D: !0,
											},
											0
									  ))
									: (this.nextArrowTL.clear(),
									  this.nextArrowTL.to(
											this.nextArrowInner,
											0.5,
											{
												opacity: 0,
												scale: 0.35,
												ease: "expo.out",
												force3D: !0,
											},
											0
									  ));
							},
						},
						{
							key: "prevMouseMove",
							value: function (t) {
								var e = Math.min(
										t.pageX - this.data.sliderEdges.left,
										this.data.sliderEdges.xCenter
									),
									n = Math.min(
										Math.max(0, t.pageY - this.data.sliderEdges.top),
										this.data.sliderEdges.bottom - this.data.arrowHeight
									),
									i = e - this.data.arrowWidth,
									r = n - this.data.arrowHeight;
								e > this.data.arrowWidth &&
									e <
										this.data.sliderEdges.xCenter -
											this.data.arrowWidth -
											this.data.sliderEdges.left &&
									er.set(this.prevArrow, { x: i, force3D: !0 }),
									n > this.data.arrowHeight &&
										n <
											this.data.sliderEdges.bottom -
												this.data.arrowHeight -
												this.data.sliderEdges.top &&
										er.set(this.prevArrow, { y: r, force3D: !0 });
							},
						},
						{
							key: "nextMouseMove",
							value: function (t) {
								var e = Math.min(
										t.pageX - this.data.sliderEdges.xCenter,
										this.data.sliderEdges.right
									),
									n = Math.min(
										Math.max(0, t.pageY - this.data.sliderEdges.top),
										this.data.sliderEdges.bottom
									),
									i = e - this.data.arrowWidth,
									r = n - this.data.arrowHeight;
								e > this.data.arrowWidth &&
									er.set(this.nextArrow, { x: i, force3D: !0 }),
									n > this.data.arrowHeight &&
										er.set(this.nextArrow, { y: r, force3D: !0 });
							},
						},
						{
							key: "playVideo",
							value: function (t) {
								var e = t.querySelector("video");
								if (e)
									try {
										e.play();
									} catch (t) {
										console.log(t);
									}
							},
						},
						{
							key: "pauseVideo",
							value: function (t) {
								var e = t.querySelector("video");
								e && e.pause();
							},
						},
						{
							key: "forward",
							value: function () {
								var t = this,
									e =
										arguments.length > 0 &&
										void 0 !== arguments[0] &&
										arguments[0];
								er.delayedCall(0.7, function () {
									t.data.animating = !1;
								}),
									this.swapSliderIndex(e),
									this.data.forwardTL.clear(),
									this.data.forwardTL.fromTo(
										this.allSlides[this.data.thisSlideIdx],
										1.05,
										{ xPercent: 100, opacity: 1 },
										{ xPercent: 0, ease: "expo.out", force3D: !0 }
									);
							},
						},
						{
							key: "reverse",
							value: function () {
								var t = this,
									e =
										arguments.length > 0 &&
										void 0 !== arguments[0] &&
										arguments[0];
								er.delayedCall(0.7, function () {
									t.data.animating = !1;
								}),
									this.swapSliderIndex(e, !0),
									this.data.backwardTL.clear(),
									this.data.backwardTL.fromTo(
										this.allSlides[this.data.thisSlideIdx],
										1.05,
										{ xPercent: -100, opacity: 1 },
										{ xPercent: 0, ease: "expo.out", force3D: !0 }
									);
							},
						},
					]),
					t
				);
			})();
		function ib(t) {
			var e = (function () {
				if ("undefined" == typeof Reflect || !Reflect.construct) return !1;
				if (Reflect.construct.sham) return !1;
				if ("function" == typeof Proxy) return !0;
				try {
					return (
						Date.prototype.toString.call(
							Reflect.construct(Date, [], function () {})
						),
						!0
					);
				} catch (t) {
					return !1;
				}
			})();
			return function () {
				var n,
					i = Jx()(t);
				if (e) {
					var r = Jx()(this).constructor;
					n = Reflect.construct(i, arguments, r);
				} else n = i.apply(this, arguments);
				return Xx()(this, n);
			};
		}
		var rb = (function (t) {
				qx()(n, t);
				var e = ib(n);
				function n() {
					return p()(this, n), e.apply(this, arguments);
				}
				return (
					m()(n, [
						{ key: "onEnter", value: function () {} },
						{
							key: "onEnterCompleted",
							value: function () {
								for (
									var t = document.querySelectorAll(".slider"), e = 0;
									e < t.length;
									e++
								)
									new nb(t[e]);
							},
						},
						{ key: "onLeave", value: function () {} },
						{ key: "onLeaveCompleted", value: function () {} },
					]),
					n
				);
			})(u.Renderer),
			ob = (function () {
				function t(e, n) {
					if ((p()(this, t), e && n)) {
						x(this, ["kill", "open", "close", "onKeyDown", "setupDom"]);
						var i = e.querySelectorAll("button, a");
						(this.dom = {
							el: e,
							trigger: n,
							bgColor: e.querySelector(".bg-color"),
							scrollWrapper: e.querySelector(".scroll-wrapper"),
							backdrop: e.querySelector(".backdrop"),
							headline: e.querySelector("h2"),
							subHeadline: e.querySelector(".left p"),
							copy: e.querySelector(".right p"),
							close: e.querySelector(".close"),
							interactiveFirst: i[0],
							interactiveLast: i[i.length - 1],
						}),
							(this.isOpen = !1),
							(this.tl = er.timeline()),
							this.setupDom(),
							this.addEvents();
					}
				}
				return (
					m()(t, [
						{
							key: "addEvents",
							value: function () {
								this.dom.backdrop.addEventListener("click", this.close),
									this.dom.close.addEventListener("click", this.close),
									this.dom.trigger.addEventListener("click", this.open),
									document.addEventListener("keydown", this.onKeyDown);
							},
						},
						{
							key: "setupDom",
							value: function () {
								this.isOpen ||
									(er.set(this.dom.close, { scale: 0 }),
									er.set(
										[this.dom.headline, this.dom.subHeadline, this.dom.copy],
										{ y: 13, opacity: 0 }
									),
									er.set(this.dom.scrollWrapper, { yPercent: 4 }),
									er.set(this.dom.bgColor, { opacity: 0 }),
									er.set(M.header, { zIndex: 99 }));
							},
						},
						{
							key: "onKeyDown",
							value: function () {
								27 === event.keyCode && this.isOpen && this.close();
							},
						},
						{
							key: "open",
							value: function () {
								var t = this;
								this.isOpen ||
									((this.isOpen = !0),
									this.tl.clear(),
									this.tl
										.set(M.header, { zIndex: 7, pointerEvents: "none" })
										.set(this.dom.el, { autoAlpha: 1, pointerEvents: "all" })
										.to(
											this.dom.scrollWrapper,
											0.3,
											{ yPercent: 0, ease: "sine.out" },
											0
										)
										.to(
											this.dom.bgColor,
											0.25,
											{ opacity: 1, ease: "sine.out" },
											0
										)
										.to(
											[this.dom.headline, this.dom.subHeadline, this.dom.copy],
											0.5,
											{
												stagger: 0.045,
												opacity: 1,
												y: 0,
												ease: "sine.out",
												force3D: !0,
											},
											0.15
										)
										.to(
											this.dom.close,
											0.9,
											{
												scale: 1,
												ease: "back.out(1.7)",
												force3D: !0,
												onComplete: function () {
													_.keyToggle && t.dom.interactiveFirst.focus();
												},
											},
											"-=.12"
										));
							},
						},
						{
							key: "close",
							value: function () {
								this.isOpen &&
									((this.isOpen = !1),
									_.keyToggle && (this.dom.trigger.focus(), Jo(this.dom.el)),
									this.tl.clear(),
									this.tl
										.to(this.dom.el, 0.3, {
											autoAlpha: 0,
											pointerEvents: "none",
											ease: "sine.out",
										})
										.call(this.setupDom));
							},
						},
						{
							key: "kill",
							value: function () {
								er.set(M.header, { zIndex: 99 }),
									document.removeEventListener("keydown", this.onKeyDown),
									(this.dom = null),
									(this.isOpen = null),
									(this.tl = null);
							},
						},
					]),
					t
				);
			})(),
			sb = (function () {
				function t(e) {
					p()(this, t),
						e &&
							(x(this, ["onMouseMove", "setPos", "start", "stop", "run"]),
							(this.dom = {
								el: e,
								clientList: document.querySelector(".client-list"),
							}),
							(this.cur = { x: _.windowWidth / 2, y: _.windowHeight / 2 }),
							(this.last = { x: this.cur.x, y: this.cur.y }),
							(this.state = { isRunning: !1 }),
							(this.ease = 0.1),
							this.addEvents());
				}
				return (
					m()(t, [
						{
							key: "addEvents",
							value: function () {
								document.addEventListener("mousemove", this.onMouseMove, {
									passive: !0,
								}),
									this.dom.clientList.addEventListener(
										"mouseenter",
										this.start
									),
									this.dom.clientList.addEventListener("mouseleave", this.stop);
							},
						},
						{
							key: "onMouseMove",
							value: function (t) {
								this.setPos(t);
							},
						},
						{
							key: "setPos",
							value: function (t) {
								this.cur = { x: t.clientX, y: t.clientY };
							},
						},
						{
							key: "run",
							value: function () {
								this.state.isRunning &&
									((this.last.x = y(this.last.x, this.cur.x, this.ease)),
									(this.last.y = y(this.last.y, this.cur.y, this.ease)),
									er.set(this.dom.el, {
										x: this.last.x,
										y: this.last.y,
										force3D: !0,
									}),
									(this.raf = requestAnimationFrame(this.run)));
							},
						},
						{
							key: "start",
							value: function () {
								(this.state.isRunning = !0),
									er.set(this.dom.el, { x: this.last.x, y: this.last.y, z: 0 }),
									this.run();
							},
						},
						{
							key: "stop",
							value: function () {
								(this.state.isRunning = !1), cancelAnimationFrame(this.raf);
							},
						},
						{
							key: "kill",
							value: function () {
								cancelAnimationFrame(this.raf),
									document.removeEventListener("mousemove", this.onMouseMove, {
										passive: !0,
									}),
									(this.dom = null),
									(this.cur = null),
									(this.last = null),
									(this.state = null),
									(this.ease = null),
									(this.raf = null);
							},
						},
					]),
					t
				);
			})(),
			ab = (function () {
				function t(e, n, i) {
					if ((p()(this, t), e)) {
						x(this, [
							"onMouseEnter",
							"onMouseLeave",
							"onMouseMove",
							"loadImages",
						]);
						e.dataset.uid;
						(this.imageContainer = i),
							(this.bounds = e.getBoundingClientRect()),
							(this.centerBounds = [
								this.bounds.width / 2,
								this.bounds.height / 2,
							]),
							(this.angle = 0),
							(this.secondaryImages = i.querySelectorAll(".secondary"));
						var r = i.querySelectorAll("img");
						(this.dom = { el: e, images: r, imgCount: r.length }),
							(this.curImg = 0),
							(this.state = { isHover: !1, firstHover: !0, isLinkHover: !1 }),
							(this.mouse = {
								totalDistance: 0,
								stepDistance: 75,
								nextStep: 75,
								cur: { x: 0, y: 0 },
								last: { x: 0, y: 0 },
							}),
							this.addEvents();
					}
				}
				return (
					m()(t, [
						{
							key: "addEvents",
							value: function () {
								this.dom.el.addEventListener(
									"mouseenter",
									this.onMouseEnter,
									!1
								),
									this.dom.el.addEventListener(
										"mouseleave",
										this.onMouseLeave,
										!1
									),
									this.secondaryImages.length &&
										this.dom.el.addEventListener(
											"mousemove",
											this.onMouseMove,
											{ passive: !0 }
										);
							},
						},
						{
							key: "loadImages",
							value: function () {
								(this.state.firstHover = !1),
									this.secondaryImages[0] &&
										(Ix.loadImages(
											this.secondaryImages,
											"nodeList",
											function () {}
										),
										(this.min = 1));
							},
						},
						{
							key: "onMouseEnter",
							value: function () {
								var t =
									arguments.length > 0 &&
									void 0 !== arguments[0] &&
									arguments[0];
								(!1 !== _.mouseEnterContext && !1 === t) ||
									((_.mouseEnterContext = "aboutBrandHover"),
									(_.mouseEnterData = this),
									(this.state.isHover = !0),
									this.state.firstHover && this.loadImages(),
									(this.mouse.totalDistance =
										this.curImg * this.mouse.stepDistance),
									(this.mouse.nextStep =
										this.mouse.totalDistance + this.mouse.stepDistance),
									er.set(this.imageContainer, { display: "block" }),
									er.set(this.dom.images[this.curImg], { scale: 0.38 }),
									er.to(this.dom.images[this.curImg], 0.29, {
										autoAlpha: 1,
										scale: 1,
										force3D: !0,
									}),
									(this.mouse.cur.x = this.mouse.last.x = event.layerX),
									(this.mouse.cur.y = this.mouse.last.y = event.layerY));
							},
						},
						{
							key: "onMouseMove",
							value: function () {
								if (!this.state.isLinkHover) {
									!1 === _.mouseEnterContext && this.onMouseEnter(!0),
										(this.mouse.cur.x = event.layerX),
										(this.mouse.cur.y = event.layerY);
									var t = Math.abs(this.mouse.cur.x - this.mouse.last.x);
									(this.mouse.totalDistance += t),
										this.mouse.totalDistance > this.mouse.nextStep &&
											((this.mouse.nextStep += this.mouse.stepDistance),
											(this.curImg += 1),
											this.curImg === this.dom.imgCount && (this.curImg = 0),
											er.to(this.dom.images, 0.28, {
												autoAlpha: 0,
												force3D: !0,
												ease: "sine.out",
											}),
											er.set(this.dom.images[this.curImg], { scale: 0.38 }),
											er.to(this.dom.images[this.curImg], 0.29, {
												autoAlpha: 1,
												scale: 1,
												force3D: !0,
												ease: "sine.inOut",
											})),
										(this.mouse.last.x = this.mouse.cur.x),
										(this.mouse.last.y = this.mouse.cur.y);
								}
							},
						},
						{
							key: "onMouseLeave",
							value: function () {
								var t = this;
								(this.state.isHover = !1),
									er.to(this.dom.images, 0.28, {
										autoAlpha: 0,
										clearProps: "transform",
										onComplete: function () {
											t.state.isHover ||
												er.set(t.imageContainer, { display: "none" });
										},
									});
							},
						},
						{
							key: "kill",
							value: function () {
								(this.dom = null),
									(this.mouse = null),
									(this.state = null),
									(this.secondaryImages = null),
									(this.curImg = null);
							},
						},
					]),
					t
				);
			})();
		function cb(t) {
			var e = (function () {
				if ("undefined" == typeof Reflect || !Reflect.construct) return !1;
				if (Reflect.construct.sham) return !1;
				if ("function" == typeof Proxy) return !0;
				try {
					return (
						Date.prototype.toString.call(
							Reflect.construct(Date, [], function () {})
						),
						!0
					);
				} catch (t) {
					return !1;
				}
			})();
			return function () {
				var n,
					i = Jx()(t);
				if (e) {
					var r = Jx()(this).constructor;
					n = Reflect.construct(i, arguments, r);
				} else n = i.apply(this, arguments);
				return Xx()(this, n);
			};
		}
		var lb = (function (t) {
			qx()(n, t);
			var e = cb(n);
			function n() {
				return p()(this, n), e.apply(this, arguments);
			}
			return (
				m()(n, [
					{ key: "onEnter", value: function () {} },
					{
						key: "onEnterCompleted",
						value: function () {
							var t,
								e,
								n,
								i = this;
							if (
								(_.aboutHandLoaded || (_.aboutHandLoaded = !0),
								(this.modals = []),
								document
									.querySelectorAll(".partner-modal")
									.forEach(function (t) {
										var e = t.dataset.uid,
											n = document.querySelector(
												"[data-modal='".concat(e, "']")
											);
										i.modals.push(new ob(t, n));
									}),
								(t = window.innerWidth > 1024 ? "desktop" : "mobile"),
								(e = document.querySelectorAll(
									".staff-svgs .".concat(t, " path")
								)),
								(n = e.length),
								(Wo = er.timeline({
									repeat: -1,
									paused: !0,
									repeatDelay: 4,
								})).add(function () {
									for (var t = 0; t < 2; t++) {
										var i =
											e[
												((r = 0),
												(o = n),
												Math.floor(Math.random() * (o - r) + r))
											];
										qo(i, 0.5 * t);
									}
									var r, o;
								}, 0.1),
								window.innerWidth > 1024 && !_.isMobile)
							) {
								var r = document.querySelector(".thumbnail-wrapper");
								this.thumbnailWrapper = new sb(r);
								var o = r.querySelectorAll(".project-wrapper");
								this.imageWrappersArray = [];
								var s = document.querySelectorAll(".img-hover");
								Array.prototype.slice.call(s).forEach(function (t, e) {
									var n = new ab(t, e, o[e]);
									i.imageWrappersArray.push(n);
								});
							}
						},
					},
					{
						key: "onLeave",
						value: function () {
							Dx.closeAboutMenu();
						},
					},
					{
						key: "onLeaveCompleted",
						value: function () {
							Wo.kill(),
								this.thumbnailWrapper && this.thumbnailWrapper.kill(),
								this.modals.forEach(function (t) {
									t.kill();
								});
						},
					},
				]),
				n
			);
		})(u.Renderer);
		function hb(t) {
			var e = (function () {
				if ("undefined" == typeof Reflect || !Reflect.construct) return !1;
				if (Reflect.construct.sham) return !1;
				if ("function" == typeof Proxy) return !0;
				try {
					return (
						Date.prototype.toString.call(
							Reflect.construct(Date, [], function () {})
						),
						!0
					);
				} catch (t) {
					return !1;
				}
			})();
			return function () {
				var n,
					i = Jx()(t);
				if (e) {
					var r = Jx()(this).constructor;
					n = Reflect.construct(i, arguments, r);
				} else n = i.apply(this, arguments);
				return Xx()(this, n);
			};
		}
		var ub,
			db,
			pb,
			fb,
			mb,
			gb,
			vb,
			yb,
			xb = document.getElementById("global-mask"),
			bb = (function (t) {
				qx()(n, t);
				var e = hb(n);
				function n() {
					return p()(this, n), e.apply(this, arguments);
				}
				return (
					m()(n, [
						{
							key: "out",
							value: function (t) {
								t.from, t.trigger;
								var e = t.done,
									n = Ax.returnVisibleParts(),
									i = 0;
								_.isGreaterThan767 &&
									(Px.isOpen && (Px.close(), (i = 0.1)),
									Rx.isOpen && ((i = 0.1), Rx.close())),
									Ax.headerScrolled && Cx.showHeader();
								Ax.destroy(),
									er.delayedCall(i, function () {
										if (n.length > 0) {
											for (var t = 0; t < n.length; t++)
												"fade" === n[t].anim && _.tripMode
													? er.to(n[t].el, 0.5, {
															stagger: 0.04,
															opacity: 0,
															ease: "expo.out",
													  })
													: "footer" === n[t].anim &&
													  er.to(n[t].el, 1, {
															stagger: -0.04,
															opacity: 0,
															yPercent: 101,
															ease: "expo.out",
													  });
											_.tripMode
												? er.delayedCall(0.7, function () {
														er.set(M.tieDieEl, { zIndex: 99 }), e();
												  })
												: er.to(xb, 0.4, {
														autoAlpha: 1,
														ease: "power3.out",
														onComplete: function () {
															e();
														},
												  });
										} else e();
									}),
									er.set(xb, { pointerEvents: "all" });
							},
						},
						{
							key: "in",
							value: function (t) {
								var e = t.from,
									n = t.to,
									i = (t.trigger, t.done);
								(M.viewEl = n),
									(_.namespace = n.dataset.routerView),
									e.remove(),
									(document.body.scrollTop = 0),
									window.scroll(0, 0),
									(_.transitionFinished = !0),
									i();
							},
						},
					]),
					n
				);
			})(u.Transition),
			wb = n(6),
			_b = n.n(wb),
			Mb = "transform",
			Sb = Mb + "Origin",
			Tb = function (t) {
				var e = t.ownerDocument || t;
				!(Mb in t.style) &&
					"msTransform" in t.style &&
					(Sb = (Mb = "msTransform") + "Origin");
				for (; e.parentNode && (e = e.parentNode); );
				if (((db = window), (vb = new kb()), e)) {
					(ub = e), (pb = e.documentElement), (fb = e.body);
					var n = e.createElement("div"),
						i = e.createElement("div");
					fb.appendChild(n),
						n.appendChild(i),
						(n.style.position = "static"),
						(n.style[Mb] = "translate3d(0,0,1px)"),
						(yb = i.offsetParent !== n),
						fb.removeChild(n);
				}
				return e;
			},
			Eb = [],
			Ab = [],
			Lb = function () {
				return (
					db.pageYOffset || ub.scrollTop || pb.scrollTop || fb.scrollTop || 0
				);
			},
			Pb = function () {
				return (
					db.pageXOffset || ub.scrollLeft || pb.scrollLeft || fb.scrollLeft || 0
				);
			},
			Rb = function (t) {
				return (
					t.ownerSVGElement ||
					("svg" === (t.tagName + "").toLowerCase() ? t : null)
				);
			},
			Cb = function t(e) {
				return (
					"fixed" === db.getComputedStyle(e).position ||
					((e = e.parentNode) && 1 === e.nodeType ? t(e) : void 0)
				);
			},
			Ob = function t(e, n) {
				if (e.parentNode && (ub || Tb(e))) {
					var i = Rb(e),
						r = i
							? i.getAttribute("xmlns") || "http://www.w3.org/2000/svg"
							: "http://www.w3.org/1999/xhtml",
						o = i ? (n ? "rect" : "g") : "div",
						s = 2 !== n ? 0 : 100,
						a = 3 === n ? 100 : 0,
						c = "position:absolute;display:block;pointer-events:none;",
						l = ub.createElementNS
							? ub.createElementNS(r.replace(/^https/, "http"), o)
							: ub.createElement(o);
					return (
						n &&
							(i
								? (gb || (gb = t(e)),
								  l.setAttribute("width", 0.01),
								  l.setAttribute("height", 0.01),
								  l.setAttribute("transform", "translate(" + s + "," + a + ")"),
								  gb.appendChild(l))
								: (mb || ((mb = t(e)).style.cssText = c),
								  (l.style.cssText =
										c +
										"width:0.1px;height:0.1px;top:" +
										a +
										"px;left:" +
										s +
										"px"),
								  mb.appendChild(l))),
						l
					);
				}
				throw "Need document and parent.";
			},
			Db = function (t, e) {
				var n,
					i,
					r,
					o,
					s,
					a = Rb(t),
					c = t === a,
					l = a ? Eb : Ab;
				if (t === db) return t;
				if (
					(l.length || l.push(Ob(t, 1), Ob(t, 2), Ob(t, 3)),
					(n = a ? gb : mb),
					a)
				)
					(r = c ? { x: 0, y: 0 } : t.getBBox()),
						(i = t.transform ? t.transform.baseVal : {}).numberOfItems
							? ((o =
									(i =
										i.numberOfItems > 1
											? (function (t) {
													for (
														var e = new kb(), n = 0;
														n < t.numberOfItems;
														n++
													)
														e.multiply(t.getItem(n).matrix);
													return e;
											  })(i)
											: i.getItem(0).matrix).a *
										r.x +
									i.c * r.y),
							  (s = i.b * r.x + i.d * r.y))
							: ((i = vb), (o = r.x), (s = r.y)),
						e && "g" === t.tagName.toLowerCase() && (o = s = 0),
						n.setAttribute(
							"transform",
							"matrix(" +
								i.a +
								"," +
								i.b +
								"," +
								i.c +
								"," +
								i.d +
								"," +
								(i.e + o) +
								"," +
								(i.f + s) +
								")"
						),
						(c ? a : t.parentNode).appendChild(n);
				else {
					if (((o = s = 0), yb))
						for (
							i = t.offsetParent, r = t;
							r && (r = r.parentNode) && r !== i && r.parentNode;

						)
							(db.getComputedStyle(r)[Mb] + "").length > 4 &&
								((o = r.offsetLeft), (s = r.offsetTop), (r = 0));
					((r = n.style).top = t.offsetTop - s + "px"),
						(r.left = t.offsetLeft - o + "px"),
						(i = db.getComputedStyle(t)),
						(r[Mb] = i[Mb]),
						(r[Sb] = i[Sb]),
						(r.border = i.border),
						(r.borderLeftStyle = i.borderLeftStyle),
						(r.borderTopStyle = i.borderTopStyle),
						(r.borderLeftWidth = i.borderLeftWidth),
						(r.borderTopWidth = i.borderTopWidth),
						(r.position = "fixed" === i.position ? "fixed" : "absolute"),
						t.parentNode.appendChild(n);
				}
				return n;
			},
			Ib = function (t, e, n, i, r, o, s) {
				return (
					(t.a = e), (t.b = n), (t.c = i), (t.d = r), (t.e = o), (t.f = s), t
				);
			},
			kb = (function () {
				function t() {
					var e =
							arguments.length > 0 && void 0 !== arguments[0]
								? arguments[0]
								: 1,
						n =
							arguments.length > 1 && void 0 !== arguments[1]
								? arguments[1]
								: 0,
						i =
							arguments.length > 2 && void 0 !== arguments[2]
								? arguments[2]
								: 0,
						r =
							arguments.length > 3 && void 0 !== arguments[3]
								? arguments[3]
								: 1,
						o =
							arguments.length > 4 && void 0 !== arguments[4]
								? arguments[4]
								: 0,
						s =
							arguments.length > 5 && void 0 !== arguments[5]
								? arguments[5]
								: 0;
					p()(this, t), Ib(this, e, n, i, r, o, s);
				}
				return (
					m()(t, [
						{
							key: "inverse",
							value: function () {
								var t = this.a,
									e = this.b,
									n = this.c,
									i = this.d,
									r = this.e,
									o = this.f,
									s = t * i - e * n;
								return Ib(
									this,
									i / s,
									-e / s,
									-n / s,
									t / s,
									(n * o - i * r) / s,
									-(t * o - e * r) / s
								);
							},
						},
						{
							key: "multiply",
							value: function (t) {
								var e = this.a,
									n = this.b,
									i = this.c,
									r = this.d,
									o = this.e,
									s = this.f,
									a = t.a,
									c = t.c,
									l = t.b,
									h = t.d,
									u = t.e,
									d = t.f;
								return Ib(
									this,
									a * e + l * i,
									a * n + l * r,
									c * e + h * i,
									c * n + h * r,
									o + u * e + d * i,
									s + u * n + d * r
								);
							},
						},
						{
							key: "clone",
							value: function () {
								return new t(this.a, this.b, this.c, this.d, this.e, this.f);
							},
						},
						{
							key: "equals",
							value: function (t) {
								var e = this.a,
									n = this.b,
									i = this.c,
									r = this.d,
									o = this.e,
									s = this.f;
								return (
									e === t.a &&
									n === t.b &&
									i === t.c &&
									r === t.d &&
									o === t.e &&
									s === t.f
								);
							},
						},
						{
							key: "apply",
							value: function (t) {
								var e =
										arguments.length > 1 && void 0 !== arguments[1]
											? arguments[1]
											: {},
									n = t.x,
									i = t.y,
									r = this.a,
									o = this.b,
									s = this.c,
									a = this.d,
									c = this.e,
									l = this.f;
								return (
									(e.x = n * r + i * s + c || 0),
									(e.y = n * o + i * a + l || 0),
									e
								);
							},
						},
					]),
					t
				);
			})();
		function Nb(t, e, n) {
			if (!t || !t.parentNode || (ub || Tb(t)).documentElement === t)
				return new kb();
			var i = Rb(t) ? Eb : Ab,
				r = Db(t, n),
				o = i[0].getBoundingClientRect(),
				s = i[1].getBoundingClientRect(),
				a = i[2].getBoundingClientRect(),
				c = r.parentNode,
				l = Cb(t),
				h = new kb(
					(s.left - o.left) / 100,
					(s.top - o.top) / 100,
					(a.left - o.left) / 100,
					(a.top - o.top) / 100,
					o.left + (l ? 0 : Pb()),
					o.top + (l ? 0 : Lb())
				);
			return c.removeChild(r), e ? h.inverse() : h;
		}
		function Bb(t) {
			var e = (function () {
				if ("undefined" == typeof Reflect || !Reflect.construct) return !1;
				if (Reflect.construct.sham) return !1;
				if ("function" == typeof Proxy) return !0;
				try {
					return (
						Date.prototype.toString.call(
							Reflect.construct(Date, [], function () {})
						),
						!0
					);
				} catch (t) {
					return !1;
				}
			})();
			/*!
			 * Draggable 3.5.1
			 * https://greensock.com
			 *
			 * @license Copyright 2008-2020, GreenSock. All rights reserved.
			 * Subject to the terms at https://greensock.com/standard-license or for
			 * Club GreenSock members, the agreement issued with that membership.
			 * @author: Jack Doyle, jack@greensock.com
			 */
			return function () {
				var n,
					i = Jx()(t);
				if (e) {
					var r = Jx()(this).constructor;
					n = Reflect.construct(i, arguments, r);
				} else n = i.apply(this, arguments);
				return Xx()(this, n);
			};
		}
		var Fb,
			zb,
			Hb,
			Ub,
			Gb,
			Vb,
			jb,
			Wb,
			qb,
			Yb,
			Xb,
			Zb,
			Jb,
			Kb,
			Qb,
			$b,
			tw,
			ew,
			nw,
			iw,
			rw,
			ow = function () {
				return "undefined" != typeof window;
			},
			sw = function () {
				return Fb || (ow() && (Fb = window.gsap) && Fb.registerPlugin && Fb);
			},
			aw = function (t) {
				return "function" == typeof t;
			},
			cw = function (t) {
				return "object" === Fx()(t);
			},
			lw = function (t) {
				return void 0 === t;
			},
			hw = function () {
				return !1;
			},
			uw = "transform",
			dw = "transformOrigin",
			pw = function (t) {
				return Math.round(1e4 * t) / 1e4;
			},
			fw = Array.isArray,
			mw = function (t, e) {
				var n = Hb.createElementNS
					? Hb.createElementNS(
							(e || "http://www.w3.org/1999/xhtml").replace(/^https/, "http"),
							t
					  )
					: Hb.createElement(t);
				return n.style ? n : Hb.createElement(t);
			},
			gw = 180 / Math.PI,
			vw = 1e20,
			yw = new kb(),
			xw =
				Date.now ||
				function () {
					return new Date().getTime();
				},
			bw = [],
			ww = {},
			_w = 0,
			Mw = /^(?:a|input|textarea|button|select)$/i,
			Sw = 0,
			Tw = {},
			Ew = {},
			Aw = function (t, e) {
				var n,
					i = {};
				for (n in t) i[n] = e ? t[n] * e : t[n];
				return i;
			},
			Lw = function (t, e) {
				for (var n in e) n in t || (t[n] = e[n]);
				return t;
			},
			Pw = function () {
				return bw.forEach(function (t) {
					return t();
				});
			},
			Rw = function (t) {
				bw.push(t), 1 === bw.length && Fb.ticker.add(Pw);
			},
			Cw = function () {
				return !bw.length && Fb.ticker.remove(Pw);
			},
			Ow = function (t) {
				for (var e = bw.length; e--; ) bw[e] === t && bw.splice(e, 1);
				Fb.to(Cw, {
					overwrite: !0,
					delay: 15,
					duration: 0,
					onComplete: Cw,
					data: "_draggable",
				});
			},
			Dw = function (t, e, n, i) {
				if (t.addEventListener) {
					var r = Jb[e];
					(i = i || (Xb ? { passive: !1 } : null)),
						t.addEventListener(r || e, n, i),
						r && e !== r && t.addEventListener(e, n, i);
				}
			},
			Iw = function (t, e, n) {
				if (t.removeEventListener) {
					var i = Jb[e];
					t.removeEventListener(i || e, n),
						i && e !== i && t.removeEventListener(e, n);
				}
			},
			kw = function (t) {
				t.preventDefault && t.preventDefault(),
					t.preventManipulation && t.preventManipulation();
			},
			Nw = function (t, e) {
				for (var n = t.length; n--; ) if (t[n].identifier === e) return !0;
			},
			Bw = function t(e) {
				(Qb = e.touches && Kb < e.touches.length), Iw(e.target, "touchend", t);
			},
			Fw = function (t) {
				(Qb = t.touches && Kb < t.touches.length), Dw(t.target, "touchend", Bw);
			},
			zw = function (t) {
				return (
					zb.pageYOffset ||
					t.scrollTop ||
					t.documentElement.scrollTop ||
					t.body.scrollTop ||
					0
				);
			},
			Hw = function (t) {
				return (
					zb.pageXOffset ||
					t.scrollLeft ||
					t.documentElement.scrollLeft ||
					t.body.scrollLeft ||
					0
				);
			},
			Uw = function t(e, n) {
				Dw(e, "scroll", n), Vw(e.parentNode) || t(e.parentNode, n);
			},
			Gw = function t(e, n) {
				Iw(e, "scroll", n), Vw(e.parentNode) || t(e.parentNode, n);
			},
			Vw = function (t) {
				return !(
					t &&
					t !== Ub &&
					9 !== t.nodeType &&
					t !== Hb.body &&
					t !== zb &&
					t.nodeType &&
					t.parentNode
				);
			},
			jw = function (t, e) {
				var n = "x" === e ? "Width" : "Height",
					i = "scroll" + n,
					r = "client" + n;
				return Math.max(
					0,
					Vw(t)
						? Math.max(Ub[i], Gb[i]) - (zb["inner" + n] || Ub[r] || Gb[r])
						: t[i] - t[r]
				);
			},
			Ww = function t(e, n) {
				var i = jw(e, "x"),
					r = jw(e, "y");
				Vw(e) ? (e = Ew) : t(e.parentNode, n),
					(e._gsMaxScrollX = i),
					(e._gsMaxScrollY = r),
					n ||
						((e._gsScrollX = e.scrollLeft || 0),
						(e._gsScrollY = e.scrollTop || 0));
			},
			qw = function (t, e, n) {
				var i = t.style;
				i &&
					(lw(i[e]) && (e = qb(e, t) || e),
					null == n
						? i.removeProperty &&
						  i.removeProperty(e.replace(/([A-Z])/g, "-$1").toLowerCase())
						: (i[e] = n));
			},
			Yw = function (t) {
				return zb.getComputedStyle(
					t instanceof Element ? t : t.host || (t.parentNode || {}).host || t
				);
			},
			Xw = {},
			Zw = function (t) {
				if (t === zb)
					return (
						(Xw.left = Xw.top = 0),
						(Xw.width = Xw.right =
							Ub.clientWidth || t.innerWidth || Gb.clientWidth || 0),
						(Xw.height = Xw.bottom =
							(t.innerHeight || 0) - 20 < Ub.clientHeight
								? Ub.clientHeight
								: t.innerHeight || Gb.clientHeight || 0),
						Xw
					);
				var e = t.ownerDocument || Hb,
					n = lw(t.pageX)
						? t.nodeType || lw(t.left) || lw(t.top)
							? Yb(t)[0].getBoundingClientRect()
							: t
						: {
								left: t.pageX - Hw(e),
								top: t.pageY - zw(e),
								right: t.pageX - Hw(e) + 1,
								bottom: t.pageY - zw(e) + 1,
						  };
				return (
					lw(n.right) && !lw(n.width)
						? ((n.right = n.left + n.width), (n.bottom = n.top + n.height))
						: lw(n.width) &&
						  (n = {
								width: n.right - n.left,
								height: n.bottom - n.top,
								right: n.right,
								left: n.left,
								bottom: n.bottom,
								top: n.top,
						  }),
					n
				);
			},
			Jw = function (t, e, n) {
				var i,
					r = t.vars,
					o = r[n],
					s = t._listeners[e];
				return (
					aw(o) &&
						(i = o.apply(
							r.callbackScope || t,
							r[n + "Params"] || [t.pointerEvent]
						)),
					s && !1 === t.dispatchEvent(e) && (i = !1),
					i
				);
			},
			Kw = function (t, e) {
				var n,
					i,
					r,
					o = Yb(t)[0];
				return o.nodeType || o === zb
					? $w(o, e)
					: lw(t.left)
					? {
							left: (i = t.min || t.minX || t.minRotation || 0),
							top: (n = t.min || t.minY || 0),
							width: (t.max || t.maxX || t.maxRotation || 0) - i,
							height: (t.max || t.maxY || 0) - n,
					  }
					: ((r = { x: 0, y: 0 }),
					  {
							left: t.left - r.x,
							top: t.top - r.y,
							width: t.width,
							height: t.height,
					  });
			},
			Qw = {},
			$w = function (t, e) {
				e = Yb(e)[0];
				var n,
					i,
					r,
					o,
					s,
					a,
					c,
					l,
					h,
					u,
					d,
					p,
					f,
					m,
					g = t.getBBox && t.ownerSVGElement,
					v = t.ownerDocument || Hb;
				if (t === zb)
					(r = zw(v)),
						(i =
							(n = Hw(v)) +
							(v.documentElement.clientWidth ||
								t.innerWidth ||
								v.body.clientWidth ||
								0)),
						(o =
							r +
							((t.innerHeight || 0) - 20 < v.documentElement.clientHeight
								? v.documentElement.clientHeight
								: t.innerHeight || v.body.clientHeight || 0));
				else {
					if (e === zb || lw(e)) return t.getBoundingClientRect();
					(n = r = 0),
						g
							? ((d = (u = t.getBBox()).width), (p = u.height))
							: (t.viewBox &&
									(u = t.viewBox.baseVal) &&
									((n = u.x || 0),
									(r = u.y || 0),
									(d = u.width),
									(p = u.height)),
							  d ||
									((u = "border-box" === (f = Yw(t)).boxSizing),
									(d =
										(parseFloat(f.width) || t.clientWidth || 0) +
										(u
											? 0
											: parseFloat(f.borderLeftWidth) +
											  parseFloat(f.borderRightWidth))),
									(p =
										(parseFloat(f.height) || t.clientHeight || 0) +
										(u
											? 0
											: parseFloat(f.borderTopWidth) +
											  parseFloat(f.borderBottomWidth))))),
						(i = d),
						(o = p);
				}
				return t === e
					? { left: n, top: r, width: i - n, height: o - r }
					: ((a = (s = Nb(e, !0).multiply(Nb(t))).apply({ x: n, y: r })),
					  (c = s.apply({ x: i, y: r })),
					  (l = s.apply({ x: i, y: o })),
					  (h = s.apply({ x: n, y: o })),
					  (n = Math.min(a.x, c.x, l.x, h.x)),
					  (r = Math.min(a.y, c.y, l.y, h.y)),
					  {
							left: n + ((m = e.parentNode || {}).scrollLeft || 0),
							top: r + (m.scrollTop || 0),
							width: Math.max(a.x, c.x, l.x, h.x) - n,
							height: Math.max(a.y, c.y, l.y, h.y) - r,
					  });
			},
			t_ = function (t, e, n, i, r, o) {
				var s,
					a,
					c,
					l = {};
				if (e)
					if (1 !== r && e instanceof Array) {
						if (((l.end = s = []), (c = e.length), cw(e[0])))
							for (a = 0; a < c; a++) s[a] = Aw(e[a], r);
						else for (a = 0; a < c; a++) s[a] = e[a] * r;
						(n += 1.1), (i -= 1.1);
					} else
						aw(e)
							? (l.end = function (n) {
									var i,
										o,
										s = e.call(t, n);
									if (1 !== r)
										if (cw(s)) {
											for (o in ((i = {}), s)) i[o] = s[o] * r;
											s = i;
										} else s *= r;
									return s;
							  })
							: (l.end = e);
				return (
					(n || 0 === n) && (l.max = n),
					(i || 0 === i) && (l.min = i),
					o && (l.velocity = 0),
					l
				);
			},
			e_ = function t(e) {
				var n;
				return (
					!(!e || !e.getAttribute || e === Gb) &&
					(!(
						"true" !== (n = e.getAttribute("data-clickable")) &&
						("false" === n ||
							(!e.onclick &&
								!Mw.test(e.nodeName + "") &&
								"true" !== e.getAttribute("contentEditable")))
					) ||
						t(e.parentNode))
				);
			},
			n_ = function (t, e) {
				for (var n, i = t.length; i--; )
					((n = t[i]).ondragstart = n.onselectstart = e ? null : hw),
						Fb.set(n, { lazy: !0, userSelect: e ? "text" : "none" });
			},
			i_ = function t(e) {
				return (
					"fixed" === Yw(e).position ||
					((e = e.parentNode) && 1 === e.nodeType ? t(e) : void 0)
				);
			},
			r_ = function (t, e) {
				(t = Fb.utils.toArray(t)[0]), (e = e || {});
				var n,
					i,
					r,
					o,
					s,
					a,
					c = document.createElement("div"),
					l = c.style,
					h = t.firstChild,
					u = 0,
					d = 0,
					p = t.scrollTop,
					f = t.scrollLeft,
					m = t.scrollWidth,
					g = t.scrollHeight,
					v = 0,
					y = 0,
					x = 0;
				iw && !1 !== e.force3D
					? ((s = "translate3d("), (a = "px,0px)"))
					: uw && ((s = "translate("), (a = "px)")),
					(this.scrollTop = function (t, e) {
						if (!arguments.length) return -this.top();
						this.top(-t, e);
					}),
					(this.scrollLeft = function (t, e) {
						if (!arguments.length) return -this.left();
						this.left(-t, e);
					}),
					(this.left = function (n, i) {
						if (!arguments.length) return -(t.scrollLeft + d);
						var r = t.scrollLeft - f,
							o = d;
						if ((r > 2 || r < -2) && !i)
							return (
								(f = t.scrollLeft),
								Fb.killTweensOf(this, { left: 1, scrollLeft: 1 }),
								this.left(-f),
								void (e.onKill && e.onKill())
							);
						(n = -n) < 0
							? ((d = (n - 0.5) | 0), (n = 0))
							: n > y
							? ((d = (n - y) | 0), (n = y))
							: (d = 0),
							(d || o) &&
								(this._skip || (l[uw] = s + -d + "px," + -u + a),
								d + v >= 0 && (l.paddingRight = d + v + "px")),
							(t.scrollLeft = 0 | n),
							(f = t.scrollLeft);
					}),
					(this.top = function (n, i) {
						if (!arguments.length) return -(t.scrollTop + u);
						var r = t.scrollTop - p,
							o = u;
						if ((r > 2 || r < -2) && !i)
							return (
								(p = t.scrollTop),
								Fb.killTweensOf(this, { top: 1, scrollTop: 1 }),
								this.top(-p),
								void (e.onKill && e.onKill())
							);
						(n = -n) < 0
							? ((u = (n - 0.5) | 0), (n = 0))
							: n > x
							? ((u = (n - x) | 0), (n = x))
							: (u = 0),
							(u || o) && (this._skip || (l[uw] = s + -d + "px," + -u + a)),
							(t.scrollTop = 0 | n),
							(p = t.scrollTop);
					}),
					(this.maxScrollTop = function () {
						return x;
					}),
					(this.maxScrollLeft = function () {
						return y;
					}),
					(this.disable = function () {
						for (h = c.firstChild; h; )
							(o = h.nextSibling), t.appendChild(h), (h = o);
						t === c.parentNode && t.removeChild(c);
					}),
					(this.enable = function () {
						if ((h = t.firstChild) !== c) {
							for (; h; ) (o = h.nextSibling), c.appendChild(h), (h = o);
							t.appendChild(c), this.calibrate();
						}
					}),
					(this.calibrate = function (e) {
						var o,
							s,
							a,
							h = t.clientWidth === n;
						(p = t.scrollTop),
							(f = t.scrollLeft),
							(h &&
								t.clientHeight === i &&
								c.offsetHeight === r &&
								m === t.scrollWidth &&
								g === t.scrollHeight &&
								!e) ||
								((u || d) &&
									((s = this.left()),
									(a = this.top()),
									this.left(-t.scrollLeft),
									this.top(-t.scrollTop)),
								(o = Yw(t)),
								(h && !e) ||
									((l.display = "block"),
									(l.width = "auto"),
									(l.paddingRight = "0px"),
									(v = Math.max(0, t.scrollWidth - t.clientWidth)) &&
										(v +=
											parseFloat(o.paddingLeft) +
											(rw ? parseFloat(o.paddingRight) : 0))),
								(l.display = "inline-block"),
								(l.position = "relative"),
								(l.overflow = "visible"),
								(l.verticalAlign = "top"),
								(l.boxSizing = "content-box"),
								(l.width = "100%"),
								(l.paddingRight = v + "px"),
								rw && (l.paddingBottom = o.paddingBottom),
								(n = t.clientWidth),
								(i = t.clientHeight),
								(m = t.scrollWidth),
								(g = t.scrollHeight),
								(y = t.scrollWidth - n),
								(x = t.scrollHeight - i),
								(r = c.offsetHeight),
								(l.display = "block"),
								(s || a) && (this.left(s), this.top(a)));
					}),
					(this.content = c),
					(this.element = t),
					(this._skip = !1),
					this.enable();
			},
			o_ = function (t) {
				if (ow() && document.body) {
					var e = window && window.navigator;
					(zb = window),
						(Hb = document),
						(Ub = Hb.documentElement),
						(Gb = Hb.body),
						(Vb = mw("div")),
						(nw = !!window.PointerEvent),
						((jb = mw("div")).style.cssText =
							"visibility:hidden;height:1px;top:-1px;pointer-events:none;position:relative;clear:both;cursor:grab"),
						(ew = "grab" === jb.style.cursor ? "grab" : "move"),
						($b = e && -1 !== e.userAgent.toLowerCase().indexOf("android")),
						(Zb =
							("ontouchstart" in Ub && "orientation" in zb) ||
							(e && (e.MaxTouchPoints > 0 || e.msMaxTouchPoints > 0))),
						(i = mw("div")),
						(r = mw("div")),
						(o = r.style),
						(s = Gb),
						(o.display = "inline-block"),
						(o.position = "relative"),
						(i.style.cssText = r.innerHTML =
							"width:90px;height:40px;padding:10px;overflow:auto;visibility:hidden"),
						i.appendChild(r),
						s.appendChild(i),
						(n = r.offsetHeight + 18 > i.scrollHeight),
						s.removeChild(i),
						(rw = n),
						(Jb = (function (t) {
							for (
								var e = t.split(","),
									n = (
										("onpointerdown" in Vb)
											? "pointerdown,pointermove,pointerup,pointercancel"
											: ("onmspointerdown" in Vb)
											? "MSPointerDown,MSPointerMove,MSPointerUp,MSPointerCancel"
											: t
									).split(","),
									i = {},
									r = 4;
								--r > -1;

							)
								(i[e[r]] = n[r]), (i[n[r]] = e[r]);
							try {
								Ub.addEventListener(
									"test",
									null,
									Object.defineProperty({}, "passive", {
										get: function () {
											Xb = 1;
										},
									})
								);
							} catch (t) {}
							return i;
						})("touchstart,touchmove,touchend,touchcancel")),
						Dw(Hb, "touchcancel", hw),
						Dw(zb, "touchmove", hw),
						Gb && Gb.addEventListener("touchstart", hw),
						Dw(Hb, "contextmenu", function () {
							for (var t in ww) ww[t].isPressed && ww[t].endDrag();
						}),
						(Fb = Wb = sw());
				}
				var n, i, r, o, s;
				Fb
					? ((tw = Fb.plugins.inertia),
					  (qb = Fb.utils.checkPrefix),
					  (uw = qb(uw)),
					  (dw = qb(dw)),
					  (Yb = Fb.utils.toArray),
					  (iw = !!qb("perspective")))
					: t && console.warn("Please gsap.registerPlugin(Draggable)");
			},
			s_ = (function (t) {
				qx()(n, t);
				var e = Bb(n);
				function n(t, i) {
					var r;
					p()(this, n),
						(r = e.call(this)),
						Fb || o_(1),
						(t = Yb(t)[0]),
						tw || (tw = Fb.plugins.inertia),
						(r.vars = i = Aw(i || {})),
						(r.target = t),
						(r.x = r.y = r.rotation = 0),
						(r.dragResistance = parseFloat(i.dragResistance) || 0),
						(r.edgeResistance = isNaN(i.edgeResistance)
							? 1
							: parseFloat(i.edgeResistance) || 0),
						(r.lockAxis = i.lockAxis),
						(r.autoScroll = i.autoScroll || 0),
						(r.lockedAxis = null),
						(r.allowEventDefault = !!i.allowEventDefault),
						Fb.getProperty(t, "x");
					var o,
						s,
						a,
						c,
						l,
						h,
						u,
						d,
						f,
						m,
						g,
						v,
						y,
						x,
						b,
						w,
						_,
						M,
						S,
						T,
						E,
						A,
						L,
						P,
						R,
						C,
						O,
						D,
						I,
						k,
						N,
						B = (i.type || "x,y").toLowerCase(),
						F = ~B.indexOf("x") || ~B.indexOf("y"),
						z = -1 !== B.indexOf("rotation"),
						H = z ? "rotation" : F ? "x" : "left",
						U = F ? "y" : "top",
						G = !(!~B.indexOf("x") && !~B.indexOf("left") && "scroll" !== B),
						V = !(!~B.indexOf("y") && !~B.indexOf("top") && "scroll" !== B),
						j = i.minimumMovement || 2,
						W = _b()(r),
						q = Yb(i.trigger || i.handle || t),
						Y = {},
						X = 0,
						Z = !1,
						J = i.autoScrollMarginTop || 40,
						K = i.autoScrollMarginRight || 40,
						Q = i.autoScrollMarginBottom || 40,
						$ = i.autoScrollMarginLeft || 40,
						tt = i.clickableTest || e_,
						et = 0,
						nt = t._gsap || Fb.core.getCache(t),
						it = i_(t),
						rt = function (e, n) {
							return parseFloat(nt.get(t, e, n));
						},
						ot = t.ownerDocument || Hb,
						st = function (t) {
							return (
								kw(t),
								t.stopImmediatePropagation && t.stopImmediatePropagation(),
								!1
							);
						},
						at = function e(n) {
							if (W.autoScroll && W.isDragging && (Z || _)) {
								var i,
									r,
									o,
									a,
									c,
									l,
									h,
									u,
									p = t,
									f = 15 * W.autoScroll;
								for (
									Z = !1,
										Ew.scrollTop =
											null != zb.pageYOffset
												? zb.pageYOffset
												: null != ot.documentElement.scrollTop
												? ot.documentElement.scrollTop
												: ot.body.scrollTop,
										Ew.scrollLeft =
											null != zb.pageXOffset
												? zb.pageXOffset
												: null != ot.documentElement.scrollLeft
												? ot.documentElement.scrollLeft
												: ot.body.scrollLeft,
										a = W.pointerX - Ew.scrollLeft,
										c = W.pointerY - Ew.scrollTop;
									p && !r;

								)
									(i = (r = Vw(p.parentNode)) ? Ew : p.parentNode),
										(o = r
											? {
													bottom: Math.max(
														Ub.clientHeight,
														zb.innerHeight || 0
													),
													right: Math.max(Ub.clientWidth, zb.innerWidth || 0),
													left: 0,
													top: 0,
											  }
											: i.getBoundingClientRect()),
										(l = h = 0),
										V &&
											((u = i._gsMaxScrollY - i.scrollTop) < 0
												? (h = u)
												: c > o.bottom - Q && u
												? ((Z = !0),
												  (h = Math.min(
														u,
														(f * (1 - Math.max(0, o.bottom - c) / Q)) | 0
												  )))
												: c < o.top + J &&
												  i.scrollTop &&
												  ((Z = !0),
												  (h = -Math.min(
														i.scrollTop,
														(f * (1 - Math.max(0, c - o.top) / J)) | 0
												  ))),
											h && (i.scrollTop += h)),
										G &&
											((u = i._gsMaxScrollX - i.scrollLeft) < 0
												? (l = u)
												: a > o.right - K && u
												? ((Z = !0),
												  (l = Math.min(
														u,
														(f * (1 - Math.max(0, o.right - a) / K)) | 0
												  )))
												: a < o.left + $ &&
												  i.scrollLeft &&
												  ((Z = !0),
												  (l = -Math.min(
														i.scrollLeft,
														(f * (1 - Math.max(0, a - o.left) / $)) | 0
												  ))),
											l && (i.scrollLeft += l)),
										r &&
											(l || h) &&
											(zb.scrollTo(i.scrollLeft, i.scrollTop),
											bt(W.pointerX + l, W.pointerY + h)),
										(p = i);
							}
							if (_) {
								var m = W.x,
									g = W.y;
								z
									? ((W.deltaX = m - parseFloat(nt.rotation)),
									  (W.rotation = m),
									  (nt.rotation = m + "deg"),
									  nt.renderTransform(1, nt))
									: s
									? (V && ((W.deltaY = g - s.top()), s.top(g)),
									  G && ((W.deltaX = m - s.left()), s.left(m)))
									: F
									? (V &&
											((W.deltaY = g - parseFloat(nt.y)), (nt.y = g + "px")),
									  G && ((W.deltaX = m - parseFloat(nt.x)), (nt.x = m + "px")),
									  nt.renderTransform(1, nt))
									: (V &&
											((W.deltaY = g - parseFloat(t.style.top || 0)),
											(t.style.top = g + "px")),
									  G &&
											((W.deltaY = m - parseFloat(t.style.left || 0)),
											(t.style.left = m + "px"))),
									!d ||
										n ||
										D ||
										((D = !0),
										!1 === Jw(W, "drag", "onDrag") &&
											(G && (W.x -= W.deltaX), V && (W.y -= W.deltaY), e(!0)),
										(D = !1));
							}
							_ = !1;
						},
						ct = function (e, n) {
							var i,
								r,
								o = W.x,
								a = W.y;
							t._gsap || (nt = Fb.core.getCache(t)),
								F
									? ((W.x = parseFloat(nt.x)), (W.y = parseFloat(nt.y)))
									: z
									? (W.x = W.rotation = parseFloat(nt.rotation))
									: s
									? ((W.y = s.top()), (W.x = s.left()))
									: ((W.y =
											parseInt(t.style.top || ((r = Yw(t)) && r.top), 10) || 0),
									  (W.x = parseInt(t.style.left || (r || {}).left, 10) || 0)),
								(S || T || E) &&
									!n &&
									(W.isDragging || W.isThrowing) &&
									(E &&
										((Tw.x = W.x),
										(Tw.y = W.y),
										(i = E(Tw)).x !== W.x && ((W.x = i.x), (_ = !0)),
										i.y !== W.y && ((W.y = i.y), (_ = !0))),
									S &&
										(i = S(W.x)) !== W.x &&
										((W.x = i), z && (W.rotation = i), (_ = !0)),
									T && ((i = T(W.y)) !== W.y && (W.y = i), (_ = !0))),
								_ && at(!0),
								e ||
									((W.deltaX = W.x - o),
									(W.deltaY = W.y - a),
									Jw(W, "throwupdate", "onThrowUpdate"));
						},
						lt = function (t, e, n, i) {
							return (
								null == e && (e = -vw),
								null == n && (n = vw),
								aw(t)
									? function (r) {
											var o = W.isPressed ? 1 - W.edgeResistance : 1;
											return (
												t.call(
													W,
													r > n ? n + (r - n) * o : r < e ? e + (r - e) * o : r
												) * i
											);
									  }
									: fw(t)
									? function (i) {
											for (var r, o, s = t.length, a = 0, c = vw; --s > -1; )
												(o = (r = t[s]) - i) < 0 && (o = -o),
													o < c && r >= e && r <= n && ((a = s), (c = o));
											return t[a];
									  }
									: isNaN(t)
									? function (t) {
											return t;
									  }
									: function () {
											return t * i;
									  }
							);
						},
						ht = function () {
							var e, n, r, o;
							(u = !1),
								s
									? (s.calibrate(),
									  (W.minX = g = -s.maxScrollLeft()),
									  (W.minY = y = -s.maxScrollTop()),
									  (W.maxX = m = W.maxY = v = 0),
									  (u = !0))
									: i.bounds &&
									  ((e = Kw(i.bounds, t.parentNode)),
									  z
											? ((W.minX = g = e.left),
											  (W.maxX = m = e.left + e.width),
											  (W.minY = y = W.maxY = v = 0))
											: lw(i.bounds.maxX) && lw(i.bounds.maxY)
											? ((n = Kw(t, t.parentNode)),
											  (W.minX = g =
													Math.round(rt(H, "px") + e.left - n.left - 0.5)),
											  (W.minY = y =
													Math.round(rt(U, "px") + e.top - n.top - 0.5)),
											  (W.maxX = m = Math.round(g + (e.width - n.width))),
											  (W.maxY = v = Math.round(y + (e.height - n.height))))
											: ((e = i.bounds),
											  (W.minX = g = e.minX),
											  (W.minY = y = e.minY),
											  (W.maxX = m = e.maxX),
											  (W.maxY = v = e.maxY)),
									  g > m && ((W.minX = m), (W.maxX = m = g), (g = W.minX)),
									  y > v && ((W.minY = v), (W.maxY = v = y), (y = W.minY)),
									  z && ((W.minRotation = g), (W.maxRotation = m)),
									  (u = !0)),
								i.liveSnap &&
									((r = !0 === i.liveSnap ? i.snap || {} : i.liveSnap),
									(o = fw(r) || aw(r)),
									z
										? ((S = lt(o ? r : r.rotation, g, m, 1)), (T = null))
										: r.points
										? (E = (function (t, e, n, i, r, o, s) {
												return (
													(o = o && o < vw ? o * o : vw),
													aw(t)
														? function (a) {
																var c,
																	l,
																	h,
																	u = W.isPressed ? 1 - W.edgeResistance : 1,
																	d = a.x,
																	p = a.y;
																return (
																	(a.x = d =
																		d > n
																			? n + (d - n) * u
																			: d < e
																			? e + (d - e) * u
																			: d),
																	(a.y = p =
																		p > r
																			? r + (p - r) * u
																			: p < i
																			? i + (p - i) * u
																			: p),
																	(c = t.call(W, a)) !== a &&
																		((a.x = c.x), (a.y = c.y)),
																	1 !== s && ((a.x *= s), (a.y *= s)),
																	o < vw &&
																		(l = a.x - d) * l + (h = a.y - p) * h > o &&
																		((a.x = d), (a.y = p)),
																	a
																);
														  }
														: fw(t)
														? function (e) {
																for (
																	var n, i, r, s, a = t.length, c = 0, l = vw;
																	--a > -1;

																)
																	(s =
																		(n = (r = t[a]).x - e.x) * n +
																		(i = r.y - e.y) * i) < l &&
																		((c = a), (l = s));
																return l <= o ? t[c] : e;
														  }
														: function (t) {
																return t;
														  }
												);
										  })(o ? r : r.points, g, m, y, v, r.radius, s ? -1 : 1))
										: (G &&
												(S = lt(
													o ? r : r.x || r.left || r.scrollLeft,
													g,
													m,
													s ? -1 : 1
												)),
										  V &&
												(T = lt(
													o ? r : r.y || r.top || r.scrollTop,
													y,
													v,
													s ? -1 : 1
												))));
						},
						ut = function () {
							(W.isThrowing = !1), Jw(W, "throwcomplete", "onThrowComplete");
						},
						dt = function () {
							W.isThrowing = !1;
						},
						pt = function (e, n) {
							var r, o, a, c;
							e && tw
								? (!0 === e &&
										((r = i.snap || i.liveSnap || {}),
										(o = fw(r) || aw(r)),
										(e = {
											resistance:
												(i.throwResistance || i.resistance || 1e3) /
												(z ? 10 : 1),
										}),
										z
											? (e.rotation = t_(W, o ? r : r.rotation, m, g, 1, n))
											: (G &&
													(e[H] = t_(
														W,
														o ? r : r.points || r.x || r.left,
														m,
														g,
														s ? -1 : 1,
														n || "x" === W.lockedAxis
													)),
											  V &&
													(e[U] = t_(
														W,
														o ? r : r.points || r.y || r.top,
														v,
														y,
														s ? -1 : 1,
														n || "y" === W.lockedAxis
													)),
											  (r.points || (fw(r) && cw(r[0]))) &&
													((e.linkedProps = H + "," + U),
													(e.radius = r.radius)))),
								  (W.isThrowing = !0),
								  (c = isNaN(i.overshootTolerance)
										? 1 === i.edgeResistance
											? 0
											: 1 - W.edgeResistance + 0.2
										: i.overshootTolerance),
								  e.duration ||
										(e.duration = {
											max: Math.max(
												i.minDuration || 0,
												"maxDuration" in i ? i.maxDuration : 2
											),
											min: isNaN(i.minDuration)
												? 0 === c || (cw(e) && e.resistance > 1e3)
													? 0
													: 0.5
												: i.minDuration,
											overshoot: c,
										}),
								  (W.tween = a =
										Fb.to(s || t, {
											inertia: e,
											data: "_draggable",
											onComplete: ut,
											onInterrupt: dt,
											onUpdate: i.fastMode ? Jw : ct,
											onUpdateParams: i.fastMode
												? [W, "onthrowupdate", "onThrowUpdate"]
												: r && r.radius
												? [!1, !0]
												: [],
										})),
								  i.fastMode ||
										(s && (s._skip = !0),
										a.render(1e9, !0, !0),
										ct(!0, !0),
										(W.endX = W.x),
										(W.endY = W.y),
										z && (W.endRotation = W.x),
										a.play(0),
										ct(!0, !0),
										s && (s._skip = !1)))
								: u && W.applyBounds();
						},
						ft = function (e) {
							var n,
								i = P;
							(P = Nb(t.parentNode, !0)),
								e &&
									W.isPressed &&
									!P.equals(i || new kb()) &&
									((n = i.inverse().apply({ x: a, y: c })),
									P.apply(n, n),
									(a = n.x),
									(c = n.y)),
								P.equals(yw) && (P = null);
						},
						mt = function () {
							var e,
								n,
								i,
								r = 1 - W.edgeResistance,
								o = it ? Hw(ot) : 0,
								d = it ? zw(ot) : 0;
							ft(!1),
								P &&
									((Qw.x = W.pointerX - o),
									(Qw.y = W.pointerY - d),
									P.apply(Qw, Qw),
									(a = Qw.x),
									(c = Qw.y)),
								_ && (bt(W.pointerX, W.pointerY), at(!0)),
								s
									? (ht(), (h = s.top()), (l = s.left()))
									: (gt() ? (ct(!0, !0), ht()) : W.applyBounds(),
									  z
											? ((e = t.ownerSVGElement
													? [
															nt.xOrigin - t.getBBox().x,
															nt.yOrigin - t.getBBox().y,
													  ]
													: (Yw(t)[dw] || "0 0").split(" ")),
											  (w = W.rotationOrigin =
													Nb(t).apply({
														x: parseFloat(e[0]) || 0,
														y: parseFloat(e[1]) || 0,
													})),
											  ct(!0, !0),
											  (n = W.pointerX - w.x - o),
											  (i = w.y - W.pointerY + d),
											  (l = W.x),
											  (h = W.y = Math.atan2(i, n) * gw))
											: ((h = rt(U, "px")), (l = rt(H, "px")))),
								u &&
									r &&
									(l > m
										? (l = m + (l - m) / r)
										: l < g && (l = g - (g - l) / r),
									z ||
										(h > v
											? (h = v + (h - v) / r)
											: h < y && (h = y - (y - h) / r))),
								(W.startX = l),
								(W.startY = h);
						},
						gt = function () {
							return W.tween && W.tween.isActive();
						},
						vt = function () {
							!jb.parentNode ||
								gt() ||
								W.isDragging ||
								jb.parentNode.removeChild(jb);
						},
						yt = function (e, r) {
							var l;
							if (
								!o ||
								W.isPressed ||
								!e ||
								(!(("mousedown" !== e.type && "pointerdown" !== e.type) || r) &&
									xw() - et < 30 &&
									Jb[W.pointerEvent.type])
							)
								N && e && o && kw(e);
							else {
								if (
									((R = gt()),
									(W.pointerEvent = e),
									Jb[e.type]
										? ((L = ~e.type.indexOf("touch")
												? e.currentTarget || e.target
												: ot),
										  Dw(L, "touchend", wt),
										  Dw(L, "touchmove", xt),
										  Dw(L, "touchcancel", wt),
										  Dw(ot, "touchstart", Fw))
										: ((L = null), Dw(ot, "mousemove", xt)),
									(O = null),
									(nw && L) ||
										(Dw(ot, "mouseup", wt),
										e && e.target && Dw(e.target, "mouseup", wt)),
									(A = tt.call(W, e.target) && !1 === i.dragClickables && !r))
								)
									return (
										Dw(e.target, "change", wt),
										Jw(W, "pressInit", "onPressInit"),
										Jw(W, "press", "onPress"),
										void n_(q, !0)
									);
								if (
									((C =
										!(
											!L ||
											G === V ||
											!1 === W.vars.allowNativeTouchScrolling ||
											(W.vars.allowContextMenu &&
												e &&
												(e.ctrlKey || e.which > 2))
										) && (G ? "y" : "x")),
									(N = !C && !W.allowEventDefault) &&
										(kw(e), Dw(zb, "touchforcechange", kw)),
									e.changedTouches
										? ((e = x = e.changedTouches[0]), (b = e.identifier))
										: e.pointerId
										? (b = e.pointerId)
										: (x = b = null),
									Kb++,
									Rw(at),
									(c = W.pointerY = e.pageY),
									(a = W.pointerX = e.pageX),
									Jw(W, "pressInit", "onPressInit"),
									(C || W.autoScroll) && Ww(t.parentNode),
									!t.parentNode ||
										!W.autoScroll ||
										s ||
										z ||
										!t.parentNode._gsMaxScrollX ||
										jb.parentNode ||
										t.getBBox ||
										((jb.style.width = t.parentNode.scrollWidth + "px"),
										t.parentNode.appendChild(jb)),
									mt(),
									W.tween && W.tween.kill(),
									(W.isThrowing = !1),
									Fb.killTweensOf(s || t, Y, !0),
									s && Fb.killTweensOf(t, { scrollTo: 1 }, !0),
									(W.tween = W.lockedAxis = null),
									(i.zIndexBoost || (!z && !s && !1 !== i.zIndexBoost)) &&
										(t.style.zIndex = n.zIndex++),
									(W.isPressed = !0),
									(d = !(!i.onDrag && !W._listeners.drag)),
									(f = !(!i.onMove && !W._listeners.move)),
									!z && (!1 !== i.cursor || i.activeCursor))
								)
									for (l = q.length; --l > -1; )
										Fb.set(q[l], {
											cursor:
												i.activeCursor ||
												i.cursor ||
												("grab" === ew ? "grabbing" : ew),
										});
								Jw(W, "press", "onPress");
							}
						},
						xt = function (t) {
							var e,
								n,
								i,
								r,
								s,
								l,
								h = t;
							if (o && !Qb && W.isPressed && t) {
								if (((W.pointerEvent = t), (e = t.changedTouches))) {
									if ((t = e[0]) !== x && t.identifier !== b) {
										for (
											r = e.length;
											--r > -1 && (t = e[r]).identifier !== b;

										);
										if (r < 0) return;
									}
								} else if (t.pointerId && b && t.pointerId !== b) return;
								L &&
								C &&
								!O &&
								((Qw.x = t.pageX),
								(Qw.y = t.pageY),
								P && P.apply(Qw, Qw),
								(n = Qw.x),
								(i = Qw.y),
								(((s = Math.abs(n - a)) !== (l = Math.abs(i - c)) &&
									(s > j || l > j)) ||
									($b && C === O)) &&
									((O = s > l && G ? "x" : "y"),
									C && O !== C && Dw(zb, "touchforcechange", kw),
									!1 !== W.vars.lockAxisOnTouchScroll &&
										G &&
										V &&
										((W.lockedAxis = "x" === O ? "y" : "x"),
										aw(W.vars.onLockAxis) && W.vars.onLockAxis.call(W, h)),
									$b && C === O))
									? wt(h)
									: (W.allowEventDefault ||
									  (C && (!O || C === O)) ||
									  !1 === h.cancelable
											? N && (N = !1)
											: (kw(h), (N = !0)),
									  W.autoScroll && (Z = !0),
									  bt(t.pageX, t.pageY, f));
							} else N && t && o && kw(t);
						},
						bt = function (t, e, n) {
							var i,
								r,
								o,
								s,
								d,
								p,
								f = 1 - W.dragResistance,
								x = 1 - W.edgeResistance,
								b = W.pointerX,
								M = W.pointerY,
								A = h,
								L = W.x,
								R = W.y,
								C = W.endX,
								O = W.endY,
								D = W.endRotation,
								I = _;
							(W.pointerX = t),
								(W.pointerY = e),
								it && ((t -= Hw(ot)), (e -= zw(ot))),
								z
									? ((s = Math.atan2(w.y - e, t - w.x) * gw),
									  (d = W.y - s) > 180
											? ((h -= 360), (W.y = s))
											: d < -180 && ((h += 360), (W.y = s)),
									  W.x !== l || Math.abs(h - s) > j
											? ((W.y = s), (o = l + (h - s) * f))
											: (o = l))
									: (P &&
											((p = t * P.a + e * P.c + P.e),
											(e = t * P.b + e * P.d + P.f),
											(t = p)),
									  (i = t - a),
									  (r = e - c) < j && r > -j && (r = 0),
									  i < j && i > -j && (i = 0),
									  (W.lockAxis || W.lockedAxis) &&
											(i || r) &&
											((p = W.lockedAxis) ||
												((W.lockedAxis = p =
													G && Math.abs(i) > Math.abs(r)
														? "y"
														: V
														? "x"
														: null),
												p &&
													aw(W.vars.onLockAxis) &&
													W.vars.onLockAxis.call(W, W.pointerEvent)),
											"y" === p ? (r = 0) : "x" === p && (i = 0)),
									  (o = pw(l + i * f)),
									  (s = pw(h + r * f))),
								(S || T || E) && (W.x !== o || (W.y !== s && !z))
									? (E &&
											((Tw.x = o),
											(Tw.y = s),
											(p = E(Tw)),
											(o = pw(p.x)),
											(s = pw(p.y))),
									  S && (o = pw(S(o))),
									  T && (s = pw(T(s))))
									: u &&
									  (o > m
											? (o = m + Math.round((o - m) * x))
											: o < g && (o = g + Math.round((o - g) * x)),
									  z ||
											(s > v
												? (s = Math.round(v + (s - v) * x))
												: s < y && (s = Math.round(y + (s - y) * x)))),
								(W.x !== o || (W.y !== s && !z)) &&
									(z
										? ((W.endRotation = W.x = W.endX = o), (_ = !0))
										: (V && ((W.y = W.endY = s), (_ = !0)),
										  G && ((W.x = W.endX = o), (_ = !0))),
									n && !1 === Jw(W, "move", "onMove")
										? ((W.pointerX = b),
										  (W.pointerY = M),
										  (h = A),
										  (W.x = L),
										  (W.y = R),
										  (W.endX = C),
										  (W.endY = O),
										  (W.endRotation = D),
										  (_ = I))
										: !W.isDragging &&
										  W.isPressed &&
										  ((W.isDragging = !0), Jw(W, "dragstart", "onDragStart")));
						},
						wt = function e(n, r) {
							if (
								o &&
								W.isPressed &&
								(!n ||
									null == b ||
									r ||
									!(
										(n.pointerId && n.pointerId !== b) ||
										(n.changedTouches && !Nw(n.changedTouches, b))
									))
							) {
								W.isPressed = !1;
								var s,
									a,
									c,
									l,
									h,
									u = n,
									d = W.isDragging,
									p =
										W.vars.allowContextMenu && n && (n.ctrlKey || n.which > 2),
									f = Fb.delayedCall(0.001, vt);
								if (
									(L
										? (Iw(L, "touchend", e),
										  Iw(L, "touchmove", xt),
										  Iw(L, "touchcancel", e),
										  Iw(ot, "touchstart", Fw))
										: Iw(ot, "mousemove", xt),
									Iw(zb, "touchforcechange", kw),
									(nw && L) ||
										(Iw(ot, "mouseup", e),
										n && n.target && Iw(n.target, "mouseup", e)),
									(_ = !1),
									A && !p)
								)
									return (
										n && (Iw(n.target, "change", e), (W.pointerEvent = u)),
										n_(q, !1),
										Jw(W, "release", "onRelease"),
										Jw(W, "click", "onClick"),
										void (A = !1)
									);
								if ((Ow(at), !z))
									for (a = q.length; --a > -1; )
										qw(
											q[a],
											"cursor",
											i.cursor || (!1 !== i.cursor ? ew : null)
										);
								if ((d && ((X = Sw = xw()), (W.isDragging = !1)), Kb--, n)) {
									if (
										(s = n.changedTouches) &&
										(n = s[0]) !== x &&
										n.identifier !== b
									) {
										for (
											a = s.length;
											--a > -1 && (n = s[a]).identifier !== b;

										);
										if (a < 0) return;
									}
									(W.pointerEvent = u),
										(W.pointerX = n.pageX),
										(W.pointerY = n.pageY);
								}
								return (
									p && u
										? (kw(u), (N = !0), Jw(W, "release", "onRelease"))
										: u && !d
										? ((N = !1),
										  R &&
												(i.snap || i.bounds) &&
												pt(i.inertia || i.throwProps),
										  Jw(W, "release", "onRelease"),
										  ($b && "touchmove" === u.type) ||
												-1 !== u.type.indexOf("cancel") ||
												(Jw(W, "click", "onClick"),
												xw() - et < 300 &&
													Jw(W, "doubleclick", "onDoubleClick"),
												(l = u.target || t),
												(et = xw()),
												(h = function () {
													et === I ||
														!W.enabled() ||
														W.isPressed ||
														u.defaultPrevented ||
														(l.click
															? l.click()
															: ot.createEvent &&
															  ((c =
																	ot.createEvent("MouseEvents")).initMouseEvent(
																	"click",
																	!0,
																	!0,
																	zb,
																	1,
																	W.pointerEvent.screenX,
																	W.pointerEvent.screenY,
																	W.pointerX,
																	W.pointerY,
																	!1,
																	!1,
																	!1,
																	!1,
																	0,
																	null
															  ),
															  l.dispatchEvent(c)));
												}),
												$b || u.defaultPrevented || Fb.delayedCall(0.05, h)))
										: (pt(i.inertia || i.throwProps),
										  W.allowEventDefault ||
										  !u ||
										  (!1 === i.dragClickables && tt.call(W, u.target)) ||
										  !d ||
										  (C && (!O || C !== O)) ||
										  !1 === u.cancelable
												? (N = !1)
												: ((N = !0), kw(u)),
										  Jw(W, "release", "onRelease")),
									gt() && f.duration(W.tween.duration()),
									d && Jw(W, "dragend", "onDragEnd"),
									!0
								);
							}
							N && n && o && kw(n);
						},
						_t = function (e) {
							if (e && W.isDragging && !s) {
								var n = e.target || t.parentNode,
									i = n.scrollLeft - n._gsScrollX,
									r = n.scrollTop - n._gsScrollY;
								(i || r) &&
									(P
										? ((a -= i * P.a + r * P.c), (c -= r * P.d + i * P.b))
										: ((a -= i), (c -= r)),
									(n._gsScrollX += i),
									(n._gsScrollY += r),
									bt(W.pointerX, W.pointerY));
							}
						},
						Mt = function (t) {
							var e = xw(),
								n = e - et < 40,
								i = e - X < 40,
								r = n && I === et,
								o = W.pointerEvent && W.pointerEvent.defaultPrevented,
								s = n && k === et,
								a = t.isTrusted || (null == t.isTrusted && n && r);
							if (
								((r || (i && !1 !== W.vars.suppressClickOnDrag)) &&
									t.stopImmediatePropagation &&
									t.stopImmediatePropagation(),
								n &&
									(!W.pointerEvent || !W.pointerEvent.defaultPrevented) &&
									(!r || (a && !s)))
							)
								return a && r && (k = et), void (I = et);
							(W.isPressed || i || n) && ((a && t.detail && n && !o) || kw(t));
						},
						St = function (t) {
							return P
								? {
										x: t.x * P.a + t.y * P.c + P.e,
										y: t.x * P.b + t.y * P.d + P.f,
								  }
								: { x: t.x, y: t.y };
						};
					return (
						(M = n.get(t)) && M.kill(),
						(r.startDrag = function (e, n) {
							var i, r, o, s;
							yt(e || W.pointerEvent, !0),
								n &&
									!W.hitTest(e || W.pointerEvent) &&
									((i = Zw(e || W.pointerEvent)),
									(r = Zw(t)),
									(o = St({
										x: i.left + i.width / 2,
										y: i.top + i.height / 2,
									})),
									(s = St({
										x: r.left + r.width / 2,
										y: r.top + r.height / 2,
									})),
									(a -= o.x - s.x),
									(c -= o.y - s.y)),
								W.isDragging ||
									((W.isDragging = !0), Jw(W, "dragstart", "onDragStart"));
						}),
						(r.drag = xt),
						(r.endDrag = function (t) {
							return wt(t || W.pointerEvent, !0);
						}),
						(r.timeSinceDrag = function () {
							return W.isDragging ? 0 : (xw() - X) / 1e3;
						}),
						(r.timeSinceClick = function () {
							return (xw() - et) / 1e3;
						}),
						(r.hitTest = function (t, e) {
							return n.hitTest(W.target, t, e);
						}),
						(r.getDirection = function (e, n) {
							var i,
								r,
								o,
								s,
								a,
								c,
								u =
									"velocity" === e && tw
										? e
										: cw(e) && !z
										? "element"
										: "start";
							return (
								"element" === u && ((a = Zw(W.target)), (c = Zw(e))),
								(i =
									"start" === u
										? W.x - l
										: "velocity" === u
										? tw.getVelocity(t, H)
										: a.left + a.width / 2 - (c.left + c.width / 2)),
								z
									? i < 0
										? "counter-clockwise"
										: "clockwise"
									: ((n = n || 2),
									  (r =
											"start" === u
												? W.y - h
												: "velocity" === u
												? tw.getVelocity(t, U)
												: a.top + a.height / 2 - (c.top + c.height / 2)),
									  (s =
											(o = Math.abs(i / r)) < 1 / n
												? ""
												: i < 0
												? "left"
												: "right"),
									  o < n &&
											("" !== s && (s += "-"), (s += r < 0 ? "up" : "down")),
									  s)
							);
						}),
						(r.applyBounds = function (e, n) {
							var r, o, s, a, c, l;
							if (e && i.bounds !== e) return (i.bounds = e), W.update(!0, n);
							if ((ct(!0), ht(), u && !gt())) {
								if (
									((r = W.x),
									(o = W.y),
									r > m ? (r = m) : r < g && (r = g),
									o > v ? (o = v) : o < y && (o = y),
									(W.x !== r || W.y !== o) &&
										((s = !0),
										(W.x = W.endX = r),
										z ? (W.endRotation = r) : (W.y = W.endY = o),
										(_ = !0),
										at(!0),
										W.autoScroll && !W.isDragging))
								)
									for (
										Ww(t.parentNode),
											a = t,
											Ew.scrollTop =
												null != zb.pageYOffset
													? zb.pageYOffset
													: null != ot.documentElement.scrollTop
													? ot.documentElement.scrollTop
													: ot.body.scrollTop,
											Ew.scrollLeft =
												null != zb.pageXOffset
													? zb.pageXOffset
													: null != ot.documentElement.scrollLeft
													? ot.documentElement.scrollLeft
													: ot.body.scrollLeft;
										a && !l;

									)
										(c = (l = Vw(a.parentNode)) ? Ew : a.parentNode),
											V &&
												c.scrollTop > c._gsMaxScrollY &&
												(c.scrollTop = c._gsMaxScrollY),
											G &&
												c.scrollLeft > c._gsMaxScrollX &&
												(c.scrollLeft = c._gsMaxScrollX),
											(a = c);
								W.isThrowing &&
									(s || W.endX > m || W.endX < g || W.endY > v || W.endY < y) &&
									pt(i.inertia || i.throwProps, s);
							}
							return W;
						}),
						(r.update = function (e, n, i) {
							var r = W.x,
								o = W.y;
							return (
								ft(!n),
								e ? W.applyBounds() : (_ && i && at(!0), ct(!0)),
								n && (bt(W.pointerX, W.pointerY), _ && at(!0)),
								W.isPressed &&
									!n &&
									((G && Math.abs(r - W.x) > 0.01) ||
										(V && Math.abs(o - W.y) > 0.01 && !z)) &&
									mt(),
								W.autoScroll &&
									(Ww(t.parentNode, W.isDragging),
									(Z = W.isDragging),
									at(!0),
									Gw(t, _t),
									Uw(t, _t)),
								W
							);
						}),
						(r.enable = function (e) {
							var n,
								r,
								a,
								c = { lazy: !0 };
							if (
								(z || !1 === i.cursor || (c.cursor = i.cursor || ew),
								Fb.utils.checkPrefix("touchCallout") &&
									(c.touchCallout = "none"),
								(c.touchAction =
									G === V
										? "none"
										: i.allowNativeTouchScrolling || i.allowEventDefault
										? "manipulation"
										: G
										? "pan-y"
										: "pan-x"),
								"soft" !== e)
							) {
								for (r = q.length; --r > -1; )
									(a = q[r]),
										nw || Dw(a, "mousedown", yt),
										Dw(a, "touchstart", yt),
										Dw(a, "click", Mt, !0),
										Fb.set(a, c),
										a.getBBox &&
											a.ownerSVGElement &&
											Fb.set(a.ownerSVGElement, {
												touchAction:
													G === V
														? "none"
														: i.allowNativeTouchScrolling || i.allowEventDefault
														? "manipulation"
														: G
														? "pan-y"
														: "pan-x",
											}),
										i.allowContextMenu || Dw(a, "contextmenu", st);
								n_(q, !1);
							}
							return (
								Uw(t, _t),
								(o = !0),
								tw &&
									"soft" !== e &&
									tw.track(s || t, F ? "x,y" : z ? "rotation" : "top,left"),
								(t._gsDragID = n = "d" + _w++),
								(ww[n] = W),
								s && (s.enable(), (s.element._gsDragID = n)),
								(i.bounds || z) && mt(),
								i.bounds && W.applyBounds(),
								W
							);
						}),
						(r.disable = function (e) {
							var n,
								i,
								r = W.isDragging;
							if (!z) for (n = q.length; --n > -1; ) qw(q[n], "cursor", null);
							if ("soft" !== e) {
								for (n = q.length; --n > -1; )
									(i = q[n]),
										qw(i, "touchCallout", null),
										qw(i, "touchAction", null),
										Iw(i, "mousedown", yt),
										Iw(i, "touchstart", yt),
										Iw(i, "click", Mt),
										Iw(i, "contextmenu", st);
								n_(q, !0),
									L &&
										(Iw(L, "touchcancel", wt),
										Iw(L, "touchend", wt),
										Iw(L, "touchmove", xt)),
									Iw(ot, "mouseup", wt),
									Iw(ot, "mousemove", xt);
							}
							return (
								Gw(t, _t),
								(o = !1),
								tw &&
									"soft" !== e &&
									tw.untrack(s || t, F ? "x,y" : z ? "rotation" : "top,left"),
								s && s.disable(),
								Ow(at),
								(W.isDragging = W.isPressed = A = !1),
								r && Jw(W, "dragend", "onDragEnd"),
								W
							);
						}),
						(r.enabled = function (t, e) {
							return arguments.length ? (t ? W.enable(e) : W.disable(e)) : o;
						}),
						(r.kill = function () {
							return (
								(W.isThrowing = !1),
								W.tween && W.tween.kill(),
								W.disable(),
								Fb.set(q, { clearProps: "userSelect" }),
								delete ww[t._gsDragID],
								W
							);
						}),
						~B.indexOf("scroll") &&
							((s = r.scrollProxy =
								new r_(
									t,
									Lw(
										{
											onKill: function () {
												W.isPressed && wt(null);
											},
										},
										i
									)
								)),
							(t.style.overflowY = V && !Zb ? "auto" : "hidden"),
							(t.style.overflowX = G && !Zb ? "auto" : "hidden"),
							(t = s.content)),
						z ? (Y.rotation = 1) : (G && (Y[H] = 1), V && (Y[U] = 1)),
						(nt.force3D = !("force3D" in i) || i.force3D),
						r.enable(),
						r
					);
				}
				return (
					m()(n, null, [
						{
							key: "register",
							value: function (t) {
								(Fb = t), o_();
							},
						},
						{
							key: "create",
							value: function (t, e) {
								return (
									Wb || o_(!0),
									Yb(t).map(function (t) {
										return new n(t, e);
									})
								);
							},
						},
						{
							key: "get",
							value: function (t) {
								return ww[(Yb(t)[0] || {})._gsDragID];
							},
						},
						{
							key: "timeSinceDrag",
							value: function () {
								return (xw() - Sw) / 1e3;
							},
						},
						{
							key: "hitTest",
							value: function (t, e, n) {
								if (t === e) return !1;
								var i,
									r,
									o,
									s = Zw(t),
									a = Zw(e),
									c = s.top,
									l = s.left,
									h = s.right,
									u = s.bottom,
									d = s.width,
									p = s.height,
									f = a.left > h || a.right < l || a.top > u || a.bottom < c;
								return f || !n
									? !f
									: ((o = -1 !== (n + "").indexOf("%")),
									  (n = parseFloat(n) || 0),
									  ((i = {
											left: Math.max(l, a.left),
											top: Math.max(c, a.top),
									  }).width = Math.min(h, a.right) - i.left),
									  (i.height = Math.min(u, a.bottom) - i.top),
									  !(i.width < 0 || i.height < 0) &&
											(o
												? ((n *= 0.01),
												  (r = i.width * i.height) >= d * p * n ||
														r >= a.width * a.height * n)
												: i.width > n && i.height > n));
							},
						},
					]),
					n
				);
			})(
				(function () {
					function t(e) {
						p()(this, t), (this._listeners = {}), (this.target = e || this);
					}
					return (
						m()(t, [
							{
								key: "addEventListener",
								value: function (t, e) {
									var n = this._listeners[t] || (this._listeners[t] = []);
									~n.indexOf(e) || n.push(e);
								},
							},
							{
								key: "removeEventListener",
								value: function (t, e) {
									var n = this._listeners[t],
										i = (n && n.indexOf(e)) || -1;
									i > -1 && n.splice(i, 1);
								},
							},
							{
								key: "dispatchEvent",
								value: function (t) {
									var e,
										n = this;
									return (
										(this._listeners[t] || []).forEach(function (i) {
											return (
												!1 === i.call(n, { type: t, target: n.target }) &&
												(e = !1)
											);
										}),
										e
									);
								},
							},
						]),
						t
					);
				})()
			);
		!(function (t, e) {
			for (var n in e) n in t || (t[n] = e[n]);
		})(s_.prototype, {
			pointerX: 0,
			pointerY: 0,
			startX: 0,
			startY: 0,
			deltaX: 0,
			deltaY: 0,
			isDragging: !1,
			isPressed: !1,
		}),
			(s_.zIndex = 1e3),
			(s_.version = "3.5.1"),
			sw() && Fb.registerPlugin(s_);
		/*!
		 * VelocityTracker: 3.2.6
		 * https://greensock.com
		 *
		 * Copyright 2008-2020, GreenSock. All rights reserved.
		 * Subject to the terms at https://greensock.com/standard-license or for
		 * Club GreenSock members, the agreement issued with that membership.
		 * @author: Jack Doyle, jack@greensock.com
		 */
		var a_,
			c_,
			l_,
			h_,
			u_,
			d_,
			p_,
			f_,
			m_ = function () {
				return a_ || ("undefined" != typeof window && (a_ = window.gsap));
			},
			g_ = {},
			v_ = function (t) {
				return f_(t).id;
			},
			y_ = function (t) {
				return g_[v_("string" == typeof t ? l_(t)[0] : t)];
			},
			x_ = function (t) {
				var e,
					n = u_;
				if (t - p_ >= 0.05)
					for (p_, p_ = t; n; )
						((e = n.g(n.t, n.p)) !== n.v1 || t - n.t1 > 0.2) &&
							((n.v2 = n.v1), (n.v1 = e), (n.t2 = n.t1), (n.t1 = t)),
							(n = n._next);
			},
			b_ = { deg: 360, rad: 2 * Math.PI },
			w_ = function () {
				(a_ = m_()) &&
					((l_ = a_.utils.toArray),
					(h_ = a_.utils.getUnit),
					(f_ = a_.core.getCache),
					(d_ = a_.ticker),
					(c_ = 1));
			},
			__ = (function () {
				function t(e, n) {
					p()(this, t),
						c_ || w_(),
						(this.target = l_(e)[0]),
						(g_[v_(this.target)] = this),
						(this._props = {}),
						n && this.add(n);
				}
				return (
					m()(
						t,
						[
							{
								key: "get",
								value: function (t, e) {
									var n,
										i,
										r,
										o = this._props[t];
									return (
										o || console.warn("Not tracking " + t + " velocity."),
										(n =
											parseFloat(e ? o.v1 : o.g(o.t, o.p)) - parseFloat(o.v2)),
										(i = o.rCap) &&
											(n %= i) !== n % (i / 2) &&
											(n = n < 0 ? n + i : n - i),
										(r = n / ((e ? o.t1 : d_.time) - o.t2)),
										Math.round(1e4 * r) / 1e4
									);
								},
							},
							{
								key: "getAll",
								value: function () {
									var t,
										e = {},
										n = this._props;
									for (t in n) e[t] = this.get(t);
									return e;
								},
							},
							{
								key: "isTracking",
								value: function (t) {
									return t in this._props;
								},
							},
							{
								key: "add",
								value: function (t, e) {
									t in this._props ||
										(u_ || (d_.add(x_), (p_ = d_.time)),
										(u_ = this._props[t] =
											new (function t(e, n, i, r) {
												p()(this, t),
													(this.t = e),
													(this.p = n),
													(this.g = e._gsap.get),
													(this.rCap = b_[i || h_(this.g(e, n))]),
													(this.v1 = this.v2 = 0),
													(this.t1 = this.t2 = d_.time),
													r && ((this._next = r), (r._prev = this));
											})(this.target, t, e, u_)));
								},
							},
							{
								key: "remove",
								value: function (t) {
									var e,
										n,
										i = this._props[t];
									i &&
										((e = i._prev),
										(n = i._next),
										e && (e._next = n),
										n ? (n._prev = e) : u_ === i && (d_.remove(x_), (u_ = 0)),
										delete this._props[t]);
								},
							},
							{
								key: "kill",
								value: function (t) {
									for (var e in this._props) this.remove(e);
									t || delete g_[v_(this.target)];
								},
							},
						],
						[
							{
								key: "register",
								value: function (t) {
									(a_ = t), w_();
								},
							},
							{
								key: "track",
								value: function (e, n, i) {
									c_ || w_();
									for (
										var r,
											o,
											s = [],
											a = l_(e),
											c = n.split(","),
											l = (i || "").split(","),
											h = a.length;
										h--;

									) {
										for (r = y_(a[h]) || new t(a[h]), o = c.length; o--; )
											r.add(c[o], l[o] || l[0]);
										s.push(r);
									}
									return s;
								},
							},
							{
								key: "untrack",
								value: function (t, e) {
									var n = (e || "").split(",");
									l_(t).forEach(function (t) {
										var e = y_(t);
										e &&
											(n.length
												? n.forEach(function (t) {
														return e.remove(t);
												  })
												: e.kill(1));
									});
								},
							},
							{
								key: "isTracking",
								value: function (t, e) {
									var n = y_(t);
									return n && n.isTracking(e);
								},
							},
							{
								key: "getVelocity",
								value: function (t, e) {
									var n = y_(t);
									return n && n.isTracking(e)
										? n.get(e)
										: console.warn("Not tracking velocity of " + e);
								},
							},
						]
					),
					t
				);
			})();
		(__.getByTarget = y_), m_() && a_.registerPlugin(__);
		/*!
		 * InertiaPlugin 3.2.6
		 * https://greensock.com
		 *
		 * @license Copyright 2008-2020, GreenSock. All rights reserved.
		 * Subject to the terms at https://greensock.com/standard-license or for
		 * Club GreenSock members, the agreement issued with that membership.
		 * @author: Jack Doyle, jack@greensock.com
		 */
		var M_,
			S_,
			T_,
			E_,
			A_,
			L_,
			P_,
			R_,
			C_,
			O_,
			D_,
			I_ = __.getByTarget,
			k_ = function () {
				return (
					M_ ||
					("undefined" != typeof window &&
						(M_ = window.gsap) &&
						M_.registerPlugin &&
						M_)
				);
			},
			N_ = function (t) {
				return "number" == typeof t;
			},
			B_ = function (t) {
				return "object" === Fx()(t);
			},
			F_ = function (t) {
				return "function" == typeof t;
			},
			z_ = Array.isArray,
			H_ = function (t) {
				return t;
			},
			U_ = function (t, e, n) {
				for (var i in e) i in t || i === n || (t[i] = e[i]);
				return t;
			},
			G_ = function (t, e, n, i, r) {
				var o,
					s,
					a,
					c,
					l = e.length,
					h = 0,
					u = 1e10;
				if (B_(t)) {
					for (; l--; ) {
						for (a in ((o = e[l]), (s = 0), t)) s += (c = o[a] - t[a]) * c;
						s < u && ((h = l), (u = s));
					}
					if ((r || 1e10) < 1e10 && r < Math.sqrt(u)) return t;
				} else
					for (; l--; )
						(s = (o = e[l]) - t) < 0 && (s = -s),
							s < u && o >= i && o <= n && ((h = l), (u = s));
				return e[h];
			},
			V_ = function (t, e, n, i, r, o) {
				if ("auto" === t.end) return t;
				var s,
					a,
					c = t.end;
				if (((n = isNaN(n) ? 1e10 : n), (i = isNaN(i) ? -1e10 : i), B_(e))) {
					if (
						((s = e.calculated ? e : (F_(c) ? c(e) : G_(e, c, n, i, o)) || e),
						!e.calculated)
					) {
						for (a in s) e[a] = s[a];
						e.calculated = !0;
					}
					s = s[r];
				} else s = F_(c) ? c(e) : z_(c) ? G_(e, c, n, i, o) : parseFloat(c);
				return (
					s > n ? (s = n) : s < i && (s = i),
					{ max: s, min: s, unitFactor: t.unitFactor }
				);
			},
			j_ = function (t, e, n) {
				return isNaN(t[e]) ? n : +t[e];
			},
			W_ = function (t, e) {
				return (0.05 * e * t) / O_;
			},
			q_ = function (t, e, n) {
				return Math.abs(((e - t) * O_) / n / 0.05);
			},
			Y_ = {
				resistance: 1,
				checkpoint: 1,
				preventOvershoot: 1,
				linkedProps: 1,
				radius: 1,
				duration: 1,
			},
			X_ = function (t, e, n, i) {
				if (e.linkedProps) {
					var r,
						o,
						s,
						a,
						c,
						l,
						h = e.linkedProps.split(","),
						u = {};
					for (r = 0; r < h.length; r++)
						(s = e[(o = h[r])]) &&
							((a = N_(s.velocity)
								? s.velocity
								: (c = c || I_(t)) && c.isTracking(o)
								? c.get(o)
								: 0),
							(l = Math.abs(a / j_(s, "resistance", i))),
							(u[o] = parseFloat(n(t, o)) + W_(a, l)));
					return u;
				}
			},
			Z_ = function () {
				(M_ = k_()) &&
					((T_ = M_.parseEase),
					(E_ = M_.utils.toArray),
					(P_ = M_.utils.getUnit),
					(C_ = M_.core.getCache),
					(D_ = M_.utils.clamp),
					(A_ = T_("power3")),
					(O_ = A_(0.05)),
					(R_ = M_.core.PropTween),
					M_.config({
						resistance: 100,
						unitFactors: { time: 1e3, totalTime: 1e3 },
					}),
					(L_ = M_.config()),
					M_.registerPlugin(__),
					(S_ = 1));
			},
			J_ = {
				version: "3.2.6",
				name: "inertia",
				register: function (t) {
					(M_ = t), Z_();
				},
				init: function (t, e, n, i, r) {
					S_ || Z_();
					var o = I_(t);
					if ("auto" === e) {
						if (!o)
							return void console.warn(
								"No inertia tracking on " +
									t +
									". InertiaPlugin.track(target) first."
							);
						e = o.getAll();
					}
					(this.target = t), (this.tween = n);
					var s,
						a,
						c,
						l,
						h,
						u,
						d,
						p,
						f,
						m = t._gsap,
						g = m.get,
						v = e.duration,
						y = B_(v),
						x = e.preventOvershoot || (y && 0 === v.overshoot),
						b = j_(e, "resistance", L_.resistance),
						w = N_(v)
							? v
							: (function (t, e) {
									var n =
											arguments.length > 2 && void 0 !== arguments[2]
												? arguments[2]
												: 10,
										i =
											arguments.length > 3 && void 0 !== arguments[3]
												? arguments[3]
												: 0.2,
										r =
											arguments.length > 4 && void 0 !== arguments[4]
												? arguments[4]
												: 1,
										o =
											arguments.length > 5 && void 0 !== arguments[5]
												? arguments[5]
												: 0;
									if (("string" == typeof t && (t = E_(t)[0]), !t)) return 0;
									var s,
										a,
										c,
										l,
										h,
										u,
										d,
										p,
										f,
										m,
										g = 0,
										v = 1e10,
										y = e.inertia || e,
										x = C_(t).get,
										b = j_(y, "resistance", L_.resistance);
									for (s in ((m = X_(t, y, x, b)), y))
										Y_[s] ||
											((a = y[s]),
											B_(a) ||
												((p = p || I_(t)) && p.isTracking(s)
													? (a = N_(a)
															? { velocity: a }
															: { velocity: p.get(s) })
													: ((l = +a || 0), (c = Math.abs(l / b)))),
											B_(a) &&
												((l = N_(a.velocity)
													? a.velocity
													: (p = p || I_(t)) && p.isTracking(s)
													? p.get(s)
													: 0),
												(c = D_(i, n, Math.abs(l / j_(a, "resistance", b)))),
												(u = (h = parseFloat(x(t, s)) || 0) + W_(l, c)),
												"end" in a &&
													((a = V_(
														a,
														m && s in m ? m : u,
														a.max,
														a.min,
														s,
														y.radius
													)),
													o && (y[s] = U_(a, y[s], "end"))),
												"max" in a && u > +a.max + 1e-10
													? ((f = a.unitFactor || L_.unitFactors[s] || 1),
													  (d =
															(h > a.max && a.min !== a.max) ||
															(l * f > -15 && l * f < 45)
																? i + 0.1 * (n - i)
																: q_(h, a.max, l)) +
															r <
															v && (v = d + r))
													: "min" in a &&
													  u < +a.min - 1e-10 &&
													  ((f = a.unitFactor || L_.unitFactors[s] || 1),
													  (d =
															(h < a.min && a.min !== a.max) ||
															(l * f > -45 && l * f < 15)
																? i + 0.1 * (n - i)
																: q_(h, a.min, l)) +
															r <
															v && (v = d + r)),
												d > g && (g = d)),
											c > g && (g = c));
									return g > v && (g = v), g > n ? n : g < i ? i : g;
							  })(
									t,
									e,
									(y && v.max) || 10,
									(y && v.min) || 0.2,
									y && "overshoot" in v ? +v.overshoot : x ? 0 : 1
							  );
					for (s in ((f = X_(t, e, g, b)), e))
						Y_[s] ||
							((a = e[s]),
							F_(a) && (a = a(i, t, r)),
							N_(a)
								? (h = a)
								: B_(a) && !isNaN(a.velocity)
								? (h = +a.velocity)
								: o && o.isTracking(s)
								? (h = o.get(s))
								: console.warn(
										"ERROR: No velocity was defined for " +
											t +
											" property: " +
											s
								  ),
							(u = W_(h, w)),
							(p = 0),
							(c = g(t, s)),
							(l = P_(c)),
							(c = parseFloat(c)),
							B_(a) &&
								((d = c + u),
								"end" in a &&
									(a = V_(a, f && s in f ? f : d, a.max, a.min, s, e.radius)),
								"max" in a && +a.max < d
									? x || a.preventOvershoot
										? (u = a.max - c)
										: (p = a.max - c - u)
									: "min" in a &&
									  +a.min > d &&
									  (x || a.preventOvershoot
											? (u = a.min - c)
											: (p = a.min - c - u))),
							this._props.push(s),
							(this._pt = new R_(
								this._pt,
								t,
								s,
								c,
								0,
								H_,
								0,
								m.set(t, s, this)
							)),
							(this._pt.u = l || 0),
							(this._pt.c1 = u),
							(this._pt.c2 = p));
					return n.duration(w), 1;
				},
				render: function (t, e) {
					var n,
						i = e._pt;
					for (t = A_(e.tween._time / e.tween._dur); i; )
						i.set(
							i.t,
							i.p,
							((n = i.s + i.c1 * t + i.c2 * t * t),
							Math.round(1e4 * n) / 1e4 + i.u),
							i.d,
							t
						),
							(i = i._next);
				},
			};
		"track,untrack,isTracking,getVelocity,getByTarget"
			.split(",")
			.forEach(function (t) {
				return (J_[t] = __[t]);
			}),
			k_() && M_.registerPlugin(J_),
			er.registerPlugin(s_),
			er.registerPlugin(J_);
		function K_(t) {
			var e = (function () {
				if ("undefined" == typeof Reflect || !Reflect.construct) return !1;
				if (Reflect.construct.sham) return !1;
				if ("function" == typeof Proxy) return !0;
				try {
					return (
						Date.prototype.toString.call(
							Reflect.construct(Date, [], function () {})
						),
						!0
					);
				} catch (t) {
					return !1;
				}
			})();
			return function () {
				var n,
					i = Jx()(t);
				if (e) {
					var r = Jx()(this).constructor;
					n = Reflect.construct(i, arguments, r);
				} else n = i.apply(this, arguments);
				return Xx()(this, n);
			};
		}
		var Q_ = (function (t) {
				qx()(n, t);
				var e = K_(n);
				function n() {
					return p()(this, n), e.apply(this, arguments);
				}
				return (
					m()(n, [
						{
							key: "onEnter",
							value: function () {
								er.set(".back-to-top", { display: "none" }),
									(function (t) {
										if (t)
											for (
												var e = t.length,
													n = 1,
													i = document.getElementById("main"),
													r = [],
													o = !1,
													s = !0,
													a = 0,
													c = 0,
													l = 0,
													h = 0,
													u = 0,
													d = 0,
													p = function (e) {
														var s = t[e],
															a = s.parentElement;
														(r[e] = s_.create(a, {
															bounds: i,
															throwProps: !0,
															edgeResistance: 0.6,
															activeCursor: "move",
															cursor: "move",
															onPress: function () {
																(n += 1),
																	er.set(a, { zIndex: n }),
																	er.to(s, 0.3, {
																		scale: 0.88,
																		ease: "sine.out",
																		force3D: !0,
																	});
															},
															onRelease: function () {
																er.set(a, { zIndex: 1 }),
																	er.to(s, 0.25, {
																		scale: 1,
																		ease: "sine.out",
																		force3D: !0,
																	});
															},
														})),
															a.addEventListener("focus", function (t) {
																document.addEventListener("keydown", m),
																	document.addEventListener("keyup", g);
															}),
															a.addEventListener("blur", function (t) {
																document.removeEventListener("keydown", m),
																	document.removeEventListener("keyup", g),
																	(o = !1);
															});
													},
													f = 0;
												f < e;
												f++
											)
												p(f);
										function m(t) {
											var e = t.target,
												n = t.target.dataset.index;
											o
												? (37 == t.keyCode &&
														(s &&
															((a = r[n][0].x), (u = r[n][0].minX), (s = !1)),
														a - 10 > u &&
															((a -= 10), er.set(e, { x: a, force3D: !0 }))),
												  38 == t.keyCode &&
														(s &&
															((c = r[n][0].y), (d = r[n][0].minY), (s = !1)),
														c - 10 > d &&
															((c -= 10), er.set(e, { y: c, force3D: !0 }))),
												  39 == t.keyCode &&
														(s &&
															((a = r[n][0].x), (l = r[n][0].maxX), (s = !1)),
														a + 10 < l &&
															((a += 10), er.set(e, { x: a, force3D: !0 }))),
												  40 == t.keyCode &&
														(s &&
															((c = r[n][0].y), (h = r[n][0].maxY), (s = !1)),
														c + 10 < h &&
															((c += 10), er.set(e, { y: c, force3D: !0 }))),
												  13 == t.keyCode && ((o = !1), (s = !0)))
												: 13 == t.keyCode && (o = !0);
										}
										function g(t) {
											var e = t.target.dataset.index;
											o &&
												(37 == t.keyCode && ((s = !0), (r[e][0].x = a)),
												38 == t.keyCode && ((s = !0), (r[e][0].y = c)),
												39 == t.keyCode && ((s = !0), (r[e][0].x = a)),
												40 == t.keyCode && ((s = !0), (r[e][0].y = c)));
										}
									})(document.querySelectorAll(".copy-wrapper img"));
							},
						},
						{ key: "onEnterCompleted", value: function () {} },
						{ key: "onLeave", value: function () {} },
						{
							key: "onLeaveCompleted",
							value: function () {
								er.set(".back-to-top", { display: "flex" });
							},
						},
					]),
					n
				);
			})(u.Renderer),
			$_ = new u.Core({
				renderers: {
					home: Qx,
					work: eb,
					"work-type": rb,
					"about-us": lb,
					"not-found": Q_,
				},
				transitions: { default: bb, contextual: {} },
			});
		$_.on("NAVIGATE_OUT", function (t) {
			t.from, t.trigger, t.location;
			!(function (t, e, n) {
				for (var i = 0; i < Gx.length; i++) Gx[i].kill();
				Lx && Lx.close(), Ox && Ox.hide(), (_.transitionFinished = !1);
			})();
		}),
			$_.on("NAVIGATE_IN", function (t) {
				var e = t.to;
				t.trigger, t.location;
				!(function (t, e, n) {
					jx(t.view.dataset.routerView);
				})(e);
			}),
			$_.on("NAVIGATE_END", function (t) {
				t.from, t.to, t.trigger, t.location;
			}),
			"scrollRestoration" in history && (history.scrollRestoration = "manual");
		var tM = n(11);
		(_.isMobile =
			tM.any ||
			((/iPad|iPhone|iPod/.test(navigator.platform) ||
				("MacIntel" === navigator.platform && navigator.maxTouchPoints > 1)) &&
				!window.MSStream)),
			_.isMobile &&
				document.getElementsByTagName("html")[0].classList.add("touch"),
			document.addEventListener(
				"DOMContentLoaded",
				function () {
					(_.windowWidth = w().width),
						(_.windowHeight = w().height),
						(_.isGreaterThan767 =
							_.windowWidth > 767 &&
							!document.body.classList.contains("force-mobile")),
						(function () {
							M.viewEl = document.querySelector("[data-router-view]");
							var t = "mobile";
							_.isGreaterThan767 && (t = "desktop"),
								(Ix = new g("image-load", { size: t }));
							var e = M.viewEl.dataset.routerView,
								n = 0.01 * _.windowHeight;
							switch (
								("about-us" === e &&
									(M.aboutHand.classList.remove("preload"),
									M.aboutHand.classList.add("preload-critical")),
								(_.queryParams = b()),
								document.body.style.setProperty("--vh", "".concat(n, "px")),
								document.body.style.setProperty("--vhu", "".concat(n, "px")),
								(S.renderer = new kp({ antialias: !0, alpha: !0 })),
								S.renderer.setPixelRatio(window.devicePixelRatio),
								S.renderer.setSize(_.windowWidth, _.windowHeight),
								S.renderer.setClearColor(0, 0),
								(S.renderer.shadowMap.enabled = !0),
								(S.renderer.shadowMap.type = us),
								(S.scene = new Nl()),
								(S.camera = new gv(
									_.windowWidth / -2,
									_.windowWidth / 2,
									_.windowHeight / 2,
									_.windowHeight / -2,
									1,
									150
								)),
								(S.camera.position.z = 1),
								(S.navCanvasWrapper = document.querySelector(
									".canvas-wrapper.nav"
								)),
								S.navCanvasWrapper.appendChild(S.renderer.domElement),
								(Ox = new zx(document.querySelector(".pencil-bar"))),
								(Dx = new Hx()),
								jx(e),
								e)
							) {
								case "home":
									for (
										var i = document.querySelectorAll(
												".featured-work .work-tile a"
											),
											r = [],
											o = 0;
										o < i.length;
										o++
									)
										r.push(i[o].href);
									r.push("/work/"),
										r.push("/about-us/"),
										r.push("/contact/"),
										r.push("/careers/"),
										ss(r);
									break;
								case "work":
									ss(["/", "/about-us/", /contact/, /careers/]);
									break;
								case "work-type":
									ss(["/", "/about-us/", /contact/, /careers/, "/work/"]);
									break;
								case "about-us":
									ss(["/", /contact/, /careers/, "/work/"]);
									break;
								case "contact":
									ss(["/", /about-us/, /careers/, "/work/"]);
									break;
								case "careers":
								case "careers-type":
									ss(["/", /contact/, /about-us/, "/work/"]);
							}
							_.isMobile ||
								(M.footer.addEventListener("mouseenter", function () {
									Vx.play();
								}),
								M.footer.addEventListener("mouseleave", function () {
									Vx.reverse();
								}));
							var s = document.getElementById("envelope-hitbox"),
								a = function t() {
									Ix.loadImages(
										document.querySelectorAll(".third-media .preload"),
										"nodeList",
										function () {}
									),
										M.header.removeEventListener("mouseenter", t),
										s.removeEventListener("focus", t);
								};
							s.addEventListener("focus", a),
								M.header.addEventListener("mouseenter", a),
								(Cx = new Nx(S.navCanvasWrapper));
						})();
				},
				!1
			),
			(window.onload = function () {
				(_.windowWidth = w().width),
					(_.windowHeight = w().height),
					(_.isGreaterThan767 =
						_.windowWidth > 767 &&
						!document.body.classList.contains("force-mobile")),
					(function () {
						if (w().width > 767) {
							var t = document.getElementById("about-drawer"),
								e = document.getElementById("work-drawer");
							(Px = new Ko(t, "about")),
								(Rx = new Ko(e, "work")),
								(_.aboutDrawerScroll = new Ux(t)),
								(_.workDrawerScroll = new Ux(e));
							var n = "mousewheel";
							_.isFirefox && (n = "DOMMouseScroll"),
								Px.backdrop.addEventListener(
									n,
									function (t) {
										t.preventDefault(), t.stopPropagation();
									},
									{ passive: !0 }
								);
						} else
							(Lx = new Xo(document.getElementById("mobile-nav"))),
								Ix.loadImages(
									document.querySelectorAll("#about-hand"),
									"nodeList",
									function () {}
								);
					})();
			});
		var eM = setTimeout(function () {}, 0);
		(window.onresize = function () {
			clearTimeout(eM),
				(eM = setTimeout(function () {
					(_.windowWidth = w().width),
						(_.windowHeight = w().height),
						(function () {
							var t = w().width,
								e = !1;
							_.windowWidth === t && _.isMobile && (e = !0),
								(_.windowHeight = w().height),
								(_.windowWidth = t);
							var n = 0.01 * _.windowHeight;
							if (
								(e ||
									document.body.style.setProperty("--vh", "".concat(n, "px")),
								document.body.style.setProperty("--vhu", "".concat(n, "px")),
								Ax.resize(e),
								Cx && !e && Cx.onResize(),
								Gx.length > 0)
							)
								for (var i = 0; i < Gx.length; i++) Gx[i].onResize();
						})();
				}, 250));
		}),
			document.addEventListener("keyup", function (t) {
				var e = t.key;
				("Escape" !== e && "Esc" !== e) ||
					(Px.isOpen && Px.close(), Rx.isOpen && Rx.close());
			}),
			(navigator.userAgent || navigator.vendor || window.opera).indexOf(
				"Instagram"
			) > -1 && (document.body.className += " instagram-browser force-mobile");
	},
]);
